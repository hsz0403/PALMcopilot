[{"history": {"proof": "intros Phi Hmax x y. split. - intros H. apply (MCS_element_derivable Phi Hmax) in H as H1. srun best use: maximal_consistent_orp_witnessed unfold: orp_witnessed. - intros [Hx | Hy]. + hcrush use: @derivable_closed_element_derivable, @maximal_consistent_derivable_closed unfold: derivable_closed inv: IntuitionisticPropositionalSequentCalculus. + hauto lq: on use: @maximal_consistent_derivable_closed, maximal_consistent_orp_witnessed, @DCS_orp_iff.", "repairs": ["", "", "", "", "", "hammer", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "destruct H1 as [Hx Hy].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "apply (MCS_orp_iff Phi Hmax) in Hx.", "exn": "No such hypothesis: Hx", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "apply (MCS_orp_iff Phi Hmax) in Hy.", "exn": "No such hypothesis: Hy", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "destruct Hx, Hy.", "exn": "The reference Hx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left."], "tactic": "apply H0.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+"], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr H : Phi (x || y) H1 : Phi |-- x || y Unable to unify \"Phi (x || y)\" with \"maximal consistent Phi\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+"], "tactic": "apply H1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr H : Phi (x || y) H1 : Phi |-- x || y Unable to unify \"Phi |-- x || y\" with \"consistent (Phi;; x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hx : Phi x The term \"minSC\" has type \"MinimumSequentCalculus L Gamma\" while it is expected to have type \"derivable_closed Phi\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "apply (MCS_nonelement_inconsistent Phi Hmax).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hx : Phi x Unable to unify \"(~ Phi ?M2425 -> Phi |-- ?M2425 --> FF) /\\\\ (Phi |-- ?M2425 --> FF -> ~ Phi ?M2425)\" with \"Phi (x || y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+", "shelve.", "-", "intros [Hx | Hy].", "+", "shelve.", "+"], "tactic": "apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hy : Phi y The term \"minSC\" has type \"MinimumSequentCalculus L Gamma\" while it is expected to have type \"derivable_closed Phi\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "left.", "apply maximal_consistent_spec.", "+", "shelve.", "+", "shelve.", "-", "intros [Hx | Hy].", "+", "shelve.", "+"], "tactic": "apply (MCS_nonelement_inconsistent Phi Hmax).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hy : Phi y Unable to unify \"(~ Phi ?M2425 -> Phi |-- ?M2425 --> FF) /\\\\ (Phi |-- ?M2425 --> FF -> ~ Phi ?M2425)\" with \"Phi (x || y)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros Phi Hmax x y. split. - intros H. apply (MCS_element_derivable Phi Hmax) in H as H1. destruct H1 as [Hx Hy]. apply (MCS_orp_iff Phi Hmax) in Hx. apply (MCS_orp_iff Phi Hmax) in Hy. destruct Hx, Hy. + left. apply H0. + right. apply H. + right. apply H1. - intros [Hx | Hy]. + apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y). * apply (MCS_nonelement_inconsistent Phi Hmax). intros H. apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax). apply H. apply MCS_nonelement_element. apply H0. apply H. * left. apply H0. + apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y). * apply (MCS_nonelement_inconsistent Phi Hmax). intros H. apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax). apply H. apply MCS_nonelement_element. apply H1. apply H. * right. apply H1.", "succ": true}]