[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros B l c f.", "induction l as [| x xs IHxs].", "-", "simpl.", "auto.", "-", "simpl."], "tactic": "rewrite <- IHxs.", "exn": "Found no subterm matching \"fold_left (fun (a : nat) (b : B) => a + f b) xs c\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros B l c f.", "induction l as [| x xs IHxs].", "-", "simpl.", "auto.", "-", "simpl."], "tactic": "rewrite fold_left_app.", "exn": "Found no subterm matching \"fold_left ?M1499 (?M1500 ++ ?M1501) ?M1502\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros B l c f.", "induction l as [| x xs IHxs].", "-", "simpl.", "auto.", "-", "simpl."], "tactic": "reflexivity.", "exn": "In environment A : Type eqA_dec : forall a b : A, {a = b} + {a <> b} B : Type x : B xs : list B c : nat f : B -> nat IHxs : c + fold_left (fun (a : nat) (b : B) => a + f b) xs 0 = fold_left (fun (a : nat) (b : B) => a + f b) xs c Unable to unify \"fold_left (fun (a : nat) (b : B) => a + f b) xs (c + f x)\" with \"c + fold_left (fun (a : nat) (b : B) => a + f b) xs (f x)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros B l c f. induction l as [| x xs IHxs]. - simpl. auto. - simpl. rewrite <- IHxs. rewrite fold_left_app. reflexivity.", "succ": false}]