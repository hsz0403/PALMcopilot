[{"history": {"proof": "intros L a. induction L. - simpl. sfirstorder depth: 3use: ordered_skip, permutation_one_inv_aux, permutation_swap, ordered_inv_order, ordered_one, insert_ordered. - simpl. destruct (order_fun a a0) eqn:H. + apply order_fun_true in H. sfirstorder depth: 3use: ordered_skip, permutation_one_inv_aux, permutation_swap, ordered_inv_order, ordered_one, insert_ordered. + apply order_fun_false in H. sauto lq: on depth: 3use: ordered_skip, permutation_one_inv_aux, permutation_swap, ordered_inv_order, ordered_one, insert_ordered.", "repairs": ["", "", "", "", "hammer", "", "", "", "", "", "hammer", "", "", "hammer"], "exceptions": [{"ctx": ["intros L a.", "induction L.", "-", "simpl."], "tactic": "apply permutation_one_inv_aux.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a : A Unable to unify \"?M1431 = [?M1433]\" with \"permutation [a] [a]\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl."], "tactic": "apply permutation_swap.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a : A Unable to unify \"permutation (?M1430 :: ?M1431 :: ?M1432) (?M1431 :: ?M1430 :: ?M1432)\" with \"permutation [a] [a]\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "shelve.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H."], "tactic": "apply insert_ordered.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a0 : A L : list A a : A IHL : permutation (a :: L) (insert a L) H : order a a0 Unable to unify \"ordered order (insert ?M1438 ?M1436)\" with \"permutation (a :: a0 :: L) (a :: a0 :: L)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "shelve.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H."], "tactic": "apply ordered_one.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a0 : A L : list A a : A IHL : permutation (a :: L) (insert a L) H : order a a0 Unable to unify \"ordered ?M1437 [?M1438]\" with \"permutation (a :: a0 :: L) (a :: a0 :: L)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "shelve.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "shelve.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "shelve.", "+", "apply order_fun_false in H."], "tactic": "apply ordered_skip.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a0 : A L : list A a : A IHL : permutation (a :: L) (insert a L) H : order a0 a Unable to unify \"ordered ?M1440 (?M1442 :: ?M1444)\" with \"permutation (a :: a0 :: L) (a0 :: insert a L)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "shelve.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "shelve.", "+", "apply order_fun_false in H."], "tactic": "apply ordered_inv_order in IHl.", "exn": "No such hypothesis: IHl", "type": "no_hypos", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "shelve.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "shelve.", "+", "apply order_fun_false in H."], "tactic": "apply IHl.", "exn": "The reference IHl was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros L a. induction L. - simpl. apply permutation_one_inv_aux. apply permutation_swap. - simpl. destruct (order_fun a a0) eqn:H. + apply order_fun_true in H. apply insert_ordered. apply ordered_one. + apply order_fun_false in H. apply ordered_skip. apply ordered_inv_order in IHl. apply IHl.", "succ": true}]