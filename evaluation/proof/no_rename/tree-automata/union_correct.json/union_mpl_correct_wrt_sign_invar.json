[{"history": {"proof": "srun best use: st_compat_check_0_correct, union_mpl_correct_wrt_sign_invar_1, st_compat_check_0_complete, st_compat_check_correct, st_compat_check_complete unfold: st_compat_check.", "repairs": ["hammer"], "exceptions": []}, "chat": [], "original": "intros s0 s1 sigma H1 H2 a p H3. unfold state_correct_wrt_sign in *. intros H4. unfold union_mpl. destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto. + apply umpl_conv_0_correct_wrt_sign_invar in H1. apply H1 in H4. destruct H4 as [n [H5 H6]]. exists n. split; auto. + destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate). apply umpl_conv_0_correct_wrt_sign_invar in H2. apply H2 in H4. destruct H4 as [n [H5 H6]]. exists n. split; auto. + apply umpl_conv_0_correct_wrt_sign_invar in H1. apply H1 in H4. destruct H4 as [n [H5 H6]]. apply umpl_conv_0_correct_wrt_sign_invar in H2. apply H2 in H4. destruct H4 as [n' [H7 H8]]. exists (n + n'). split. * rewrite H5, H7. reflexivity. * rewrite H6, H8. apply pl_tl_length_concat.", "succ": true}]