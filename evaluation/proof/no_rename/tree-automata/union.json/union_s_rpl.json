[{"history": {"proof": "intros s d a pl c tl H1 H2. srun best use: union_s_rpl_3 unfold: union_s_rpl_def.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left."], "tactic": "eapply union_s0d_0.", "exn": "In environment d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M0 prec_list) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (M1 prec_list a pl) (app c tl) Unable to unify \"c\" with \"a\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left."], "tactic": "apply H1.", "exn": "In environment d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M0 prec_list) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (M1 prec_list a pl) (app c tl) Unable to unify \"?M1861 = prec_empty /\\\\ ?M1862 = prec_empty \\\\/ ?M1861 <> prec_empty /\\\\ ?M1862 <> prec_empty\" with \"state_reconnait d (M1 prec_list a pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-"], "tactic": "destruct (ad =? c)%N eqn:Adc.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) The term \"ad\" has type \"Set\" while it is expected to have type \"N\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "eapply union_s0d_1_0.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) Unable to unify \"state_reconnait ?M1863 (union_mpl_0 ?M1864 ?M1865 (M1 prec_list ?M1864 ?M1866)) (app ?M1864 ?M1867)\" with \"state_reconnait d (M1 prec_list a pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "apply H1.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) Unable to unify \"?M1864 = prec_empty /\\\\ ?M1865 = prec_empty \\\\/ ?M1864 <> prec_empty /\\\\ ?M1865 <> prec_empty\" with \"state_reconnait d (M1 prec_list a pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "apply H2.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) Unable to unify \"state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl)\" with \"state_reconnait d (M1 prec_list a pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "eapply union_s0d_1_1.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) Unable to unify \"state_reconnait ?M1863 (union_mpl_0 ?M1864 ?M1865 (M1 prec_list ?M1866 ?M1867)) (app ?M1864 ?M1868)\" with \"state_reconnait d (M1 prec_list a pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "apply H1.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) Unable to unify \"?M1864 = prec_empty /\\\\ ?M1865 = prec_empty \\\\/ ?M1864 <> prec_empty /\\\\ ?M1865 <> prec_empty\" with \"state_reconnait d (M1 prec_list a pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left."], "tactic": "apply n.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind."], "tactic": ["apply H2.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left."], "tactic": "eapply union_s0d_2_0.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app 0%N tl) Unable to unify \"state_reconnait ?M1874 (union_mpl_0 0%N ?M1875 (M2 prec_list ?M1876 ?M1877)) (app 0%N ?M1878)\" with \"state_reconnait d (M1 prec_list a pl) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left."], "tactic": "apply H1.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app 0%N tl) Unable to unify \"?M1875 = prec_empty /\\\\ ?M1876 = prec_empty \\\\/ ?M1875 <> prec_empty /\\\\ ?M1876 <> prec_empty\" with \"state_reconnait d (M1 prec_list a pl) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left."], "tactic": "apply H2.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app 0%N tl) Unable to unify \"state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app 0%N tl)\" with \"state_reconnait d (M1 prec_list a pl) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left.", "shelve.", "+", "right."], "tactic": "eapply union_s0d_2_1.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list p : positive tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app (N.pos p) tl) Unable to unify \"state_reconnait ?M1877 (union_mpl_0 1%N ?M1878 (M2 prec_list ?M1879 ?M1880)) (app 1%N ?M1881)\" with \"state_reconnait d (M2 prec_list s1 s2) (app (N.pos p) tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left.", "shelve.", "+", "right."], "tactic": "apply H1.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list p : positive tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app (N.pos p) tl) Unable to unify \"?M1878 = prec_empty /\\\\ ?M1879 = prec_empty \\\\/ ?M1878 <> prec_empty /\\\\ ?M1879 <> prec_empty\" with \"state_reconnait d (M2 prec_list s1 s2) (app (N.pos p) tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "apply H2.", "-", "left.", "apply prec_list_ind.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct c as [|p].", "+", "left.", "shelve.", "+", "right."], "tactic": "apply H2.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list p : positive tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app (N.pos p) tl) Unable to unify \"state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app (N.pos p) tl)\" with \"state_reconnait d (M2 prec_list s1 s2) (app (N.pos p) tl)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s d a pl c tl H1 H2. unfold mpl_compat in H1. unfold union_mpl_0 in H2. destruct s. - left. eapply union_s0d_0. apply H1. apply H2. - destruct (ad =? c)%N eqn:Adc. + left. eapply union_s0d_1_0. apply H1. apply H2. + right. eapply union_s0d_1_1. apply H1. apply n. apply H2. - destruct c as [|p]. + left. eapply union_s0d_2_0. apply H1. apply H2. + right. eapply union_s0d_2_1. apply H1. apply H2.", "succ": true}]