[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-"], "tactic": "apply H in H1.", "exn": "Unable to apply lemma of type \"mpl_compat (M2 prec_list m m0) s1\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-"], "tactic": "apply H0 in H1.", "exn": "Unable to apply lemma of type \"state_reconnait d (M2 prec_list m m0) (app c tl)\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-"], "tactic": "apply H1.", "exn": "In environment m : state H1 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m) (app c tl) m0 : state H2 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m0) (app c tl) s1 : state d : preDTA c : ad tl : term_list H : mpl_compat (M2 prec_list m m0) s1 H0 : state_reconnait d (M2 prec_list m m0) (app c tl) Unable to unify \"state_reconnait ?M1856 (union_mpl m ?M1855) (app ?M1857 ?M1858) /\\\\ state_reconnait ?M1856 (union_mpl ?M1855 m) (app ?M1857 ?M1858)\" with \"state_reconnait d (union_mpl (M2 prec_list m m0) s1) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "shelve.", "-"], "tactic": "apply H0 in H2.", "exn": "Unable to apply lemma of type \"state_reconnait d (M2 prec_list m m0) (app c tl)\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m0) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "shelve.", "-"], "tactic": "apply H in H2.", "exn": "Unable to apply lemma of type \"mpl_compat (M2 prec_list m m0) s1\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m0) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "shelve.", "-"], "tactic": "apply H2.", "exn": "In environment m : state H1 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m) (app c tl) m0 : state H2 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m0) (app c tl) s1 : state d : preDTA c : ad tl : term_list H : mpl_compat (M2 prec_list m m0) s1 H0 : state_reconnait d (M2 prec_list m m0) (app c tl) Unable to unify \"state_reconnait ?M1856 (union_mpl m0 ?M1855) (app ?M1857 ?M1858) /\\\\ state_reconnait ?M1856 (union_mpl ?M1855 m0) (app ?M1857 ?M1858)\" with \"state_reconnait d (union_mpl s1 (M2 prec_list m m0)) (app c tl)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m H1 m0 H2. unfold union_std_def in *. intros. split. - apply H in H1. apply H0 in H1. apply H1. - apply H0 in H2. apply H in H2. apply H2.", "succ": false}]