[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "apply orb_incr.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"if ?M1882 || ?M1884 then if ?M1883 || ?M1885 then True else False else if ?M1883 || ?M1885 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1 then if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else False else if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "apply andb_inc_l.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"if ?M1883 && ?M1882 then if ?M1884 && ?M1882 then True else False else if ?M1884 && ?M1882 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1 then if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else False else if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b."], "tactic": "apply andb_incr.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"if ?M1887 && ?M1889 then if ?M1888 && ?M1890 then True else False else if ?M1888 && ?M1890 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1 then if b then True else False else if b then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b."], "tactic": "apply leb_reflexive.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"b\" with \"match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b."], "tactic": "apply leb_antisymmetric with b0.", "exn": "The reference b0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b."], "tactic": "apply leb_transitive with b1.", "exn": "The reference b1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++"], "tactic": "apply (lem_get_leb _ _ a b0 b1 H E0 E).", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++"], "tactic": "apply leb_transitive with (mlattice bool m0 b1).", "exn": "The reference b1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++"], "tactic": "-", "exn": "Wrong bullet -: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply orb_incr.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 E0 : MapGet bool m0 a = None Unable to unify \"if ?M1887 || ?M1889 then if ?M1888 || ?M1890 then True else False else if ?M1888 || ?M1890 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end then if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else False else if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply andb_inc_r.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 E0 : MapGet bool m0 a = None Unable to unify \"if ?M1887 && ?M1888 then if ?M1887 && ?M1889 then True else False else if ?M1887 && ?M1889 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end then if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else False else if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply leb_transitive with (mlattice bool m0 b1); auto.", "exn": "The reference b1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "apply andb_inc_l.", "exn": "In environment a : ad p1 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"if ?M1893 && ?M1892 then if ?M1894 && ?M1892 then True else False else if ?M1894 && ?M1892 then True else True\" with \"if b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1 then if match MapGet bool m1 a with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => false end then True else False else if match MapGet bool m1 a with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => false end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "*"], "tactic": "apply leb_transitive with (mlattice bool m0 b1).", "exn": "The reference b1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "*"], "tactic": "apply lem_get_leb with a b0 b1; auto.", "exn": "The reference b0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "*", "shelve.", "*", "apply leb_transitive with b; auto."], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "++", "shelve.", "++", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "apply leb_transitive with b.", "*", "shelve.", "*", "apply leb_transitive with b; auto.", "--", "shelve.", "--", "shelve.", "-"], "tactic": "apply leb_transitive with b; auto.", "exn": "The reference b was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros p m0 m1 H. unfold leb, pl_non_empty in *. destruct p; try auto. destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto). + destruct (MapGet bool m0 a) eqn:E0. - apply orb_incr. * apply andb_inc_l. apply leb_transitive with b. { apply andb_incr. apply leb_reflexive. apply leb_antisymmetric with b0. } { apply leb_transitive with b1. ++ apply (lem_get_leb _ _ a b0 b1 H E0 E). ++ apply leb_transitive with (mlattice bool m0 b1). -- apply lem_domain_equal with m0; auto. -- apply lem_domain_equal with m1; auto. } * apply leb_transitive with (mlattice bool m1 b). { apply lem_domain_equal with m1; auto. } { apply andb_incr; auto. } - apply orb_incr. * apply andb_inc_r. apply leb_transitive with (mlattice bool m0 b1); auto. apply lem_domain_equal with m0; auto. * apply leb_transitive with b; auto. + destruct (MapGet bool m0 a) eqn:E0. - apply andb_inc_l. apply leb_transitive with b. * apply leb_transitive with (mlattice bool m0 b1). { apply lem_get_leb with a b0 b1; auto. } { apply lem_domain_equal with m0; auto. } * apply leb_transitive with b; auto. - apply leb_transitive with b; auto.", "succ": false}]