[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-"], "tactic": "apply H.", "exn": "In environment m0, m1, m : Map bool H : (fix lem (m0 m1 : Map bool) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a b => match m1 with | @M1 _ a' b' => if (a =? a')%N then leb b b' else False | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => lem a c /\\\\ lem b d | _ => False end end) m0 m1 Unable to unify \"(fix lem (m0 m1 : Map bool) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a b => match m1 with | @M1 _ a' b' => if (a =? a')%N then leb b b' else False | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => lem a c /\\\\ lem b d | _ => False end end) m0 m1\" with \"lem ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) (M0 state) m m0) ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) (M0 state) m m1)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-"], "tactic": "destruct z eqn:Ez.", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*"], "tactic": ["destruct H as [H0 H1].", ""], "exn": "Expects a disjunctive pattern with 0 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "destruct r eqn:Er.", "exn": "The reference r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "destruct r0; destruct r1; simpl.", "exn": "The reference r0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "destruct H; destruct r1; simpl.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "destruct H; destruct r1; simpl.", "*", "shelve.", "*", "reflexivity."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "destruct H; destruct r1; simpl.", "*", "shelve.", "*", "reflexivity.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 m d H.", "unfold lem in H.", "unfold dta_app_ne_aux.", "destruct d; simpl.", "-", "shelve.", "-", "destruct a eqn:Ea.", "+", "destruct m0; destruct m1; simpl.", "*", "shelve.", "*", "contradiction.", "*", "contradiction.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "destruct H; destruct r1; simpl.", "*", "shelve.", "*", "reflexivity.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros m0 m1 m d H. unfold lem in H. unfold dta_app_ne_aux. destruct d; simpl. - apply H. - destruct z eqn:Ez. + destruct m0; destruct m1; simpl. * intros Hlem. destruct (a =? a0)%N eqn:Elem. { apply leb_correct. } { contradiction. } * contradiction. * contradiction. * destruct H as [H0 H1]. split. { apply (dta_app_ne_inc_1 s m0 m1). apply H0. } { apply (dta_app_ne_inc_1 s m0 m1). apply H1. } + contradiction. - destruct r eqn:Er. + destruct r0; destruct r1; simpl. * reflexivity. * reflexivity. * reflexivity. * destruct H as [H0 H1]. split. { apply (dta_app_ne_aux_domain d0 m r0). apply H0. } { apply (dta_app_ne_aux_domain d1 m r1). apply H1. } + reflexivity.", "succ": false}]