[{"history": {"proof": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. hauto use: st_kill_2, prec_list_kill_ref_ok_invar.", "repairs": ["", "", "", "", "hammer"], "exceptions": [{"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-"], "tactic": ["destruct p as [a' p'].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+"], "tactic": "destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1.", "exn": "The reference s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+"], "tactic": "apply IHs.", "exn": "The reference IHs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++"], "tactic": ["apply H2.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4."], "tactic": "apply H1 with (a:=a'').", "exn": "In environment d : preDTA s2 : Map prec_list sigma : signature H1 : forall (a : ad) (p : prec_list), MapGet prec_list (M2 prec_list (M0 prec_list) s2) a = Some p -> prec_list_ref_ok p d H2 : predta_correct_wrt_sign d sigma a : ad p : prec_list H3 : MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M2 prec_list (M0 prec_list) s2)) a = Some p IHs1 : (forall (a : ad) (p : prec_list), MapGet prec_list (M0 prec_list) a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M0 prec_list)) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) IHs2 : (forall (a : ad) (p : prec_list), MapGet prec_list s2 a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) s2) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) a'' : Map state p'' : prec_list_ref_ok p a'' H4 : Map state The term \"a''\" has type \"Map state\" while it is expected to have type \"N\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4."], "tactic": "apply H1 with (a:=a).", "exn": "In environment d : preDTA s2 : Map prec_list sigma : signature H1 : forall (a : ad) (p : prec_list), MapGet prec_list (M2 prec_list (M0 prec_list) s2) a = Some p -> prec_list_ref_ok p d H2 : predta_correct_wrt_sign d sigma a : ad p : prec_list H3 : MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M2 prec_list (M0 prec_list) s2)) a = Some p IHs1 : (forall (a : ad) (p : prec_list), MapGet prec_list (M0 prec_list) a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M0 prec_list)) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) IHs2 : (forall (a : ad) (p : prec_list), MapGet prec_list s2 a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) s2) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) a'' : Map state p'' : prec_list_ref_ok p a'' H4 : Map state Unable to unify \"MapGet prec_list (M2 prec_list (M0 prec_list) s2) a = Some ?M1870\" with \"forall a : ad, prec_occur p a -> exists s : state, MapGet state H4 a = Some s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+"], "tactic": "apply H2.", "exn": "In environment d : preDTA a0 : ad p0 : prec_list s2 : Map prec_list sigma : signature H1 : forall (a : ad) (p : prec_list), MapGet prec_list (M2 prec_list (M1 prec_list a0 p0) s2) a = Some p -> prec_list_ref_ok p d H2 : predta_correct_wrt_sign d sigma a : ad p : prec_list H3 : MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M2 prec_list (M1 prec_list a0 p0) s2)) a = Some p IHs1 : (forall (a : ad) (p : prec_list), MapGet prec_list (M1 prec_list a0 p0) a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M1 prec_list a0 p0)) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) IHs2 : (forall (a : ad) (p : prec_list), MapGet prec_list s2 a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) s2) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) Unable to unify \"predta_correct_wrt_sign d sigma\" with \"prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+"], "tactic": "destruct (states_kill_aux (dta_non_empty_states d) s1) eqn:E2.", "exn": "The reference s1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*"], "tactic": "destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1.", "exn": "The reference s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1."], "tactic": "apply IHs0.", "exn": "The reference IHs0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply prec_list_ind.", "intros a'' p'' H4."], "tactic": ["apply H1 with (a:=a'').", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply prec_list_ind.", "intros a'' p'' H4."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply prec_list_ind.", "intros a'' p'' H4.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply IHs1.", "++"], "tactic": "apply IHs0.", "exn": "The reference IHs0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply prec_list_ind.", "intros a'' p'' H4.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply IHs1.", "++", "apply prec_list_ind.", "intros a'' p'' H4."], "tactic": ["apply H1 with (a:=a'').", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply prec_list_ind.", "intros a'' p'' H4.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply IHs1.", "++", "apply prec_list_ind.", "intros a'' p'' H4."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply Map_ind.", "++", "shelve.", "++", "shelve.", "++", "intros a'' p'' H4.", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply prec_list_ind.", "intros a'' p'' H4.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply IHs1.", "++", "apply prec_list_ind.", "intros a'' p'' H4.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "apply H2.", "exn": "In environment d : preDTA s1_1, s1_2, s2 : Map prec_list sigma : signature H1 : forall (a : ad) (p : prec_list), MapGet prec_list (M2 prec_list (M2 prec_list s1_1 s1_2) s2) a = Some p -> prec_list_ref_ok p d H2 : predta_correct_wrt_sign d sigma a : ad p : prec_list H3 : MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M2 prec_list (M2 prec_list s1_1 s1_2) s2)) a = Some p IHs1 : (forall (a : ad) (p : prec_list), MapGet prec_list (M2 prec_list s1_1 s1_2) a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M2 prec_list s1_1 s1_2)) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) IHs2 : (forall (a : ad) (p : prec_list), MapGet prec_list s2 a = Some p -> prec_list_ref_ok p d) -> MapGet prec_list (states_kill_aux (dta_non_empty_states d) s2) a = Some p -> prec_list_ref_ok p (preDTA_kill (dta_non_empty_states d) d) a0 : ad p0 : prec_list E2 : states_kill_aux (dta_non_empty_states d) s1_2 = M1 prec_list a0 p0 Unable to unify \"predta_correct_wrt_sign d sigma\" with \"MapGet prec_list (states_kill_aux (dta_non_empty_states d) (M2 prec_list s1_1 s1_2)) a = Some p\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. unfold states_kill_aux. induction s. - simpl. auto. - destruct p as [a' p']. destruct (prec_list_kill (dta_non_empty_states d) p') eqn:E. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. - destruct s1. + destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. + destruct (states_kill_aux (dta_non_empty_states d) s1) eqn:E2. * destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). * apply IHs1. ++ apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2.", "succ": true}]