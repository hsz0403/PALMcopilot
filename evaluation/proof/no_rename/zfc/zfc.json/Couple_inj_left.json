[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros A A' B B' H.", "inversion H."], "tactic": "apply H0.", "exn": "In environment A, A', B, B' : Ens H : EQ (Couple A A') (Couple B B') H0 : forall x : bool, EXType bool (fun y : bool => EQ (bool_rect (fun _ : bool => Ens) (Sing A) (Paire Vide (Sing A')) x) (bool_rect (fun _ : bool => Ens) (Sing B) (Paire Vide (Sing B')) y)) H1 : forall y : bool, EXType bool (fun x : bool => EQ (bool_rect (fun _ : bool => Ens) (Sing A) (Paire Vide (Sing A')) x) (bool_rect (fun _ : bool => Ens) (Sing B) (Paire Vide (Sing B')) y)) Unable to unify \"EXType bool (fun y : bool => EQ (bool_rect (fun _ : bool => Ens) (Sing A) (Paire Vide (Sing A')) ?M1451) (bool_rect (fun _ : bool => Ens) (Sing B) (Paire Vide (Sing B')) y))\" with \"(fix F (e : Ens) : (fun _ : Ens => Ens -> Prop) e := match e as e0 return ((fun _ : Ens => Ens -> Prop) e0) with | sup A e0 => (fun (A0 : Type) (_ : A0 -> Ens) (eq1 : A0 -> Ens -> Prop) (X0 : Ens) => Ens_rect (fun _ : Ens => Prop) (fun (B : Type) (g : B -> Ens) (_ : B -> Prop) => (forall x : A0, EXType B (fun y : B => eq1 x (g y))) /\\\\ (forall y : B, EXType A0 (fun x : A0 => eq1 x (g y)))) X0) A e0 (fun a : A => F (e0 a)) end) A B\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A A' B B' H.", "inversion H."], "tactic": "apply H1.", "exn": "In environment A, A', B, B' : Ens H : EQ (Couple A A') (Couple B B') H0 : forall x : bool, EXType bool (fun y : bool => EQ (bool_rect (fun _ : bool => Ens) (Sing A) (Paire Vide (Sing A')) x) (bool_rect (fun _ : bool => Ens) (Sing B) (Paire Vide (Sing B')) y)) H1 : forall y : bool, EXType bool (fun x : bool => EQ (bool_rect (fun _ : bool => Ens) (Sing A) (Paire Vide (Sing A')) x) (bool_rect (fun _ : bool => Ens) (Sing B) (Paire Vide (Sing B')) y)) Unable to unify \"EXType bool (fun x : bool => EQ (bool_rect (fun _ : bool => Ens) (Sing A) (Paire Vide (Sing A')) x) (bool_rect (fun _ : bool => Ens) (Sing B) (Paire Vide (Sing B')) ?M1451))\" with \"(fix F (e : Ens) : (fun _ : Ens => Ens -> Prop) e := match e as e0 return ((fun _ : Ens => Ens -> Prop) e0) with | sup A e0 => (fun (A0 : Type) (_ : A0 -> Ens) (eq1 : A0 -> Ens -> Prop) (X0 : Ens) => Ens_rect (fun _ : Ens => Prop) (fun (B : Type) (g : B -> Ens) (_ : B -> Prop) => (forall x : A0, EXType B (fun y : B => eq1 x (g y))) /\\\\ (forall y : B, EXType A0 (fun x : A0 => eq1 x (g y)))) X0) A e0 (fun a : A => F (e0 a)) end) A B\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros A A' B B' H. inversion H. intros. apply H0. apply H1.", "succ": false}]