[{"history": {"proof": "hauto lq: on use: Zp_mult_one, Zp_mult_comm.", "repairs": ["hammer"], "exceptions": [{"ctx": ["unfold Zp_mult."], "tactic": "rewrite Zp_mult_one.", "exn": "Found no subterm matching \"Op \u2297 ?M1442\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "rewrite rem_prop with (n:=1).", "exn": "Found no subterm matching \"rem ?M1449 ?M1450\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "rewrite Nat.mul_1_l.", "exn": "Found no subterm matching \"1 * ?M1449\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "apply rem_lt.", "exn": "In environment p : nat Hp : p <> 0 x : Z_Zp Unable to unify \"rem ?M1451 ?M1449 = ?M1451\" with \"proj1_sig x = proj1_sig ((let (x, _) := x in fun H : Z_Zp => let (y, _) := H in exist (fun x0 : nat => x0 < p) (rem (x * y) p) (div_rem_spec2 (x * y) Hp)) Op)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "apply Hp.", "exn": "In environment p : nat Hp : p <> 0 x : Z_Zp Unable to unify \"p <> 0\" with \"proj1_sig x = proj1_sig ((let (x, _) := x in fun H : Z_Zp => let (y, _) := H in exist (fun x0 : nat => x0 < p) (rem (x * y) p) (div_rem_spec2 (x * y) Hp)) Op)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "apply lt_pirr.", "exn": "In environment p : nat Hp : p <> 0 x : Z_Zp Unable to unify \"?M1451 = ?M1452\" with \"proj1_sig x = proj1_sig ((let (x, _) := x in fun H : Z_Zp => let (y, _) := H in exist (fun x0 : nat => x0 < p) (rem (x * y) p) (div_rem_spec2 (x * y) Hp)) Op)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "rewrite Nat.mul_comm.", "exn": "Found no subterm matching \"?M1449 * ?M1450\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "apply rem_lt.", "exn": "In environment p : nat Hp : p <> 0 x : Z_Zp Unable to unify \"rem ?M1451 ?M1449 = ?M1451\" with \"proj1_sig x = proj1_sig ((let (x, _) := x in fun H : Z_Zp => let (y, _) := H in exist (fun x0 : nat => x0 < p) (rem (x * y) p) (div_rem_spec2 (x * y) Hp)) Op)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "apply Hp.", "exn": "In environment p : nat Hp : p <> 0 x : Z_Zp Unable to unify \"p <> 0\" with \"proj1_sig x = proj1_sig ((let (x, _) := x in fun H : Z_Zp => let (y, _) := H in exist (fun x0 : nat => x0 < p) (rem (x * y) p) (div_rem_spec2 (x * y) Hp)) Op)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Zp_mult.", "symmetry.", "apply Zp_inj."], "tactic": "apply lt_pirr.", "exn": "In environment p : nat Hp : p <> 0 x : Z_Zp Unable to unify \"?M1451 = ?M1452\" with \"proj1_sig x = proj1_sig ((let (x, _) := x in fun H : Z_Zp => let (y, _) := H in exist (fun x0 : nat => x0 < p) (rem (x * y) p) (div_rem_spec2 (x * y) Hp)) Op)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. unfold Zp_mult. rewrite Zp_mult_one. symmetry. apply Zp_inj. rewrite rem_prop with (n:=1). - rewrite Nat.mul_1_l. apply rem_lt. + apply Hp. + apply lt_pirr. - rewrite Nat.mul_comm. apply rem_lt. + apply Hp. + apply lt_pirr.", "succ": true}]