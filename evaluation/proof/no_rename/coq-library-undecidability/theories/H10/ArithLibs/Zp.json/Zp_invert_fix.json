[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split; intros.", "-", "destruct (nat2Zp_choose x) as [HxZp | [HxOp | [HxOpmo | [m [Hm Hm']]]]].", "+", "rewrite HxZp.", "left.", "reflexivity.", "+", "rewrite HxOp.", "right.", "left.", "reflexivity.", "+", "rewrite HxOpmo.", "right.", "right."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["split; intros.", "-", "destruct (nat2Zp_choose x) as [HxZp | [HxOp | [HxOpmo | [m [Hm Hm']]]]].", "+", "rewrite HxZp.", "left.", "reflexivity.", "+", "rewrite HxOp.", "right.", "left.", "reflexivity.", "+", "rewrite HxOpmo.", "right.", "right.", "reflexivity.", "+"], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros. split; intros. - destruct (nat2Zp_choose x) as [HxZp | [HxOp | [HxOpmo | [m [Hm Hm']]]]]. + rewrite HxZp. left. reflexivity. + rewrite HxOp. right. left. reflexivity. + rewrite HxOpmo. right. right. left. reflexivity. + destruct (Zp_invert_eq_not_zero x) as [H1 H2]. * intro. apply Hp. rewrite H. apply Z_inj_0. * rewrite <- H2. destruct (Zp_invert_spec2 x) as [H3 H4]. assert (loc1: x \u2297 inv x = Op). { apply H4. intro contra. apply H1. apply contra. } apply Zp_prime_square_one in loc1. destruct loc1. ++ left. rewrite H5. apply Zp_mult_zero. ++ right. left. rewrite H5. apply Zp_mult_one_r. - intros [HxZp | [HxOp | HxOpmo]]. + subst. apply Zp_invert_eq_not_zero. intro. apply Hp. apply Z_inj_0. apply Zp_mult_zero. + subst. apply Zp_invert_eq_not_zero. * intro. apply Hp. apply Z_inj_0. * apply Zp_mult_one. + subst. apply Zp_invert_eq_not_zero. * intro. apply Hp. apply Z_inj_0. * apply Zp_mult_minus_one.", "succ": false}]