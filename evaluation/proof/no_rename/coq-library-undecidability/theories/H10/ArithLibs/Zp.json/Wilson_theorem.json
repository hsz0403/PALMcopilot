[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "intros p H. intros H2. split. - intros Hprime. split. + unfold divides. exists (fact (p - 1)). replace (fact (p - 1) + 1) with (1 + fact (p - 1)). * rewrite Nat.add_comm. rewrite Nat2Z.inj_add. apply Zp_lprod_fact; auto. * simpl. reflexivity. + intros q Hq. destruct (prime_or_div q) as [[r [Hqr Hdiv]] | Hprimeq]. * apply prime_ge_2 in Hprime. destruct r. ++ rewrite Hdiv in Hqr. simpl in Hqr. lia. ++ destruct (Nat.eq_dec p (S (S n))) as [Heq | Hneq]. ** left; auto. ** right. apply prime_algo. --- lia. --- intros n Hn. intros Hdiv2. destruct (Nat.eq_dec n 0) as [Heq' | Hneq']. +++ subst; contradiction. +++ apply Hprime. subst q. exists (S n). rewrite mult_comm. apply divides_plus; auto. replace (2 * S n) with (S (S (2 * n))) in Hdiv2. **** inversion Hdiv2. **** lia. * exfalso. apply Hprime. ** apply prime_ge_2; auto. ** exists q. apply Hdiv. - intros Hdiv. destruct (prime_or_div p) as [[q [Hqp Hdivq]] | Hprimep]. + contradiction. + apply prime_ge_2 in Hprimep. apply prime_algo; auto. * intuition. * intros n Hn. intros Hdiv2. destruct n. ++ lia. ++ apply Hprimep. -- pose (k := (S (S n))). exists k. rewrite mult_comm. apply divides_plus; auto. -- replace (3 + 2 * S n) with (S (S (3 + 2 * n))) in Hdiv2. ** inversion Hdiv2. ** lia.", "succ": false}]