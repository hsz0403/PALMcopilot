[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold is_gcd.", "unfold alpha_nat."], "tactic": "unfold alpha_nat in \u03b1.", "exn": "No such hypothesis: \u03b1", "type": "no_hypos", "handled": true}, {"ctx": ["unfold is_gcd.", "unfold alpha_nat."], "tactic": "unfold alpha_nat in IHn.", "exn": "No such hypothesis: IHn", "type": "no_hypos", "handled": true}, {"ctx": ["unfold is_gcd.", "unfold alpha_nat."], "tactic": "unfold is_gcd in IHn.", "exn": "No such hypothesis: IHn", "type": "no_hypos", "handled": true}, {"ctx": ["unfold is_gcd.", "unfold alpha_nat."], "tactic": "destruct (Z_of_nat_set Zpos).", "exn": "In environment b_nat : nat Hb_nat : (2 <= b_nat)%nat b := Z.of_nat b_nat : Z Hb : 2 <= b A_eq_3_12 : forall n : nat, exists u v : Z, u * \u03b1 (S n) + v * \u03b1 n = 1 n : nat The term \"Z.pos\" has type \"positive -> Z\" while it is expected to have type \"Z -> Set\" (cannot unify \"Z\" and \"positive\").", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "unfold is_gcd. unfold alpha_nat. unfold alpha_nat in \u03b1. intros. unfold alpha_nat. unfold alpha_nat in IHn. unfold is_gcd in IHn. unfold is_gcd. destruct (Z_of_nat_set Zpos). * intros n0. apply IHn with (k:=n0). + auto. + auto. * unfold Z_of_nat in H. discriminate H.", "succ": false}]