[{"history": {"proof": "hauto l: on depth: 3.", "repairs": ["hammer"], "exceptions": []}, "chat": [], "original": "intros r q p. split. - intros H. unfold expo_conditions. split. + unfold expo. rewrite H. case_eq r. * intros. left. split. reflexivity. rewrite H0. reflexivity. * intros n Hn. right. case_eq q. { intros. left. split. reflexivity. right. split. omega. reflexivity. } { intros m Hm. right. split. omega. left. exists (alpha_nat (q + 4) (1 + r)), (alpha_nat (n * q)), (alpha_nat (q * r)). repeat split; try omega. } - intros [H1 | [H2 | [H3 H4]]]. + induction r. * simpl. intros H. apply expo_necessity in H. rewrite H. reflexivity. * simpl. rewrite power_S. simpl. rewrite IHr. reflexivity. + destruct H2 as [H2 | [H2 | [H2 H5]]]. * rewrite H2. apply expo_necessity. reflexivity. * rewrite power_0_inv in H2. destruct H2. apply expo_necessity in H. rewrite H. rewrite H1. reflexivity. omega. * destruct H5 as [b [m [a1 [a2 [a3 Hcond]]]]]. apply expo_necessity in H3. apply expo_necessity in H4. rewrite H3, H4. assert (G1: b * (n * q) = b * (q * m)). { rewrite Hcond. omega. } assert (G2: a1 + n * q + 2 = a1 + q * m). { rewrite Hcond. omega. } rewrite Nat.add_comm in G2. rewrite G1, G2. reflexivity.", "succ": true}]