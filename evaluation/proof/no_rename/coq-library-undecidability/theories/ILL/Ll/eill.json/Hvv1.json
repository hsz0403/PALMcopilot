[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["apply nat_sorted_injective."], "tactic": "apply (list_injective_rect eill_vars (fun ll => nat_sorted ll -> list_injective ll)).", "exn": "In environment \u03a3 : list eill_cmd \u0393 : list eill_vars vv := nat_sort vars : list eill_vars The term \"eill_vars\" has type \"Set\" while it is expected to have type \"list ?X -> Type\".", "type": "wrong_type", "handled": true}, {"ctx": ["apply nat_sorted_injective."], "tactic": "apply in_list_injective_0.", "exn": "In environment \u03a3 : list eill_cmd \u0393 : list eill_vars vv := nat_sort vars : list eill_vars l : list ?M1448 a : ?M1448 m : list ?M1448 b : ?M1448 r : list ?M1448 Unable to unify \"nil = l ++ a :: m ++ b :: r\" with \"vv = l ++ a :: m ++ b :: r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["apply nat_sorted_injective.", "intros x ll H1 H2."], "tactic": "apply list_injective_inv in H2.", "exn": "Unable to apply lemma of type \"forall (X : Type) (x : X) (ll : list X), list_injective (x :: ll) -> ~ In x ll /\\\\ list_injective ll\" on hypothesis of type \"eill_vars\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["apply nat_sorted_injective.", "intros x ll H1 H2."], "tactic": ["destruct H2 as [H2 _].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "apply nat_sorted_injective. apply (list_injective_rect eill_vars (fun ll => nat_sorted ll -> list_injective ll)). - apply in_list_injective_0. - intros x ll H1 H2. apply list_injective_inv in H2. destruct H2 as [H2 _]. apply H2.", "succ": false}]