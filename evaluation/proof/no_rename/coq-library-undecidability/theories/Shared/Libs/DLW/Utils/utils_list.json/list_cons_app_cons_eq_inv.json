[{"history": {"proof": "intros. sauto q: on depth: 3.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros."], "tactic": "apply list_app_cons_eq_inv in H.", "exn": "Unable to apply lemma of type \"forall (X : Type) (l1 l2 r1 r2 : list X) (x : X), l1 ++ r1 = l2 ++ x :: r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ x :: r2} + {m : list X | l2 ++ x :: m = l1 /\\\\ r2 = m ++ r1}\" on hypothesis of type \"x :: r1 = l2 ++ y :: r2\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros."], "tactic": ["destruct H as [[m [H1 H2]] | [m [H1 H2]]].", ""], "exn": "Expects a disjunctive pattern with 1 branch or a conjunctive pattern made of 0 patterns.", "type": "num_branch_both", "handled": false}]}, "chat": [], "original": "intros. apply list_app_cons_eq_inv in H. destruct H as [[m [H1 H2]] | [m [H1 H2]]]. * left. split. + apply app_eq_unit in H1. destruct H1 as [H1 | H1]. - destruct H1. reflexivity. - destruct H1 as [H1 H3]. inversion H1. + split. - apply elt_eq_unit in H2. destruct H2 as [H2 _]. auto. - apply elt_eq_unit in H2. destruct H2 as [_ H2]. auto. * right. exists m. split; auto.", "succ": true}]