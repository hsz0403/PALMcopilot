[{"history": {"proof": "simpl. hauto lq: on use: expf_B0_CS, expf_B0_CN, expf_B0_CS_2, expf_B0_CS_1, expf_B0_CS_1_b inv: sumbool.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "destruct (expf_dec m x0 xb0) as [H_dec | H_dec].", "exn": "The reference xb0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "destruct H.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "split; auto.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "split; auto.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "destruct H.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "split; auto.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "split; auto.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro.", "shelve.", "-", "intro."], "tactic": "destruct (expf_dec m x0 xb0) as [H_dec | H_dec].", "exn": "The reference xb0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro.", "shelve.", "-", "intro.", "destruct H0."], "tactic": "destruct H0.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro.", "shelve.", "-", "intro.", "destruct H0.", "destruct Iter.", "++", "left."], "tactic": "split; auto.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}, {"ctx": ["simpl.", "intros.", "unfold expf.", "split.", "-", "intro.", "shelve.", "-", "intro.", "destruct H0.", "destruct Iter.", "++", "left.", "++", "left."], "tactic": "split; auto.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}]}, "chat": [], "original": "simpl. intros. unfold expf. split. - intro. destruct (expf_dec m x0 xb0) as [H_dec | H_dec]. + destruct H. * left. split; auto. * right. left. split; auto. + destruct H. * right. right. left. split; auto. * left. split; auto. - intro. destruct (expf_dec m x0 xb0) as [H_dec | H_dec]. + destruct H0. * destruct H0. ++ left. split; auto. ++ right. left. split; auto. * right. right. left. split; auto. + destruct H0. * left. split; auto. * right. right. right. split; auto.", "succ": true}]