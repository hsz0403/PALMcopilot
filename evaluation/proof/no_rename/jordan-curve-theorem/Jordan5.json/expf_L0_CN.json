[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x y z t H1 H2 H3 H4 H5."], "tactic": "unfold expf_dec.", "exn": "Cannot coerce expf_dec to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-"], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-"], "tactic": "apply (expf_L0_CS m x y z t H1 H2 H4 H6).", "exn": "In environment m : fmap x, y, z, t : dart H1 : inv_hmap (L m zero x y) H2 : exd m z H3 : expf (L m zero x y) z t H4 := cA m zero x : dart H5 := cA_1 m one x : dart H6 : expf m (cA_1 m one x) y The term \"H4\" has type \"dart\" while it is expected to have type \"if expf_dec m (cA_1 m one x) y then betweenf m (cA_1 m one x) z y /\\\\ betweenf m (cA_1 m one x) t y \\\\/ betweenf m (cA_1 m one (cA_1 m zero y)) z (cA m zero x) /\\\\ betweenf m (cA_1 m one (cA_1 m zero y)) t (cA m zero x) \\\\/ ~ expf m (cA_1 m one x) z /\\\\ expf m z t else expf m (cA_1 m one x) z /\\\\ expf m y t \\\\/ expf m (cA_1 m one x) t /\\\\ expf m y z \\\\/ expf m z t\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-", "shelve.", "-"], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-", "shelve.", "-", "destruct (expf_dec m z t) as [H8 | H9].", "+"], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-", "shelve.", "-", "destruct (expf_dec m z t) as [H8 | H9].", "+"], "tactic": "apply H8.", "exn": "In environment m : fmap x, y, z, t : dart H1 : inv_hmap (L m zero x y) H2 : exd m z H3 : expf (L m zero x y) z t H4 := cA m zero x : dart H5 := cA_1 m one x : dart H7 : ~ expf m (cA_1 m one x) y H8 : expf m z t Unable to unify \"expf m z t\" with \"let y_0 := cA_1 m zero y in let y_0_1 := cA_1 m one y_0 in if expf_dec m H5 y then betweenf m H5 z y /\\\\ betweenf m H5 t y \\\\/ betweenf m y_0_1 z H4 /\\\\ betweenf m y_0_1 t H4 \\\\/ ~ expf m H5 z /\\\\ expf m z t else expf m z t \\\\/ expf m z y /\\\\ expf m t H4 \\\\/ expf m t y /\\\\ expf m z H4\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-", "shelve.", "-", "destruct (expf_dec m z t) as [H8 | H9].", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-", "shelve.", "-", "destruct (expf_dec m z t) as [H8 | H9].", "+", "shelve.", "+"], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y z t H1 H2 H3 H4 H5.", "destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7].", "-", "shelve.", "-", "destruct (expf_dec m z t) as [H8 | H9].", "+", "shelve.", "+"], "tactic": ["destruct H9 as [H10 | [H11 H12]].", ""], "exn": "Expects a disjunctive pattern with 0 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros m x y z t H1 H2 H3 H4 H5. unfold expf_dec. destruct (expf_dec m (cA_1 m one x) y) as [H6 | H7]. - left. apply (expf_L0_CS m x y z t H1 H2 H4 H6). - right. destruct (expf_dec m z t) as [H8 | H9]. + left. apply H8. + right. destruct H9 as [H10 | [H11 H12]]. * left. split. -- apply (expf_L0_5 m x y z t H1 H2 H6 H7 H11). -- apply H10. * right. split. -- apply (expf_L0_5bis m x y z t H1 H2 H6 H7 H11). -- apply (conj H12 H10).", "succ": false}]