[{"history": {"proof": "intros m k j x z Hmap Hneq. strivial use: cA_cA_1_B_ter.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B."], "tactic": "destruct Hmap.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst."], "tactic": "reflexivity.", "exn": "In environment m : fmap j : dim z : dart Hmap : inv_hmap m Hneq : zero <> j Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero z) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*"], "tactic": "destruct (eq_dart_dec (cA_1 m0 zero z) z) as [H1 | H1].", "exn": "The reference m0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++"], "tactic": "rewrite H1.", "exn": "Found no subterm matching \"cA_1 m zero z\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++"], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j e : k = zero n : x <> z H1 : cA_1 m zero z = z Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k x) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++"], "tactic": "rewrite H1.", "exn": "Found no subterm matching \"cA_1 m zero z\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++"], "tactic": "apply cA_cA_1; auto.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j e : k = zero n : x <> z H1 : cA_1 m zero z <> z Unable to unify \"cA ?M2295 ?M2296 (cA_1 ?M2295 ?M2296 ?M2297) = ?M2297\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k x) j z = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++"], "tactic": "+", "exn": "Wrong bullet +: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst."], "tactic": "reflexivity.", "exn": "In environment m : fmap j : dim z : dart Hmap : inv_hmap m n : one <> zero Hneq : one <> j Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m one z) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++"], "tactic": "destruct (eq_dart_dec (cA_1 m0 one z) z) as [H2 | H2].", "exn": "The reference m0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--"], "tactic": "rewrite H2.", "exn": "Found no subterm matching \"cA_1 m one z\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--"], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j n : k <> zero e : k = one n0 : x <> z H2 : cA_1 m one z = z Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k x) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--"], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--"], "tactic": "rewrite H2.", "exn": "Found no subterm matching \"cA_1 m one z\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--"], "tactic": "apply cA_cA_1; auto.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j n : k <> zero e : k = one n0 : x <> z H2 : cA_1 m one z <> z Unable to unify \"cA ?M2325 ?M2326 (cA_1 ?M2325 ?M2326 ?M2327) = ?M2327\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k x) j z = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--"], "tactic": "*", "exn": "Wrong bullet *: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*"], "tactic": "destruct (eq_dim_dec k k0).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*"], "tactic": "destruct (eq_dart_dec x0 x).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--"], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j n : k <> zero n0 : k <> one e : x = x Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k x) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--"], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--"], "tactic": "destruct (eq_dart_dec x0 z).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst."], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim z : dart Hmap : inv_hmap m Hneq : k <> j n : k <> zero n0 : k <> one n1 : z <> z Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k z) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst."], "tactic": "**", "exn": "Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**"], "tactic": "destruct (eq_dim_dec k0 zero).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto."], "tactic": "apply cA_exd; auto.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j n : k <> zero n0 : k <> one n1 : x <> x n2 : x <> z Unable to unify \"(fix exd (m : fmap) (x : dart) {struct m} : Prop := match m with | V => False | I m0 x0 _ _ => x0 = x \\\\/ exd m0 x | L m0 _ _ _ => exd m0 x end) ?M2384 ?M2386\" with \"nil = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---"], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k <> j n : k <> zero n0 : k <> one n1 : x <> x n2 : x <> z Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---"], "tactic": "destruct (eq_dim_dec k k0).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---"], "tactic": "--", "exn": "Wrong bullet --: Current bullet --- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---", "shelve."], "tactic": "--", "exn": "Wrong bullet --: Expecting ---.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---", "shelve.", "---"], "tactic": "destruct (eq_dart_dec x0 x).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---", "shelve.", "---", "destruct (eq_dart_dec x x)."], "tactic": "**", "exn": "Wrong bullet **: Current bullet --- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "destruct (eq_dart_dec (cA_1 m zero z) z) as [H1 | H1].", "++", "shelve.", "++", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++", "destruct (eq_dart_dec (cA_1 m one z) z) as [H2 | H2].", "--", "shelve.", "--", "shelve.", "*", "destruct (eq_dart_dec x x).", "--", "shelve.", "--", "destruct (eq_dart_dec x z).", "**", "subst.", "shelve.", "**", "rewrite not_exd_cA; try auto.", "---", "shelve.", "---", "destruct (eq_dart_dec x x).", "+++", "shelve.", "+++", "shelve."], "tactic": "**", "exn": "Wrong bullet **: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros m k j x z Hmap Hneq. unfold cA, B. destruct Hmap. unfold cA, cA_1 in *. destruct (eq_dim_dec k zero). + destruct (eq_dart_dec x z). * subst. reflexivity. * destruct (eq_dart_dec (cA_1 m0 zero z) z) as [H1 | H1]. ++ rewrite H1. reflexivity. ++ rewrite H1. apply cA_cA_1; auto. + destruct (eq_dim_dec k one). * destruct (eq_dart_dec x z). ++ subst. reflexivity. ++ destruct (eq_dart_dec (cA_1 m0 one z) z) as [H2 | H2]. -- rewrite H2. reflexivity. -- rewrite H2. apply cA_cA_1; auto. * destruct (eq_dim_dec k k0). ++ destruct (eq_dart_dec x0 x). -- reflexivity. -- destruct (eq_dart_dec x0 z). ** subst. reflexivity. ** destruct (eq_dim_dec k0 zero). --- rewrite not_exd_cA; try auto. apply cA_exd; auto. --- reflexivity. ++ destruct (eq_dim_dec k k0). -- destruct (eq_dart_dec x0 x). ** reflexivity. ** destruct (eq_dart_dec x0 z). --- subst. reflexivity. --- destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. +++ rewrite H2. reflexivity. +++ rewrite H2. apply cA_cA_1; auto. -- destruct (eq_dim_dec k k0). ** destruct (eq_dart_dec x0 x). --- reflexivity. --- destruct (eq_dart_dec x0 z). +++ subst. unfold cA. rewrite not_exd_cA; try auto. apply cA_exd; auto. +++ destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. ++++ rewrite H2. reflexivity. ++++ rewrite H2. apply cA_cA_1; auto. ** simpl. destruct (eq_dart_dec x0 x); try reflexivity. destruct (eq_dart_dec x0 z); try reflexivity. destruct (eq_dart_dec (cA_1 (B m0 k0 x) k z) z0); try reflexivity. destruct (eq_dim_dec k0 zero); try reflexivity. destruct (eq_dart_dec x0 z0); try reflexivity. destruct (eq_dart_dec (cA_1 m0 zero z0) z); try reflexivity. apply cA_cA_1; auto.", "succ": true}]