[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m k x Hmap.", "unfold B."], "tactic": "destruct Hmap as [Hpmap1 Hpmap2].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+"], "tactic": "unfold inv_hmap in Hpmap1.", "exn": "No such hypothesis: Hpmap1", "type": "no_hypos", "handled": true}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+"], "tactic": "destruct Hpmap1 as [Hpmap1 _].", "exn": "The reference Hpmap1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+", "destruct fpoint as [fpoint _]."], "tactic": "apply Hpmap1 in Hx.", "exn": "The reference Hpmap1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+", "destruct fpoint as [fpoint _].", "apply Ring_polynom.PEc in Hx."], "tactic": ["destruct Hx as [Hx _].", ""], "exn": "Expects a disjunctive pattern with 9 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+", "destruct fpoint as [fpoint _].", "apply Ring_polynom.PEc in Hx."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+", "destruct fpoint as [fpoint _].", "apply Ring_polynom.PEc in Hx.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k x Hmap.", "unfold B.", "destruct (exd_dec m x) as [Hx | Hx].", "-", "unfold A.", "destruct m.", "+", "contradiction.", "+", "destruct fpoint as [fpoint _].", "apply Ring_polynom.PEc in Hx.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply exd_B in Hx;auto.", "exn": "Unable to apply lemma of type \"forall (m : fmap) (k : dim) (x z : dart), exd m z <-> exd (B m k x) z\" on hypothesis of type \"exd (L m d d0 d1) x\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros m k x Hmap. unfold B. destruct Hmap as [Hpmap1 Hpmap2]. destruct (exd_dec m x) as [Hx | Hx]. - unfold A. destruct m. + contradiction. + unfold inv_hmap in Hpmap1. destruct Hpmap1 as [Hpmap1 _]. apply Hpmap1 in Hx. destruct Hx as [Hx _]. apply not_exd_A_nil in Hx; auto. destruct (eq_dim_dec d k) as [Hdim | Hdim]. * destruct (eq_dart_dec d0 x) as [Hdart | Hdart]. { contradiction. } { apply Hpmap1 in Hx. destruct Hx as [_ Hx]. apply Hx; auto. } * apply Hpmap1 in Hx. destruct Hx as [_ Hx]. apply Hx; auto. - apply exd_B in Hx;auto.", "succ": false}]