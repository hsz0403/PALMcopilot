[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "apply fast_Zmult_plus_distr_l with (p:=p) in H.", "exn": "The reference p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "apply fast_Zmult_plus_distr_l with (p:=p) in H.", "exn": "In environment p : positive H : match p with | (_~0)%positive => True | _ => False end H0 : False The term \"p\" has type \"positive\" while it is expected to have type \"Z\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "rewrite H.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "apply fast_Zmult_plus_distr_l with (p:=p) in H.", "exn": "In environment p, q : positive H : match p with | (_~0)%positive => True | _ => False end H0 : match q with | (_~0)%positive => False | _ => True end The term \"p\" has type \"positive\" while it is expected to have type \"Z\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "rewrite H.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*"], "tactic": "apply Zplus_lt_compat_l in H0.", "exn": "Unable to apply lemma of type \"forall n m p : Z, n < m -> p + n < p + m\" on hypothesis of type \"Zodd q\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*"], "tactic": "apply Z.le_gt_trans with (m:=q) in H0.", "exn": "The reference Z.le_gt_trans was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*"], "tactic": "apply Z.lt_sub_lt_add in H0.", "exn": "Unable to apply lemma of type \"forall n m p q : Z, n - m < p - q <-> n + q < m + p\" on hypothesis of type \"Zodd q\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*"], "tactic": "apply Z.le_sub_le_add in H.", "exn": "Unable to apply lemma of type \"forall n m p q : Z, n - m <= p - q <-> n + q <= m + p\" on hypothesis of type \"Zeven p\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*"], "tactic": "rewrite Z.add_sub_assoc in H0.", "exn": "Found no subterm matching \"?M1872 + (?M1873 - ?M1874)\" in H0.", "type": "no_subterm", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*"], "tactic": "rewrite Z.sub_add_simpl_l in H.", "exn": "The reference Z.sub_add_simpl_l was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+"], "tactic": "*", "exn": "Wrong bullet *: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "apply fast_Zmult_plus_distr_l with (p:=q) in H.", "exn": "In environment q : positive H : True H0 : match q with | (_~0)%positive => False | _ => True end The term \"q\" has type \"positive\" while it is expected to have type \"Z\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "apply fast_Zmult_plus_distr_l with (p:=q) in H.", "exn": "The reference q was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++"], "tactic": "rewrite H.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++"], "tactic": "apply fast_Zmult_plus_distr_l with (p:=q) in H.", "exn": "In environment p, q : positive H : match p with | (_~0)%positive => True | _ => False end H0 : match q with | (_~0)%positive => False | _ => True end The term \"q\" has type \"positive\" while it is expected to have type \"Z\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++"], "tactic": "rewrite H.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++"], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply Zplus_lt_compat_r in H0.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply Z.le_gt_trans with (m:=q) in H0.", "exn": "The reference Z.le_gt_trans was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply Z.lt_sub_lt_add in H0.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "apply Z.le_sub_le_add in H.", "exn": "Unable to apply lemma of type \"forall n m p q : Z, n - m <= p - q <-> n + q <= m + p\" on hypothesis of type \"Zodd p /\\\\ Zeven q\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "rewrite Z.add_sub_assoc in H0.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-"], "tactic": "rewrite Z.sub_add_simpl_l in H.", "exn": "The reference Z.sub_add_simpl_l was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-", "rewrite Zodd_ex_iff in H."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p q H.", "destruct H.", "-", "destruct H.", "unfold both_odd.", "split.", "*", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "*", "rewrite Zeven_quot2 in H.", "+", "shelve.", "+", "destruct p as [|p|p]; destruct q as [|q|q]; simpl in *.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "++", "auto.", "++", "auto.", "++", "shelve.", "++", "auto.", "++", "shelve.", "++", "shelve.", "-", "rewrite Zodd_ex_iff in H.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros p q H. destruct H. - destruct H. + unfold both_odd. split. * destruct p as [|p|p]; destruct q as [|q|q]; simpl in *. ++ discriminate. ++ discriminate. ++ apply fast_Zmult_plus_distr_l with (p:=p) in H. rewrite H. apply Zeven_Qeq_0 in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=p) in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=p) in H. rewrite H. auto. ++ discriminate. ++ auto. ++ discriminate. ++ discriminate. * apply Zplus_lt_compat_l in H0. apply Z.le_gt_trans with (m:=q) in H0. apply Z.lt_sub_lt_add in H0. apply Z.le_sub_le_add in H. rewrite Z.add_sub_assoc in H0. rewrite Z.sub_add_simpl_l in H. auto. + unfold both_odd. split. * destruct p as [|p|p]; destruct q as [|q|q]; simpl in *. ++ discriminate. ++ discriminate. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. apply Zeven_Qeq_0 in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ discriminate. ++ auto. ++ discriminate. ++ discriminate. * apply Zplus_lt_compat_r in H0. apply Z.le_gt_trans with (m:=q) in H0. apply Z.lt_sub_lt_add in H0. apply Z.le_sub_le_add in H. rewrite Z.add_sub_assoc in H0. rewrite Z.sub_add_simpl_l in H. auto. - destruct H. + unfold both_odd. split. * destruct p as [|p|p]; destruct q as [|q|q]; simpl in *. ++ discriminate. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum p * Z.pos (Qden q)) in H; auto. apply eq_sym in H. apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=p) in H. rewrite H. apply Zeven_Qeq_0 in H. rewrite H. auto. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum p * Z.pos (Qden q)) in H; auto. apply eq_sym in H. apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=p) in H. rewrite H. auto. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum p * Z.pos (Qden q)) in H; auto. apply eq_sym in H. apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=p) in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ auto. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ auto. * apply Zplus_lt_compat_r in H0. apply Z.le_gt_trans with (m:=p) in H0. apply Z.lt_sub_lt_add in H0. apply Z.le_sub_le_add in H. rewrite Z.add_sub_assoc in H0. rewrite Z.sub_add_simpl_l in H. auto. + unfold both_odd. split. * destruct p as [|p|p]; destruct q as [|q|q]; simpl in *. ++ discriminate. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum p * Z.pos (Qden q)) in H; auto. apply eq_sym in H. apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum p * Z.pos (Qden q)) in H; auto. apply eq_sym in H. apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum p * Z.pos (Qden q)) in H; auto. apply eq_sym in H. apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. ++ auto. ++ discriminate. ++ apply Qeq_alt in H. unfold Qeq in H. apply eq_trans with (y:=Qnum q * Z.pos (Qden p)) in H; auto. apply fast_Zmult_plus_distr_l with (p:=q) in H. rewrite H. auto. * apply Zplus_lt_compat_r in H0. apply Z.le_gt_trans with (m:=p) in H0. apply Z.lt_sub_lt_add in H0. apply Z.le_sub_le_add in H. rewrite Z.add_sub_assoc in H0. rewrite Z.sub_add_simpl_l in H. auto.", "succ": false}]