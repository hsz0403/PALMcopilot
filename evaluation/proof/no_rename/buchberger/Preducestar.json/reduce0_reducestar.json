[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "unfold reduceplus.", "exn": "Cannot coerce reduceplus to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "apply reduce_inv2.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p Unable to unify \"exists (x : list (Term ?M2180 ?M2191)) (a : Term ?M2180 ?M2191), ~ zeroP ?M2181 ?M2183 a /\\\\ inPolySet ?M2180 ?M2181 ?M2183 ?M2191 ?M2192 x ?M2195 /\\\\ canonical ?M2181 ?M2183 ?M2192 x /\\\\ eqP ?M2180 ?M2183 ?M2191 ?M2197 (minuspf ?M2180 ?M2181 ?M2182 ?M2183 ?M2185 ?M2186 ?M2187 ?M2190 ?M2191 ?M2192 ?M2193 ?M2196 (mults ?M2187 a x))\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "apply cs.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p Unable to unify \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "exists p.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "apply rep_plus_zero_reduce.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p Unable to unify \"exists r1 : list (Term ?M2180 ?M2191), reduceplus ?M2180 ?M2181 ?M2182 ?M2183 ?M2185 ?M2186 ?M2187 ?M2188 ?M2190 ?M2191 ?M2192 ?M2193 ?M2195 ?M2200 r1 /\\\\ reduceplus ?M2180 ?M2181 ?M2182 ?M2183 ?M2185 ?M2186 ?M2187 ?M2188 ?M2190 ?M2191 ?M2192 ?M2193 ?M2195 ?M2201 (mults ?M2187 (invTerm ?M2185 (T1 ?M2182 ?M2191)) r1)\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "apply cs.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p Unable to unify \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "exists r1.", "exn": "The reference r1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "apply reduce_inv2.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p Unable to unify \"exists (x : list (Term ?M2180 ?M2191)) (a : Term ?M2180 ?M2191), ~ zeroP ?M2181 ?M2183 a /\\\\ inPolySet ?M2180 ?M2181 ?M2183 ?M2191 ?M2192 x ?M2195 /\\\\ canonical ?M2181 ?M2183 ?M2192 x /\\\\ eqP ?M2180 ?M2183 ?M2191 ?M2197 (minuspf ?M2180 ?M2181 ?M2182 ?M2183 ?M2185 ?M2186 ?M2187 ?M2190 ?M2191 ?M2192 ?M2193 ?M2196 (mults ?M2187 a x))\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "apply cs.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p Unable to unify \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0."], "tactic": "exists q.", "exn": "The reference q was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-"], "tactic": "destruct IHcanonical as [t Ht].", "exn": "The reference IHcanonical was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "destruct Ht as [Ht1 Ht2].", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "exists t.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply reducestar0.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"reducestar ?M2187 ?M2188 ?M2189\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "unfold reduceplus.", "exn": "Cannot coerce reduceplus to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply reduce_inv2.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"exists (x : list (Term ?M2187 ?M2198)) (a : Term ?M2187 ?M2198), ~ zeroP ?M2188 ?M2190 a /\\\\ inPolySet ?M2187 ?M2188 ?M2190 ?M2198 ?M2199 x ?M2202 /\\\\ canonical ?M2188 ?M2190 ?M2199 x /\\\\ eqP ?M2187 ?M2190 ?M2198 ?M2204 (minuspf ?M2187 ?M2188 ?M2189 ?M2190 ?M2192 ?M2193 ?M2194 ?M2197 ?M2198 ?M2199 ?M2200 ?M2203 (mults ?M2194 a x))\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply cs.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "exists p.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply rep_plus_zero_reduce.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"exists r1 : list (Term ?M2187 ?M2198), reduceplus ?M2187 ?M2188 ?M2189 ?M2190 ?M2192 ?M2193 ?M2194 ?M2195 ?M2197 ?M2198 ?M2199 ?M2200 ?M2202 ?M2207 r1 /\\\\ reduceplus ?M2187 ?M2188 ?M2189 ?M2190 ?M2192 ?M2193 ?M2194 ?M2195 ?M2197 ?M2198 ?M2199 ?M2200 ?M2202 ?M2208 (mults ?M2194 (invTerm ?M2192 (T1 ?M2189 ?M2198)) r1)\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply cs.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "exists r1.", "exn": "The reference r1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply reduce_inv2.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"exists (x : list (Term ?M2187 ?M2198)) (a : Term ?M2187 ?M2198), ~ zeroP ?M2188 ?M2190 a /\\\\ inPolySet ?M2187 ?M2188 ?M2190 ?M2198 ?M2199 x ?M2202 /\\\\ canonical ?M2188 ?M2190 ?M2199 x /\\\\ eqP ?M2187 ?M2190 ?M2198 ?M2204 (minuspf ?M2187 ?M2188 ?M2189 ?M2190 ?M2192 ?M2193 ?M2194 ?M2197 ?M2198 ?M2199 ?M2200 ?M2203 (mults ?M2194 a x))\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "apply cs.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) p : list (Term A n) H : olist (A:=A) ltM p H0 : nZterm A0 eqA (n:=n) p t : forall x : mon n, ~ ltM x (zero_mon n) Ht : forall x : mon n, ~ ltM x x ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) Unable to unify \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\" with \"reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p H.", "induction H.", "exists p.", "apply reducestar0.", "-", "destruct os as [t Ht]."], "tactic": "exists q.", "exn": "The reference q was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros Q p H. induction H. - exists p. apply reducestar0. unfold reduceplus. split. apply reduce_inv2. apply cs. exists p. auto. unfold irreducible. split. apply rep_plus_zero_reduce. apply cs. exists r1. split. apply reduce_inv2. apply cs. exists q. auto. - destruct IHcanonical as [t Ht]. destruct Ht as [Ht1 Ht2]. exists t. apply reducestar0. unfold reduceplus. split. apply reduce_inv2. apply cs. exists p. auto. unfold irreducible. split. apply rep_plus_zero_reduce. apply cs. exists r1. split. apply reduce_inv2. apply cs. exists q. auto.", "succ": false}]