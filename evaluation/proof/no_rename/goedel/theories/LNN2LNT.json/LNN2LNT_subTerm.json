[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros t v s.", "unfold LNN2LNT_term.", "induction t using fol.Term_rect.", "-", "simpl."], "tactic": "reflexivity.", "exn": "In environment n, v : nat s : fol.Term LNN Unable to unify \"if Nat.eq_dec v n then (fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) s else fol.var LNT n\" with \"(fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) (if Nat.eq_dec v n then s else fol.var LNN n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros t v s.", "unfold LNN2LNT_term.", "induction t using fol.Term_rect.", "-", "simpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros t v s.", "unfold LNN2LNT_term.", "induction t using fol.Term_rect.", "-", "simpl.", "shelve.", "-", "simpl.", "f_equal."], "tactic": ["induction t; simpl.", ""], "exn": "Abstracting over the terms \"n\" and \"t\" leads to a term fun (n0 : nat) (t0 : fol.Terms LNN n0) => (fix LNN2LNT_term (t1 : fol.Term LNN) : Term := match t1 with | @fol.var _ v0 => var v0 | @apply _ f0 ts => apply LNT f0 (LNN2LNT_terms (LNTFunctionArity f0) ts) end with LNN2LNT_terms (n1 : nat) (ts : fol.Terms LNN n1) {struct ts} : Terms n1 := match ts in (fol.Terms _ n2) return (Terms n2) with | @Tnil _ => Tnil LNT | @Tcons _ m s0 ss => Tcons LNT m (LNN2LNT_term s0) (LNN2LNT_terms m ss) end for LNN2LNT_terms) (LNTFunctionArity f) (substituteTerms LNN (LNTFunctionArity f) t0 v s) = substituteTerms LNT (LNTFunctionArity f) ((fix LNN2LNT_term (t1 : fol.Term LNN) : Term := match t1 with | @fol.var _ v0 => var v0 | @apply _ f0 ts => apply LNT f0 (LNN2LNT_terms (LNTFunctionArity f0) ts) end with LNN2LNT_terms (n1 : nat) (ts : fol.Terms LNN n1) {struct ts} : Terms n1 := match ts in (fol.Terms _ n2) return (Terms n2) with | @Tnil _ => Tnil LNT | @Tcons _ m s0 ss => Tcons LNT m (LNN2LNT_term s0) (LNN2LNT_terms m ss) end for LNN2LNT_terms) (LNTFunctionArity f) t0) v ((fix LNN2LNT_term (t1 : fol.Term LNN) : Term := match t1 with | @fol.var _ v0 => var v0 | @apply _ f0 ts => apply LNT f0 (LNN2LNT_terms (LNTFunctionArity f0) ts) end with LNN2LNT_terms (n1 : nat) (ts : fol.Terms LNN n1) {struct ts} : Terms n1 := match ts in (fol.Terms _ n2) return (Terms n2) with | @Tnil _ => Tnil LNT | @Tcons _ m s0 ss => Tcons LNT m (LNN2LNT_term s0) (LNN2LNT_terms m ss) end for LNN2LNT_term) s) which is ill-typed. Reason is: Illegal application: The term \"substituteTerms\" of type \"forall (L : Language) (n : nat), fol.Terms L n -> nat -> fol.Term L -> fol.Terms L n\" cannot be applied to the terms \"LNN\" : \"Language\" \"LNTFunctionArity f\" : \"nat\" \"t0\" : \"fol.Terms LNN n0\" \"v\" : \"nat\" \"s\" : \"fol.Term LNN\" The 3rd term has type \"fol.Terms LNN n0\" which should be coercible to \"fol.Terms LNN (LNTFunctionArity f)\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "intros t v s. unfold LNN2LNT_term. induction t using fol.Term_rect. - simpl. reflexivity. - simpl. f_equal. induction t; simpl. + f_equal. apply IHt. + unfold LNN2LNT_terms in IHt. rewrite IHt. reflexivity.", "succ": false}]