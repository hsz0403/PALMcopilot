[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a a0 b0.", "unfold translateLT, subAllFormula."], "tactic": "rewrite LNN2LNT_term.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT, subAllFormula."], "tactic": "rewrite LNN2LNT_term.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT, subAllFormula."], "tactic": "reflexivity.", "exn": "In environment a, a0 : fol.Term LNN b0 : fol.Terms LNN 0 Unable to unify \"(fix subAllFormula (f : fol.Formula LNT) (m : nat -> fol.Term LNT) {struct f} : fol.Formula LNT := match f with | @fol.equal _ t s => fol.equal LNT (subAllTerm LNT t m) (subAllTerm LNT s m) | @atomic _ r ts => atomic LNT r (subAllTerms LNT (arity LNT (inl r)) ts m) | @fol.impH _ f0 g => fol.impH LNT (subAllFormula f0 m) (subAllFormula g m) | @fol.notH _ f0 => fol.notH LNT (subAllFormula f0 m) | @fol.forallH _ n f0 => fol.forallH LNT (newVar (freeVarFormula LNT f0 ++ freeVarMap LNT (freeVarFormula LNT (fol.forallH LNT n f0)) m)) (subAllFormula f0 (fun v : nat => if Nat.eq_dec v n then fol.var LNT (newVar (freeVarFormula LNT f0 ++ freeVarMap LNT (freeVarFormula LNT (fol.forallH LNT n f0)) m)) else m v)) end) LTFormula (fun H : nat => nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a) (fun (H0 : nat) (_ : fol.Term LNT) => nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a0) (fun (H1 : nat) (_ : fol.Term LNT) => var H1) H0) H)\" with \"sig_rec (fun _ : {t : fol.Term LNN * fol.Terms LNN 1 | Tcons LNN 1 (fst t) (snd t) = Tcons LNN 1 a (Tcons LNN 0 a0 b0)} => Formula) (fun (x : fol.Term LNN * fol.Terms LNN 1) (p : Tcons LNN 1 (fst x) (snd x) = Tcons LNN 1 a (Tcons LNN 0 a0 b0)) => prod_rec (fun x0 : fol.Term LNN * fol.Terms LNN 1 => Tcons LNN 1 (fst x0) (snd x0) = Tcons LNN 1 a (Tcons LNN 0 a0 b0) -> Formula) (fun (a1 : fol.Term LNN) (b : fol.Terms LNN 1) (_ : Tcons LNN 1 (fst (a1, b)) (snd (a1, b)) = Tcons LNN 1 a (Tcons LNN 0 a0 b0)) => sig_rec (fun _ : {t : fol.Term LNN * fol.Terms LNN 0 | Tcons LNN 0 (fst t) (snd t) = b} => Formula) (fun (x0 : fol.Term LNN * fol.Terms LNN 0) (p1 : Tcons LNN 0 (fst x0) (snd x0) = b) => prod_rec (fun x1 : fol.Term LNN * fol.Terms LNN 0 => Tcons LNN 0 (fst x1) (snd x1) = b -> Formula) (fun (a0 : fol.Term LNN) (b0 : fol.Terms LNN 0) (_ : Tcons LNN 0 (fst (a0, b0)) (snd (a0, b0)) = b) => (fix subAllFormula (f : fol.Formula LNT) (m : nat -> fol.Term LNT) {struct f} : fol.Formula LNT := match f with | @fol.equal _ t s => fol.equal LNT (subAllTerm LNT t m) (subAllTerm LNT s m) | @atomic _ r ts => atomic LNT r (subAllTerms LNT (arity LNT (inl r)) ts m) | @fol.impH _ f0 g => fol.impH LNT (subAllFormula f0 m) (subAllFormula g m) | @fol.notH _ f0 => fol.notH LNT (subAllFormula f0 m) | @fol.forallH _ n f0 => fol.forallH LNT (newVar (freeVarFormula LNT f0 ++ freeVarMap LNT (freeVarFormula LNT (fol.forallH LNT n f0)) m)) (subAllFormula f0 (fun v : nat => if Nat.eq_dec v n then fol.var LNT (newVar (freeVarFormula LNT f0 ++ freeVarMap LNT (freeVarFormula LNT (fol.forallH LNT n f0)) m)) else m v)) end) LTFormula (fun H : nat => nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a1) (fun (H0 : nat) (_ : fol.Term LNT) => nat_rec (fun _ : nat => fol.Term LNT) (LNN2LNT_term a0) (fun (H1 : nat) (_ : fol.Term LNT) => var H1) H0) H)) x0 p1) (consTerms LNN 0 b)) x p) (consTerms LNN 1 (Tcons LNN 1 a (Tcons LNN 0 a0 b0)))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros a a0 b0. unfold translateLT, subAllFormula. rewrite LNN2LNT_term. rewrite LNN2LNT_term. reflexivity.", "succ": false}]