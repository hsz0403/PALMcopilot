[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros x y.", "destruct x,y.", "-", "left."], "tactic": "reflexivity.", "exn": "In environment L : Language language_dec : language_decideable nilTermsHelp := fun (n : nat) (H : n = 0) => nat_rec (fun n0 : nat => n0 = 0 -> Terms n0) (fun _ : 0 = 0 => Tnil) (fun (n0 : nat) (_ : n0 = 0 -> Terms n0) (H0 : S n0 = 0) => let H1 : False := eq_ind (S n0) (fun e : nat => match e with | 0 => False | S _ => True end) I 0 H0 in False_rec (Terms (S n0)) H1) n H : forall n : nat, n = 0 -> Terms n consTermsHelp := fun (n : nat) (H : Terms n) => match n with | 0 => forall p : 0 = n, {_ : unit | eq_rec 0 (fun z : nat => Terms z) Tnil n p = H} | S n0 => forall p : S n0 = n, {t : Term * Terms n0 | eq_rec (S n0) (fun z : nat => Terms z) (Tcons n0 (fst t) (snd t)) n p = H} end : forall n : nat, Terms n -> Set n, n0 : nat Unable to unify \"var n0\" with \"var n\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "destruct x,y.", "-", "left."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros x y.", "destruct x,y.", "-", "left.", "shelve.", "-", "right.", "intros H.", "inversion H.", "-", "right.", "intros H.", "inversion H.", "-"], "tactic": "destruct (BinPos.Pos.eq_dec p p0).", "exn": "The reference p0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y.", "destruct x,y.", "-", "left.", "shelve.", "-", "right.", "intros H.", "inversion H.", "-", "right.", "intros H.", "inversion H.", "-", "left."], "tactic": "reflexivity.", "exn": "In environment L : Language language_dec : language_decideable nilTermsHelp := fun (n : nat) (H : n = 0) => nat_rec (fun n0 : nat => n0 = 0 -> Terms n0) (fun _ : 0 = 0 => Tnil) (fun (n0 : nat) (_ : n0 = 0 -> Terms n0) (H0 : S n0 = 0) => let H1 : False := eq_ind (S n0) (fun e : nat => match e with | 0 => False | S _ => True end) I 0 H0 in False_rec (Terms (S n0)) H1) n H : forall n : nat, n = 0 -> Terms n consTermsHelp := fun (n : nat) (H : Terms n) => match n with | 0 => forall p : 0 = n, {_ : unit | eq_rec 0 (fun z : nat => Terms z) Tnil n p = H} | S n0 => forall p : S n0 = n, {t : Term * Terms n0 | eq_rec (S n0) (fun z : nat => Terms z) (Tcons n0 (fst t) (snd t)) n p = H} end : forall n : nat, Terms n -> Set f : Functions L t : Terms (arity L (inr f)) f0 : Functions L t0 : Terms (arity L (inr f0)) Unable to unify \"apply f0 t0\" with \"apply f t\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "destruct x,y.", "-", "left.", "shelve.", "-", "right.", "intros H.", "inversion H.", "-", "right.", "intros H.", "inversion H.", "-", "left."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros x y. destruct x,y. - left. reflexivity. - right. intros H. inversion H. - right. intros H. inversion H. - destruct (BinPos.Pos.eq_dec p p0). + left. subst. reflexivity. + right. intros H. inversion H. contradiction.", "succ": false}]