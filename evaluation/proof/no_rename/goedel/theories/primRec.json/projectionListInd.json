[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n m p1 p2.", "unfold projectionList."], "tactic": "rewrite (extEqualOneParamList _ _ _ _ _ p1).", "exn": "In environment n, m : nat p1, p2 : m <= n The term \"p1\" has type \"m <= n\" while it is expected to have type \"extEqualVector (S ?n) ?m ?l1 ?l2\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros n m p1 p2.", "unfold projectionList."], "tactic": "apply extEqualVectorRefl.", "exn": "In environment n, m : nat p1, p2 : m <= n Unable to unify \"(fix rect2_fix (n : nat) (v1 : Vector.t (naryFunc ?M1412) n) {struct v1} : forall v2 : Vector.t (naryFunc ?M1412) n, (fun (n0 : nat) (_ _ : Vector.t (naryFunc ?M1412) n0) => Prop) n v1 v2 := match v1 as v2 in (Vector.t _ n0) return (forall v3 : Vector.t (naryFunc ?M1412) n0, (fun (n1 : nat) (_ _ : Vector.t (naryFunc ?M1412) n1) => Prop) n0 v2 v3) with | @Vector.nil _ => fun v2 : Vector.t (naryFunc ?M1412) 0 => Vector.case0 ((fun (n0 : nat) (_ _ : Vector.t (naryFunc ?M1412) n0) => Prop) 0 (Vector.nil (naryFunc ?M1412))) True v2 | @Vector.cons _ h1 n' t1 => fun v2 : Vector.t (naryFunc ?M1412) (S n') => Vector.caseS' v2 (fun v2' : Vector.t (naryFunc ?M1412) (S n') => (fun (n0 : nat) (_ _ : Vector.t (naryFunc ?M1412) n0) => Prop) (S n') (Vector.cons (naryFunc ?M1412) h1 n' t1) v2') (fun (h2 : naryFunc ?M1412) (t2 : Vector.t (naryFunc ?M1412) n') => (fun (n0 : nat) (_ _ : Vector.t (naryFunc ?M1412) n0) (X : Prop) (a b : naryFunc ?M1412) => extEqual ?M1412 a b /\\\\ X) n' t1 t2 (rect2_fix n' t1 t2) h1 h2) end) ?M1413 ?M1414 ?M1414\" with \"evalPrimRecs n m (projectionListPR n m p1) = evalPrimRecs n m (projectionListPR n m p2)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros n m p1 p2. unfold projectionList. rewrite (extEqualOneParamList _ _ _ _ _ p1). apply extEqualVectorRefl.", "succ": false}]