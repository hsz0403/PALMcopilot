[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H."], "tactic": "destruct H as [H | [H | H]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left."], "tactic": "apply H.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula n : nat A, B : Formula v : nat H : In v (list_remove nat Nat.eq_dec 0 ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) A ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) \\\\/ In v (if match match match Nat.eq_dec n n with | left e => left (f_equal_nat nat S n n e) | right n0 => right (not_eq_S n n n0) end with | left e => left (f_equal_nat nat S (S n) (S n) e) | right n0 => right (not_eq_S (S n) (S n) n0) end with | left e => left (f_equal_nat nat S (S (S n)) (S (S n)) e) | right n0 => right (not_eq_S (S (S n)) (S (S n)) n0) end then if match Nat.eq_dec n (S (S n)) with | left e0 => left (f_equal_nat nat S n (S (S n)) e0) | right n0 => right (not_eq_S n (S (S n)) n0) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S (S (S n)) :: (if match Nat.eq_dec n (S (S n)) with | left e => left (f_equal_nat nat S n (S (S n)) e) | right n1 => right (not_eq_S n (S (S n)) n1) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))))) Unable to unify \"In v (list_remove nat Nat.eq_dec 0 ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) A ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) \\\\/ In v (if match match match Nat.eq_dec n n with | left e => left (f_equal_nat nat S n n e) | right n0 => right (not_eq_S n n n0) end with | left e => left (f_equal_nat nat S (S n) (S n) e) | right n0 => right (not_eq_S (S n) (S n) n0) end with | left e => left (f_equal_nat nat S (S (S n)) (S (S n)) e) | right n0 => right (not_eq_S (S (S n)) (S (S n)) n0) end then if match Nat.eq_dec n (S (S n)) with | left e0 => left (f_equal_nat nat S n (S (S n)) e0) | right n0 => right (not_eq_S n (S (S n)) n0) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S (S (S n)) :: (if match Nat.eq_dec n (S (S n)) with | left e => left (f_equal_nat nat S n (S (S n)) e) | right n1 => right (not_eq_S n (S (S n)) n1) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))\" with \"In v (freeVarFormula LNN A)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left."], "tactic": "apply in_app_or in H.", "exn": "Unable to apply lemma of type \"forall (A : Type) (l m : list A) (a : A), In a (l ++ m) -> In a l \\\\/ In a m\" on hypothesis of type \"In v (list_remove nat Nat.eq_dec 0 ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) A ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) \\\\/ In v (if match match match Nat.eq_dec n n with | left e => left (f_equal_nat nat S n n e) | right n0 => right (not_eq_S n n n0) end with | left e => left (f_equal_nat nat S (S n) (S n) e) | right n0 => right (not_eq_S (S n) (S n) n0) end with | left e => left (f_equal_nat nat S (S (S n)) (S (S n)) e) | right n0 => right (not_eq_S (S (S n)) (S (S n)) n0) end then if match Nat.eq_dec n (S (S n)) with | left e0 => left (f_equal_nat nat S n (S (S n)) e0) | right n0 => right (not_eq_S n (S (S n)) n0) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S (S (S n)) :: (if match Nat.eq_dec n (S (S n)) with | left e => left (f_equal_nat nat S n (S (S n)) e) | right n1 => right (not_eq_S n (S (S n)) n1) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+"], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+"], "tactic": "apply H.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula n : nat A, B : Formula v : nat H : In v (list_remove nat Nat.eq_dec 0 ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) A ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) Unable to unify \"In v (list_remove nat Nat.eq_dec 0 ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) A ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n))))))\" with \"In v (freeVarFormula LNN A)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+"], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+"], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+"], "tactic": "apply H.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula n : nat A, B : Formula v : nat H : In v (if match match match Nat.eq_dec n n with | left e => left (f_equal_nat nat S n n e) | right n0 => right (not_eq_S n n n0) end with | left e => left (f_equal_nat nat S (S n) (S n) e) | right n0 => right (not_eq_S (S n) (S n) n0) end with | left e => left (f_equal_nat nat S (S (S n)) (S (S n)) e) | right n0 => right (not_eq_S (S (S n)) (S (S n)) n0) end then if match Nat.eq_dec n (S (S n)) with | left e0 => left (f_equal_nat nat S n (S (S n)) e0) | right n0 => right (not_eq_S n (S (S n)) n0) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S (S (S n)) :: (if match Nat.eq_dec n (S (S n)) with | left e => left (f_equal_nat nat S n (S (S n)) e) | right n1 => right (not_eq_S n (S (S n)) n1) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))))) Unable to unify \"In v (if match match match Nat.eq_dec n n with | left e => left (f_equal_nat nat S n n e) | right n0 => right (not_eq_S n n n0) end with | left e => left (f_equal_nat nat S (S n) (S n) e) | right n0 => right (not_eq_S (S n) (S n) n0) end with | left e => left (f_equal_nat nat S (S (S n)) (S (S n)) e) | right n0 => right (not_eq_S (S (S n)) (S (S n)) n0) end then if match Nat.eq_dec n (S (S n)) with | left e0 => left (f_equal_nat nat S n (S (S n)) e0) | right n0 => right (not_eq_S n (S (S n)) n0) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S (S (S n)) :: (if match Nat.eq_dec n (S (S n)) with | left e => left (f_equal_nat nat S n (S (S n)) e) | right n1 => right (not_eq_S n (S (S n)) n1) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))\" with \"In v (freeVarFormula LNN A)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+"], "tactic": "apply in_app_or in H.", "exn": "Unable to apply lemma of type \"forall (A : Type) (l m : list A) (a : A), In a (l ++ m) -> In a l \\\\/ In a m\" on hypothesis of type \"In v (if match match match Nat.eq_dec n n with | left e => left (f_equal_nat nat S n n e) | right n0 => right (not_eq_S n n n0) end with | left e => left (f_equal_nat nat S (S n) (S n) e) | right n0 => right (not_eq_S (S n) (S n) n0) end with | left e => left (f_equal_nat nat S (S (S n)) (S (S n)) e) | right n0 => right (not_eq_S (S (S n)) (S (S n)) n0) end then if match Nat.eq_dec n (S (S n)) with | left e0 => left (f_equal_nat nat S n (S (S n)) e0) | right n0 => right (not_eq_S n (S (S n)) n0) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S (S (S n)) :: (if match Nat.eq_dec n (S (S n)) with | left e => left (f_equal_nat nat S n (S (S n)) e) | right n1 => right (not_eq_S n (S (S n)) n1) end then list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n))))))) else S n :: list_remove nat Nat.eq_dec (S (S (S n))) (list_remove nat Nat.eq_dec 0 (list_remove nat Nat.eq_dec (S n) ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN B (S (S n)) (var (S (S (S n))))) ++ (fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | Languages.LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+"], "tactic": "destruct H as [H | H].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n A B v H.", "unfold freeVarFormula in H.", "simpl in H.", "apply in_app_or in H.", "left.", "destruct H as [H | H].", "+", "shelve.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros n A B v H. unfold freeVarFormula in H. simpl in H. apply in_app_or in H. destruct H as [H | [H | H]]. - left. apply H. - apply in_app_or in H. destruct H as [H | H]. + left. apply H. + right. left. apply H. - apply in_app_or in H. destruct H as [H | H]. + right. left. apply H. + right. right. apply H.", "succ": false}]