[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n x H.", "induction n using gt_wf_ind.", "apply Nat.order_induction_0.", "+"], "tactic": "apply lt_wf.", "exn": "In environment x : nat -> nat n : nat H : forall z : nat, z < n -> x z > 0 H0 : forall m : nat, n > m -> (forall z : nat, z < m -> x z > 0) -> prod m x > 0 Unable to unify \"well_founded lt\" with \"Morphisms.Proper (Morphisms.respectful eq iff) (gt (prod n x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n x H.", "induction n using gt_wf_ind.", "apply Nat.order_induction_0.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n x H.", "induction n using gt_wf_ind.", "apply Nat.order_induction_0.", "+", "shelve.", "+", "apply gt_wf_rec."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n x H.", "induction n using gt_wf_ind.", "apply Nat.order_induction_0.", "+", "shelve.", "+", "apply gt_wf_rec.", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n x H.", "induction n using gt_wf_ind.", "apply Nat.order_induction_0.", "+", "shelve.", "+", "apply gt_wf_rec.", "shelve.", "+", "shelve.", "+", "apply Nat.order_induction with n."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n x H.", "induction n using gt_wf_ind.", "apply Nat.order_induction_0.", "+", "shelve.", "+", "apply gt_wf_rec.", "shelve.", "+", "shelve.", "+", "apply Nat.order_induction with n.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros n x H. induction n using gt_wf_ind. - apply Nat.order_induction_0. + apply lt_wf. + apply gt_wf_rec. intros n Hrec H0. apply gt_wf_ind. * apply lt_wf. * intros m H1 H2. apply Hrec. intros z Hz. apply H. apply Nat.lt_le_trans with m. ++ auto. ++ apply H1. apply le_lt_trans with m. -- apply le_pred. -- auto. + auto. + auto. - apply Nat.order_induction with n. + apply lt_wf. + intros m H0 H1. destruct m. * apply H1. apply Nat.lt_0_succ. * apply Hrec. intros z Hz. apply H. apply lt_n_S. apply Hz. apply gt_trans_S with n. ++ auto. ++ apply lt_n_S. apply Nat.lt_le_trans with m. -- auto. -- apply le_pred. + intros m H0 H1. apply Hrec. * intros z Hz. apply H. apply lt_n_S. apply Hz. * apply gt_trans_S with n. ++ auto. ++ apply le_pred. + apply H in H0. apply le_gt_trans with m. * apply le_pred. * apply H1. + auto. + auto.", "succ": false}]