[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f g a b Hf Hg.", "intros eps."], "tactic": "destruct (Hf (mkposreal eps (pos_eps eps))) as [phi [psi [H1 H2]]].", "exn": "The reference pos_eps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]]."], "tactic": "destruct (Hg (mkposreal eps (pos_eps eps))) as [phi' [psi' [H1' H2']]].", "exn": "The reference pos_eps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "exists (fun x => phi x + phi' x).", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H1 : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t H2 : Rabs (RiemannInt_SF psi) < {| pos := eps; cond_pos := cond_pos eps |} phi', psi' : StepFun a b H1' : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H2' : Rabs (RiemannInt_SF psi') < {| pos := eps; cond_pos := cond_pos eps |} The term \"fun x : R => phi x + phi' x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "exists (fun x => psi x + psi' x).", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H1 : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t H2 : Rabs (RiemannInt_SF psi) < {| pos := eps; cond_pos := cond_pos eps |} phi', psi' : StepFun a b H1' : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H2' : Rabs (RiemannInt_SF psi') < {| pos := eps; cond_pos := cond_pos eps |} The term \"fun x : R => psi x + psi' x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "split; intros.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "rewrite <- Rplus_assoc.", "exn": "Found no subterm matching \"?M2313 + (?M2314 + ?M2315)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "apply Rplus_le_compat; [apply H1 | apply H1'].", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H1 : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t H2 : Rabs (RiemannInt_SF psi) < {| pos := eps; cond_pos := cond_pos eps |} phi', psi' : StepFun a b H1' : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H2' : Rabs (RiemannInt_SF psi') < {| pos := eps; cond_pos := cond_pos eps |} Unable to unify \"?M2313 + ?M2315 < ?M2314 + ?M2316 \\\\/ ?M2313 + ?M2315 = ?M2314 + ?M2316\" with \"{phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t + g t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "rewrite Rabs_RiemannInt_SF.", "exn": "The reference Rabs_RiemannInt_SF was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "rewrite Rmax_right."], "tactic": "apply Rplus_lt_compat; [apply H2 | apply H2'].", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H1 : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t H2 : Rabs (RiemannInt_SF psi) < {| pos := eps; cond_pos := cond_pos eps |} phi', psi' : StepFun a b H1' : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H2' : Rabs (RiemannInt_SF psi') < {| pos := eps; cond_pos := cond_pos eps |} Unable to unify \"?M2317 + ?M2319 < ?M2318 + ?M2320\" with \"{phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= b -> Rabs (f t + g t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros f g a b Hf Hg. intros eps. destruct (Hf (mkposreal eps (pos_eps eps))) as [phi [psi [H1 H2]]]. destruct (Hg (mkposreal eps (pos_eps eps))) as [phi' [psi' [H1' H2']]]. exists (fun x => phi x + phi' x). exists (fun x => psi x + psi' x). split; intros. - rewrite <- Rplus_assoc. apply Rplus_le_compat; [apply H1 | apply H1']. - simpl. rewrite Rabs_RiemannInt_SF. apply Rplus_lt_compat; [apply H2 | apply H2'].", "succ": false}]