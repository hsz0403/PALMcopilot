[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx."], "tactic": "rewrite SF_rev_surj.", "exn": "The LHS of SF_rev_surj (SF_rev _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx.", "rewrite SF_sup_ly.", "simpl."], "tactic": "rewrite rev_unif_part.", "exn": "The reference rev_unif_part was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx.", "rewrite SF_sup_ly.", "simpl.", "rewrite unif_part_bound."], "tactic": "reflexivity.", "exn": "In environment f : R -> R a, b : R n : nat Unable to unify \"{| SF_h := b + 0 * (a - b) / (INR n + 1); SF_t := (b + 1 * (a - b) / (INR n + 1), if Req_EM_T (b + 0 * (a - b) / (INR n + 1)) (b + 1 * (a - b) / (INR n + 1)) then 0 else Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin (b + 0 * (a - b) / (INR n + 1)) (b + 1 * (a - b) / (INR n + 1)) < x < Rmax (b + 0 * (a - b) / (INR n + 1)) (b + 1 * (a - b) / (INR n + 1)))) :: pairmap (fun x y : R => (y, if Req_EM_T x y then 0 else Lub_Rbar (fun y0 : R => exists x0 : R, y0 = f x0 /\\\\ Rmin x y < x0 < Rmax x y))) (b + 1 * (a - b) / (INR n + 1)) [seq b + INR i * (a - b) / (INR n + 1) | i <- seq.iota 2 n] |}\" with \"{| SF_h := head 0 (rev (rev (unif_part b a n))); SF_t := zip (behead (rev (rev (unif_part b a n)))) (rev (Sup_fct f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1)) :: pairmap (Sup_fct f) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) |}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold SF_sup_seq. unfold SF_rev. unfold SF_make. unfold SF_seq_f2. unfold Sup_fct. unfold unif_part. rewrite SF_sup_lx. rewrite SF_rev_surj. rewrite SF_sup_ly. simpl. rewrite rev_unif_part. reflexivity.", "succ": false}]