[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold Sup_fct."], "tactic": "unfold Req_EM_T.", "exn": "Cannot coerce Req_EM_T to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["unfold Sup_fct."], "tactic": "destruct (R_eq_dec a b) eqn:E.", "exn": "The reference R_eq_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold Sup_fct.", "destruct (Req_dec a b) eqn:E.", "-"], "tactic": "rewrite E.", "exn": "The LHS of E (Req_dec a b) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Sup_fct.", "destruct (Req_dec a b) eqn:E.", "-"], "tactic": "reflexivity.", "exn": "In environment f : R -> R a, b : R e : a = b E : Req_dec a b = or_introl e Unable to unify \"if Req_EM_T b a then Finite 0 else Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin b a < x < Rmax b a)\" with \"if Req_EM_T a b then Finite 0 else Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin a b < x < Rmax a b)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Sup_fct.", "destruct (Req_dec a b) eqn:E.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold Sup_fct.", "destruct (Req_dec a b) eqn:E.", "-", "shelve.", "-"], "tactic": "apply is_lub_Rbar_unique.", "exn": "In environment f : R -> R a, b : R n : a <> b E : Req_dec a b = or_intror n Unable to unify \"Lub_Rbar ?M2373 = ?M2374\" with \"(if Req_EM_T a b then 0 else Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin a b < x < Rmax a b)) = (if Req_EM_T b a then 0 else Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin b a < x < Rmax b a))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold Sup_fct. unfold Inf_fct. unfold Req_EM_T. destruct (R_eq_dec a b) eqn:E. - rewrite E. reflexivity. - apply is_lub_Rbar_unique. intros x. split. + unfold is_lub. split. * intros y Hy. destruct Hy as [x0 [Hfx0 Hrange]]. exists x0. split. { apply Rmin_r. } { apply Rmax_l. } * intros y [x0 [Hfx0 [Hmin Hmax]]]. apply Rmin_r in Hmin. apply Rmax_l in Hmax. exists y. split. { exists x0. split; auto. } { auto. } + intros y [Hlub1 Hlub2]. apply Rmin_r in Hlub1. apply Rmax_l in Hlub2. destruct (Rlt_dec a b). * contradict n0. apply Rmin_l in Hlub1. apply Rmax_r in Hlub2. lra. * lra.", "succ": false}]