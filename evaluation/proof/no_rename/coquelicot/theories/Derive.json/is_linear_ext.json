[{"history": {"proof": "intros l_eq l1_linear. split. - intros x y. hauto lq: on depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal. - intros k x. hauto lq: on depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal. - destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]]. destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]. split. + hauto lq: on depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal. + intros x. specialize (norm x). specialize (norm x). hauto lq: on depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal. + sauto lq: on depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal. + scongruence depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal. + hauto lq: on depth: 3use: Rmult_le_compat_r, Rmax_case_strong, is_linear, linear_plus, f_equal, Rmax_l, linear_scal.", "repairs": ["", "", "", "", "hammer", "", "", "hammer", "", "", "", "", "", "hammer", "", "", "ref_not_found", "ref_not_found", "hammer", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros l_eq l1_linear."], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "rewrite <- (linear_plus l1 x y).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x, y : U The term \"x\" has type \"NormedModule.sort K U\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "rewrite -> (linear_plus l2 x y).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x, y : U The term \"x\" has type \"NormedModule.sort K U\" while it is expected to have type \"is_linear l2\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "apply f_equal, l_eq.", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x, y : U Unable to unify \"plus (l2 x)\" with \"l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "rewrite <- (linear_scal l1 k x).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 k : K x : U The term \"k\" has type \"AbsRing.sort K\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "rewrite -> (linear_scal l2 k x).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 k : K x : U The term \"k\" has type \"AbsRing.sort K\" while it is expected to have type \"is_linear l2\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "apply f_equal, l_eq.", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 k : K x : U Unable to unify \"scal k\" with \"l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]."], "tactic": "exists (Rmax M1 M2).", "exn": "The reference M2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+"], "tactic": "apply Rmax_case_strong; auto.", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 Unable to unify \"?M2396 <= ?M2395 -> ?M2397 ?M2395\" with \"let (sort, _, _) := U in sort\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "shelve.", "+", "intros x."], "tactic": "specialize (norm_bound1 x).", "exn": "The reference norm_bound1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "shelve.", "+", "intros x.", "specialize (norm x)."], "tactic": "specialize (norm_bound2 x).", "exn": "The reference norm_bound2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "shelve.", "+", "intros x.", "specialize (norm x).", "specialize (norm x)."], "tactic": "apply Rle_trans with (r2 := M1 * norm x).", "exn": "The reference M1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "shelve.", "+", "intros x.", "specialize (norm x).", "specialize (norm x)."], "tactic": "apply norm_bound1.", "exn": "The reference norm_bound1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x.", "shelve.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "shelve.", "+", "intros x.", "specialize (norm x).", "specialize (norm x)."], "tactic": "apply Rmult_le_compat_r; [apply Rmax_l | apply norm_bound2].", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x : K r2 : R Unable to unify \"0 < ?M2395 \\\\/ 0 = ?M2395\" with \"R\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l_eq l1_linear. unfold is_linear. split. - intros x y. rewrite <- (linear_plus l1 x y). rewrite -> (linear_plus l2 x y). apply f_equal, l_eq. - intros k x. rewrite <- (linear_scal l1 k x). rewrite -> (linear_scal l2 k x). apply f_equal, l_eq. - destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]]. destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]. exists (Rmax M1 M2). split. + apply Rmax_case_strong; auto. + intros x. specialize (norm_bound1 x). specialize (norm_bound2 x). apply Rle_trans with (r2 := M1 * norm x). * apply norm_bound1. * apply Rmult_le_compat_r; [apply Rmax_l | apply norm_bound2].", "succ": true}]