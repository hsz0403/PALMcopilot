[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f x.", "split.", "-", "intros cont_eps.", "unfold continuity_pt in cont_eps.", "intros eps."], "tactic": "specialize (cont_eps (mkposreal eps)).", "exn": "In environment f : R -> R x : R cont_eps : continue_in f no_cond x eps : posreal The term \"mkposreal eps\" has type \"0 < eps -> posreal\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f x.", "split.", "-", "intros cont_eps.", "unfold continuity_pt in cont_eps.", "intros eps.", "unfold locally, Rabs in *."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros f x.", "split.", "-", "intros cont_eps.", "unfold continuity_pt in cont_eps.", "intros eps.", "unfold locally, Rabs in *.", "shelve.", "-", "intros cont_loc.", "unfold continuity_pt.", "intros eps."], "tactic": "specialize (cont_loc (mkposreal eps)).", "exn": "In environment f : R -> R x : R cont_loc : forall eps : posreal, locally x (fun u : R_UniformSpace => Rabs (f u - f x) < eps) eps : R The term \"mkposreal eps\" has type \"0 < eps -> posreal\" while it is expected to have type \"posreal\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f x.", "split.", "-", "intros cont_eps.", "unfold continuity_pt in cont_eps.", "intros eps.", "unfold locally, Rabs in *.", "shelve.", "-", "intros cont_loc.", "unfold continuity_pt.", "intros eps.", "unfold locally, Rabs in *."], "tactic": "intros [delta Hdelta].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros f x.", "split.", "-", "intros cont_eps.", "unfold continuity_pt in cont_eps.", "intros eps.", "unfold locally, Rabs in *.", "shelve.", "-", "intros cont_loc.", "unfold continuity_pt.", "intros eps.", "unfold locally, Rabs in *.", "intros H."], "tactic": "apply cont_loc.", "exn": "In environment f : R -> R x : R cont_loc : forall eps : posreal, exists eps0 : posreal, forall y : R_UniformSpace, ball x eps0 y -> (if Rcase_abs (f y - f x) then - (f y - f x) else f y - f x) < eps eps : R H : eps > 0 Unable to unify \"exists eps : posreal, forall y : R_UniformSpace, ball x eps y -> (if Rcase_abs (f y - f x) then - (f y - f x) else f y - f x) < ?M2447\" with \"exists alp : R, alp > 0 /\\\\ (forall x0 : Base R_met, D_x no_cond x x0 /\\\\ dist R_met x0 x < alp -> dist R_met (f x0) (f x) < eps)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f x.", "split.", "-", "intros cont_eps.", "unfold continuity_pt in cont_eps.", "intros eps.", "unfold locally, Rabs in *.", "shelve.", "-", "intros cont_loc.", "unfold continuity_pt.", "intros eps.", "unfold locally, Rabs in *.", "intros H."], "tactic": "exists delta.", "exn": "The reference delta was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros f x. split. - intros cont_eps. unfold continuity_pt in cont_eps. intros eps. specialize (cont_eps (mkposreal eps)). unfold locally, Rabs in *. unfold Rabs in *. intros H. apply cont_eps in H as [delta Hdelta]. exists delta. intros y Hy. apply Hdelta in Hy. unfold no_cond; auto. - intros cont_loc. unfold continuity_pt. intros eps. specialize (cont_loc (mkposreal eps)). unfold locally, Rabs in *. unfold Rabs in *. intros [delta Hdelta]. intros H. apply cont_loc. exists delta. intros y Hy. apply Hdelta. unfold no_cond; auto.", "succ": false}]