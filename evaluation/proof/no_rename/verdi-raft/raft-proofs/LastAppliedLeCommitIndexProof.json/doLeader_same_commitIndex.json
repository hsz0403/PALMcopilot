[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "unfold doLeader in H.", "destruct (advanceCommitIndex st h0) eqn:H_advance."], "tactic": "destruct (shouldSend r) eqn:H_send.", "exn": "The reference r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold doLeader in H.", "destruct (advanceCommitIndex st h0) eqn:H_advance.", "inversion H; subst; clear H."], "tactic": "apply le_S.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params st : raft_data os : list raft_output d' : raft_data ms : list (name * msg) h0 : name currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) H_advance : advanceCommitIndex st h0 = mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories H1 : match Raft.type st with | Leader => if shouldSend then ([], mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h0) (filter (fun h : name => if name_eq_dec h0 h then false else true) nodes)) else ([], mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, d', ms) Unable to unify \"?M1659 <= S ?M1660\" with \"Raft.commitIndex st <= Raft.commitIndex d'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold doLeader in H.", "destruct (advanceCommitIndex st h0) eqn:H_advance.", "inversion H; subst; clear H."], "tactic": "apply advanceCommitIndex_commitIndex.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params st : raft_data os : list raft_output d' : raft_data ms : list (name * msg) h0 : name currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) H_advance : advanceCommitIndex st h0 = mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories H1 : match Raft.type st with | Leader => if shouldSend then ([], mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h0) (filter (fun h : name => if name_eq_dec h0 h then false else true) nodes)) else ([], mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, d', ms) Unable to unify \"Raft.commitIndex ?M1659 <= Raft.commitIndex (advanceCommitIndex ?M1659 ?M1660)\" with \"Raft.commitIndex st <= Raft.commitIndex d'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold doLeader in H.", "destruct (advanceCommitIndex st h0) eqn:H_advance.", "inversion H; subst; clear H."], "tactic": "inversion H; subst; clear H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold doLeader in H.", "destruct (advanceCommitIndex st h0) eqn:H_advance.", "inversion H; subst; clear H."], "tactic": "apply advanceCommitIndex_commitIndex.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params st : raft_data os : list raft_output d' : raft_data ms : list (name * msg) h0 : name currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) H_advance : advanceCommitIndex st h0 = mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories H1 : match Raft.type st with | Leader => if shouldSend then ([], mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h0) (filter (fun h : name => if name_eq_dec h0 h then false else true) nodes)) else ([], mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, d', ms) Unable to unify \"Raft.commitIndex ?M1659 <= Raft.commitIndex (advanceCommitIndex ?M1659 ?M1660)\" with \"Raft.commitIndex st <= Raft.commitIndex d'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold doLeader in H.", "destruct (advanceCommitIndex st h0) eqn:H_advance.", "inversion H; subst; clear H."], "tactic": "inversion H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros. unfold doLeader in H. destruct (advanceCommitIndex st h0) eqn:H_advance. destruct (shouldSend r) eqn:H_send. - inversion H; subst; clear H. apply le_S. apply advanceCommitIndex_commitIndex. - inversion H; subst; clear H. apply advanceCommitIndex_commitIndex. - inversion H.", "succ": false}]