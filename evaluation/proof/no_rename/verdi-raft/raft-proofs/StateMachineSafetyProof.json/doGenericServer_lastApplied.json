[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = [] H : ([], RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output st (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st), []) = (out, st', ms) H1 : [] = out H2 : mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st) (stateMachine st) (nextIndex st) (matchIndex st) (shouldSend st) (votesReceived st) (type st) (clientCache st) (electoralVictories st) = st' H3 : [] = ms Unable to unify \"lastApplied st\" with \"lastApplied (mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st) (stateMachine st) (nextIndex st) (matchIndex st) (shouldSend st) (votesReceived st) (type st) (clientCache st) (electoralVictories st))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-"], "tactic": "destruct p as [out' st''].", "exn": "The reference p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+"], "tactic": "right.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params out' : nat st'' : forall x y : input, {x = y} + {x <> y} output_eq_dec : forall x y : output, {x = y} + {x <> y} clientId : Type clientId_eq_dec : forall x y : clientId, {x = y} + {x <> y} rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) e : entry l : list entry Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = e :: l H : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data Raft.clientId output state (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state), [])) = (out, st', ms) H1 : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, {| RaftState.currentTerm := RaftState.currentTerm term name entry logIndex serverType data clientId output state; RaftState.votedFor := RaftState.votedFor term name entry logIndex serverType data clientId output state; RaftState.leaderId := RaftState.leaderId term name entry logIndex serverType data clientId output state; RaftState.log := RaftState.log term name entry logIndex serverType data clientId output state; RaftState.commitIndex := RaftState.commitIndex term name entry logIndex serverType data clientId output state; RaftState.lastApplied := if RaftState.lastApplied term name entry logIndex serverType data clientId output state <? RaftState.commitIndex term name entry logIndex serverType data clientId output state then RaftState.commitIndex term name entry logIndex serverType data clientId output state else RaftState.lastApplied term name entry logIndex serverType data clientId output state; RaftState.stateMachine := RaftState.stateMachine term name entry logIndex serverType data clientId output state; RaftState.nextIndex := RaftState.nextIndex term name entry logIndex serverType data clientId output state; RaftState.matchIndex := RaftState.matchIndex term name entry logIndex serverType data clientId output state; RaftState.shouldSend := RaftState.shouldSend term name entry logIndex serverType data clientId output state; RaftState.votesReceived := RaftState.votesReceived term name entry logIndex serverType data clientId output state; RaftState.type := RaftState.type term name entry logIndex serverType data clientId output state; RaftState.clientCache := RaftState.clientCache term name entry logIndex serverType data clientId output state; RaftState.electoralVictories := RaftState.electoralVictories term name entry logIndex serverType data clientId output state |}, [])) = (out, st', ms) Unable to unify \"?M3414 <= S ?M3415\" with \"S (lastApplied st) <= commitIndex st\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+"], "tactic": "split; [auto |].", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq."], "tactic": "apply filter_In in Heq.", "exn": "Unable to apply lemma of type \"forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x (filter f l) <-> In x l /\\\\ f x = true\" on hypothesis of type \"e :: l = rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq']."], "tactic": "apply andb_true_iff in Heq'.", "exn": "No such hypothesis: Heq'", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq']."], "tactic": "destruct Heq' as [H1 H2].", "exn": "The reference Heq' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2]."], "tactic": "apply Nat.ltb_lt in H1.", "exn": "Unable to apply lemma of type \"forall n m : nat, (n <? m) = true <-> n < m\" on hypothesis of type \"(let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, {| RaftState.currentTerm := RaftState.currentTerm term name entry logIndex serverType data clientId output state; RaftState.votedFor := RaftState.votedFor term name entry logIndex serverType data clientId output state; RaftState.leaderId := RaftState.leaderId term name entry logIndex serverType data clientId output state; RaftState.log := RaftState.log term name entry logIndex serverType data clientId output state; RaftState.commitIndex := RaftState.commitIndex term name entry logIndex serverType data clientId output state; RaftState.lastApplied := if RaftState.lastApplied term name entry logIndex serverType data clientId output state <? RaftState.commitIndex term name entry logIndex serverType data clientId output state then RaftState.commitIndex term name entry logIndex serverType data clientId output state else RaftState.lastApplied term name entry logIndex serverType data clientId output state; RaftState.stateMachine := RaftState.stateMachine term name entry logIndex serverType data clientId output state; RaftState.nextIndex := RaftState.nextIndex term name entry logIndex serverType data clientId output state; RaftState.matchIndex := RaftState.matchIndex term name entry logIndex serverType data clientId output state; RaftState.shouldSend := RaftState.shouldSend term name entry logIndex serverType data clientId output state; RaftState.votesReceived := RaftState.votesReceived term name entry logIndex serverType data clientId output state; RaftState.type := RaftState.type term name entry logIndex serverType data clientId output state; RaftState.clientCache := RaftState.clientCache term name entry logIndex serverType data clientId output state; RaftState.electoralVictories := RaftState.electoralVictories term name entry logIndex serverType data clientId output state |}, [])) = (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data Raft.clientId output state (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state), []))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2]."], "tactic": "apply Nat.leb_le in H2.", "exn": "No such hypothesis: H2", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2]."], "tactic": "apply findGtIndex_In in Hin.", "exn": "No such hypothesis: Hin", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2]."], "tactic": "destruct Hin as [Hin _].", "exn": "The reference Hin was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2].", "destruct st' as [st' _]."], "tactic": "exists e.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2].", "destruct st' as [st' _]."], "tactic": "split; auto.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2].", "destruct st' as [st' _]."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2].", "destruct st' as [st' _].", "shelve.", "+"], "tactic": "apply Nat.lt_le_incl.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params out' : nat st'' : forall x y : input, {x = y} + {x <> y} output_eq_dec : forall x y : output, {x = y} + {x <> y} clientId : Type clientId_eq_dec : forall x y : clientId, {x = y} + {x <> y} rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) e : entry l : list entry Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = e :: l H : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data Raft.clientId output state (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state), [])) = (out, st', ms) H1 : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, {| RaftState.currentTerm := RaftState.currentTerm term name entry logIndex serverType data clientId output state; RaftState.votedFor := RaftState.votedFor term name entry logIndex serverType data clientId output state; RaftState.leaderId := RaftState.leaderId term name entry logIndex serverType data clientId output state; RaftState.log := RaftState.log term name entry logIndex serverType data clientId output state; RaftState.commitIndex := RaftState.commitIndex term name entry logIndex serverType data clientId output state; RaftState.lastApplied := if RaftState.lastApplied term name entry logIndex serverType data clientId output state <? RaftState.commitIndex term name entry logIndex serverType data clientId output state then RaftState.commitIndex term name entry logIndex serverType data clientId output state else RaftState.lastApplied term name entry logIndex serverType data clientId output state; RaftState.stateMachine := RaftState.stateMachine term name entry logIndex serverType data clientId output state; RaftState.nextIndex := RaftState.nextIndex term name entry logIndex serverType data clientId output state; RaftState.matchIndex := RaftState.matchIndex term name entry logIndex serverType data clientId output state; RaftState.shouldSend := RaftState.shouldSend term name entry logIndex serverType data clientId output state; RaftState.votesReceived := RaftState.votesReceived term name entry logIndex serverType data clientId output state; RaftState.type := RaftState.type term name entry logIndex serverType data clientId output state; RaftState.clientCache := RaftState.clientCache term name entry logIndex serverType data clientId output state; RaftState.electoralVictories := RaftState.electoralVictories term name entry logIndex serverType data clientId output state |}, [])) = (out, st', ms) Unable to unify \"?M3441 <= ?M3442\" with \"lastApplied st' = commitIndex st\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct raft_params as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "symmetry in Heq.", "destruct Heq as [Hin Heq'].", "destruct H as [H1 H2].", "destruct st' as [st' _].", "shelve.", "+"], "tactic": "apply Nat.ltb_lt.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params out' : nat st'' : forall x y : input, {x = y} + {x <> y} output_eq_dec : forall x y : output, {x = y} + {x <> y} clientId : Type clientId_eq_dec : forall x y : clientId, {x = y} + {x <> y} rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) e : entry l : list entry Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = e :: l H : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data Raft.clientId output state (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state), [])) = (out, st', ms) H1 : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out'0, state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out'0, state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out'0, state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out'0, state) in (out, {| RaftState.currentTerm := RaftState.currentTerm term name entry logIndex serverType data clientId output state; RaftState.votedFor := RaftState.votedFor term name entry logIndex serverType data clientId output state; RaftState.leaderId := RaftState.leaderId term name entry logIndex serverType data clientId output state; RaftState.log := RaftState.log term name entry logIndex serverType data clientId output state; RaftState.commitIndex := RaftState.commitIndex term name entry logIndex serverType data clientId output state; RaftState.lastApplied := if RaftState.lastApplied term name entry logIndex serverType data clientId output state <? RaftState.commitIndex term name entry logIndex serverType data clientId output state then RaftState.commitIndex term name entry logIndex serverType data clientId output state else RaftState.lastApplied term name entry logIndex serverType data clientId output state; RaftState.stateMachine := RaftState.stateMachine term name entry logIndex serverType data clientId output state; RaftState.nextIndex := RaftState.nextIndex term name entry logIndex serverType data clientId output state; RaftState.matchIndex := RaftState.matchIndex term name entry logIndex serverType data clientId output state; RaftState.shouldSend := RaftState.shouldSend term name entry logIndex serverType data clientId output state; RaftState.votesReceived := RaftState.votesReceived term name entry logIndex serverType data clientId output state; RaftState.type := RaftState.type term name entry logIndex serverType data clientId output state; RaftState.clientCache := RaftState.clientCache term name entry logIndex serverType data clientId output state; RaftState.electoralVictories := RaftState.electoralVictories term name entry logIndex serverType data clientId output state |}, [])) = (out, st', ms) Unable to unify \"((?M3441 <? ?M3442) = true -> ?M3441 < ?M3442) /\\\\ (?M3441 < ?M3442 -> (?M3441 <? ?M3442) = true)\" with \"lastApplied st' = commitIndex st\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st out st' ms H. unfold doGenericServer, applyEntries in H. destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq. - inversion H. left. reflexivity. - destruct p as [out' st'']. inversion H; subst. right. split. + right. split; [auto |]. symmetry in Heq. apply filter_In in Heq. destruct Heq as [Hin Heq']. apply andb_true_iff in Heq'. destruct Heq' as [H1 H2]. apply Nat.ltb_lt in H1. apply Nat.leb_le in H2. apply findGtIndex_In in Hin. destruct Hin as [Hin _]. exists e. split; auto. + apply Nat.lt_le_incl. apply Nat.ltb_lt. auto.", "succ": false}]