[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st src t v st' crony HhandleRequestVoteReply HinVotesReceived.", "unfold handleRequestVoteReply in HhandleRequestVoteReply.", "destruct (currentTerm st <? t) eqn:HtermLess.", "-", "inversion HhandleRequestVoteReply."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t v st' crony HhandleRequestVoteReply HinVotesReceived.", "unfold handleRequestVoteReply in HhandleRequestVoteReply.", "destruct (currentTerm st <? t) eqn:HtermLess.", "-", "inversion HhandleRequestVoteReply.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:HtLess.", "+", "inversion HhandleRequestVoteReply."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t v st' crony HhandleRequestVoteReply HinVotesReceived.", "unfold handleRequestVoteReply in HhandleRequestVoteReply.", "destruct (currentTerm st <? t) eqn:HtermLess.", "-", "inversion HhandleRequestVoteReply.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:HtLess.", "+", "inversion HhandleRequestVoteReply.", "shelve.", "+"], "tactic": "destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:Hwon.", "exn": "The reference voteGranted was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st src t v st' crony HhandleRequestVoteReply HinVotesReceived.", "unfold handleRequestVoteReply in HhandleRequestVoteReply.", "destruct (currentTerm st <? t) eqn:HtermLess.", "-", "inversion HhandleRequestVoteReply.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:HtLess.", "+", "inversion HhandleRequestVoteReply.", "shelve.", "+", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:Hwon.", "*", "inversion HhandleRequestVoteReply; subst.", "left.", "split; auto."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st src t v st' crony HhandleRequestVoteReply HinVotesReceived.", "unfold handleRequestVoteReply in HhandleRequestVoteReply.", "destruct (currentTerm st <? t) eqn:HtermLess.", "-", "inversion HhandleRequestVoteReply.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:HtLess.", "+", "inversion HhandleRequestVoteReply.", "shelve.", "+", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:Hwon.", "*", "inversion HhandleRequestVoteReply; subst.", "left.", "split; auto."], "tactic": "apply votes_received_cronies; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface vci : votes_correct_interface cvfsi : candidates_vote_for_selves_interface h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output src : name t : nat v : bool crony : name HtermLess : (currentTerm st <? t) = false HtLess : (t <? currentTerm st) = false Hwon : v && wonElection (dedup name_eq_dec (src :: votesReceived st)) = true H : match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if v then [src] else []) ++ votesReceived st)) Leader) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ([(currentTerm st, src :: votesReceived st, log st)] ++ electoralVictories st) | _ => st end = match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if v then [src] else []) ++ votesReceived st)) Leader) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ([(currentTerm st, src :: votesReceived st, log st)] ++ electoralVictories st) | _ => st end HinVotesReceived : In crony (votesReceived match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if v then [src] else []) ++ votesReceived st)) Leader) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ([(currentTerm st, src :: votesReceived st, log st)] ++ electoralVictories st) | _ => st end) Unable to unify \"Prop\" with \"crony = src\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st src t v st' crony HhandleRequestVoteReply HinVotesReceived. unfold handleRequestVoteReply in HhandleRequestVoteReply. destruct (currentTerm st <? t) eqn:HtermLess. - inversion HhandleRequestVoteReply. - destruct (t <? currentTerm st) eqn:HtLess. + inversion HhandleRequestVoteReply. + destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:Hwon. * inversion HhandleRequestVoteReply; subst. left. split; auto. right. apply votes_received_cronies; auto.", "succ": false}]