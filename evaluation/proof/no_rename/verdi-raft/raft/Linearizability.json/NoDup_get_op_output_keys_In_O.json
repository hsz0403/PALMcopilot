[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros xs ys k H1 H2."], "tactic": "apply (NoDup_remove_2 k).", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x <> y} xs, ys : list op k : K H1 : NoDup (get_op_output_keys (xs ++ O k :: ys)) H2 : In (O k) (xs ++ ys) The term \"k\" has type \"K\" while it is expected to have type \"list ?A\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros xs ys k H1 H2."], "tactic": "apply (NoDup_app_3_not_in_2 _ _ [] ys k) in H1.", "exn": "The reference NoDup_app_3_not_in_2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros xs ys k H1 H2.", "apply In_split in H2.", "destruct H2 as [xs' [ys' H2']]."], "tactic": "rewrite H2'.", "exn": "Found no subterm matching \"xs ++ ys\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros xs ys k H1 H2.", "apply In_split in H2.", "destruct H2 as [xs' [ys' H2']]."], "tactic": "apply in_app_iff in H1.", "exn": "Unable to apply lemma of type \"forall (A : Type) (l l' : list A) (a : A), In a (l ++ l') <-> In a l \\\\/ In a l'\" on hypothesis of type \"NoDup (get_op_output_keys (xs ++ O k :: ys))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros xs ys k H1 H2.", "apply In_split in H2.", "destruct H2 as [xs' [ys' H2']].", "destruct H1.", "-"], "tactic": "apply (dedup_partition K K_eq_dec _ _ _ _) in H; rewrite H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs ys k H1 H2.", "apply In_split in H2.", "destruct H2 as [xs' [ys' H2']].", "destruct H1.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros xs ys k H1 H2.", "apply In_split in H2.", "destruct H2 as [xs' [ys' H2']].", "destruct H1.", "-", "shelve.", "-"], "tactic": "apply (dedup_partition K K_eq_dec _ _ _ _) in H; rewrite H.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x <> y} xs, ys : list op k, x : K l : list K H : ~ In x l H1 : NoDup l xs', ys' : list op H2' : xs ++ ys = xs' ++ O k :: ys' The term \"K\" has type \"Type\" while it is expected to have type \"forall x0 y : ?A, {x0 = y} + {x0 <> y}\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros xs ys k H1 H2. apply (NoDup_remove_2 k). apply (NoDup_app_3_not_in_2 _ _ [] ys k) in H1. simpl in H1. auto. apply In_split in H2. destruct H2 as [xs' [ys' H2']]. rewrite H2'. apply in_app_iff in H1. destruct H1. - apply (dedup_partition K K_eq_dec _ _ _ _) in H; rewrite H. destruct (K_eq_dec k k) as [e|n]; [contradiction|]. apply (get_op_output_keys_complete _ _ k) in H. apply (get_op_output_keys_sound k (k :: _)) in H. simpl in H. contradiction. - apply (dedup_partition K K_eq_dec _ _ _ _) in H; rewrite H. destruct (K_eq_dec k k) as [e|n]; [contradiction|]. apply (get_op_output_keys_complete _ _ k) in H. apply (get_op_output_keys_sound _ _ _) in H. simpl in H. contradiction.", "succ": false}]