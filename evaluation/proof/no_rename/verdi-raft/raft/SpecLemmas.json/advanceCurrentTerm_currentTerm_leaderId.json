[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "destruct st.", "destruct orig_base_params.", "destruct one_node_params.", "destruct raft_params.", "simpl.", "left."], "tactic": "apply Nat.lt_succ_diag_r.", "exn": "In environment orig_base_params : BaseParams data : Type input : Type output : Type one_node_params : OneNodeParams {| data := data; input := input; output := output |} raft_params : RaftParams {| data := data; input := input; output := output |} currentTerm : term N : nat input_eq_dec : forall x y : Net.input, {x = y} + {x <> y} output_eq_dec : forall x y : Net.output, {x = y} + {x <> y} clientId : Type clientId_eq_dec : forall x y : clientId, {x = y} + {x <> y} votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : Net.data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (Raft.clientId * (nat * Net.output)) electoralVictories : list (term * list name * list entry) t : nat init : Net.data handler : Net.input -> Net.data -> Net.output * Net.data Unable to unify \"S ?M1660 <= S ?M1660\" with \"S currentTerm <= RaftState.currentTerm term name entry logIndex serverType data clientId output (advanceCurrentTerm {| RaftState.currentTerm := currentTerm; RaftState.votedFor := votedFor; RaftState.leaderId := leaderId; RaftState.log := log; RaftState.commitIndex := commitIndex; RaftState.lastApplied := lastApplied; RaftState.stateMachine := stateMachine; RaftState.nextIndex := nextIndex; RaftState.matchIndex := matchIndex; RaftState.shouldSend := shouldSend; RaftState.votesReceived := votesReceived; RaftState.type := type; RaftState.clientCache := clientCache; RaftState.electoralVictories := electoralVictories |} t)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. destruct st. destruct orig_base_params. destruct one_node_params. destruct raft_params. simpl. left. apply Nat.lt_succ_diag_r.", "succ": false}]