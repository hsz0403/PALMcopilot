[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st d m t n pli plt es ci H_handleAppendEntries.", "unfold handleAppendEntries in H_handleAppendEntries.", "inversion H_handleAppendEntries; subst."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st, d : raft_data m : msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex H_handleAppendEntries : (if t <? currentTerm st then (st, AppendEntriesReply (currentTerm st) es false) else if pli =? 0 then if haveNewEntries st es then ({[{[{[{[advanceCurrentTerm st t with log := es]} with commitIndex := Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex es))]} with type := Follower]} with leaderId := Some n]}, AppendEntriesReply t es true) else ({[{[advanceCurrentTerm st t with type := Follower]} with leaderId := Some n]}, AppendEntriesReply t es true) else match findAtIndex (log st) pli with | Some e => if negb (plt =? eTerm e) then (st, AppendEntriesReply (currentTerm st) es false) else if haveNewEntries st es then ({[{[{[{[advanceCurrentTerm st t with log := es ++ removeAfterIndex (log st) pli]} with commitIndex := Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex (es ++ removeAfterIndex (log st) pli)))]} with type := Follower]} with leaderId := Some n]}, AppendEntriesReply t es true) else ({[{[advanceCurrentTerm st t with type := Follower]} with leaderId := Some n]}, AppendEntriesReply t es true) | None => (st, AppendEntriesReply (currentTerm st) es false) end) = (d, m) H0 : (if t <? currentTerm st then (st, AppendEntriesReply (currentTerm st) es false) else if pli =? 0 then if haveNewEntries st es then (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) es (Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex es))) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true) else (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) (log (advanceCurrentTerm st t)) (commitIndex (advanceCurrentTerm st t)) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true) else match findAtIndex (log st) pli with | Some e => if negb (plt =? eTerm e) then (st, AppendEntriesReply (currentTerm st) es false) else if haveNewEntries st es then (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) (es ++ removeAfterIndex (log st) pli) (Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex (es ++ removeAfterIndex (log st) pli)))) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true) else (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) (log (advanceCurrentTerm st t)) (commitIndex (advanceCurrentTerm st t)) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true) | None => (st, AppendEntriesReply (currentTerm st) es false) end) = (d, m) Unable to unify \"clientCache st\" with \"clientCache d\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st d m t n pli plt es ci H_handleAppendEntries. unfold handleAppendEntries in H_handleAppendEntries. inversion H_handleAppendEntries; subst. reflexivity.", "succ": false}]