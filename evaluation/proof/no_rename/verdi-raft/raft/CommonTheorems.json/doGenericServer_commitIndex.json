[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st out st' ms H.", "unfold doGenericServer in H.", "destruct (applyEntries h st (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))))).", "inversion H."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) l : list raft_output r : raft_data H : (l, {[r with lastApplied := if lastApplied r <? commitIndex r then commitIndex r else lastApplied r]}, []) = (out, st', ms) H1 : l = out H2 : mkRaft_data (currentTerm r) (votedFor r) (leaderId r) (log r) (commitIndex r) (if lastApplied r <? commitIndex r then commitIndex r else lastApplied r) (stateMachine r) (nextIndex r) (matchIndex r) (shouldSend r) (votesReceived r) (type r) (clientCache r) (electoralVictories r) = st' H3 : [] = ms Unable to unify \"commitIndex st\" with \"commitIndex (mkRaft_data (currentTerm r) (votedFor r) (leaderId r) (log r) (commitIndex r) (if lastApplied r <? commitIndex r then commitIndex r else lastApplied r) (stateMachine r) (nextIndex r) (matchIndex r) (shouldSend r) (votesReceived r) (type r) (clientCache r) (electoralVictories r))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st out st' ms H. unfold doGenericServer in H. destruct (applyEntries h st (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))))). inversion H. reflexivity.", "succ": false}]