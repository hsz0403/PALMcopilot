[{"history": {"proof": "intros l e H_sorted H_in. unfold maxTerm. induction l as [|e' l' IHl]. - inversion H_in. - destruct H_in as [Heq | Hin]. + subst. left. + apply H_sorted. sfirstorder depth: 3use: in_cons, sorted_cons.", "repairs": ["", "", "", "", "", "", "", "", "", "", "", "", "hammer"], "exceptions": [{"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst."], "tactic": "apply Nat.max_le_iff.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params l' : list entry e : entry H_sorted : sorted (e :: l') IHl : sorted l' -> In e l' -> (fix maxTerm (entries : list entry) : term := match entries with | [] => 0 | e :: _ => eTerm e end) l' >= eTerm e Unable to unify \"(?M1656 <= Nat.max ?M1654 ?M1655 -> ?M1656 <= ?M1654 \\\\/ ?M1656 <= ?M1655) /\\\\ (?M1656 <= ?M1654 \\\\/ ?M1656 <= ?M1655 -> ?M1656 <= Nat.max ?M1654 ?M1655)\" with \"eTerm e <= eTerm e\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst.", "left."], "tactic": "apply le_refl.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst.", "left.", "+"], "tactic": "apply Nat.max_le_iff.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry H_sorted : sorted (e' :: l') Hin : In e l' IHl : sorted l' -> In e l' -> (fix maxTerm (entries : list entry) : term := match entries with | [] => 0 | e :: _ => eTerm e end) l' >= eTerm e Unable to unify \"(?M1657 <= Nat.max ?M1655 ?M1656 -> ?M1657 <= ?M1655 \\\\/ ?M1657 <= ?M1656) /\\\\ (?M1657 <= ?M1655 \\\\/ ?M1657 <= ?M1656 -> ?M1657 <= Nat.max ?M1655 ?M1656)\" with \"eTerm e <= eTerm e'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst.", "left.", "+"], "tactic": "right.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry H_sorted : sorted (e' :: l') Hin : In e l' IHl : sorted l' -> In e l' -> (fix maxTerm (entries : list entry) : term := match entries with | [] => 0 | e :: _ => eTerm e end) l' >= eTerm e Unable to unify \"?M1655 <= S ?M1656\" with \"eTerm e <= eTerm e'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst.", "left.", "+"], "tactic": "apply IHl.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry H_sorted : sorted (e' :: l') Hin : In e l' IHl : sorted l' -> In e l' -> (fix maxTerm (entries : list entry) : term := match entries with | [] => 0 | e :: _ => eTerm e end) l' >= eTerm e Unable to unify \"(fix maxTerm (entries : list entry) : term := match entries with | [] => 0 | e :: _ => eTerm e end) l' >= eTerm e\" with \"eTerm e' >= eTerm e\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst.", "left.", "+"], "tactic": "apply sorted_cons in H_sorted.", "exn": "Unable to find an instance for the variable a.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros l e H_sorted H_in.", "unfold maxTerm.", "induction l as [|e' l' IHl].", "-", "inversion H_in.", "-", "destruct H_in as [Heq | Hin].", "+", "subst.", "left.", "+", "apply H_sorted."], "tactic": "apply in_cons; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry H_sorted : sorted (e' :: l') Hin : In e l' IHl : sorted l' -> In e l' -> (fix maxTerm (entries : list entry) : term := match entries with | [] => 0 | e :: _ => eTerm e end) l' >= eTerm e Unable to unify \"?M1660 = ?M1661 \\\\/ (fix In (a : ?M1659) (l : list ?M1659) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) ?M1661 ?M1662\" with \"(fix In (a : entry) (l : list entry) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) e l'\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l e H_sorted H_in. unfold maxTerm. simpl. induction l as [|e' l' IHl]. - inversion H_in. - destruct H_in as [Heq | Hin]. + subst. apply Nat.max_le_iff. left. apply le_refl. + apply Nat.max_le_iff. right. apply IHl. * apply sorted_cons in H_sorted. apply H_sorted. * apply in_cons; auto.", "succ": true}]