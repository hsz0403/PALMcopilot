[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "assert (In p (nwPackets st))."], "tactic": "apply in_or_app.", "exn": "In environment orig_base_params : BaseParams orig_multi_params : MultiParams orig_base_params st : seq_num_network p : packet xs, ys : list packet d : data l : list (name * msg) l' : list (name * seq_num_msg) n : nat H : sequence_sane st H0 : sequence_seen st H1 : sequence_equality st H2 : nwPackets st = xs ++ p :: ys H3 : ~ In (tmNum (pBody p)) (assoc_default name_eq_dec (tdSeen (nwState st (pDst p))) (pSrc p) []) H4 : processPackets (tdNum (nwState st (pDst p))) l = (n, l') Unable to unify \"(fix In (a : ?M1635) (l : list ?M1635) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) ?M1638 (?M1636 ++ ?M1637)\" with \"(fix In (a : packet) (l : list packet) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) p (nwPackets st)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "assert (In p (nwPackets st)).", "qsimpl time: 1 use: in_or_app."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "assert (In p (nwPackets st)).", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "assert (In p (nwPackets st)).", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app."], "tactic": "assert (exists p', pDst p' = pDst p /\\ pBody p' = pBody p /\\ pSrc p' = pSrc p /\\ pRcvd p' = true /\\ In p' (nwPackets st)).", "exn": "The reference pRcvd was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros. assert (In p (nwPackets st)). apply in_or_app. right. left. trivial. assert (exists p', pDst p' = pDst p /\\ pBody p' = pBody p /\\ pSrc p' = pSrc p /\\ pRcvd p' = true /\\ In p' (nwPackets st)). inversion H1. subst xs. simpl in H2. clear H1. find_apply_lem_hyp in_split. break_exists. subst. simpl in *. repeat find_apply_lem_hyp in_app_or. intuition; try congruence. exists x. intuition; repeat find_rewrite; auto. assert (pNum (pBody p) < nwSeqNum (nwState st (pDst p))). unfold seq_num_invariant in *. eauto. unfold revertNetwork. simpl. apply processPackets_spec in H3. repeat find_higher_order_rewrite. unfold update2 in *. repeat break_match; repeat find_rewrite; unfold seq_num_net_invariant, well_ordered_net in *; simpl in *; unfold seq_num_packet_invariant in *. - unfold seq_num_nw_state_invariant, seq_num_msg in *. remember (assoc_set (assoc_set (nwState st (pDst p)) (tmNum (pBody p))) (pSrc p) (pBody (pDst p))) as st'. rewrite <- H4 in *. assert (assoc_default _ (tdSeen (nwState st (pDst p))) (pSrc p) [] = assoc_default _ (tdSeen (nwState st' (pDst p))) (pSrc p) []). unfold st'. repeat find_rewrite. unfold assoc_set. break_if; auto. find_rewrite. auto. break_if. + break_exists. intuition. - unfold seq_num_nw_state_invariant in *. remember (assoc_set (nwState st (pDst p)) (tmNum (pBody p)) (pSrc p, (tmNum (pBody p), snd (assoc_default _ (tdData (nwState st n0)) (pSrc p) [])))) as st'. rewrite <- H4 in *. assert (assoc_default _ (tdData (nwState st n0)) (pSrc p) [] = assoc_default _ (tdData (nwState st' n0)) (pSrc p) []). unfold st'. repeat find_rewrite. unfold assoc_set. break_if; auto. find_rewrite. auto. break_if. + find_apply_lem_hyp pRcvd_true_seen_true. break_exists. intuition. repeat find_rewrite. unfold assoc_set in *. break_if; try congruence; subst x. auto. + break_exists. intuition. - find_apply_lem_hyp pRcvd_true_seen_true. break_exists. intuition. congruence.", "hammer_times": 3, "succ": false}]