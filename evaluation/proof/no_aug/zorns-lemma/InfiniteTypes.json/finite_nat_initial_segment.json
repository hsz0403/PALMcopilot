[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n.", "induction n.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "shelve.", "+"], "tactic": "apply finite_nat_cardinal.", "exn": "The reference finite_nat_cardinal was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "shelve.", "+", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros n. induction n. - apply empty_finite. - apply finite_subtype with (P := fun (m:nat) => m < S n). + apply finite_exp. * apply finite_exp. { apply finite_exp. - apply finite_nat_cardinal. - apply finite_prod. + apply FiniteT_has_nat_cardinal. + apply FiniteT_has_nat_cardinal. } { apply finite_prod. - apply FiniteT_has_nat_cardinal. - apply FiniteT_has_nat_cardinal. } * apply finite_prod. { apply FiniteT_nat_cardinal. apply add_finite. apply FiniteT_has_nat_cardinal. } { apply add_finite. apply finite_nat_cardinal. } + intros m. destruct (lt_dec m (S n)). * exists m. split. { apply cardinal_unicity with (n := S n). - apply FiniteT_has_nat_cardinal. - apply card_add. + apply finite_nat_cardinal. + apply card_empty. } { intros p H. apply Fin.to_nat_of_nat. } * intros [p Hp]. apply (False_rect _ (nlt_0_r m Hp)).", "succ": false}]