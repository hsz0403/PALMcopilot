[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros L1 L2 p zerop_p In_p_L.", "unfold redacc.", "induction L1 as [|a L1' IHL1].", "-", "simpl in In_p_L."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros L1 L2 p zerop_p In_p_L.", "unfold redacc.", "induction L1 as [|a L1' IHL1].", "-", "simpl in In_p_L.", "shelve.", "-", "simpl.", "destruct (zerop_dec (nf (L1' ++ L2) a)) as [eq | neq].", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros L1 L2 p zerop_p In_p_L.", "unfold redacc.", "induction L1 as [|a L1' IHL1].", "-", "simpl in In_p_L.", "shelve.", "-", "simpl.", "destruct (zerop_dec (nf (L1' ++ L2) a)) as [eq | neq].", "+", "shelve.", "+", "exists (nf (L1' ++ L2) a).", "split.", "*", "apply in_app_or in In_p_L.", "destruct In_p_L.", "apply in_or_app.", "left."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros L1 L2 p zerop_p In_p_L. unfold redacc. induction L1 as [|a L1' IHL1]. - simpl in In_p_L. contradiction. - simpl. destruct (zerop_dec (nf (L1' ++ L2) a)) as [eq | neq]. + apply IHL1. intros H. apply In_app_iff in H. destruct H. * apply zerop_nf_cb in eq. contradiction. * apply In_split in H as [l1 [l2 H]]. rewrite H. apply in_or_app. right. left. + exists (nf (L1' ++ L2) a). split. * apply in_app_or in In_p_L. destruct In_p_L. { apply in_or_app. left. apply redacc_cb. auto. } { apply in_or_app. right. auto. } * split. { apply nf_div_zero1; auto. } { auto. }", "succ": false}]