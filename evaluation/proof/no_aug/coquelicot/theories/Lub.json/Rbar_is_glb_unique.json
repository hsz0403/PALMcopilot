[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros E l H.", "exn": "E is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros E' l H.", "exn": "l is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros E' l' H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros E l H. unfold Rbar_is_glb, Rbar_glb in H. destruct H as [H1 H2]. apply Rbar_is_lub_unique. apply Rbar_glb_lub. split. + intros b Hb. apply (proj2 (is_glb_Rbar_correct (fun x : Rbar => is_finite x /\\ E x) l)). split. * intros x [Hfin Ex]. apply (Rbar_lb_eq_ub _ _ H1 Hb _ Ex). destruct x; simpl in Hfin; try contradiction. apply Hfin. * intros b' Hb'. apply (Rbar_lb_ub _ _ Hb' H1). + intros b Hb. apply (proj1 (is_glb_Rbar_correct (fun x : Rbar => is_finite x /\\ E x) l)). split. * intros x [Hfin Ex]. apply (Rbar_lb_eq_ub _ _ H1 Hb _ Ex). destruct x; simpl in Hfin; try contradiction. apply Hfin. * intros b' Hb'. apply (Rbar_lb_ub _ _ Hb' H1).", "succ": false}]