[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros K V F FF k Hmult n m.", "exn": "K is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V F FF k Hmult n m.", "exn": "V is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V' F FF k Hmult n m.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "shelve.", "-", "intros x limx.", "unfold is_domin."], "tactic": "intros eps Heps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "shelve.", "-", "intros x limx.", "unfold is_domin.", "intros."], "tactic": "specialize (limx (ball_norm x (mkposreal _ Heps))) as limx'.", "exn": "The reference Heps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "shelve.", "-", "intros x limx.", "unfold is_domin.", "intros."], "tactic": "destruct limx' as [limx1 limx2].", "exn": "The reference limx' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "shelve.", "-", "intros x limx.", "unfold is_domin.", "intros.", "destruct K as [limx1 limx2].", "unfold scal."], "tactic": "apply (filter_imp (fun y : V => ball_norm x (mkposreal _ Heps) y) (fun y : V => ball_norm (scal k x) (mkposreal _ Heps) y)).", "exn": "The reference Heps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "shelve.", "-", "intros x limx.", "unfold is_domin.", "intros.", "destruct K as [limx1 limx2].", "unfold scal."], "tactic": "intros y Hy.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "shelve.", "-", "intros x limx.", "unfold is_domin.", "intros.", "destruct K as [limx1 limx2].", "unfold scal."], "tactic": "apply Hy.", "exn": "The reference Hy was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros K V F FF k Hmult n m. unfold filterdiff. split. - unfold is_linear. split. + intros x y. unfold scal. rewrite <- module_mult_comm. reflexivity. + intros x limx. unfold is_domin. intros eps Heps. unfold filterlim, locally in limx. specialize (Hmult n m) as Hmult_comm. unfold scal. specialize (limx (ball_norm x (mkposreal _ Heps))) as limx'. destruct limx' as [limx1 limx2]. apply (filter_imp (fun y : V => ball_norm x (mkposreal _ Heps) y) (fun y : V => ball_norm (scal k x) (mkposreal _ Heps) y)). * intros y Hy. rewrite <- Hmult_comm. apply Hy. * apply limx2. - intros x limx. unfold is_domin. intros eps Heps. unfold filterlim, locally in limx. specialize (limx (ball_norm x (mkposreal _ Heps))) as limx'. destruct limx' as [limx1 limx2]. unfold scal. apply (filter_imp (fun y : V => ball_norm x (mkposreal _ Heps) y) (fun y : V => ball_norm (scal k x) (mkposreal _ Heps) y)). + intros y Hy. apply Hy. + apply limx2.", "succ": false}]