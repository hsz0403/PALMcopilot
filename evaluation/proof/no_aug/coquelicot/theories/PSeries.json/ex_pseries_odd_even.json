[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "intros. apply ex_pseries_R in H as H1. apply ex_pseries_R in H0 as H2. apply ex_pseries_dec in H1 as [H1 | H1]; apply ex_pseries_dec in H2 as [H2 | H2]. - apply ex_pseries_R. apply is_pseries_odd_even with (l1 := PSeries (fun n : nat => a (2 * n)%nat) (x ^ 2)) (l2 := PSeries (fun n : nat => a (2 * n + 1)%nat) (x ^ 2)). + apply PSeries_correct. apply H1. + apply PSeries_correct. apply H2. - apply ex_pseries_R. apply ex_pseries_decr_n in H1. apply ex_pseries_decr_n in H2. rewrite (PSeries_decr_n (fun n : nat => a (2 * n)%nat) 1 (x^2)) in H1. rewrite (PSeries_decr_n (fun n : nat => a (2 * n + 1)%nat) 1 (x^2)) in H2. apply is_pseries_unique in H1. apply is_pseries_unique in H2. rewrite H1. rewrite H2. apply is_pseries_odd_even with (l1 := 0) (l2 := 0). + unfold PSeries. rewrite Series_incr_1. unfold PS_incr_1. ring. + unfold PSeries. rewrite Series_incr_1. unfold PS_incr_1. ring. - apply ex_pseries_R. apply PSeries_plus in H1; apply PSeries_plus in H2. rewrite H1. rewrite H2. apply is_pseries_plus'; apply (PSeries_correct (fun n : nat => a (2 * n)%nat)). apply H1. apply H2. - apply ex_pseries_R. apply PSeries_plus in H1; apply PSeries_plus in H2. rewrite H1. rewrite H2. apply is_pseries_plus'; apply (PSeries_correct (fun n : nat => a (2 * n)%nat)). apply H1. apply H2.", "succ": false}]