[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros f a b If H1 H2 H3.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' a b If H1 H2 H3.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' a' b If H1 H2 H3.", "exn": "b is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' a' b' If H1 H2 H3.", "exn": "If is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' a' b' If' H1 H2 H3.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros f a b If H1 H2 H3. unfold is_RInt in H2. unfold filterlim in H2. unfold is_RInt in H1. unfold filterlim in H1. apply (norm_RInt_le f (fun _ => 0) a b If 0). - apply H1. - intros x H4. specialize (H3 x H4). apply H3. - apply filterlim_ext with (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)). + intros ptd. reflexivity. + apply H2.", "succ": false}]