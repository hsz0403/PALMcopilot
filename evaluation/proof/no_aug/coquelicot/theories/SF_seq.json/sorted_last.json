[{"history": {"proof": "intros. generalize dependent i. induction s as [| x xs IHs]. - intros. sauto lq: on depth: 3. - intros. destruct i as [| i'] eqn:Eqi. + hauto l: on use: nth0, sorted_head, last_nth, Nat.nle_succ_0, Nat.lt_succ_diag_r unfold: lt, head, last, size. + hauto brefl: on use: lt_n_Sm_le, last_nth, Nat.lt_succ_diag_r, Nat.nle_succ_0, sorted_incr unfold: last, size, lt.", "repairs": ["no_product", "", "", "", "", "hammer", "", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": [], "tactic": "intros s i Hsorted Hsize x0.", "exn": "s is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros s' i Hsorted Hsize x0.", "exn": "i is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros s' i' Hsorted Hsize x0.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "generalize dependent i.", "induction s as [| x xs IHs].", "-", "intros."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "generalize dependent i.", "induction s as [| x xs IHs].", "-", "intros.", "shelve.", "-", "intros.", "destruct i as [| i'] eqn:Eqi.", "+", "simpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros s i Hsorted Hsize x0. generalize dependent i. induction s as [| x xs IHs]. - intros. inversion Hsize. - intros. destruct i as [| i'] eqn:Eqi. + simpl. apply (sorted_head _ 0). auto. + simpl in Hsize. apply Nat.succ_lt_mono in Hsize. apply IHs; try auto. apply sorted_incr with (j := 0); auto.", "succ": true}]