[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0."], "tactic": "destruct i.", "exn": "The reference i was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0.", "destruct H.", "simpl.", "apply Rlt_le.", "apply Hlt."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0.", "destruct H.", "simpl.", "apply Rlt_le.", "apply Hlt.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "split. - intro H. induction s as [|x [|y t] IH]. + unfold ordered_Rlist. intros. inversion H0. + unfold ordered_Rlist. intros. inversion H0. + simpl. unfold ordered_Rlist. intros. destruct (Rlt_dec x y) as [Hlt|Hnlt]. * destruct i; [inversion H0|]. simpl in H0. destruct i. { simpl. apply Rlt_le. apply Hlt. } { apply IH with (y::t); auto. } * apply Rge_not_lt in Hnlt. destruct i; [apply Hnlt|]. apply IH with (y :: t); auto. - intro H. induction s as [|x|y t] using sorted. + simpl. reflexivity. + simpl in H. unfold ordered_Rlist in H. split. * apply H. apply Nat.lt_0_succ. * apply IH. intros i Hi. apply H. apply Lt.lt_n_S. apply Hi.", "succ": false}]