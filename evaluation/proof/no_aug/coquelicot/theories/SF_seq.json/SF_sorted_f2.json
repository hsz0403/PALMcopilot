[{"history": {"proof": "qauto depth: 4 l: on use: @SF_lx_f2, Nat.lt_0_succ unfold: SF_t, SF_lx, unzip1, SF_sorted, pairmap, sorted, map, SF_seq_f2, size, behead.", "repairs": ["hammer"], "exceptions": [{"ctx": [], "tactic": "intros T f2 P Ord.", "exn": "T is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2 P Ord.", "exn": "f2 is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2' P Ord.", "exn": "P is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2' P' Ord.", "exn": "Ord is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2' P' Ord'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "shelve.", "-", "intros H.", "unfold SF_sorted, sorted in H."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "shelve.", "-", "intros H.", "unfold SF_sorted, sorted in H.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros T f2 P Ord. split. - intros H. unfold SF_sorted, sorted. destruct H as [H1 H2]. split. + simpl. destruct P. * trivial. * apply H1. + intros i Hi x. apply H2. destruct P as [|h [|h' t]]. * inversion Hi. * simpl in Hi. destruct t. { inversion Hi. } { apply Hi. } * simpl in Hi. apply Hi. - intros H. unfold SF_sorted, sorted in H. destruct H as [H1 H2]. split. + simpl in H1. destruct P. * trivial. * split. { apply H1. } { apply sorted_nth. - apply H2. - intros i Hi x. destruct P as [|h [|h' t]]. + inversion Hi. + simpl in Hi. destruct t. * inversion Hi. * apply Hi. + simpl in Hi. apply Hi. } + intros i Hi x. apply H2. destruct P as [|h [|h' t]]. * inversion Hi. * simpl in Hi. destruct t. { inversion Hi. } { apply Hi. } * simpl in Hi. apply Hi.", "succ": true}]