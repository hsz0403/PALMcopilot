[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros lg lf Hle Hlimf Hlimg.", "exn": "lg is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros lg' lf Hle Hlimf Hlimg.", "exn": "lf is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros lg' lf' Hle Hlimf Hlimg.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros lg lf Hle Hlimf Hlimg. unfold Rbar_le in Hle. destruct x. - apply Lim_correct in Hlimf. apply Lim_correct in Hlimg. apply Rbar_le_refl. - destruct lg. + destruct lf. * apply (is_lim_ext_loc f g x l) in Hle. apply (is_lim_comp f g x l lf) in Hle. apply is_lim_unique in Hle. apply is_lim_unique in Hlimf. apply is_lim_unique in Hlimg. rewrite <- Hlimf, <- Hlimg, <- Hle. apply Lim_correct. apply is_lim_opp. apply Hle. * contradiction. + apply Hle. + apply filter_forall. intros M. apply filter_imp with (P:=fun y => M < g y). * apply Lim_correct. apply is_lim_mult with (lf:=lf) (lg:=Rbar_locally' x (fun y : R => g y < M)). ++ apply Hlimf. ++ apply is_lim_mult with (lf:=lg) (lg:=Rbar_locally' x (fun y : R => g y < M)). +++ apply Hlimg. +++ apply filterlim_le with (lf:=lf) (lg:=lg). ++++ apply Hle. ++++ apply Hlimf. ++++ apply Hlimg. * apply filterlim_le with (lf:=lg) (lg:=Rbar_locally' x (fun y : R => g y < M)). ++ apply Hle. ++ apply Lim_correct. apply is_lim_inv. +++ apply Lim_correct. apply is_lim_mult with (lf:=lf) (lg:=Rbar_locally' x (fun y : R => g y < M)). ++++ apply Hlimf. ++++ apply is_lim_inv. * apply Hlimg. * discriminate. +++ discriminate.", "succ": false}]