[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros n h g f H.", "exn": "n is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros n' h g f H.", "exn": "h is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros n' h' g f H.", "exn": "g is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros n' h' g' f H.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros n' h' g' f' H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "intro bij.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros n h g f H. intro bij. inversion bij as [n' g' h' Hg Hh Hgh Hhg]. unfold sum_nat. rewrite sum_bounded_permutation with (g := g') (f := f). rewrite sum_bounded_permutation with (g := h') (f := fun i => f (g' i)). f_equal. apply functional_extensionality. intro i. apply H. apply Hg. apply Hhg.", "succ": false}]