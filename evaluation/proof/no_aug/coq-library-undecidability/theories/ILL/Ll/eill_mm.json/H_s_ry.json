[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p v.", "split.", "-", "intros H_s_ry.", "unfold s in H_s_ry.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)).", "*"], "tactic": "*", "exn": "[Focus] Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H_s_ry.", "unfold s in H_s_ry.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)).", "*", "shelve.", "*"], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H_s_ry.", "unfold s in H_s_ry.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)).", "*", "shelve.", "*", "shelve.", "+", "inversion H_s_ry; subst."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H_s_ry.", "unfold s in H_s_ry.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)).", "*", "shelve.", "*", "shelve.", "+", "inversion H_s_ry; subst.", "shelve.", "-", "intros Hv.", "unfold s.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)); auto."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H_s_ry.", "unfold s in H_s_ry.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)).", "*", "shelve.", "*", "shelve.", "+", "inversion H_s_ry; subst.", "shelve.", "-", "intros Hv.", "unfold s.", "destruct (le_lt_dec n (ry p)).", "+", "destruct (le_lt_dec (2 * n) (ry p)); auto.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply vec_one_unique with (y:=p).", "exn": "The reference vec_one_unique was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros p v. split. - intros H_s_ry. unfold s in H_s_ry. destruct (le_lt_dec n (ry p)). + destruct (le_lt_dec (2 * n) (ry p)). * apply ill_tps_vec_map_list with (s:=fun x v => v=vec_one x). intros q. apply H_s_rx. * apply H_s_ry. + inversion H_s_ry; subst. apply vec_pos_ext. intros q. destruct (Fin.eq_dec q p). * subst. apply H_s_rx. * apply H_s_ry. - intros Hv. unfold s. destruct (le_lt_dec n (ry p)). + destruct (le_lt_dec (2 * n) (ry p)); auto. + apply vec_one_unique with (y:=p). rewrite <- Hv. apply vec_pos_ext. intros q. destruct (Fin.eq_dec q p); auto.", "succ": false}]