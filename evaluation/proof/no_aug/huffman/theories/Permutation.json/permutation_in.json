[{"history": {"proof": "intros a l m HPerm HIn. induction HPerm. - sfirstorder depth: 3. - sfirstorder depth: 3. - sfirstorder depth: 3. - sfirstorder depth: 3.", "repairs": ["", "", "", "hammer", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-"], "tactic": "intros HIn'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-", "shelve.", "-"], "tactic": "intros HIn'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "intros HIn'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a l m HPerm HIn.", "induction HPerm.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "intros HIn'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros a l m HPerm HIn. induction HPerm. - intros HIn'. inversion HIn'. - intros HIn'. apply in_inv in HIn'. destruct HIn' as [Heq | HIn']. + rewrite Heq. apply in_inv in HIn. destruct HIn as [Heq | HIn]. * left. rewrite Heq. apply permutation_skip. * right. apply permutation_sym, (incl_cons b _ l2) with (a := a). ++ apply in_or_app. left. apply in_inv in HIn as [Heq'|HIn']. ** symmetry in Heq'. contradiction. ** auto. ++ apply permutation_sym. auto. ++ apply in_ex_app. exists l1, l2. auto. + apply in_inv in HIn. destruct HIn as [Heq | HIn]. * rewrite Heq. left. apply permutation_skip. * right. apply (incl_cons a _ l2). ++ apply in_or_app. right. auto. ++ auto. - intros HIn'. apply in_inv in HIn'. destruct HIn' as [Heq | HIn']. + rewrite Heq. apply permutation_swap. + apply in_inv in HIn'. destruct HIn' as [Heq|HIn']. * rewrite <- Heq. apply permutation_swap. * apply in_inv in HIn. destruct HIn as [Heq | HIn]. ++ rewrite <- Heq. apply permutation_skip. ++ right. apply Add_in with l; auto. - intros HIn'. apply (permutation_length _ _ l2) in p as Hlen. rewrite <- Hlen. apply IHHPerm2, IHHPerm1. auto.", "succ": true}]