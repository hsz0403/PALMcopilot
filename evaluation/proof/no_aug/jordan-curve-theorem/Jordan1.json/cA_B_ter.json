[{"history": {"proof": "intros m k j x z Hmap Hneq. strivial use: cA_cA_1_B_ter.", "repairs": ["", "hammer"], "exceptions": []}, "chat": [], "original": "intros m k j x z Hmap Hneq. unfold cA, B. destruct Hmap. unfold cA, cA_1 in *. destruct (eq_dim_dec k zero). + destruct (eq_dart_dec x z). * subst. reflexivity. * destruct (eq_dart_dec (cA_1 m0 zero z) z) as [H1 | H1]. ++ rewrite H1. reflexivity. ++ rewrite H1. apply cA_cA_1; auto. + destruct (eq_dim_dec k one). * destruct (eq_dart_dec x z). ++ subst. reflexivity. ++ destruct (eq_dart_dec (cA_1 m0 one z) z) as [H2 | H2]. -- rewrite H2. reflexivity. -- rewrite H2. apply cA_cA_1; auto. * destruct (eq_dim_dec k k0). ++ destruct (eq_dart_dec x0 x). -- reflexivity. -- destruct (eq_dart_dec x0 z). ** subst. reflexivity. ** destruct (eq_dim_dec k0 zero). --- rewrite not_exd_cA; try auto. apply cA_exd; auto. --- reflexivity. ++ destruct (eq_dim_dec k k0). -- destruct (eq_dart_dec x0 x). ** reflexivity. ** destruct (eq_dart_dec x0 z). --- subst. reflexivity. --- destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. +++ rewrite H2. reflexivity. +++ rewrite H2. apply cA_cA_1; auto. -- destruct (eq_dim_dec k k0). ** destruct (eq_dart_dec x0 x). --- reflexivity. --- destruct (eq_dart_dec x0 z). +++ subst. unfold cA. rewrite not_exd_cA; try auto. apply cA_exd; auto. +++ destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. ++++ rewrite H2. reflexivity. ++++ rewrite H2. apply cA_cA_1; auto. ** simpl. destruct (eq_dart_dec x0 x); try reflexivity. destruct (eq_dart_dec x0 z); try reflexivity. destruct (eq_dart_dec (cA_1 (B m0 k0 x) k z) z0); try reflexivity. destruct (eq_dim_dec k0 zero); try reflexivity. destruct (eq_dart_dec x0 z0); try reflexivity. destruct (eq_dart_dec (cA_1 m0 zero z0) z); try reflexivity. apply cA_cA_1; auto.", "succ": true}]