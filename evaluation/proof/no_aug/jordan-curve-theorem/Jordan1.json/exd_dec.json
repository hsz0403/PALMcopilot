[{"history": {"proof": "intros m x. induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH]. - right. intros H. inversion H. - destruct (eq_dart_dec x d) as [Eq|Neq]. + left. left. sfirstorder depth: 3. + destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx]. * sfirstorder depth: 3. * sfirstorder depth: 3. * destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx]. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * apply Z_rec. apply Z_rec. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. * apply Z_rec. apply Z_rec. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. -- sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. - sfirstorder depth: 3.", "repairs": ["", "", "", "", "", "", "", "", "", "", "", "hammer", "", "ref_not_found", "", "hammer", "", "hammer", "wrong_bullet", "ref_not_found", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "wrong_bullet", "hammer", "wrong_bullet", "hammer", "", "ref_not_found", "ref_not_found", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "unfinished_bullet", "hammer", "", "ref_not_found", "ref_not_found", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+"], "tactic": "destruct (IH Neq) as [Ex|NEx].", "exn": "The reference IH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*"], "tactic": "destruct (IH x) as [Ex|NEx].", "exn": "The reference IH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx]."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "apply NEx.", "exn": "The reference NEx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "shelve.", "*", "apply Z_rec."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "shelve.", "*", "apply Z_rec.", "apply Z_rec."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "shelve.", "*", "apply Z_rec.", "apply Z_rec.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply NEx.", "exn": "The reference NEx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "shelve.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*", "shelve.", "*", "shelve.", "*", "destruct (Ring_polynom.mk_monpol_list x) as [Ex|NEx].", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "shelve.", "*", "apply Z_rec.", "apply Z_rec.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply Z_rec."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros m x. induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH]. - right. intros H. inversion H. - destruct (eq_dart_dec x d) as [Eq|Neq]. + left. left. apply Eq. + destruct (IH Neq) as [Ex|NEx]. * left. right. apply Ex. * right. intros [H|H]. ++ apply Neq. inversion H. reflexivity. ++ apply NEx. apply H. - destruct (IH x) as [Ex|NEx]. + left. right. apply Ex. + right. intros [H|H]. * apply NEx. apply H. * apply NEx. apply H.", "succ": true}]