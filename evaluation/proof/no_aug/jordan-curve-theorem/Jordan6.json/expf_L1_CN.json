[{"history": {"proof": "intros m x y z t H1 H2 H3 H4 H5 H6 H7. hauto use: expf_L1_I_CN, expf_L1_II_CN inv: sumbool.", "repairs": ["", "hammer"], "exceptions": []}, "chat": [], "original": "intros m x y z t H1 H2 H3 H4 H5 H6 H7. unfold L, cA, cA_1, cF. case (expf_dec m x (cA m zero y)). - intros H8. assert (H10: cA m zero y = cA m zero y) by auto. rewrite <- H10 in H8. apply expf_L1_II_CN with (z := z) (t := t) in H1. + apply H1; auto. + apply H2. - intros H8. assert (H10: cA m zero y <> cA m zero y) by (intro H11; apply H8; symmetry; assumption). apply expf_not_orbit_x with (m:=m) (y0:=cA m zero y) in H2; auto. + case (expf_dec m z t). * intros H20. right; left; auto. * intros H20. case (expf_dec m z x). -- intros H21. left; right; split; [assumption | apply between_expf_L0 with (m := m) (x := x) (y := cA_1 m one x) (z := z) (t := t) in H1; assumption]. -- intros H21. case (expf_dec m x (cA m zero (cA m one x))). ++ intros H22. assert (H30: expf m x (cA m zero y)). { apply expf_trans with (y := cA m zero y); auto. } left; left; split. ** apply H30. ** apply expf_not_orbit_x with (m := m) (x := x) (y0 := cA m zero y) in H1; auto. ++ intros H22. right; left; split. ** apply betweenf_symm; auto. ** apply betweenf_symm; auto. + intros H9. apply H8; symmetry; auto.", "succ": true}]