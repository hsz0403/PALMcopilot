[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "shelve.", "-", "subst."], "tactic": "apply H11.", "exn": "The reference H11 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "shelve.", "-", "subst."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "shelve.", "-", "subst.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t. unfold not. intros Hexp_B_not_z_t. unfold expf in Hexp_B_not_z_t. unfold expf. unfold B. destruct m eqn:Em. - simpl in Hexp_B_not_z_t. contradiction. - simpl in Hexp_B_not_z_t. simpl. destruct (eq_dim_dec d zero). + destruct (eq_dart_dec d0 x). * subst. unfold not in not_exp_z_t. destruct other_exps as [H1 | H2]. { destruct H1 as [H11 H12]. unfold not in H12. apply H12 in Hexp_B_not_z_t. contradiction. } { destruct H2 as [H21 H22]. unfold not in H22. apply H22 in Hexp_B_not_z_t. contradiction. } * unfold not in not_exp_z_t. destruct other_exps as [H1 | H2]. { destruct H1 as [H11 H12]. destruct (eq_dart_dec d1 z). - subst. apply H11. - apply H12. split; auto. } { destruct H2 as [H21 H22]. destruct (eq_dart_dec d1 t). - subst. apply H21. - apply H22. split; auto. } + assert (Hmap' : inv_hmap f). { apply Hmap. } assert (Hplanar' : planar f). { apply Hplanar. } assert (Hsucc_y' : succ f zero d1). { apply Hsucc_y. } assert (Hexp_B : MF.expo (L (B f zero d) d d d1) x0 x). { apply other_exps. left. split; auto. } assert (Hexp_B_not_z_t' : MF.expo (L (B f zero d) d d d1) z t). { apply Hexp_B_not_z_t. } apply other_faces_in_cut_B0 with (m:=f) (x:=d) (z:=z) (t:=t) in Hmap'. apply Hmap'. all: auto.", "succ": false}]