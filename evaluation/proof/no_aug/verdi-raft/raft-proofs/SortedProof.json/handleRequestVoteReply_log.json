[{"history": {"proof": "intros h st src t vg st' H. srun best use: @handleRequestVoteReply_same_log unfold: name.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*"], "tactic": "destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:vote.", "exn": "The reference voteGranted was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "inversion H.", "simpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "inversion H.", "simpl.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "inversion H.", "simpl.", "shelve.", "-", "inversion H."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "inversion H.", "simpl.", "shelve.", "-", "inversion H.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros h st src t vg st' H. unfold handleRequestVoteReply in H. unfold log. destruct (currentTerm st <? t) eqn:currentTermLt. - destruct (currentTerm st <? t) eqn:currentTermLt'. + inversion H. + destruct (t <? currentTerm st) eqn:termLtcurrentTerm. * inversion H. * destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:vote. { inversion H. simpl. reflexivity. } { destruct (type st) eqn:typeSt. + inversion H. + reflexivity. + reflexivity. } - destruct (t <? currentTerm st) eqn:termLtcurrentTerm. + inversion H. + destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:vote. * inversion H. simpl. reflexivity. * destruct (type st) eqn:typeSt. ++ inversion H. ++ reflexivity. ++ reflexivity.", "succ": true}]