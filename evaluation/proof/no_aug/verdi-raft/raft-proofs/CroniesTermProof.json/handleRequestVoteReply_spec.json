[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-"], "tactic": "apply currentTerm_lte in H1 as H1'.", "exn": "The reference currentTerm_lte was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "apply ltb_true_lt in H1 as H1'.", "left."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "apply ltb_true_lt in H1 as H1'.", "left.", "shelve.", "-", "destruct (t <? currentTerm st).", "+", "right.", "split.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "apply ltb_true_lt in H1 as H1'.", "left.", "shelve.", "-", "destruct (t <? currentTerm st).", "+", "right.", "split.", "*", "shelve.", "*", "destruct (type st) eqn:H2."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "apply ltb_true_lt in H1 as H1'.", "left.", "shelve.", "-", "destruct (t <? currentTerm st).", "+", "right.", "split.", "*", "shelve.", "*", "destruct (type st) eqn:H2.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "+"], "tactic": "destruct (voteGranted && wonElection (dedup name_eq_dec (h' :: votesReceived st))) eqn:H2.", "exn": "The reference voteGranted was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros h st h' t v st' H. unfold handleRequestVoteReply in H. destruct (currentTerm st <? t) eqn:H1. - apply currentTerm_lte in H1 as H1'. left. apply H1'. - destruct (t <? currentTerm st). + right. split. * apply currentTerm_lte in Heqb as H2. apply H2. * unfold type in H. destruct (type st) eqn:H2. { simpl. reflexivity. } { simpl. rewrite H. auto. } + destruct (voteGranted && wonElection (dedup name_eq_dec (h' :: votesReceived st))) eqn:H2. * destruct (type st) eqn:H3. { simpl. reflexivity. } { simpl. rewrite H. auto. } { simpl. rewrite H. auto. }", "succ": false}]