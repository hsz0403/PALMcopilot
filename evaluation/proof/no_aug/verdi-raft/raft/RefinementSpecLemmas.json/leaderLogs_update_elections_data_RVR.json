[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "exn": "The reference voteGranted was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "shelve.", "*", "inversion H1."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "shelve.", "*", "inversion H1.", "shelve.", "*", "inversion H1.", "destruct (type (snd st)) eqn:H8."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "+", "shelve.", "+", "shelve.", "-", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "shelve.", "*", "inversion H1.", "shelve.", "*", "inversion H1.", "destruct (type (snd st)) eqn:H8.", "--", "shelve.", "--", "shelve.", "--", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros h src t1 v st t2 ll st' H1 H2. unfold handleRequestVoteReply in H1. destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|]. destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|]. destruct (type (snd st)) eqn:H5. - inversion H1; subst. right. split; try reflexivity. split; [reflexivity|]. split; [reflexivity|]. apply eq_nat_dec. - inversion H1; subst. right. split; try reflexivity. split; [reflexivity|]. split; [reflexivity|]. apply eq_nat_dec. - destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6. + destruct (type (snd st)) eqn:H7. * inversion H1; subst. left. apply H2. * inversion H1. * inversion H1. + destruct (type (snd st)) eqn:H8. * inversion H1. * inversion H1. * inversion H1.", "succ": false}]