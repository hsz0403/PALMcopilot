[{"history": {"proof": "intros d m0 m1 m2 H1 H2. unfold lemd in *. destruct H1 as [H1_1 [H1_2 H1_3]]. destruct H2 as [H2_1 [H2_2 H2_3]]. split. + sfirstorder depth: 3use: map_or_def_ok_d, borne_1_2, map_or_def_ok, lem_domain_equal. + srun best use: lem_transitive unfold: r_transitive.", "repairs": ["", "", "", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros d m0 m1 m2 H1 H2. unfold lemd in *. destruct H1 as [H1_1 [H1_2 H1_3]]. destruct H2 as [H2_1 [H2_2 H2_3]]. split. + split. - apply (borne_1_2 m0 m1). * intros Hin. apply (borne_1_2 m1 m2). ++ intros Hin'. apply (map_or_def_ok_d d m1 m2 H1_2 H2_2). ++ intros Hin''. apply (borne_1_2 m0 m1). ** apply H1_1. ** apply H2_1. ** apply Hin. * intros Hin'. apply (borne_1_2 m0 m1). ++ apply H1_1. ++ apply H2_1. ++ apply Hin'. - apply (map_or_def_ok m0 m1). apply (lem_domain_equal m0 m1 H1_3). + apply (map_or_def_ok_d d m0 m2). * apply H1_2. * apply H2_2.", "succ": true}]