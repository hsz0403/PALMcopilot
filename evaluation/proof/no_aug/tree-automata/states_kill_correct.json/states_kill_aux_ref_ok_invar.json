[{"history": {"proof": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. hauto use: st_kill_2, prec_list_kill_ref_ok_invar.", "repairs": ["", "", "", "", "hammer"], "exceptions": [{"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-"], "tactic": ["destruct p as [a' p'].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+"], "tactic": "destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1.", "exn": "The reference s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+"], "tactic": "apply IHs.", "exn": "The reference IHs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'')."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+"], "tactic": "intros a'' p'' H4.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+"], "tactic": "apply H1 with (a:=a'').", "exn": "The reference a'' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+", "shelve.", "+"], "tactic": "destruct (states_kill_aux (dta_non_empty_states d) s1) eqn:E2.", "exn": "The reference s1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*"], "tactic": "destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1.", "exn": "The reference s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1."], "tactic": "apply IHs0.", "exn": "The reference IHs0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply positive_ind.", "intros a'' p'' H4."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply positive_ind.", "intros a'' p'' H4.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply IHs1.", "++"], "tactic": "apply IHs0.", "exn": "The reference IHs0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+", "apply IHs2.", "++", "intros a'' p'' H4.", "apply H1 with (a:=a'').", "shelve.", "++", "shelve.", "+", "shelve.", "+", "destruct (states_kill_aux (dta_non_empty_states d) s1_2) eqn:E2.", "*", "apply IHs1.", "apply positive_ind.", "intros a'' p'' H4.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply IHs1.", "++", "apply pl_path_ind.", "intros a'' p'' H4.", "apply H1 with (a:=a'')."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. unfold states_kill_aux. induction s. - simpl. auto. - destruct p as [a' p']. destruct (prec_list_kill (dta_non_empty_states d) p') eqn:E. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. - destruct s1. + destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. + destruct (states_kill_aux (dta_non_empty_states d) s1) eqn:E2. * destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). * apply IHs1. ++ apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2.", "succ": true}]