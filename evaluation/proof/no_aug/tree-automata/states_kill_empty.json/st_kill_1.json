[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+"], "tactic": "destruct (prec_list_kill m p) eqn: eq2.", "exn": "The reference p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+"], "tactic": "destruct (prec_list_kill m p0) eqn: eq3.", "exn": "The reference p0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "rewrite eq2.", "exn": "The reference eq2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "rewrite eq3.", "exn": "The reference eq3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros s m a p p' H1 H2. unfold prec_list_kill in H1. destruct p. - destruct (MapGet bool m a) eqn: eq1. + destruct (prec_list_kill m p) eqn: eq2. * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. subst. clear H1. inversion H2. inversion H1. subst. clear H2. exists (states_kill m s). split. - unfold states_kill. destruct (states_kill_aux m s). inversion H1. inversion H1. + simpl. rewrite eq2. rewrite eq3. reflexivity. + reflexivity. - unfold MapGet. rewrite <- H2. rewrite eq1. reflexivity. } { inversion H1. inversion H1. inversion H1. } * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. inversion H1. } { inversion H1. subst. apply H2. } + discriminate H1. - destruct (MapGet bool m a) eqn: eq1. + destruct (prec_list_kill m p) eqn: eq2. * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. subst. clear H1. inversion H2. inversion H1. subst. clear H2. exists (states_kill m s). split. - unfold states_kill. destruct (states_kill_aux m s). inversion H1. inversion H1. + simpl. rewrite eq2. rewrite eq3. reflexivity. + reflexivity. - unfold MapGet. rewrite <- H2. rewrite eq1. reflexivity. } { inversion H1. inversion H1. inversion H1. } * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. inversion H1. } { inversion H1. subst. apply H2. } + discriminate H1.", "succ": false}]