[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-"], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-"], "tactic": "apply leb_transitive with b; auto.", "exn": "The reference b was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros p m0 m1 H. unfold leb, pl_non_empty in *. destruct p; try auto. destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto). + destruct (MapGet bool m0 a) eqn:E0. - apply orb_incr. * apply andb_inc_l. apply leb_transitive with b. { apply andb_incr. apply leb_reflexive. apply leb_antisymmetric with b0. } { apply leb_transitive with b1. ++ apply (lem_get_leb _ _ a b0 b1 H E0 E). ++ apply leb_transitive with (mlattice bool m0 b1). -- apply lem_domain_equal with m0; auto. -- apply lem_domain_equal with m1; auto. } * apply leb_transitive with (mlattice bool m1 b). { apply lem_domain_equal with m1; auto. } { apply andb_incr; auto. } - apply orb_incr. * apply andb_inc_r. apply leb_transitive with (mlattice bool m0 b1); auto. apply lem_domain_equal with m0; auto. * apply leb_transitive with b; auto. + destruct (MapGet bool m0 a) eqn:E0. - apply andb_inc_l. apply leb_transitive with b. * apply leb_transitive with (mlattice bool m0 b1). { apply lem_get_leb with a b0 b1; auto. } { apply lem_domain_equal with m0; auto. } * apply leb_transitive with b; auto. - apply leb_transitive with b; auto.", "succ": false}]