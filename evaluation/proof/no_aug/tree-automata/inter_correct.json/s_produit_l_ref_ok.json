[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "shelve.", "*", "shelve.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros s a p d0 d1 H0 H1. unfold state_ref_ok in *. intros H2 H3. unfold s_produit_l. destruct s. - simpl in *. auto. - destruct a0. + simpl in *. destruct (a =? N0)%N eqn:E. * apply Nat.eqb_eq in E. subst. simpl. rewrite sproductl_0_def with (s := M1 prec_list a p) (a := N0) (p := p) (c := N0) (r0 := pl_produit a1 p) (r1 := M0 prec_list); auto. rewrite H2. reflexivity. * apply Nat.eqb_neq in E. simpl. rewrite E. apply H2. + destruct (a =? N.pos p~1)%N eqn:E. * apply Nat.eqb_eq in E. subst. simpl. reflexivity. * apply Nat.eqb_neq in E. simpl. apply H2. + destruct (a =? N.pos p~0)%N eqn:E. * apply Nat.eqb_eq in E. subst. simpl. reflexivity. * apply Nat.eqb_neq in E. simpl. apply H2. + simpl. apply H2.", "succ": false}]