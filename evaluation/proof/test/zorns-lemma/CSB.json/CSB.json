[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "exists (fun _ => match eq_O_or_S x with | inl _ => fst (P x) | inr _ => snd (P x) end).", "exn": "The reference eq_O_or_S was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "exists (fun _ => match eq_O_or_S x with | inl _ => fst (P x) | inr _ => snd (P x) end). red in |- *. split. unfold injective in |- *. intros. elim (axs_sum X (fun x : X => (Y * Y) * (Y * Y)) P x). intros. elim H0. intros. elim H1. intros. elim H2. intros. elim H3. intros. elim H4. intros. elim H5. intros. elim H6. intros. cut (x0 = x1). intro. rewrite H7. auto. apply (H x0 x1 (x2, x3) (x4, x5)). auto. auto. unfold surjective in |- *. intros. elim (axs_sum Y (fun z : Y => exists x : X, z = match eq_O_or_S x with | inl _ => fst (P x) | inr _ => snd (P x) end) Q y). intros. elim H0. intros. elim H1. intros. elim (axs_comprehension (fun x : X => (Y * Y) * (Y * Y)) (reunion (reunion (reunion (reunion (fun x : X => Im_z x (fun t : T => P x t)) (fun x : X => Im_z x (fun t : T => Q x t)))))) P x0). intros. elim H3. intros. elim H4. intros. clear H3 H4. elim H2. intros. clear H2. elim H0. intros. elim H0. intros. clear H0. cut (exd (c_end X Y T) x1). intro. cut (x1 = snd (P x0)). intro. cut (exd (c_end X Y T) x2). intro. cut (x2 = fst (P x0)). intros. cut (exd (c_end X Y T) x3). intro. cut (x3 = snd (Q y)). intro. cut (exd (c_end X Y T) x4). intro. cut (x4 = fst (Q y)). intros. exists (couple x1 x2). split. unfold couple in |- *. simpl in |- *. rewrite <- H7. rewrite <- H9. rewrite <- H11. rewrite <- H13. rewrite <- H15. rewrite <- H17. rewrite <- H18. apply (prf_is_cd1 y x3 x4 x0). auto. auto. auto. auto. auto. auto. unfold couple in |- *. simpl in |- *. rewrite <- H7. rewrite <- H9. rewrite <- H11. rewrite <- H13. rewrite <- H15. rewrite <- H17. rewrite <- H18. apply (prf_is_cd2 x0 x1 x2 y). auto. auto. auto. auto. auto. auto. apply (exd_c_end X Y T x0). apply (exd_c_end X Y T x0). apply (exd_c_end X Y T y). case x0. simpl in |- *. intros. rewrite <- H11. trivial. simpl in |- *. intros. rewrite <- H11. trivial. case x0. simpl in |- *. intros. rewrite <- H10. trivial. simpl in |- *. intros. rewrite <- H10. trivial. case x0. simpl in |- *. intros. rewrite <- H9. trivial. simpl in |- *. intros. rewrite <- H9. trivial. case x0. simpl in |- *. intros. rewrite <- H8. trivial. simpl in |- *. intros. rewrite <- H8. trivial. case x0. simpl in |- *. intro. cut (exd (c_end X Y T) x1). intro. cut (x1 = fst (P x0)). intro. cut (exd (c_end X Y T) x2). intro. cut (x2 = snd (P x0)). intros. cut (exd (c_end X Y T) x3). intro. cut (x3 = fst (Q y)). intro. cut (exd (c_end X Y T) x4). intro. cut (x4 = snd (Q y)). intros. exists (couple x3 x4). split. unfold couple in |- *. simpl in |- *. rewrite <- H13. rewrite <- H15. rewrite <- H17. rewrite <- H19. rewrite <- H20. apply (prf_is_cd3 y x1 x2 x0). auto. auto. auto. auto. auto. unfold couple in |- *. simpl in |- *. rewrite <- H13. rewrite <- H15. rewrite <- H17. rewrite <- H19. rewrite <- H20. apply (prf_is_cd4 x0 x3 x4 y). auto. auto. auto. auto. auto. apply (exd_c_end X Y T x0). apply (exd_c_end X Y T y). case x0. simpl in |- *. intros. rewrite <- H11. trivial. simpl in |- *. intros. rewrite <- H11. trivial. case x0. simpl in |- *. intros. rewrite <- H10. trivial. simpl in |- *. intros. rewrite <- H10. trivial. case x0. simpl in |- *. intros. rewrite <- H9. trivial. simpl in |- *. intros. rewrite <- H9. trivial. case x0. simpl in |- *. intros. rewrite <- H8. trivial. simpl in |- *.", "hammer_times": 1, "succ": false}]