[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "assert (forall a:partial_injection, In (image_partial_injection_set S) a -> exists y : partial_injection, In S y /\\ forall z : partial_injection, In S z -> (forall x:nat, le (proj1_sig (y x)) (proj1_sig (z x)) \\/ proj1_sig (y x) = proj1_sig (z x)) -> (forall x:nat, le (proj1_sig (a x)) (proj1_sig (y x)))).", "exn": "The reference image_partial_injection_set was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros. assert (forall a:partial_injection, In (image_partial_injection_set S) a -> exists y : partial_injection, In S y /\\ forall z : partial_injection, In S z -> (forall x:nat, le (proj1_sig (y x)) (proj1_sig (z x)) \\/ proj1_sig (y x) = proj1_sig (z x)) -> (forall x:nat, le (proj1_sig (a x)) (proj1_sig (y x)))). intros. apply dependent_choice_nat with (P:=fun (i:nat) (x:partial_injection) (y:partial_injection) => In S y /\\ (forall z:partial_injection, In S z -> (forall w:nat, le (proj1_sig (y w)) (proj1_sig (z w)) \\/ proj1_sig (y w) = proj1_sig (z w)) -> (forall w:nat, le (proj1_sig (x w)) (proj1_sig (y w))))). intros. destruct (classic (forall z:partial_injection, In S z -> (forall w:nat, le (proj1_sig (y w)) (proj1_sig (z w)) \\/ proj1_sig (y w) = proj1_sig (z w)) -> (forall w:nat, le (proj1_sig (x w)) (proj1_sig (y w))))); auto. elim (not_all_ex_not _ _ H0). intros. elim H1. intros. assert (In (image_partial_injection_set S) x0). apply in_image_set_elt_in_set; trivial. apply (chain_relation _ H y x0); trivial. assert (exists y0 : partial_injection, In S y0 /\\ (forall z : partial_injection, In S z -> (forall w : nat, le (proj1_sig (y0 w)) (proj1_sig (z w)) \\/ proj1_sig (y0 w) = proj1_sig (z w)) -> (forall w : nat, le (proj1_sig (x w)) (proj1_sig (y0 w))))). apply H2; trivial. destruct H4. destruct H4. assert (forall z:partial_injection, In S z -> (forall w:nat, le (proj1_sig x1 w) (proj1_sig (z w)) \\/ proj1_sig x1 w = proj1_sig (z w)) -> (forall w:nat, le (proj1_sig x w) (proj1_sig x1 w))). intros. destruct (classic (forall w:nat, le (proj1_sig x w) (proj1_sig x1 w))); auto. elim (not_all_ex_not _ _ H6). intros. assert (le (proj1_sig x1 a) (proj1_sig x a) \\/ proj1_sig x1 a = proj1_sig x a). apply (H4 x0). auto. destruct H9. elim (le_not_gt _ _ H9). auto. assert (injective x1). unfold injective. intros. destruct x. destruct y. destruct (classic (x <= n)). destruct (classic (x <= n0)). assert (x = n). apply le_antisym; trivial. rewrite <- H8. rewrite <- H9. apply H7; trivial. assert (n = n0). apply le_antisym; auto. rewrite H10. trivial. assert (n = n0). apply le_antisym; auto. assert (x = n0). apply le_antisym; trivial. rewrite H11. rewrite <- H12. apply H7; trivial. assert (In (image_partial_injection_set S) x1). apply in_image_set_elt_in_set; trivial. destruct H7. elim (lt_not_le _ _ H7). apply (proj2 (constructive_definite_description _ H5)). destruct (constructive_definite_description _ H5). exists x1. destruct x1. destruct H7. split. auto. intros. apply le_n.", "hammer_times": 2, "succ": false}]