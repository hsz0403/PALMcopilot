[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "exists (fun k => match k with 1 => 0 | 2*k => S (double k) | Pos.succ (2*k) => double k end). intros. rewrite code_correct. destruct (dec_eq_pos n m); intuition; try congruence. + rewrite <- (code_double_pos (S (n/2) - 1)). apply code_inj; simpl. rewrite (div_2_succ_1 n); auto. + rewrite <- (code_double_pos (m/2 - 1)). apply code_inj; simpl. rewrite (div_2_succ_1 m); auto. apply f_equal2 with (f := Pos.add); auto. + revert H0. assert (m/2 + (m/2 + 0) = m/2 + (n/2 + 1)). replace (m/2) with (n/2) by congruence. ring. intros. destruct (mod_2_cases m); destruct (mod_2_cases n); auto; try congruence. * elimtype False. rewrite <- (div_2_fix m) in H2; rewrite <- H2 in H1. destruct (mod_2_cases m); auto; try congruence. * replace m with (m/2 + m/2) in H2 by ring. replace n with (n/2 + n/2) by ring. rewrite H2 in H1. elimtype False. destruct (mod_2_cases m); auto; try congruence. * elimtype False. rewrite <- (div_2_fix n) in H2; rewrite <- H2 in H1. destruct (mod_2_cases n); auto; try congruence. * replace n with (n/2 + n/2) in H2 by ring. replace m with (m/2 + m/2) by ring. rewrite H2 in H1. elimtype False. destruct (mod_2_cases n); auto; try congruence.", "hammer_times": 1, "succ": false}, {"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "exists (fun k => match k with 1 => 0 | 2*k => S (double k) | Pos.succ (2*k) => double k end). intros. rewrite code_correct. destruct (dec_eq_pos n m); intuition; try congruence. + rewrite <- (code_double_pos (S (n/2) - 1)). apply code_inj; simpl. rewrite (div_2_succ_1 n); auto. + rewrite <- (code_double_pos (m/2 - 1)). apply code_inj; simpl. rewrite (div_2_succ_1 m); auto. apply f_equal2 with (f := Pos.add); auto. + revert H0. assert (m/2 + (m/2 + 0) = m/2 + (n/2 + 1)). replace (m/2) with (n/2) by congruence. ring. intros. destruct (mod_2_cases m); destruct (mod_2_cases n); auto; try congruence. * elimtype False. rewrite <- (div_2_fix m) in H2; rewrite <- H2 in H1. destruct (mod_2_cases m); auto; try congruence. * replace m with (m/2 + m/2) in H2 by ring. replace n with (n/2 + n/2) by ring. rewrite H2 in H1. elimtype False. destruct (mod_2_cases m); auto; try congruence. * elimtype False. rewrite <- (div_2_fix n) in H2; rewrite <- H2 in H1. destruct (mod_2_cases n); auto; try congruence. * replace n with (n/2 + n/2) in H2 by ring. replace m with (m/2 + m/2) by ring. rewrite H2 in H1. elimtype False. destruct (mod_2_cases n); auto; try congruence.", "hammer_times": 1, "succ": false}]