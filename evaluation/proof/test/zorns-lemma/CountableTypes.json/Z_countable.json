[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "exists (fun k => match k with | Zneg n => 2*(INR n) | Zpos n => S (2*(INR n)) end).", "exn": "The reference INR was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": [], "tactic": "destruct x as [|p|p]; destruct y as [|q|q]; simpl; try tauto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": [], "tactic": "rewrite <- INR_IPR.", "exn": "The reference INR_IPR was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": [], "tactic": "assert (n + n = n + n) by auto.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "exists (fun k => match k with | Zneg n => 2*(INR n) | Zpos n => S (2*(INR n)) end). intros. destruct x as [|p|p]; destruct y as [|q|q]; simpl; try tauto. * rewrite <- INR_IPR. assert (n + n = n + n) by auto. abstract omega. * rewrite <- INR_IPR. assert (n + n = n + n) by auto. abstract omega. * clear H. rewrite <- INR_IPR. assert (p + p = q + q) by (apply Pos.add_reg_l; trivial). clear H. apply INR_eq in H1. rewrite <- (Pos2Nat.inj_sub p q) in H1; try (apply Pos.le_sub_le; trivial). rewrite Pos2Nat.inj_add in H1. assert (2 * INR (Pos.sub p q) = 2 * INR (Pos.sub p q)) by auto. abstract omega. Defined.", "hammer_times": 2, "succ": false}]