[{"history": {"proof": "intros Phi Psi. unfold Lindenbaum_constructable. intros. apply Lindenbaum_constructable_suffice with (P := context_sepcon_included_l Phi (proj1_sig Psi)) (cP := cP); auto. - shelve. - shelve. - shelve.", "repairs": ["", "", "", "", "", "", "", "", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nSigma: SeparationEmpLanguage.PropositionalVariables\nCV: Countable SeparationEmpLanguage.Var\nSLP: SL_Parameter\n\nGoal:\nforall (Phi : context) (Psi : {x : context | cP x}), Lindenbaum_constructable (context_sepcon_included_l Phi (proj1_sig Psi)) cP\n\nPremises:\nLindenbaum_constructable = fun (A : Type) (P cP : Ensemble A -> Prop) => forall Phi : Ensemble A, P Phi -> exists Psi : {x : Ensemble A | cP x}, Included A Phi (proj1_sig Psi) /\\ P (proj1_sig Psi) : forall A : Type, (Ensemble A -> Prop) -> (Ensemble A -> Prop) -> Prop Argument A is implicit and maximally inserted Argument scopes are [type_scope function_scope function_scope]\ncontext = fun L : Language => expr -> Prop : Language -> Type Argument L is implicit and maximally inserted\nproj1_sig : forall (A : Type) (P : A -> Prop), {x : A | P x} -> A\ncP = Intersection context (Intersection context derivable_closed orp_witnessed) consistent : context -> Prop\ncontext_sepcon_included_l = fun (L : Language) (sepconL : SepconLanguage L) (GammaD : Derivable L) (Phi2 Psi Phi1 : context) => Included expr (context_sepcon Phi1 Phi2) Psi : forall L : Language, SepconLanguage L -> Derivable L -> context -> context -> context -> Prop Arguments L, sepconL, GammaD are implicit and maximally inserted\nModule SeparationEmpLanguage := Struct Record PropositionalVariables : Type := Build_PropositionalVariables { Var : Type } Definition Var : PropositionalVariables -> Type. Inductive expr (Sigma : PropositionalVariables) : Type := andp : expr Sigma -> expr Sigma -> expr Sigma | orp : expr Sigma -> expr Sigma -> expr Sigma | impp : expr Sigma -> expr Sigma -> expr Sigma | sepcon : expr Sigma -> expr Sigma -> expr Sigma | wand : expr Sigma -> expr Sigma -> expr Sigma | emp : expr Sigma | falsep : expr Sigma | varp : Var -> expr Sigma Definition expr_rect : forall (Sigma : PropositionalVariables) (P : expr Sigma -> Type), (forall e : expr Sigma, P e -> forall e0 : expr Sigma, P e0 -> P (andp e e0)) -> (forall e : expr Sigma, P e -> forall e0 : expr Sigma, P e0 -> P (orp e e0)) -> (forall e : expr Sigma,\nCountable = fun A : Type => injection A nat : Type -> Type Argument scope is [type_scope]\ntruth_lemma_sepcon : forall (cP : context -> Prop) (rel : bijection (Kworlds ?M) {x : context | cP x}), (forall (m1 m2 m : Kworlds ?M) (Phi1 Phi2 Phi : {x : context | cP x}), rel m1 Phi1 -> rel m2 Phi2 -> rel m Phi -> join m1 m2 m <-> Included expr (context_sepcon (proj1_sig Phi1) (proj1_sig Phi2)) (proj1_sig Phi)) -> at_least derivable_closed cP -> (forall (Phi : context) (Psi : {x : context | cP x}), Lindenbaum_constructable (context_sepcon_included_l Phi (proj1_sig Psi)) cP) ->...-> proj1_sig Phi (x * y) where ?M : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Kmodel]\next_canonical_residual : forall (cP : context -> Prop) (rel : bijection (Kworlds ?M) {x : context | cP x}), (forall (m n : Kworlds ?M) (Phi Psi : {x : context | cP x}), rel m Phi -> rel n Psi -> m <= n <-> Included expr (proj1_sig Phi) (proj1_sig Psi)) -> (forall (m1 m2 m : Kworlds ?M) (Phi1 Phi2 Phi : {x : context | cP x}), rel m1 Phi1 -> rel m2 Phi2 -> rel m Phi -> join m1 m2 m <-> Included expr (context_sepcon (proj1_sig Phi1) (proj1_sig Phi2)) (proj1_sig Phi)) -> ExtSeparationLogic SeparationEmpLanguage.L (ParametricSeparationLogic.GP SLP) ->...-> ResidualSeparationAlgebra (Kworlds ?M) where ?M : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Kmodel]\ntruth_lemma_emp : forall (cP : context -> Prop) (rel : bijection (Kworlds ?M) {x : context | cP x}), (forall (m n : Kworlds ?M) (Phi Psi : {x : context | cP x}), rel m Phi -> rel n Psi -> m <= n <-> Included expr (proj1_sig Phi) (proj1_sig Psi)) -> (forall (m1 m2 m : Kworlds ?M) (Phi1 Phi2 Phi : {x : context | cP x}), rel m1 Phi1 -> rel m2 Phi2 -> rel m Phi -> join m1 m2 m <-> Included expr (context_sepcon (proj1_sig Phi1) (proj1_sig Phi2)) (proj1_sig Phi)) ->...-> proj1_sig Phi emp where ?M : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Kmodel]\ntruth_lemma_wand : forall (cP : context -> Prop) (rel : bijection (Kworlds ?M) {x : context | cP x}), (forall (m1 m2 m : Kworlds ?M) (Phi1 Phi2 Phi : {x : context | cP x}), rel m1 Phi1 -> rel m2 Phi2 -> rel m Phi -> join m1 m2 m <-> Included expr (context_sepcon (proj1_sig Phi1) (proj1_sig Phi2)) (proj1_sig Phi)) -> at_least derivable_closed cP -> (forall x : expr, Lindenbaum_constructable (cannot_derive x) cP) -> (forall (Phi : context) (Psi : {x : context | cP x}), Lindenbaum_constructable (context_sepcon_included_r Phi (proj1_sig Psi)) cP) ->...-> proj1_sig Phi (x -* y) where ?M : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Kmodel]\ntruth_lemma_impp : forall (cP : context -> Prop) (rel : bijection (Kworlds ?M) {x : context | cP x}), (forall (m n : Kworlds ?M) (Phi Psi : {x : context | cP x}), rel m Phi -> rel n Psi -> m <= n <-> Included expr (proj1_sig Phi) (proj1_sig Psi)) -> at_least derivable_closed cP -> (forall x : expr, Lindenbaum_constructable (cannot_derive x) cP) -> forall x y : expr, (forall (m : Kworlds ?M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: ?M, m |= x <-> proj1_sig Phi x) ->...-> proj1_sig Phi (x --> y) where ?M : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Kmodel]\nLindenbaum_constructable_suffice : forall P cP : Ensemble ?A -> Prop, Countable ?A -> Lindenbaum_preserves P -> Lindenbaum_ensures P cP -> Lindenbaum_constructable P cP where ?A : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Type]\nproj2_sig : forall (A : Type) (P : A -> Prop) (e : {x : A | P x}), P (proj1_sig e)\nAxiomatization2SequentCalculus_bSC = fun (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (AX : NormalAxiomatization L GammaP GammaD) (minAX : MinimumAxiomatization L GammaP) => let DW : TheoryOfSequentCalculus.DeductionWeaken L GammaD := fun (Phi Psi : context) (x : expr) (H : Included expr Phi Psi) (H0 : Phi |-- x) => (fun lemma : Psi |-- x <-> (exists xs : list expr, Forall (fun x0 : expr => Psi x0) xs /\\ |-- multi_imp xs x) => iff_flip_impl_subrelation (Psi |-- x) (exists xs : list expr, Forall (fun x0 : expr => Psi x0) xs /\\ |-- multi_imp xs x) lemma) (derivable_provable Psi x) match (fun lemma : Phi |-- x <-> (exists xs : list expr, Forall (fun x0 : expr => Phi x0) xs...\norp_witnessed = fun (L : Language) (pL : PropositionalLanguage L) (Phi : context) => forall x y : expr, Phi (x || y) -> Phi x \\/ Phi y : forall L : Language, PropositionalLanguage L -> context -> Prop Arguments L, pL are implicit and maximally inserted\nderivable_closed = fun (L : Language) (Gamma : Derivable L) (Phi : context) => forall x : expr, Phi |-- x -> Phi x : forall L : Language, Derivable L -> context -> Prop Arguments L, Gamma are implicit and maximally inserted\ncontext_sepcon = fun (L : Language) (sepconL : SepconLanguage L) (GammaD : Derivable L) (Phi Psi : context) (z : expr) => exists x y : expr, z = x * y /\\ Phi |-- x /\\ Psi |-- y : forall L : Language, SepconLanguage L -> Derivable L -> context -> context -> context Arguments L, sepconL, GammaD are implicit and maximally inserted\nRecord IntuitionisticPropositionalSequentCalculus (L : Language) (pL : PropositionalLanguage L) (Gamma : Derivable L) : Prop := Build_IntuitionisticPropositionalSequentCalculus { deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y; deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x; deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y; deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x ->...-> Phi |-- x } For IntuitionisticPropositionalSequentCalculus: Argument pL is implicit and maximally inserted For Build_IntuitionisticPropositionalSequentCalculus: Argument scopes are [_ _ _ function_scope function_scope function_scope function_scope function_scope function_scope function_scope]\nconsistent = fun (L : Language) (Gamma : Derivable L) (Phi : context) => exists x : expr, ~ Phi |-- x : forall L : Language, Derivable L -> context -> Prop Arguments L, Gamma are implicit and maximally inserted\ncannot_derive = fun (L : Language) (Gamma : Derivable L) (x : expr) (Phi : context) => ~ Phi |-- x : forall L : Language, Derivable L -> expr -> context -> Prop Arguments L, Gamma are implicit and maximally inserted\nRewriteClass.derivable_proper_impp = fun (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (SC : NormalSequentCalculus L GammaP GammaD) (bSC : BasicSequentCalculus L GammaD) (minSC : MinimumSequentCalculus L GammaD) (Phi Phi' : context) (H : Phi = Phi') => eq_ind Phi (fun Phi'0 : context => ((fun x y : expr => |-- impp x y) ==> Basics.impl)%signature (derivable Phi) (derivable Phi'0)) (fun (x1 x2 : expr) (H0 : |-- x1 --> x2) (H1 : Phi |-- x1) => let H2 : Phi |-- x1 --> x2 := deduction_weaken0 Phi (x1 --> x2) H0 in deduction_modus_ponens Phi x1 x2 H1 H2) Phi' H : forall (L : Language) (minL : MinimumLanguage L) (GammaP :...\nat_least = fun (L : Language) (P cP : context -> Prop) => forall Phi : context, cP Phi -> P Phi : forall L : Language, (context -> Prop) -> (context -> Prop) -> Prop Argument L is implicit and maximally inserted Argument scopes are [_ function_scope function_scope]\nAxiomatization2SequentCalculus_ipSC = fun (L : Language) (minL : MinimumLanguage L) (pL : PropositionalLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (AX : NormalAxiomatization L GammaP GammaD) (minAX : MinimumAxiomatization L GammaP) (ipGamma : IntuitionisticPropositionalLogic L GammaP) => let H : NormalSequentCalculus L GammaP GammaD := Axiomatization2SequentCalculus_SC in let H0 : BasicSequentCalculus L GammaD := Axiomatization2SequentCalculus_bSC in let H1 : MinimumSequentCalculus L GammaD := Axiomatization2SequentCalculus_minSC in {| deduction_andp_intros := fun (Phi : context) (x y : expr) (H2 : Phi |-- x) (H3 : Phi |-- y) => deduction_modus_ponens Phi y (x && y) H3 (deduction_modus_ponens Phi x (y...\nRewriteClass.derivable_proper_iffp = fun (L : Language) (minL : MinimumLanguage L) (pL : PropositionalLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (SC : NormalSequentCalculus L GammaP GammaD) (bSC : BasicSequentCalculus L GammaD) (minSC : MinimumSequentCalculus L GammaD) (ipSC : IntuitionisticPropositionalSequentCalculus L GammaD) (Phi Phi' : context) (H : Phi = Phi') => eq_ind Phi (fun Phi'0 : context => ((fun x y : expr => |-- x <--> y) ==> iff)%signature (derivable Phi) (derivable Phi'0)) (fun (x1 x2 : expr) (H0 : |-- x1 <--> x2) => let H1 : Phi |-- x1 <--> x2 := deduction_weaken0 Phi (x1 <--> x2) H0 in let H2 : Phi |-- x1 --> x2 := deduction_andp_elim1 Phi...\nRecord BasicSequentCalculus (L : Language) (Gamma : Derivable L) : Prop := Build_BasicSequentCalculus { deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x; derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x; deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y } For Build_BasicSequentCalculus: Argument scopes are [_ _ function_scope function_scope function_scope]\nAxiomatization2SequentCalculus_minSC = fun (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (AX : NormalAxiomatization L GammaP GammaD) (minAX : MinimumAxiomatization L GammaP) => {| deduction_modus_ponens := fun (Phi : context) (x y : expr) (H : Phi |-- x) (H0 : Phi |-- x --> y) => (fun lemma : Phi |-- y <-> (exists xs : list expr, Forall (fun x0 : expr => Phi x0) xs /\\ |-- multi_imp xs y) => iff_flip_impl_subrelation (Phi |-- y) (exists xs : list expr, Forall (fun x0 : expr => Phi x0) xs /\\ |-- multi_imp xs y) lemma) (derivable_provable Phi y) match (fun lemma : Phi |-- x <-> (exists xs : list expr, Forall (fun x0 : expr => Phi x0) xs /\\ |-- multi_imp xs x) => iff...\ncontext_sepcon_included_equiv : forall Phi Psi : context, derivable_closed Psi -> Same_set context (context_sepcon_included_l Phi Psi) (context_sepcon_included_r Phi Psi)\nAxiomatization2SequentCalculus_fwSC = fun (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (AX : NormalAxiomatization L GammaP GammaD) => {| derivable_finite_witnessed := fun (Phi : context) (y : expr) (H : Phi |-- y) => match (fun lemma : Phi |-- y <-> (exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\ |-- multi_imp xs y) => iff_impl_subrelation (Phi |-- y) (exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\ |-- multi_imp xs y) lemma) (derivable_provable Phi y) H with | ex_intro _ xs (conj H1 H2) => ex_intro (fun xs0 : list expr => Forall Phi xs0 /\\ (fun x : expr => In x xs0) |-- y) xs (conj H1 ((fun lemma : (fun x : expr => In x xs) |-- y...\nnCountable_Countable : (forall n : nat, Countable (?A n)) -> Countable {x : nat & ?A x} where ?A : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- nat -> Type]\nRecord MinimumSequentCalculus (L : Language) (minL : MinimumLanguage L) (Gamma : Derivable L) : Prop := Build_MinimumSequentCalculus { deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x - -> y -> Phi |-- y; deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x - -> y } For MinimumSequentCalculus: Argument minL is implicit and maximally inserted For Build_MinimumSequentCalculus: Argument scopes are [_ _ _ function_scope function_scope]\ndeduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x - -> y -> Phi |-- y\nderivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\ (fun x : expr => In x xs) |-- y\nRecord FiniteWitnessedSequentCalculus (L : Language) (Gamma : Derivable L) : Prop := Build_FiniteWitnessedSequentCalculus { derivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\ (fun x : expr => In x xs) |-- y } For Build_FiniteWitnessedSequentCalculus: Argument scopes are [_ _ function_scope]\nwand_deduction_theorem : forall (Phi : context) (x y : expr), context_sepcon Phi (empty_context;; x) |-- y < -> Phi |-- x -* y\nRecord NormalAxiomatization (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) : Prop := Build_NormalAxiomatization { derivable_provable : forall (Phi : context) (y : expr), Phi |-- y < -> (exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\ |-- multi_imp xs y) } For NormalAxiomatization: Argument minL is implicit and maximally inserted For Build_NormalAxiomatization: Argument scopes are [_ _ _ _ function_scope]\nsepcon_ext : forall x : expr, |-- x - -> x * TT where ?L : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Language] ?minL : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- MinimumLanguage ?L] ?pL : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- PropositionalLanguage ?L] ?sepconL : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- SepconLanguage ?L] ?Gamma : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Provable ?L] ?ExtSeparationLogic : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- ExtSeparationLogic ?L ?Gamma]\nLIN_CD : forall x : expr, Lindenbaum_constructable (cannot_derive x) cP\ndeduction_theorem : forall (Phi : context) (x y : expr), Phi;; x |-- y < -> Phi |-- x - -> y\nLindenbaum_ensures = fun (A : Type) (P cP : Ensemble A -> Prop) => forall (CA : Countable A) (init : Ensemble A), P init -> cP (LindenbaumConstruction CA init P) : forall A : Type, (Ensemble A -> Prop) -> (Ensemble A -> Prop) -> Prop Argument A is implicit and maximally inserted Argument scopes are [type_scope function_scope function_scope]\nLindenbaum_included : forall (CA : Countable ?A) (init : Ensemble ?A) (P : Ensemble ?A -> Prop), Included ?A init (LindenbaumConstruction CA init P) where ?A : [Sigma : SeparationEmpLanguage.PropositionalVariables CV : Countable SeparationEmpLanguage.Var SLP : SL_Parameter |- Type]\nSeparationEmpLanguage.formula_countable = fun (Sigma : SeparationEmpLanguage.PropositionalVariables) (X : Countable SeparationEmpLanguage.Var) => let X0 := fun n : nat => nat_rect (fun n0 : nat => Countable {x : SeparationEmpLanguage.expr Sigma | (SeparationEmpLanguage.rank x <= n0)%nat}) (bijection_Countable (bijection_sym (FBuild_bijection (SeparationEmpLanguage.Var + unit + unit) {x : SeparationEmpLanguage.expr Sigma | (SeparationEmpLanguage.rank x <= 0)%nat} (fun x : SeparationEmpLanguage.Var + unit + unit => match x with | inl (inl p) => exist (fun x0 : SeparationEmpLanguage.expr Sigma => (SeparationEmpLanguage.rank x0 <= 0)%nat) (SeparationEmpLanguage.varp p) (le_n 0) | inl (inr _) => exist (fun x0 : SeparationEmpLanguage.expr Sigma => (SeparationEmpLanguage.rank x0 <= 0)%nat) SeparationEmp...\nLindenbaum_context_sepcon_included_l_ensures_derivable_closed : forall Phi Psi : context, Lindenbaum_ensures (context_sepcon_included_l Phi Psi) derivable_closed\nexist : forall (A : Type) (P : A -> Prop) (x : A), P x -> {x : A | P x}\nLindenbaum_context_sepcon_included_l_ensures_consistent : forall Phi Psi : context, consistent Psi -> Lindenbaum_ensures (context_sepcon_included_l Phi Psi) consistent\nLindenbaum_context_sepcon_included_l_ensures_orp_witnessed : forall Phi Psi : context, derivable_closed Psi -> orp_witnessed Psi -> Lindenbaum_ensures (context_sepcon_included_l Phi Psi) orp_witnessed\nat_least_right : forall (P : context -> Prop) (cP1 : Ensemble context) (cP2 : context -> Prop), at_least P cP2 -> at_least P (Intersection context cP1 cP2)"}, {"role": "assistant", "content": "```coq\nintros Phi Psi.\nunfold Lindenbaum_constructable.\nintros.\napply Lindenbaum_constructable_suffice with (P := context_sepcon_included_l Phi (proj1_sig Psi)) (cP := cP); auto.\nQed.\n```"}], "original": "intros Phi Psi. unfold Lindenbaum_constructable. intros. apply Lindenbaum_constructable_suffice with (P := context_sepcon_included_l Phi (proj1_sig Psi)) (cP := cP); auto.", "succ": false}]