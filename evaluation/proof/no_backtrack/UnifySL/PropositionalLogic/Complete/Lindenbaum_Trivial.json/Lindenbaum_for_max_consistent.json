[{"history": {"proof": "intros P H1 H2 H3 H4. intros. split. - apply H3. apply MCS_andp_iff. + split. ++ apply MCS_andp_iff. ** shelve. ** shelve. ** shelve. ** shelve. ++ apply MCS_andp_iff. * shelve. * shelve. * shelve. * intros x y Hxy. apply MCS_andp_iff. -- shelve. -- shelve. -- shelve. -- shelve. + shelve. + shelve. + shelve. - shelve.", "repairs": ["", "no_product", "", "", "", "ref_not_found", "", "", "", "ref_not_found", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "", "ref_not_found", "", "unfinished_bullet", "wrong_bullet", "unfinished_bullet", "wrong_bullet", "unfinished_bullet", "wrong_bullet", "", "ref_not_found", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], "exceptions": [{"ctx": ["intros P H1 H2 H3 H4."], "tactic": "intros CA init Hinit.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-"], "tactic": "intros Phi HPhi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-"], "tactic": "apply H4.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"Countable expr\" with \"consistent (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-"], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3."], "tactic": "intros Psi HPsi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3."], "tactic": "apply HPhi.", "exn": "The reference HPhi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff."], "tactic": "apply Ensembles_ext.left_Included_Union.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"forall x : ?A, Ensembles.In ?A ?M2402 x -> Ensembles.In ?A (Union ?A ?M2402 ?M2403) x\" with \"consistent (fun _ : expr => P init) /\\\\ (forall Psi : context, consistent Psi -> Included expr (fun _ : expr => P init) Psi -> Included expr Psi (fun _ : expr => P init))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+"], "tactic": "intros Psi Hmax Psi_incl.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+"], "tactic": "apply Ensembles_ext.Included_trans with (Union expr Phi Psi).", "exn": "The reference Psi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+"], "tactic": "apply Ensembles_ext.Union_Included.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"(Included ?A (Union ?A ?M2402 ?M2403) ?M2404 -> Included ?A ?M2402 ?M2404 /\\\\ Included ?A ?M2403 ?M2404) /\\\\ (Included ?A ?M2402 ?M2404 /\\\\ Included ?A ?M2403 ?M2404 -> Included ?A (Union ?A ?M2402 ?M2403) ?M2404)\" with \"consistent (fun _ : expr => P init) /\\\\ (forall Psi : context, consistent Psi -> Included expr (fun _ : expr => P init) Psi -> Included expr Psi (fun _ : expr => P init))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++"], "tactic": "apply Hmax.", "exn": "The reference Hmax was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff."], "tactic": "apply Ensembles_ext.left_Included_Union.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"forall x : ?A, Ensembles.In ?A ?M2429 x -> Ensembles.In ?A (Union ?A ?M2429 ?M2430) x\" with \"consistent (fun _ : expr => consistent (fun _ : expr => P init)) /\\\\ (forall Psi : context, consistent Psi -> Included expr (fun _ : expr => consistent (fun _ : expr => P init)) Psi -> Included expr Psi (fun _ : expr => consistent (fun _ : expr => P init)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "apply Hmax.", "exn": "The reference Hmax was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff."], "tactic": "apply Ensembles_ext.right_Included_Union.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"forall x : ?A, Ensembles.In ?A ?M2457 x -> Ensembles.In ?A (Union ?A ?M2456 ?M2457) x\" with \"consistent (fun _ : expr => forall Psi : context, consistent Psi -> Included expr (fun _ : expr => P init) Psi -> Included expr Psi (fun _ : expr => P init)) /\\\\ (forall Psi : context, consistent Psi -> Included expr (fun _ : expr => forall Psi0 : context, consistent Psi0 -> Included expr (fun _ : expr => P init) Psi0 -> Included expr Psi0 (fun _ : expr => P init)) Psi -> Included expr Psi (fun _ : expr => forall Psi0 : context, consistent Psi0 -> Included expr (fun _ : expr => P init) Psi0 -> Included expr Psi0 (fun _ : expr => P init)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*"], "tactic": "intros Hmax Phi HPhi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "intros x y Hxy.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "apply HPhi.", "exn": "The reference HPhi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"Lindenbaum_ensures P orp_witnessed\" with \"expr\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "intros x y Hxy."], "tactic": "apply HPhi.", "exn": "The reference HPhi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "intros x y Hxy.", "apply MCS_andp_iff."], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init x : context y : consistent x Hxy : Included expr (fun _ : expr => P init) x Unable to unify \"Lindenbaum_ensures P orp_witnessed\" with \"maximal consistent (fun _ : expr => Included expr x (fun _ : expr => P init))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "apply H3.", "apply MCS_andp_iff.", "+", "split.", "++", "apply MCS_andp_iff.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "apply MCS_andp_iff.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "intros x y Hxy.", "apply MCS_andp_iff."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nL: Language\nminL: MinimumLanguage L\npL: PropositionalLanguage L\nGammaP: Provable L\nGammaD: Derivable L\nSC: NormalSequentCalculus L GammaP GammaD\nbSC: BasicSequentCalculus L GammaD\nfwSC: FiniteWitnessedSequentCalculus L GammaD\nminSC: MinimumSequentCalculus L GammaD\nipSC: IntuitionisticPropositionalSequentCalculus L GammaD\ncpSC: ClassicalPropositionalSequentCalculus L GammaD\nminAX: MinimumAxiomatization L GammaP\nipAX: IntuitionisticPropositionalLogic L GammaP\n\nGoal:\nforall P : Ensemble expr -> Prop, Lindenbaum_ensures P derivable_closed -> Lindenbaum_ensures P orp_witnessed -> Lindenbaum_ensures P consistent -> Lindenbaum_ensures P (maximal consistent)\n\nPremises:\nMinimumAxiomatization : forall L : Language, MinimumLanguage L -> Provable L -> Prop\norp_witnessed = fun (L : Language) (pL : PropositionalLanguage L) (Phi : context) => forall x y : expr, Phi (x || y) -> Phi x \\/ Phi y : forall L : Language, PropositionalLanguage L -> context -> Prop Arguments L, pL are implicit and maximally inserted\nRecord Derivable (L : Language) : Type := Build_Derivable { derivable : context -> expr -> Prop } For Build_Derivable: Argument scopes are [_ function_scope]\nFiniteWitnessedSequentCalculus : forall L : Language, Derivable L -> Prop\nMinimumSequentCalculus : forall L : Language, MinimumLanguage L -> Derivable L -> Prop\nRecord MinimumLanguage (L : Language) : Type := Build_MinimumLanguage { impp : expr -> expr -> expr } For Build_MinimumLanguage: Argument scopes are [_ function_scope]\nconsistent = fun (L : Language) (Gamma : Derivable L) (Phi : context) => exists x : expr, ~ Phi |-- x : forall L : Language, Derivable L -> context -> Prop Arguments L, Gamma are implicit and maximally inserted\nIntuitionisticPropositionalSequentCalculus : forall L : Language, PropositionalLanguage L -> Derivable L -> Prop\nIntuitionisticPropositionalLogic : forall (L : Language) (minL : MinimumLanguage L), PropositionalLanguage L -> forall Gamma : Provable L, MinimumAxiomatization L Gamma -> Prop\nderivable_closed = fun (L : Language) (Gamma : Derivable L) (Phi : context) => forall x : expr, Phi |-- x -> Phi x : forall L : Language, Derivable L -> context -> Prop Arguments L, Gamma are implicit and maximally inserted\nexpr = fun Language0 : Language => let (expr) := Language0 in expr : Language -> Type Argument Language is implicit and maximally inserted\nLindenbaum_ensures = fun (A : Type) (P cP : Ensemble A -> Prop) => forall (CA : Countable A) (init : Ensemble A), P init -> cP (LindenbaumConstruction CA init P) : forall A : Type, (Ensemble A -> Prop) -> (Ensemble A -> Prop) -> Prop Argument A is implicit and maximally inserted Argument scopes are [type_scope function_scope function_scope]\nNormalSequentCalculus : forall L : Language, Provable L -> Derivable L -> Prop\nRecord PropositionalLanguage (L : Language) : Type := Build_PropositionalLanguage { andp : expr -> expr -> expr; orp : expr -> expr -> expr; falsep : expr } For Build_PropositionalLanguage: Argument scopes are [_ function_scope function_scope _]\nClassicalPropositionalSequentCalculus : forall (L : Language) (minL : MinimumLanguage L) (pL : PropositionalLanguage L) (Gamma : Derivable L), BasicSequentCalculus L Gamma -> MinimumSequentCalculus L Gamma -> IntuitionisticPropositionalSequentCalculus L Gamma -> Prop\nEnsemble = fun U : Type => U -> Prop : Type -> Type Argument scope is [type_scope]\nRecord Provable (L : Language) : Type := Build_Provable { provable : expr -> Prop } For Build_Provable: Argument scopes are [_ function_scope]\nmaximal = fun (L : Language) (P : context -> Prop) (Phi : context) => P Phi /\\ (forall Psi : context, P Psi -> Included expr Phi Psi -> Included expr Psi Phi) : forall L : Language, (context -> Prop) -> context -> Prop Argument L is implicit and maximally inserted Argument scopes are [_ function_scope _]\nBasicSequentCalculus : forall L : Language, Derivable L -> Prop\nLindenbaum_ensures_by_conjunct : forall P cP1 cP2 : Ensemble ?A -> Prop, Lindenbaum_ensures P cP1 -> Lindenbaum_ensures P cP2 -> Lindenbaum_ensures P (Intersection (Ensemble ?A) cP1 cP2) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nLindenbaum_for_orp_witnessed : forall P : Ensemble expr -> Prop, Lindenbaum_preserves P -> subset_preserved P -> context_orp_captured P -> Lindenbaum_ensures P derivable_closed -> Lindenbaum_ensures P orp_witnessed\nLindenbaum_constructable_suffice : forall P cP : Ensemble ?A -> Prop, Countable ?A -> Lindenbaum_preserves P -> Lindenbaum_ensures P cP -> Lindenbaum_constructable P cP where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nLindenbaum_for_consistent : forall P : Ensemble expr -> Prop, Lindenbaum_preserves P -> at_least consistent P -> Lindenbaum_ensures P consistent\nLindenbaum_for_derivable_closed : forall P : Ensemble expr -> Prop, Lindenbaum_preserves P -> derivable_subset_preserved P -> Lindenbaum_ensures P derivable_closed\nLindenbaum_preserves_by_finiteness : forall P : Ensemble ?A -> Prop, finite_captured P -> subset_preserved P -> Lindenbaum_preserves P where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nnot_finite_witnessed_finite_captured : forall P : Ensemble ?A -> Prop, finite_witnessed P -> finite_captured (fun X : Ensemble ?A => ~ P X) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nsubset_preserved_same_set_preserved : forall P : Ensemble ?A -> Prop, subset_preserved P -> Morphisms.Proper (Morphisms.respectful (Same_set ?A) iff) P where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nLindenbaum_pointwise_finite_decided' : forall (CA : Countable ?A) (init : Ensemble ?A) (P : Ensemble ?A -> Prop), P init -> forall (a : ?A) (n : nat), CA a n -> Morphisms.Proper (Morphisms.respectful (Same_set ?A) iff) P ->...-> LindenbaumConstruction CA init P a where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nEnsembles_ext.Included_trans : forall P Q R : Ensemble ?A, Included ?A P Q -> Included ?A Q R -> Included ?A P R where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nLindenbaum_pointwise_finite_decided : forall (CA : Countable ?A) (init : Ensemble ?A) (P : Ensemble ?A -> Prop) (a : ?A) (n : nat), CA a n -> LindenbaumChain CA init P (S n) a < -> LindenbaumConstruction CA init P a where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nEnsembles_ext.left_Included_Union : forall P Q : Ensemble ?A, Included ?A P (Union ?A P Q) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nEnsembles_ext.Union_Included : forall P Q R : Ensemble ?A, Included ?A (Union ?A P Q) R < -> Included ?A P R /\\ Included ?A Q R where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nEnsembles_ext.right_Included_Union : forall P Q : Ensemble ?A, Included ?A Q (Union ?A P Q) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nLindenbaum_included_n_omega : forall (CA : Countable ?A) (init : Ensemble ?A) (P : Ensemble ?A -> Prop) (n : nat), Included ?A (LindenbaumChain CA init P n) (LindenbaumConstruction CA init P) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nLindenbaum_cannot_derive_ensures_consistent : forall x : expr, Lindenbaum_ensures (cannot_derive x) consistent where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L Gamma...\nProofTheoryPatterns.prodp_mono : forall x1 y1 x2 y2 : expr, |-- x1 - -> x2 -> |-- y1 - -> y2 -> |-- ?prodp x1 y1 - ->...-> expr] ?Monotonicity : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nLindenbaum_cannot_derive_ensures_orp_witnessed : forall x : expr, Lindenbaum_ensures (cannot_derive x) orp_witnessed where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC :...\nProofTheoryPatterns.prodp_iffp : forall x1 x2 y1 y2 : expr, |-- x1 <- -> x2 -> |-- y1 <- -> y2 -> |-- ?prodp x1 y1 <- ->...-> expr] ?Mono : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nProofTheoryPatterns.fold_left_iffp : forall (x1 x2 : expr) (xs1 xs2 : list expr), Forall2 (fun x3 x4 : expr => |-- x3 <--> x4) xs1 xs2 -> |-- x1 <- -> x2 -> |-- fold_left ?prodp xs1 x1 <- ->...-> expr] ?Mono : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nProofTheoryPatterns.Build_RightUnit' : (forall x : expr, |-- ?prodp x ?e <--> x) ->...-> expr]\ncontext_orp_captured = fun (L : Language) (pL : PropositionalLanguage L) (GammaD : Derivable L) (P : context -> Prop) => forall Phi Psi : context, P (context_orp Phi Psi) -> P Phi \\/ P Psi : forall L : Language, PropositionalLanguage L -> Derivable L -> (context -> Prop) -> Prop Arguments L, pL, GammaD are implicit and maximally inserted Argument scopes are [_ _ _ function_scope]\nProofTheoryPatterns.prodp_comm_impp : forall x y : expr, |-- ?prodp x y - ->...-> expr] ?Commutativity : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Commutativity ?L ?Gamma ?prodp]\nProofTheoryPatterns.prodp_assoc2 : forall x y z : expr, |-- ?prodp (?prodp x y) z - ->...-> expr] ?Associativity : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Associativity ?L ?Gamma ?prodp]\nProofTheoryPatterns.prodp_assoc1 : forall x y z : expr, |-- ?prodp x (?prodp y z) - ->...-> expr] ?Associativity : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Associativity ?L ?Gamma ?prodp]\nProofTheoryPatterns.left_unit1 : forall x : expr, |-- ?prodp ?e x - ->...-> expr] ?LeftUnit : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftUnit ?L ?Gamma ?e ?prodp]\nProofTheoryPatterns.left_unit2 : forall x : expr, |-- x - ->...-> expr] ?LeftUnit : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftUnit ?L ?Gamma ?e ?prodp]\nProofTheoryPatterns.assoc_fold_left_Permutation : forall (x : expr) (ys1 ys2 : list expr), Permutation.Permutation ys1 ys2 -> |-- fold_left ?prodp ys1 x <--> fold_left ?prodp ys2 x where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD...\nderivable_closed_union_derivable : forall (Phi Psi : context) (x : expr), derivable_closed Psi -> Union expr Phi Psi |-- x -> exists y : expr, Psi y /\\ Phi |-- y --> x where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus...\nProofTheoryPatterns.prodp_comm : forall x y : expr, |-- ?prodp x y <- ->...-> expr] ?Comm : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Commutativity ?L ?Gamma ?prodp]\nProofTheoryPatterns.prodp_assoc : forall x y z : expr, |-- ?prodp x (?prodp y z) <- ->...-> expr] ?Assoc : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Associativity ?L ?Gamma ?prodp]\nProofTheoryPatterns.left_unit : forall x : expr, |-- ?prodp ?e x <--> x where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSe...\nProofTheoryPatterns.assoc_fold_right_fold_left : forall xs : list expr, |-- fold_right ?prodp ?e xs --> fold_left ?prodp xs ?e where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSe...\nProofTheoryPatterns.assoc_fold_left_fold_right : forall xs : list expr, |-- fold_left ?prodp xs ?e --> fold_right ?prodp ?e xs where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSe...\nProofTheoryPatterns.fold_left_prodp_unfold : forall xs : list expr, |-- fold_left ?prodp xs ?e <--> match xs with | nil => ?e | x :: xs0 => fold_left ?prodp xs0 x end where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC...\nProofTheoryPatterns.assoc_fold_left_fold_right_equiv : forall xs : list expr, |-- fold_left ?prodp xs ?e <--> fold_right ?prodp ?e xs where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC :...\nProofTheoryPatterns.fold_right_prodp_unfold : forall xs : list expr, |-- fold_right ?prodp ?e xs <--> (fix f (xs0 : list expr) : expr := match xs0 with | nil => ?e | x :: nil => x | x :: (_ :: _) as xs1 => ?prodp x (f xs1) end) xs where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L :...\nLindenbaum_included : forall (CA : Countable ?A) (init : Ensemble ?A) (P : Ensemble ?A -> Prop), Included ?A init (LindenbaumConstruction CA init P) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nProofTheoryPatterns.Build_Associativity' : (forall x y z : expr, |-- ?prodp (?prodp x y) z <--> ?prodp x (?prodp y z)) -> ProofTheoryPatterns.Associativity L GammaP ?prodp where ?prodp : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- expr -> expr -> expr]\nderivable_subset_preserved = fun (L : Language) (Gamma : Derivable L) (P : context -> Prop) => forall Phi Psi : context, Included expr (derivable Phi) (derivable Psi) -> P Psi -> P Phi : forall L : Language, Derivable L -> (context -> Prop) -> Prop Arguments L, Gamma are implicit and maximally inserted Argument scopes are [_ _ function_scope]"}, {"role": "assistant", "content": "```coq\nintros P H1 H2 H3 H4. unfold Lindenbaum_ensures. intros CA init Hinit.\nsplit.\n- intros Phi HPhi. apply H4. unfold maximal. split.\n  + apply H3. intros Psi HPsi. apply HPhi. apply Ensembles_ext.left_Included_Union. assumption.\n  + intros Psi Hmax Psi_incl. apply Ensembles_ext.Included_trans with (Union expr Phi Psi).\n    * apply Ensembles_ext.Union_Included. split.\n      ++ apply Hmax. apply Ensembles_ext.left_Included_Union.\n      ++ apply Hmax. apply Ensembles_ext.right_Included_Union.\n    * assumption.\n- intros Hmax Phi HPhi. apply H1. apply H2.\n  + intros x y Hxy. apply HPhi. apply H2. left. assumption.\n  + intros x y Hxy. apply HPhi. apply H2. right. assumption.\nQed.\n```"}], "original": "intros P H1 H2 H3 H4. unfold Lindenbaum_ensures. intros CA init Hinit. split. - intros Phi HPhi. apply H4. unfold maximal. split. + apply H3. intros Psi HPsi. apply HPhi. apply Ensembles_ext.left_Included_Union. auto. + intros Psi Hmax Psi_incl. apply Ensembles_ext.Included_trans with (Union expr Phi Psi). * apply Ensembles_ext.Union_Included. split. ++ apply Hmax. apply Ensembles_ext.left_Included_Union. ++ apply Hmax. apply Ensembles_ext.right_Included_Union. * auto. - intros Hmax Phi HPhi. apply H1. apply H2. + intros x y Hxy. apply HPhi. apply H2. left. auto. + intros x y Hxy. apply HPhi. apply H2. right. auto.", "succ": false}]