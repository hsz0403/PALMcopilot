[{"history": {"proof": "intros Phi Psi Phi' Psi' H1 H2 z. intros [x [y [H3 [H4 H5]]]]. exists x, y. split. - auto. - split. + apply (deduction_weaken _ _ _ H1) in H4. auto. + apply (deduction_weaken _ _ _ H2) in H5. auto.", "repairs": ["", "", "", "", "", "", "", "", "", "ref_not_found", "", "", "ref_not_found", ""], "exceptions": [{"ctx": ["intros Phi Psi Phi' Psi' H1 H2 z.", "intros [x [y [H3 [H4 H5]]]].", "exists x, y.", "split.", "-", "auto.", "-", "split.", "+"], "tactic": "apply (Included_trans _ _ _ H1) in H4.", "exn": "The reference Included_trans was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Psi Phi' Psi' H1 H2 z.", "intros [x [y [H3 [H4 H5]]]].", "exists x, y.", "split.", "-", "auto.", "-", "split.", "+", "apply (deduction_weaken _ _ _ H1) in H4."], "tactic": "apply derivable_mono in H4.", "exn": "Unable to find an instance for the variable Psi.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Phi Psi Phi' Psi' H1 H2 z.", "intros [x [y [H3 [H4 H5]]]].", "exists x, y.", "split.", "-", "auto.", "-", "split.", "+", "apply (deduction_weaken _ _ _ H1) in H4.", "auto.", "+"], "tactic": "apply (Included_trans _ _ _ H2) in H5.", "exn": "The reference Included_trans was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Psi Phi' Psi' H1 H2 z.", "intros [x [y [H3 [H4 H5]]]].", "exists x, y.", "split.", "-", "auto.", "-", "split.", "+", "apply (deduction_weaken _ _ _ H1) in H4.", "auto.", "+", "apply (deduction_weaken _ _ _ H2) in H5."], "tactic": "apply derivable_mono in H5.", "exn": "Unable to find an instance for the variable Psi.", "type": "no_instance_var", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nL: Language\nminL: MinimumLanguage L\npL: PropositionalLanguage L\nGammaP: Provable L\nGammaD: Derivable L\nSC: NormalSequentCalculus L GammaP GammaD\nbSC: BasicSequentCalculus L GammaD\nminSC: MinimumSequentCalculus L GammaD\nipSC: IntuitionisticPropositionalSequentCalculus L GammaD\nminAX: MinimumAxiomatization L GammaP\nipAX: IntuitionisticPropositionalLogic L GammaP\n\nGoal:\nforall Phi Psi Phi' Psi' : Ensemble expr, Included expr Phi Phi' -> Included expr Psi Psi' -> Included expr (context_orp Phi Psi) (context_orp Phi' Psi')\n\nPremises:\nIntuitionisticPropositionalSequentCalculus : forall L : Language, PropositionalLanguage L -> Derivable L -> Prop\ncontext_orp = fun (Phi Psi : context) (z : expr) => exists x y : expr, z = x || y /\\ Phi |-- x /\\ Psi |-- y : context -> context -> context\nMinimumAxiomatization : forall L : Language, MinimumLanguage L -> Provable L -> Prop\nNormalSequentCalculus : forall L : Language, Provable L -> Derivable L -> Prop\nRecord MinimumLanguage (L : Language) : Type := Build_MinimumLanguage { impp : expr -> expr -> expr } For Build_MinimumLanguage: Argument scopes are [_ function_scope]\nRecord Derivable (L : Language) : Type := Build_Derivable { derivable : context -> expr -> Prop } For Build_Derivable: Argument scopes are [_ function_scope]\nRecord PropositionalLanguage (L : Language) : Type := Build_PropositionalLanguage { andp : expr -> expr -> expr; orp : expr -> expr -> expr; falsep : expr } For Build_PropositionalLanguage: Argument scopes are [_ function_scope function_scope _]\nEnsemble = fun U : Type => U -> Prop : Type -> Type Argument scope is [type_scope]\nRecord Provable (L : Language) : Type := Build_Provable { provable : expr -> Prop } For Build_Provable: Argument scopes are [_ function_scope]\nIntuitionisticPropositionalLogic : forall (L : Language) (minL : MinimumLanguage L), PropositionalLanguage L -> forall Gamma : Provable L, MinimumAxiomatization L Gamma -> Prop\nMinimumSequentCalculus : forall L : Language, MinimumLanguage L -> Derivable L -> Prop\nexpr = fun Language0 : Language => let (expr) := Language0 in expr : Language -> Type Argument Language is implicit and maximally inserted\nIncluded : forall U : Type, Ensemble U -> Ensemble U -> Prop\nBasicSequentCalculus : forall L : Language, Derivable L -> Prop\ncontext_orp_mono : forall Phi Psi Phi' Psi' : context, Included expr (derivable Phi) (derivable Phi') -> Included expr (derivable Psi) (derivable Psi') -> Included expr (context_orp Phi Psi) (context_orp Phi' Psi')\nderivable_mono : forall Phi Psi : context, Included expr Phi Psi -> Included expr (derivable Phi) (derivable Psi)\nBuild_BasicSequentCalculus : forall (L : Language) (Gamma : Derivable L), (forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x) -> (forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x) -> (forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y) -> BasicSequentCalculus L Gamma\ncontext_orp_captured = fun P : context -> Prop => forall Phi Psi : context, P (context_orp Phi Psi) -> P Phi \\/ P Psi : (context -> Prop) -> Prop Argument scope is [function_scope]\nderivable_superset_preserved = fun (L : Language) (Gamma : Derivable L) (P : context -> Prop) => forall Phi Psi : context, Included expr (derivable Phi) (derivable Psi) -> P Phi -> P Psi : forall L : Language, Derivable L -> (context -> Prop) -> Prop Arguments L, Gamma are implicit and maximally inserted Argument scopes are [_ _ function_scope]\nderivable_subset_preserved = fun (L : Language) (Gamma : Derivable L) (P : context -> Prop) => forall Phi Psi : context, Included expr (derivable Phi) (derivable Psi) -> P Psi -> P Phi : forall L : Language, Derivable L -> (context -> Prop) -> Prop Arguments L, Gamma are implicit and maximally inserted Argument scopes are [_ _ function_scope]\nmaximal = fun (L : Language) (P : context -> Prop) (Phi : context) => P Phi /\\ (forall Psi : context, P Psi -> Included expr Phi Psi -> Included expr Psi Phi) : forall L : Language, (context -> Prop) -> context -> Prop Argument L is implicit and maximally inserted Argument scopes are [_ function_scope _]\nRewriteClass.derivable_proper_impp = fun (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (SC : NormalSequentCalculus L GammaP GammaD) (bSC : BasicSequentCalculus L GammaD) (minSC : MinimumSequentCalculus L GammaD) (Phi Phi' : context) (H : Phi = Phi') => eq_ind Phi (fun Phi'0 : context => Morphisms.respectful (fun x y : expr => |-- x --> y) Basics.impl (derivable Phi) (derivable Phi'0)) (fun (x1 x2 : expr) (H0 : |-- x1 --> x2) (H1 : Phi |-- x1) => let H2 : Phi |-- x1 --> x2 := deduction_weaken0 Phi (x1 --> x2) H0 in deduction_modus_ponens Phi x1 x2 H1 H2) Phi' H : forall (L : Language) (minL : MinimumLanguage L) (GammaP...\ndeduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x\nderivable_proper_iffp = fun (L : Language) (minL : MinimumLanguage L) (pL : PropositionalLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (SC : NormalSequentCalculus L GammaP GammaD) (bSC : BasicSequentCalculus L GammaD) (minSC : MinimumSequentCalculus L GammaD) (ipSC : IntuitionisticPropositionalSequentCalculus L GammaD) (Phi Phi' : context) (H : Phi = Phi') => eq_ind Phi (fun Phi'0 : context => Morphisms.respectful (fun x y : expr => |-- x <--> y) iff (derivable Phi) (derivable Phi'0)) (fun (x1 x2 : expr) (H0 : |-- x1 <--> x2) => let H1 : Phi |-- x1 <--> x2 := deduction_weaken0 Phi (x1 <--> x2) H0 in let H2 : Phi |-- x1 --> x2 := deduction_andp_elim1 Phi (...\nEnsemblesProperties.superset_preserved = fun (A : Type) (P : Ensemble A -> Prop) => forall Phi Psi : Ensemble A, Included A Phi Psi -> P Phi -> P Psi : forall A : Type, (Ensemble A -> Prop) -> Prop Argument A is implicit and maximally inserted Argument scopes are [type_scope function_scope]\nEnsemblesProperties.subset_preserved = fun (A : Type) (P : Ensemble A -> Prop) => forall Phi Psi : Ensemble A, Included A Phi Psi -> P Psi -> P Phi : forall A : Type, (Ensemble A -> Prop) -> Prop Argument A is implicit and maximally inserted Argument scopes are [type_scope function_scope]\nEnsembles_ext.Included_trans : forall P Q R : Ensemble ?A, Included ?A P Q -> Included ?A Q R -> Included ?A P R where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nAxiomatization2SequentCalculus_bSC = fun (L : Language) (minL : MinimumLanguage L) (GammaP : Provable L) (GammaD : Derivable L) (AX : NormalAxiomatization L GammaP GammaD) (minAX : MinimumAxiomatization L GammaP) => let DW : TheoryOfSequentCalculus.DeductionWeaken L GammaD := fun (Phi Psi : context) (x : expr) (H : Included expr Phi Psi) (H0 : Phi |-- x) => (fun lemma : Psi |-- x <-> (exists xs : list expr, Forall (fun x0 : expr => Psi x0) xs /\\ |-- multi_imp xs x) => Morphisms.iff_flip_impl_subrelation (Psi |-- x) (exists xs : list expr, Forall (fun x0 : expr => Psi x0) xs /\\ |-- multi_imp xs x) lemma) (derivable_provable Psi x) match (fun lemma : Phi |-- x <-> (exists xs : list expr, Forall (fun x0 : expr => Phi x...\nEnsembles_ext.Intersection1_Included : forall P Q R : Ensemble ?A, Included ?A P R -> Included ?A (Intersection ?A P Q) R where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nEnsembles_ext.Intersection2_Included : forall P Q R : Ensemble ?A, Included ?A Q R -> Included ?A (Intersection ?A P Q) R where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nEnsembles_ext.image_Included : forall (f : ?A -> ?B) (X Y : Ensemble ?A), Included ?A X Y -> Included ?B (Ensembles_ext.image_set X f) (Ensembles_ext.image_set Y f) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type] ?B : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : Int...\nEnsembles_ext.resp_Included : forall (X Y : Ensemble ?B) (f : ?A -> ?B), Included ?B X Y -> Included ?A (Ensembles_ext.respectful_set X f) (Ensembles_ext.respectful_set Y f) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type] ?B : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD...\nEnsembles_ext.right_Included_Union : forall P Q : Ensemble ?A, Included ?A Q (Union ?A P Q) where ?A : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Type]\nderivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\ (fun x : expr => In x xs) |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSe...\ndeduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y\nderivable_trans : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Psi |-- y -> Phi |-- y\nProofTheoryPatterns.prodp_mono1 : forall x1 x2 y : expr, |-- x1 - -> x2 -> |-- ?prodp x1 y - ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nProofTheoryPatterns.funcp_mono2 : forall x y1 y2 : expr, |-- y1 - -> y2 -> |-- ?funcp x y1 - ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nProofTheoryPatterns.funcp_mono : forall x1 y1 x2 y2 : expr, |-- x2 --> x1 -> |-- y1 --> y2 -> |-- ?funcp x1 y1 --> ?funcp x2 y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : Intuitionistic...\nProofTheoryPatterns.adjoint : forall x y z : expr, |-- ?prodp x y - -> z < -> |-- x - ->...-> expr] ?Adjointness : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nderivable_provable : forall (Phi : context) (y : expr), Phi |-- y <-> (exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\ |-- multi_imp xs y) where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositional...\nProofTheoryPatterns.right_distr2 : forall x y z : expr, |-- ?sump (?prodp y x) (?prodp z x) - ->...-> expr] ?RightDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.RightDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.left_distr2 : forall x y z : expr, |-- ?sump (?prodp x y) (?prodp x z) - ->...-> expr] ?LeftDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.left_distr1 : forall x y z : expr, |-- ?prodp x (?sump y z) - ->...-> expr] ?LeftDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.right_distr1 : forall x y z : expr, |-- ?prodp (?sump y z) x - ->...-> expr] ?RightDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.RightDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.prodp_mono : forall x1 y1 x2 y2 : expr, |-- x1 - -> x2 -> |-- y1 - -> y2 -> |-- ?prodp x1 y1 - ->...-> expr] ?Monotonicity : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nfalsep_prodp : forall x : expr, |-- ?prodp FF x <- ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nprodp_orp_distr_l : forall x y z : expr, |-- ?prodp (x || y) z <- ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nfuncp_andp_distr_r : forall x y z : expr, |-- ?funcp x (y && z) <- ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nprodp_sump_distr_r : forall x y z : expr, |-- ?prodp (?sump y z) x <- ->...-> expr] ?RDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.RightDistr ?L ?Gamma ?prodp ?sump]\nprodp_sump_distr_l : forall x y z : expr, |-- ?prodp x (?sump y z) <- ->...-> expr] ?LDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftDistr ?L ?Gamma ?prodp ?sump]\nprodp_falsep : forall x : expr, |-- ?prodp x FF <--> FF where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositional...\nProofTheoryPatterns.fold_left_mono : forall (x1 x2 : expr) (xs1 xs2 : list expr), Forall2 (fun x3 x4 : expr => |-- x3 --> x4) xs1 xs2 -> |-- x1 - -> x2 -> |-- fold_left ?prodp xs1 x1 - ->...-> expr] ?Mono : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nprodp_iffp : forall x1 x2 y1 y2 : expr, |-- x1 <- -> x2 -> |-- y1 <- -> y2 -> |-- ?prodp x1 y1 <- ->...-> expr] ?Mono : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]"}, {"role": "assistant", "content": "```coq\nintros Phi Psi Phi' Psi' H1 H2 z.\nintros [x [y [H3 [H4 H5]]]].\nexists x, y.\nsplit.\n- assumption.\n- split.\n  + apply (Included_trans _ _ _ H1) in H4. apply derivable_mono in H4. assumption.\n  + apply (Included_trans _ _ _ H2) in H5. apply derivable_mono in H5. assumption.\nQed.\n```  "}], "original": "intros Phi Psi Phi' Psi' H1 H2 z. intros [x [y [H3 [H4 H5]]]]. exists x, y. split. - auto. - split. + apply (Included_trans _ _ _ H1) in H4. apply derivable_mono in H4. auto. + apply (Included_trans _ _ _ H2) in H5. apply derivable_mono in H5. auto.", "succ": true}]