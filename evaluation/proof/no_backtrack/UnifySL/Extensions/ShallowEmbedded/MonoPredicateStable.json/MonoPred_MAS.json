[{"history": {"proof": "unfold MonoPred_L, MonoPred_Gamma, MonoPred_stable. shelve.", "repairs": ["", ""], "exceptions": [{"ctx": [], "tactic": "unfold ModalAbsorbStable.", "exn": "Cannot coerce ModalAbsorbStable to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["unfold MonoPred_L, MonoPred_Gamma, MonoPred_stable."], "tactic": "unfold Language, Propositional, Provable, ModalAbsorbStable in *.", "exn": "Cannot coerce Language to an evaluable reference.", "type": "not_evaluable", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nA: Type\nR1: KI.Relation A\npo_R1: PreOrder KI.Krelation\nR2: KM.Relation A\nR3: Relation A\nukmM: UpwardsClosedOrderedKripkeModel A\nR2_incl: Inclusion KM.Krelation Krelation\n\nGoal:\nModalAbsorbStable (MonoPred_L A) (MonoPred_Gamma A) (MonoPred_stable A)\n\nPremises:\nUpwardsClosedOrderedKripkeModel : forall worlds : Type, KI.Relation worlds -> KM.Relation worlds -> Prop\nMonoPred_stable : forall (A : Type) (R1 : KI.Relation A), PreOrder KI.Krelation -> Relation A -> expr -> Prop\nKrelation = fun (worlds : Type) (Relation : Relation worlds) => Relation : forall worlds : Type, Relation worlds -> worlds -> Ensemble worlds Arguments worlds, Relation are implicit and maximally inserted Argument scopes are [type_scope _ _]\nMonoPred_L : forall A : Type, KI.Relation A -> Language\nMonoPred_Gamma : forall (A : Type) (R : KI.Relation A), PreOrder KI.Krelation -> Provable (MonoPred_L A)\nInclusion = fun (A : Type) (R1 R2 : relation A) => forall a b : A, R1 a b -> R2 a b : forall A : Type, relation A -> relation A -> Prop Argument A is implicit and maximally inserted Argument scopes are [type_scope _ _]\nModalAbsorbStable : forall L : Language, MinimumLanguage L -> ModalLanguage L -> Provable L -> (expr -> Prop) -> Prop\nModule KM := Struct Definition Relation : Type -> Type. Definition Krelation : forall worlds : Type, Relation worlds -> worlds -> worlds -> Prop. End \nModule KI := Struct Definition Relation : Type -> Type. Definition Krelation : forall worlds : Type, Relation worlds -> worlds -> Ensemble worlds. End \nRecord PreOrder (A : Type) (R : relation A) : Prop := Build_PreOrder { PreOrder_Reflexive : Reflexive R; PreOrder_Transitive : Transitive R } For PreOrder: Argument A is implicit and maximally inserted For Build_PreOrder: Argument A is implicit and maximally inserted For PreOrder: Argument scopes are [type_scope _] For Build_PreOrder: Argument scopes are [type_scope _ _ _]\nRelation = fun worlds : Type => worlds -> Ensemble worlds : Type -> Type Argument scope is [type_scope]\nMonoPred_mstable = fun (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : KM.Relation A) (R3 : Relation A) (ukmM : UpwardsClosedOrderedKripkeModel A) (R2_bis : Bisimulation Krelation KM.Krelation) => {| boxp_stable := fun x : expr => Sound_KripkeIntuitionistic.sound_boxp_stable x |} : forall (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : KM.Relation A) (R3 : Relation A) (ukmM : UpwardsClosedOrderedKripkeModel A), Bisimulation Krelation KM.Krelation -> ModalStable (MonoPred_L A) (MonoPred_Gamma A) (MonoPred_stable A) Arguments R1, po_R1, R2, R3, ukmM, R2_bis are implicit and maximally inserted Argument scopes are [type_scope _ _ _...\nKdenotation : forall M : Kmodel, Semantics (MonoPred_L A) ?MD -> expr -> Ensemble (Kworlds M) where ?MD : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Model] ?kMD : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KripkeModel ?MD]\nMonoPred_pmGamma : forall (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : KM.Relation A) (uR2 : UpwardsClosedOrderedKripkeModel A), PartialFunctional KM.Krelation -> PropositionalTransparentModality (MonoPred_L A) (MonoPred_Gamma A)\ndenote_boxp : forall x : expr, Same_set (Kworlds ?M) (Kdenotation ?M (boxp x)) (Semantics.boxp (Kdenotation ?M x)) where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?mL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl :...\nsat_boxp : forall (m : Kworlds ?M) (x : expr), satisfies (build_model ?M m) (boxp x) <-> (forall n : Kworlds ?M, KM.Krelation m n -> satisfies (build_model ?M n) x) where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?mL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A uk...\nKripke.denote_boxp : forall x : expr, Same_set (Kworlds ?M) (Kdenotation ?M (boxp x)) (Kripke.Semantics.boxp (Kdenotation ?M x)) where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?mL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripke...\nKripke.sat_boxp : forall (m : Kworlds ?M) (x : expr), satisfies (build_model ?M m) (boxp x) <-> (forall n : Kworlds ?M, KM.Krelation m n -> satisfies (build_model ?M n) x) where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?mL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 :...\nKripke.sat_andp : forall (m : Kworlds ?M) (x y : expr), satisfies (build_model ?M m) (andp x y) <-> satisfies (build_model ?M m) x /\\ satisfies (build_model ?M m) y where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?pL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM...\nKripke.sat_orp : forall (m : Kworlds ?M) (x y : expr), satisfies (build_model ?M m) (orp x y) <-> satisfies (build_model ?M m) x \\/ satisfies (build_model ?M m) y where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?pL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM :...\nKripke.denote_impp : forall x y : expr, Same_set (Kworlds ?M) (Kdenotation ?M (impp x y)) (Kripke.Semantics.impp (Kdenotation ?M x) (Kdenotation ?M y)) where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?MD : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukm...\nKripke.sat_impp : forall (m : Kworlds ?M) (x y : expr), satisfies (build_model ?M m) (impp x y) <-> (forall n : Kworlds ?M, KI.Krelation m n -> satisfies (build_model ?M n) x -> satisfies (build_model ?M n) y) where ?L : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Language] ?minL : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- MinimumLanguage ?L] ?MD : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI...\nMonoPred_KmGamma : forall (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : KM.Relation A) (uR2 : UpwardsClosedOrderedKripkeModel A), SystemK (MonoPred_L A) (MonoPred_Gamma A)\nDownwardsClosure.DownwardsClosure_increasing : forall m : ?worlds, increasing' m <-> increasing m where ?worlds : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?R : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KI.Relation ?worlds] ?po_R : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- PreOrder KI.Krelation] ?J...\nKorder_identity : forall m n : ?worlds, KI.Krelation m n -> m = n where ?worlds : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?R : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KI.Relation ?worlds] ?IdentityKripkeIntuitionisticModel : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- IdentityKrip...\nMonoPred_pstable = fun (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : Relation A) (R1_bis : Bisimulation Krelation KI.Krelation) => {| impp_stable := fun x y : expr => Sound_KripkeIntuitionistic.sound_impp_stable x y; andp_stable := fun x y : expr => Sound_KripkeIntuitionistic.sound_andp_stable x y; orp_stable := fun x y : expr => Sound_KripkeIntuitionistic.sound_orp_stable x y; falsep_stable := Sound_KripkeIntuitionistic.sound_falsep_stable; stable_proper_iffp := fun x y : expr => Sound_KripkeIntuitionistic.sound_stable_proper_iffp x y |} : forall (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : Relation A), Bisimulation Krelation KI.Krelation -> PropositionalStable (...\njoin_Korder_down : forall m1 m2 m n1 n2 : ?worlds, join m1 m2 m -> KI.Krelation n1 m1 -> KI.Krelation n2 m2 -> exists n : ?worlds, join n1 n2 n /\\ KI.Krelation n m where ?worlds : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?R : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KI.Relation ?worlds] ?J : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Rel...\njoin_Korder_up : forall m n m1 m2 : ?worlds, join m1 m2 m -> KI.Krelation m n -> exists n1 n2 : ?worlds, join n1 n2 n /\\ KI.Krelation m1 n1 /\\ KI.Krelation m2 n2 where ?worlds : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?R : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KI.Relation ?worlds] ?J : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Rel...\napp_same_set : Same_set ?A ?P ?Q -> forall x : ?A, ?P x < -> ?Q x where ?A : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?P : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Ensemble ?A] ?Q : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Ensemble ?A]\nprod_ukmM : forall (RA1 : KI.Relation ?A) (RB1 : KI.Relation ?B) (RA2 : KM.Relation ?A) (RB2 : KM.Relation ?B), UpwardsClosedOrderedKripkeModel ?A -> UpwardsClosedOrderedKripkeModel ?B -> UpwardsClosedOrderedKripkeModel (?A * ?B) where ?A : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?B : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type]\nKorder_no_branch : forall m1 m2 n : ?worlds, KI.Krelation n m1 -> KI.Krelation n m2 -> KI.Krelation m1 m2 \\/ KI.Krelation m2 m1 where ?worlds : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?R : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KI.Relation ?worlds] ?NoBranchKripkeIntuitionisticModel : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A uk...\nRelProd_Inclusion : forall (RA1 RA2 : relation ?A) (RB1 RB2 : relation ?B), Inclusion RA1 RA2 -> Inclusion RB1 RB2 -> Inclusion (RA1 * RB1)%signature (RA2 * RB2)%signature where ?A : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?B : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type]\nbuild_model : forall M : Kmodel, Kworlds M -> model where ?MD : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Model] ?KripkeModel : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- KripkeModel ?MD]\nRelProd_Preorder : forall (RA : relation ?A) (RB : relation ?B), PreOrder RA -> PreOrder RB -> PreOrder (RA * RB)%signature where ?A : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type] ?B : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type]\nMonoPred_fmSM : forall (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : KM.Relation A) (uR2 : UpwardsClosedOrderedKripkeModel A), FlatModalSemantics (MonoPred_L A) {| model := A |} tt (MonoPred_SM A)\nNone_None_option00 : forall R : relation ?A, option00_relation R None None where ?A : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type]\nMonoPred_minAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation), MinimumAxiomatization (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_ipAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation), IntuitionisticPropositionalLogic (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_cpAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation), IdentityKripkeIntuitionisticModel A -> Classical.ClassicalPropositionalLogic (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_dmpAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation), BranchJoinKripkeIntuitionisticModel A -> DeMorgan.DeMorganPropositionalLogic (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_gdpAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation), NoBranchKripkeIntuitionisticModel A -> GodelDummett.GodelDummettPropositionalLogic (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_sepconAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), SeparationLogic.SepconAxiomatization (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_sepconAX_weak : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), TheoryOfSeparationAxioms.SepconAxiomatization_weak (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_wandAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), SeparationLogic.WandAxiomatization (MonoPred_L A) (MonoPred_Gamma A)\nSome_Some_option00 : forall (R : relation ?A) (a b : ?A), R a b -> option00_relation R (Some a) (Some b) where ?A : [A : Type R1 : KI.Relation A po_R1 : PreOrder KI.Krelation R2 : KM.Relation A R3 : Relation A ukmM : UpwardsClosedOrderedKripkeModel A R2_incl : Inclusion KM.Krelation Krelation |- Type]\nMonoPred_empAX : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), UnitalSeparationAlgebra A -> SeparationLogic.EmpAxiomatization (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_gcsGamma : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), IncreasingSeparationAlgebra A -> SeparationLogic.GarbageCollectSeparationLogic (MonoPred_L A) (MonoPred_Gamma A)\nMonoPred_mL : forall (A : Type) (R1 : KI.Relation A), PreOrder KI.Krelation -> forall R2 : KM.Relation A, UpwardsClosedOrderedKripkeModel A -> ModalLanguage (MonoPred_L A)\nMonoPred_stableSM = fun (A : Type) (R1 : KI.Relation A) (po_R1 : PreOrder KI.Krelation) (R2 : Relation A) => {| semantic_stable := MonoPred_stable A; denote_stable := fun x : expr => reflexivity (Semantics.stable (Kdenotation tt x)) |} : forall (A : Type) (R1 : KI.Relation A), PreOrder KI.Krelation -> forall R2 : Relation A, SemanticStable (MonoPred_L A) {| model := A |} tt (MonoPred_SM A) Arguments R1, po_R1, R2 are implicit and maximally inserted Argument scopes are [type_scope _ _ _]\nMonoPred_fwandSM : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), WandSemantics (MonoPred_L A) {| model := A |} tt (MonoPred_SM A)\nMonoPred_fsepconSM : forall (A : Type) (R : KI.Relation A) (po_R : PreOrder KI.Krelation) (J : Join A) (SA : SeparationAlgebra A) (uSA : UpwardsClosedSeparationAlgebra A) (dSA : DownwardsClosedSeparationAlgebra A), SepconSemantics (MonoPred_L A) {| model := A |} tt (MonoPred_SM A)"}, {"role": "assistant", "content": "```coq\nunfold ModalAbsorbStable. intros. unfold MonoPred_L, MonoPred_Gamma, MonoPred_stable. unfold Language, Propositional, Provable, ModalAbsorbStable in *. auto.\nQed.```"}], "original": "unfold ModalAbsorbStable. intros. unfold MonoPred_L, MonoPred_Gamma, MonoPred_stable. unfold Language, Propositional, Provable, ModalAbsorbStable in *. auto.", "succ": false}]