[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": [{"ctx": [], "tactic": "rewrite plus_zero_r.", "exn": "The LHS of plus_zero_r (plus _ zero) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": [], "tactic": "apply plus_opp_l.", "exn": "In environment G : AbelianGroup Unable to unify \"plus (opp ?M2419) ?M2419 = zero\" with \"opp zero = zero\".", "type": "cannot_unify", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nG: AbelianGroup\n\nGoal:\nopp zero = zero\n\nPremises:\nopp = AbelianGroup.opp G (AbelianGroup.class G) : G -> G\nzero = AbelianGroup.zero G (AbelianGroup.class G) : G\nRecord mixin_of (G : Type) : Type := Mixin { plus : G -> G -> G; opp : G -> G; zero : G; ax1 : forall x y : G, plus x y = plus y x; ax2 : forall x y z : G, plus x (plus y z) = plus (plus x y) z; ax3 : forall x : G, plus x zero = x; ax4 : forall x : G, plus x (opp x) = zero } For mixin_of: Argument scope is [type_scope] For Mixin: Argument scopes are [type_scope function_scope function_scope _ function_scope function_scope function_scope function_scope]\nplus_zero_r : forall x : G, plus x zero = x\nplus_zero_l : forall x : G, plus zero x = x\nplus_opp_r : forall x : G, plus x (opp x) = zero\nplus_opp_l : forall x : G, plus (opp x) x = zero\nN.two_succ = eq_refl : 2%N = N.succ 1\nNdec.Ndiv2_bit_eq : forall a a' : N, N.odd a = N.odd a' -> N.div2 a = N.div2 a' -> a = a'\nN.lxor_eq : forall a a' : N, N.lxor a a' = 0%N -> a = a'\nN.lxor_eq_0_iff : forall a a' : N, N.lxor a a' = 0%N < -> a = a'\neq_IZR : forall n m : Z, IZR n = IZR m -> n = m\nbool_eq_ok : forall b1 b2 : bool, bool_eq b1 b2 = true -> b1 = b2\nN.eqb_eq : forall n m : N, (n =? m)%N = true < -> n = m\nZ.abs_or_opp_abs : forall n : Z, n = Z.abs n \\/ n = (- Z.abs n)%Z\nByte.byte_dec_lb : forall x y : Byte.byte, x = y -> Byte.eqb x y = true\nPeanoNat.Nat.mul_wd_obligation_1 = fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => eq_ind_r (fun x1 : nat => (x * x1)%nat = (y * y0)%nat) (eq_ind_r (fun x1 : nat => (x1 * y0)%nat = (y * y0)%nat) eq_refl H) H0 : Morphisms.respectful eq (Morphisms.respectful eq eq) Init.Nat.mul Init.Nat.mul\nPeanoNat.Nat.mod_wd_obligation_1 = fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => eq_ind_r (fun x1 : nat => x mod x1 = y mod y0) (eq_ind_r (fun x1 : nat => x1 mod y0 = y mod y0) eq_refl H) H0 : Morphisms.respectful eq (Morphisms.respectful eq eq) Nat.modulo Nat.modulo\nNat.log2_bits_unique : forall a n : nat, Nat.testbit a n = true -> (forall m : nat, (n < m)%nat -> Nat.testbit a m = false) -> Nat.log2 a = n\nN.discr : forall n : N, {p : positive | n = N.pos p} + {n = 0%N}\nVectorSpec.eq_nth_iff : forall (A : Type) (n : nat) (v1 v2 : VectorDef.t A n), (forall p1 p2 : Fin.t n, p1 = p2 -> VectorDef.nth v1 p1 = VectorDef.nth v2 p2) < -> v1 = v2\nNat.lxor_lor : forall a b : nat, Nat.land a b = 0%nat -> Nat.lxor a b = Nat.lor a b\nNdec.Ndiv2_neq : forall a a' : N, (N.div2 a =? N.div2 a')%N = false -> (a =? a')%N = false\nFSetPositive.PositiveSet.t = FSetPositive.PositiveSet.tree : Type\nN.log2_1 = (fun lemma : (2 ^ 0)%N = 1%N => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.Equivalence_Transitive (N.log2 1) (N.log2 (2 ^ 0)) (N.log2_wd 1%N (2 ^ 0)%N (RelationClasses.symmetry lemma)) 0%N 0%N (Morphisms.eq_proper_proxy 0%N)) (N.pow_0_r 2) (N.log2_pow2 0 (RelationClasses.reflexivity 0%N)) : N.log2 1 = 0%N\nN.lt = fun x y : N => (x ?= y)%N = Lt : N -> N -> Prop Argument scopes are [N_scope N_scope]\nZ.gt = fun x y : Z => (x ?= y)%Z = Gt : Z -> Z -> Prop Argument scopes are [Z_scope Z_scope]\nZ.lt = fun x y : Z => (x ?= y)%Z = Lt : Z -> Z -> Prop Argument scopes are [Z_scope Z_scope]\nPI2 = proj1_sig PI_2_aux : R\nN.eq_equiv = RelationClasses.eq_equivalence : RelationClasses.Equivalence eq\nZ.eq_equiv = RelationClasses.eq_equivalence : RelationClasses.Equivalence eq\nNat.eq_equiv = RelationClasses.eq_equivalence : RelationClasses.Equivalence eq\nRge = fun r1 r2 : R => r1 > r2 \\/ r1 = r2 : R -> R -> Prop Argument scopes are [R_scope R_scope]\nRle = fun r1 r2 : R => r1 < r2 \\/ r1 = r2 : R -> R -> Prop Argument scopes are [R_scope R_scope]\nssrnat.mul1n = ssrnat.addn0 : ssrfun.left_id 1%nat ssrnat.muln\nssrnat.NatTrec.doubleE = fun _top_assumption_ : nat => (fun (_evar_0_ : (fun n : nat => ssrnat.NatTrec.double n = ssrnat.double n) 0%nat) (_evar_0_0 : forall n : nat, (fun n0 : nat => ssrnat.NatTrec.double n0 = ssrnat.double n0) (S n)) => match _top_assumption_ as n return ((fun n0 : nat => ssrnat.NatTrec.double n0 = ssrnat.double n0) n) with | 0%nat => _evar_0_ | S x => _evar_0_0 x end) eq_refl (fun n : nat => (fun _evar_0_ : ssrnat.NatTrec.double (S n) = ssrnat.addn (S n) (S n) => eq_ind (ssrnat.addn (S n) (S n)) (fun _pattern_value_ : nat => ssrnat.NatTrec.double (S n) = _pattern_value...\nNat.pred_wd = PeanoNat.Nat.pred_wd_obligation_1 : Morphisms.Proper (Morphisms.respectful eq eq) Nat.pred\nZ.opp_wd = Morphisms.reflexive_proper Z.opp : Morphisms.Proper (Morphisms.respectful Z.eq Z.eq) Z.opp\nZ.div_unique : forall a b q r : Z, (0 <= r < b)%Z \\/ (b < r <= 0)%Z -> a = (b * q + r)%Z -> q = (a / b)%Z\nNat.eqf = fun f g : nat -> bool => forall n : nat, f n = g n : (nat -> bool) -> (nat -> bool) -> Prop Argument scopes are [function_scope function_scope]\nNat.lt_wd = PeanoNat.Nat.lt_wd_obligation_1 : Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq iff)) lt\nZ.div_1_r : forall a : Z, (a / 1)%Z = a"}, {"role": "assistant", "content": "```coq\nrewrite plus_zero_r. apply plus_opp_l.\nQed.```"}], "original": "rewrite plus_zero_r. apply plus_opp_l.", "succ": false}]