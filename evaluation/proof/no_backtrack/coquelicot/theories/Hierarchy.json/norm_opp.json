[{"history": {"proof": "intros x. shelve.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nK: AbsRing\nV: NormedModule K\n\nGoal:\nforall x : V, norm (opp x) = norm x\n\nPremises:\nopp = fun G : AbelianGroup => AbelianGroup.opp G (AbelianGroup.class G) : forall G : AbelianGroup, G -> G Argument G is implicit and maximally inserted\nnorm = NormedModule.norm K (NormedModuleAux.Pack K V (NormedModule.class K V) V) (NormedModule.class K V) : V -> R\nNotation NormedModule := NormedModule.type\nnorm_triangle : forall x y : V, norm (plus x y) <= norm x + norm y\nNormedModule.Mixin : forall (K : AbsRing) (V : NormedModuleAux K) (norm : V -> R) (norm_factor : R), (forall x y : V, norm (plus x y) <= norm x + norm y) -> (forall (l : K) (x : V), norm (scal l x) <= abs l * norm x) -> (forall (x y : V) (eps : R), norm (minus y x) < eps -> ball x eps y) -> (forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps) -> (forall x : V, norm x = 0 -> x = zero) -> NormedModule.mixin_of K V\nRecord mixin_of (K : AbsRing) (V : NormedModuleAux K) : Type := Mixin { norm : V -> R; norm_factor : R; ax1 : forall x y : V, norm (plus x y) <= norm x + norm y; ax2 : forall (l : K) (x : V), norm (scal l x) <= abs l * norm x; ax3 : forall (x y : V) (eps : R), norm (minus y x) < eps -> ball x eps y; ax4 : forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps; ax5 : forall x : V, norm x = 0 -> x = zero } For Mixin: Argument scopes are [_ _ function_scope R_scope function_scope function_scope function_scope function_scope function_scope]\nnorm_eq_zero : forall x : V, norm x = 0 -> x = zero\nnorm_scal : forall (l : K) (x : V), norm (scal l x) <= abs l * norm x\nnorm_compat1 : forall (x y : V) (eps : R), norm (minus y x) < eps -> ball x eps y\nnorm_zero = Rle_antisym (norm zero) 0 ((fun _evar_0_ : norm (scal zero zero) <= 0 => eq_ind (scal zero zero) (fun _pattern_value_ : V => norm _pattern_value_ <= 0) _evar_0_ zero (scal_zero_l zero)) ((fun _evar_0_ : norm (scal zero zero) <= 0 * norm zero => eq_ind (0 * norm zero) (fun _pattern_value_ : R => norm (scal zero zero) <= _pattern_value_) _evar_0_ 0 (Rmult_0_l (norm zero))) ((fun _evar_0_ : norm (scal zero zero) <= abs zero * norm zero => eq_ind (abs zero) (fun _pattern_value_ : R => norm (scal zero zero) <= _pattern_value_ * norm zero) _evar_0_ 0 abs_zero) (norm_scal zero zero)))) (Rplus_le_reg_r (norm zero) 0 (norm zero) ((fun _evar_0_ : norm zero <= norm zero + norm zero => eq_ind...\nnorm_compat2 : forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps\nopp_plus : forall x y : ?G, opp (plus x y) = plus (opp x) (opp y) where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nopp_opp : forall x : ?G, opp (opp x) = x where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nplus_opp_l : forall x : ?G, plus (opp x) x = zero where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nabs_opp : forall x : ?K, abs (opp x) = abs x where ?K : [K : AbsRing V : NormedModule K |- AbsRing]\nplus_opp_r : forall x : ?G, plus x (opp x) = zero where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nopp_mult_l : forall x y : ?K, opp (mult x y) = mult (opp x) y where ?K : [K : AbsRing V : NormedModule K |- Ring]\nscal_opp_l : forall (x : ?K) (u : ?V), scal (opp x) u = opp (scal x u) where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nopp_mult_m1 : forall x : ?K, opp x = mult (opp one) x where ?K : [K : AbsRing V : NormedModule K |- Ring]\nopp_mult_r : forall x y : ?K, opp (mult x y) = mult x (opp y) where ?K : [K : AbsRing V : NormedModule K |- Ring]\nscal_opp_r : forall (x : ?K) (u : ?V), scal x (opp u) = opp (scal x u) where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nabs_minus : forall x y : ?K, abs (minus x y) = abs (minus y x) where ?K : [K : AbsRing V : NormedModule K |- AbsRing]\nscal_opp_one : forall u : ?V, scal (opp one) u = opp u where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nderive_pt_id : forall x : R, derive_pt id x (derivable_pt_id x) = 1\nscal_zero_r : forall x : ?K, scal x zero = zero where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nAbsRing.ax2 : forall (K : Ring) (m : AbsRing.mixin_of K), AbsRing.abs K m (opp one) = 1\nmult_one_l : forall x : ?K, mult one x = x where ?K : [K : AbsRing V : NormedModule K |- Ring]\nplus_zero_r : forall x : ?G, plus x zero = x where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nabs_ge_0 : forall x : ?K, 0 <= abs x where ?K : [K : AbsRing V : NormedModule K |- AbsRing]\nmult_zero_r : forall x : ?K, mult x zero = zero where ?K : [K : AbsRing V : NormedModule K |- Ring]\nmult_zero_l : forall x : ?K, mult zero x = zero where ?K : [K : AbsRing V : NormedModule K |- Ring]\nabs_eq_zero : forall x : ?K, abs x = 0 -> x = zero where ?K : [K : AbsRing V : NormedModule K |- AbsRing]\nplus_comm : forall x y : ?G, plus x y = plus y x where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nderive_pt_div : forall (f1 f2 : R -> R) (x : R) (pr1 : derivable_pt f1 x) (pr2 : derivable_pt f2 x) (na : f2 x <> 0), derive_pt (f1 / f2) x (derivable_pt_div f1 f2 x pr1 pr2 na) = (derive_pt f1 x pr1 * f2 x - derive_pt f2 x pr2 * f1 x) / (f2 x)\u00b2\nNormedModule.AbelianGroup : forall K : AbsRing, NormedModule K -> AbelianGroup\nNormedModule.sort : forall K : AbsRing, NormedModule K -> Type\nNormedModule.UniformSpace : forall K : AbsRing, NormedModule K -> UniformSpace\nopp_minus : forall x y : ?G, opp (minus x y) = minus y x where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nNormedModule.ModuleSpace : forall K : AbsRing, NormedModule K -> ModuleSpace K\nNormedModule.NormedModuleAux : forall K : AbsRing, NormedModule K -> NormedModuleAux K\nscal_distr_l : forall (x : ?K) (u v : ?V), scal x (plus u v) = plus (scal x u) (scal x v) where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nabs_mult : forall x y : ?K, abs (mult x y) <= abs x * abs y where ?K : [K : AbsRing V : NormedModule K |- AbsRing]\nabs_triangle : forall x y : ?K, abs (plus x y) <= abs x + abs y where ?K : [K : AbsRing V : NormedModule K |- AbsRing]"}, {"role": "assistant", "content": "```coq\nintros x.\nrewrite norm_eq_zero with (x:=opp x).\nsymmetry.\nrewrite norm_eq_zero with (x:=x).\nreflexivity.\nQed.\n```"}], "original": "intros x.", "succ": false}]