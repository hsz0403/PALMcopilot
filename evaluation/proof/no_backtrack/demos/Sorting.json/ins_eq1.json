[{"history": {"proof": "intros n. simpl. reflexivity.", "repairs": ["", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall n : nat, ins n (Nil nat) = Cons nat n (Nil nat)\n\nPremises:\nCons : forall X : Set, X -> list X -> list X\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nins = fix ins (n : nat) (l : list nat) {struct l} : list nat := match l with | @Nil _ => Cons nat n (Nil nat) | @Cons _ m x => si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)) end : nat -> list nat -> list nat Arguments ins _%nat_scope\nNil : forall X : Set, list X\nnocc_eq1 : forall n : nat, nocc n (Nil nat) = 0\nsorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True\nsorted_eq1 = eq_refl : sorted (Nil nat) = True\nNat.shiftl = fun a : (fun _ : nat => nat) 0 => nat_rect (fun _ : nat => nat) a (fun _ : nat => Nat.double) : (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n Arguments Nat.shiftl (_ _)%nat_scope\nNat.shiftr = fun a : (fun _ : nat => nat) 0 => nat_rect (fun _ : nat => nat) a (fun _ : nat => Nat.div2) : (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n Arguments Nat.shiftr (_ _)%nat_scope\nnocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\nsorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true\nsorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x))\nVectorDef.t_ind : forall (A : Type) (P : forall n : nat, VectorDef.t A n -> Prop), P 0 (VectorDef.nil A) -> (forall (h : A) (n : nat) (t : VectorDef.t A n), P n t -> P (S n) (VectorDef.cons A h n t)) -> forall (n : nat) (t : VectorDef.t A n), P n t\nVectorDef.caseS : forall P : forall n : nat, VectorDef.t ?A (S n) -> Type, (forall (h : ?A) (n : nat) (t : VectorDef.t ?A n), P n (VectorDef.cons ?A h n t)) -> forall (n : nat) (v : VectorDef.t ?A (S n)), P n v where ?A : [ |- Type]\nInductive le (n : nat) : nat -> Prop := le_n : n <= n | le_S : forall m : nat, n <= m -> n <= S m Arguments le (_ _)%nat_scope Arguments le_n _%nat_scope Arguments le_S (_ _)%nat_scope\nPeanoNat.Nat.min_id : forall n : nat, PeanoNat.Nat.min n n = n\nnocc = fix nocc (n : nat) (l : list nat) {struct l} : nat := match l with | @Nil _ => 0 | @Cons _ m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x) end : nat -> list nat -> nat Arguments nocc _%nat_scope\nPeanoNat.Nat.sub_0_r : forall n : nat, n - 0 = n\nplus_n_O : forall n : nat, n = n + 0\nPeanoNat.Nat.mul_1_l : forall n : nat, 1 * n = n\nPeanoNat.Nat.add_0_r : forall n : nat, n + 0 = n\nPeanoNat.Nat.add_0_l : forall n : nat, 0 + n = n\nPeanoNat.Nat.add_1_l : forall n : nat, 1 + n = S n\nPeanoNat.Nat.eqb_eq : forall n m : nat, PeanoNat.Nat.eqb n m = true < -> n = m\nPeanoNat.Nat.shiftl_1_l : forall n : nat, PeanoNat.Nat.shiftl 1 n = PeanoNat.Nat.pow 2 n\nPeanoNat.Nat.eq_0_gt_0_cases : forall n : nat, n = 0 \\/ 0 < n\nPeanoNat.Nat.min_l : forall n m : nat, n <= m -> PeanoNat.Nat.min n m = n\nsorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x\nnat_ind : forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n\nPeanoNat.Nat.add_comm : forall n m : nat, n + m = m + n\nPeanoNat.Nat.log2_nonpos : forall n : nat, n <= 0 -> PeanoNat.Nat.log2 n = 0\nPeanoNat.Nat.mul_comm : forall n m : nat, n * m = m * n\nPeanoNat.Nat.mul_succ_r : forall n m : nat, n * S m = n * m + n\nPeanoNat.Nat.min_0_r : forall n : nat, PeanoNat.Nat.min n 0 = 0\nMin.min_0_r : forall n : nat, PeanoNat.Nat.min n 0 = 0\nNnat.Nat2N.id : forall n : nat, BinNat.N.to_nat (BinNat.N.of_nat n) = n\nPeanoNat.Nat.mul_0_l : forall n : nat, 0 * n = 0\nPeanoNat.Nat.sub_0_l : forall n : nat, 0 - n = 0\nPeanoNat.Nat.bits_0 : forall n : nat, PeanoNat.Nat.testbit 0 n = false\nPeanoNat.Nat.add_cancel_r : forall n m p : nat, n + p = m + p < -> n = m\nPeanoNat.Nat.divide_lcm_eq_r : forall n m : nat, PeanoNat.Nat.divide n m -> PeanoNat.Nat.lcm n m = m\nPeanoNat.Nat.ltb_lt : forall n m : nat, PeanoNat.Nat.ltb n m = true < -> n < m\nPeanoNat.Nat.divide_lcm_iff : forall n m : nat, PeanoNat.Nat.divide n m < -> PeanoNat.Nat.lcm n m = m\nPeanoNat.Nat.eqf = fun f g : nat -> bool => forall n : nat, f n = g n : (nat -> bool) -> (nat -> bool) -> Prop Arguments PeanoNat.Nat.eqf (_ _)%function_scope"}, {"role": "assistant", "content": "```coq\nintros n. simpl. reflexivity.\nQed.```"}], "original": "intros n. simpl. reflexivity.", "succ": true}]