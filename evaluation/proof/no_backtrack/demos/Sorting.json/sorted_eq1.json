[{"history": {"proof": "simpl. reflexivity.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nsorted (Nil nat) = True\n\nPremises:\nsorted = fix sorted (l : list nat) : Prop := match l with | @Nil _ => True | @Cons _ n (@Nil _) => True | @Cons _ n (@Cons _ m _ as l0) => inf_egal n m = true /\\ sorted l0 end : list nat -> Prop\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nNil : forall X : Set, list X\nByte.to_of_nat_iff : forall (x : nat) (y : Byte.byte), Byte.of_nat x = Some y < -> Byte.to_nat y = x\nNat.shiftl = fun a : (fun _ : nat => nat) 0 => nat_rect (fun _ : nat => nat) a (fun _ : nat => Nat.double) : (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n Arguments Nat.shiftl (_ _)%nat_scope\nNat.shiftr = fun a : (fun _ : nat => nat) 0 => nat_rect (fun _ : nat => nat) a (fun _ : nat => Nat.div2) : (fun _ : nat => nat) 0 -> forall n : nat, (fun _ : nat => nat) n Arguments Nat.shiftr (_ _)%nat_scope\nVectorSpec.cons_inj = fun (A : Type) (a1 a2 : A) (n : nat) (v1 v2 : VectorDef.t A n) (eq0 : VectorDef.cons A a1 n v1 = VectorDef.cons A a2 n v2) => match eq0 in (_ = x) return (VectorDef.caseS (fun (n0 : nat) (_ : VectorDef.t A (S n0)) => VectorDef.t A n0 -> Prop) (fun (a2' : A) (n0 : nat) (v2' v1' : VectorDef.t A n0) => a1 = a2' /\\ v1' = v2') x v1) with | eq_refl => conj eq_refl eq_refl end : forall (A : Type) (a1 a2 : A) (n : nat) (v1 v2 : VectorDef.t A n), VectorDef.cons A a1 n v1 = VectorDef.cons A a2 n v2 -> a1 = a2 /\\ v1 = v2 Arguments VectorSpec.cons_inj {A}%type_scope {a1 a2...\nList.nth_error_split : forall (A : Type) (l : Datatypes.list A) (n : nat) (a : A), List.nth_error l n = Some a -> exists l1 l2 : Datatypes.list A, l = (l1 ++ a :: l2)%list /\\ Datatypes.length l1 = n\nlist_rect : forall (X : Set) (P : list X -> Type), P (Nil X) -> (forall (x : X) (l : list X), P l -> P (Cons X x l)) -> forall l : list X, P l\nlist_sind : forall (X : Set) (P : list X -> SProp), P (Nil X) -> (forall (x : X) (l : list X), P l -> P (Cons X x l)) -> forall l : list X, P l\nlist_rec : forall (X : Set) (P : list X -> Set), P (Nil X) -> (forall (x : X) (l : list X), P l -> P (Cons X x l)) -> forall l : list X, P l\nlist_ind : forall (X : Set) (P : list X -> Prop), P (Nil X) -> (forall (x : X) (l : list X), P l -> P (Cons X x l)) -> forall l : list X, P l\nBinPosDef.Pos.of_nat = fix of_nat (n : nat) : BinNums.positive := match n with | S (S _ as x) => BinPosDef.Pos.succ (of_nat x) | _ => BinNums.xH end : nat -> BinNums.positive Arguments BinPosDef.Pos.of_nat _%nat_scope\nNat.add = fix add (n m : nat) {struct n} : nat := match n with | 0 => m | S p => S (add p m) end : nat -> nat -> nat Arguments Nat.add (_ _)%nat_scope\nNat.mul = fix mul (n m : nat) {struct n} : nat := match n with | 0 => 0 | S p => m + mul p m end : nat -> nat -> nat Arguments Nat.mul (_ _)%nat_scope\nNat.pow = fix pow (n m : nat) {struct m} : nat := match m with | 0 => 1 | S m0 => n * pow n m0 end : nat -> nat -> nat Arguments Nat.pow (_ _)%nat_scope\nNat.testbit = fix testbit (a n : nat) {struct n} : bool := match n with | 0 => Nat.odd a | S n0 => testbit (Nat.div2 a) n0 end : nat -> nat -> bool Arguments Nat.testbit (_ _)%nat_scope\nPeanoNat.Nat.lt_alt_wd = fun (x x' : nat) (Hx : x = x') (y y' : nat) (Hy : y = y') => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.iff_Transitive (exists p : nat, S p + x = y) (exists p : nat, S p + x' = y) (Morphisms_Prop.ex_iff_morphism (fun p : nat => S p + x = y) (fun p : nat => S p + x' = y) (fun p : nat => Morphisms.PER_morphism (RelationClasses.Equivalence_PER PeanoNat.Nat.eq_equiv) (S p + x) (S p + x') (Morphisms.Reflexive_partial_app_morphism PeanoNat.Nat.add_wd (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive (S p)) x x' Hx) y y (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive y))) (exists p : nat, S p + x' = y') (exists p...\nPeanoNat.Nat.Even_wd = fun (x y : nat) (H : x = y) => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.iff_Transitive (exists m : nat, x = 2 * m) (exists m : nat, y = 2 * m) (Morphisms_Prop.ex_iff_morphism (fun m : nat => x = 2 * m) (fun m : nat => y = 2 * m) (fun m : nat => Morphisms.PER_morphism (RelationClasses.Equivalence_PER PeanoNat.Nat.eq_equiv) x y H (2 * m) (2 * m) (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive (2 * m)))) (exists m : nat, y = 2 * m) (exists m : nat, y = 2 * m) (Morphisms.eq_proper_proxy (exists m : nat, y = 2 * m)) (RelationClasses.reflexivity (exists m : nat, y = 2 * m)) : Morphisms.Proper (Morphisms.respectful eq iff...\nNat.gcd = fix gcd (a b : nat) {struct a} : nat := match a with | 0 => b | S a' => gcd (Nat.modulo b (S a')) (S a') end : nat -> nat -> nat Arguments Nat.gcd (_ _)%nat_scope\nNat.sub = fix sub (n m : nat) {struct n} : nat := match n with | 0 => n | S k => match m with | 0 => n | S l => sub k l end end : nat -> nat -> nat Arguments Nat.sub (_ _)%nat_scope\nNat.max = fix max (n m : nat) {struct n} : nat := match n with | 0 => m | S n' => match m with | 0 => n | S m' => S (max n' m') end end : nat -> nat -> nat Arguments Nat.max (_ _)%nat_scope\nNat.min = fix min (n m : nat) {struct n} : nat := match n with | 0 => 0 | S n' => match m with | 0 => 0 | S m' => S (min n' m') end end : nat -> nat -> nat Arguments Nat.min (_ _)%nat_scope\nPeanoNat.Nat.shiftr_wd = fun (a a' : nat) (Ha : a = a') (b b' : nat) (Hb : b = b') => (fun lemma : PeanoNat.Nat.shiftr a b = PeanoNat.Nat.div a (PeanoNat.Nat.pow 2 b) => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.Equivalence_Transitive (PeanoNat.Nat.shiftr a b) (PeanoNat.Nat.div a (PeanoNat.Nat.pow 2 b)) lemma (PeanoNat.Nat.shiftr a' b') (PeanoNat.Nat.shiftr a' b') (Morphisms.eq_proper_proxy (PeanoNat.Nat.shiftr a' b'))) (PeanoNat.Nat.shiftr_div_pow2 a b) ((fun lemma : PeanoNat.Nat.shiftr a' b' = PeanoNat.Nat.div a' (PeanoNat.Nat.pow 2 b') => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses...\nVectorDef.caseS : forall P : forall n : nat, VectorDef.t ?A (S n) -> Type, (forall (h : ?A) (n : nat) (t : VectorDef.t ?A n), P n (VectorDef.cons ?A h n t)) -> forall (n : nat) (v : VectorDef.t ?A (S n)), P n v where ?A : [ |- Type]\nPeanoNat.Nat.le_wd = fun (n n' : nat) (Hn : n = n') (m m' : nat) (Hm : m = m') => (fun lemma : n < S m <-> n <= m => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.iff_Transitive (n <= m) (n < S m) (RelationClasses.symmetry lemma) (n' <= m') (n' <= m') (Morphisms.eq_proper_proxy (n' <= m'))) (PeanoNat.Nat.lt_succ_r n m) ((fun lemma : n' < S m' <-> n' <= m' => Morphisms.trans_sym_co_inv_impl_morphism (RelationClasses.Equivalence_PER RelationClasses.iff_equivalence) (n' <= m') (n' < S m') (RelationClasses.symmetry lemma)) (PeanoNat.Nat.lt_succ_r n' m') ((fun lemma : n = n' => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.iff_Transitive (n < S m) (n' < S m) (PeanoNat.Nat...\nPeanoNat.Nat.lxor_wd = fun (a a' : nat) (Ha : a = a') (b b' : nat) (Hb : b = b') => PeanoNat.Nat.bits_inj (PeanoNat.Nat.lxor a b) (PeanoNat.Nat.lxor a' b') (fun m : nat => eq_ind_r (fun b0 : bool => b0 = PeanoNat.Nat.testbit (PeanoNat.Nat.lxor a' b') m) (eq_ind_r (fun b0 : bool => xorb (PeanoNat.Nat.testbit a m) (PeanoNat.Nat.testbit b m) = b0) ((fun lemma : a = a' => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.eq_Transitive (xorb (PeanoNat.Nat.testbit a m) (PeanoNat.Nat.testbit b m)) (xorb (PeanoNat.Nat.testbit a' m) (PeanoNat.Nat.testbit b m)) (Morphisms.reflexive_proper x...\nNat.compare = fix compare (n m : nat) {struct n} : comparison := match n with | 0 => match m with | 0 => Eq | S _ => Lt end | S n' => match m with | 0 => Gt | S m' => compare n' m' end end : nat -> nat -> comparison Arguments Nat.compare (_ _)%nat_scope\nNat.eqb = fix eqb (n m : nat) {struct n} : bool := match n with | 0 => match m with | 0 => true | S _ => false end | S n' => match m with | 0 => false | S m' => eqb n' m' end end : nat -> nat -> bool Arguments Nat.eqb (_ _)%nat_scope\nPeanoNat.Nat.gcd_wd = fun (x x' : nat) (Hx : x = x') (y y' : nat) (Hy : y = y') => PeanoNat.Nat.gcd_unique x y (PeanoNat.Nat.gcd x' y') (PeanoNat.Nat.gcd_nonneg x' y') ((fun lemma : x = x' => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper PeanoNat.Nat.divide_wd tt (Morphisms.subrelation_respectful (Morphisms.subrelation_refl eq) (Morphisms.subrelation_respectful (Morphisms.subrelation_refl eq) Morphisms.iff_flip_impl_subrelation))) (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive (PeanoNat.Nat.gcd x' y')) x x' lemma) Hx (PeanoNat.Nat.gcd_divide_l x' y')) ((fun lemma : y = y' => Morphisms.Reflexive_partial_app_morphism (Morphisms.subrelation_proper PeanoNat.Nat...\nPlus.plus_is_one : forall m n : nat, m + n = 1 -> {m = 0 /\\ n = 1} + {m = 1 /\\ n = 0}\nPeanoNat.Nat.two_succ = eq_refl : 2 = 2\nPeanoNat.Nat.lcm_wd = fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.Equivalence_Transitive (x * PeanoNat.Nat.div x0 (PeanoNat.Nat.gcd x x0)) (x * PeanoNat.Nat.div y0 (PeanoNat.Nat.gcd x y0)) (Morphisms.Reflexive_partial_app_morphism PeanoNat.Nat.mul_wd (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive x) (PeanoNat.Nat.div x0 (PeanoNat.Nat.gcd x x0)) (PeanoNat.Nat.div y0 (PeanoNat.Nat.gcd x y0)) (PeanoNat.Nat.div_wd x0 y0 H0 (PeanoNat.Nat.gcd x x0) (PeanoNat.Nat.gcd x y0) (Morphisms.Reflexive_partial_app_m...\nPeanoNat.Nat.pred_0 = eq_refl : PeanoNat.Nat.pred 0 = 0\nPeanoNat.Nat.log2_up_wd = let H : Morphisms.Proper (Morphisms.respectful eq (Morphisms.respectful eq eq)) PeanoNat.Nat.compare := fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => match PeanoNat.Nat.compare_spec x x0 in (CompareSpec _ _ _ c) return (c = PeanoNat.Nat.compare y y0) with | @CompEq _ _ _ x1 => match PeanoNat.Nat.compare_spec y y0 in (CompareSpec _ _ _ c) return (x = x0 -> Eq = c) with | @CompEq _ _ _ _ => fun _ : x = x0 => eq_refl | @CompLt _ _ _ H1 => fun H2 : x = x0 => False_ind (Eq = Lt) ((fun H3 : x0 = y => (fun H4 : y = y0 => (fun H5 : y0 < y0 => PeanoNat.Nat.Private_OrderTac.Tac.lt_irrefl H...\nArithRing.natr_ring_lemma2 : forall (n : nat) (lH : Datatypes.list (Ring_polynom.PExpr BinNums.N * Ring_polynom.PExpr BinNums.N)) (l : Datatypes.list nat), Ring_polynom.interp_PElist 0 1 Nat.add Nat.mul (Ring_theory.SRsub Nat.add) (Ring_theory.SRopp (R:=nat)) eq BinNat.N.to_nat Ring_theory.id_phi_N (Ring_theory.pow_N 1 Nat.mul) l lH -> forall lmp : Datatypes.list (BinNums.N * Ring_polynom.Mon * Ring_polynom.Pol BinNums.N), Ring_polynom.mk_monpol_list BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat.N.add (fun x : BinNums.N => x) BinNat.N.eqb BinNat.N.div_eucl lH = lmp -> forall (pe : Ring_polynom.PExpr BinNums.N) (npe : Ring_polynom.Pol BinNums.N), Ring_polynom.norm_subst Bin...\nPeanoNat.Nat.max_unicity : forall n m p : nat, n < m /\\ p = m \\/ m <= n /\\ p = n -> p = PeanoNat.Nat.max n m\nPeanoNat.Nat.eq_sym = RelationClasses.Equivalence_Symmetric : RelationClasses.Symmetric eq Expanded type for implicit arguments PeanoNat.Nat.eq_sym : forall x y : nat, x = y -> y = x Arguments PeanoNat.Nat.eq_sym [x y]\nCompOpp_iff : forall c c' : comparison, CompOpp c = c' < -> c = CompOpp c'\nPeanoNat.Nat.compare_eq_iff : forall n m : nat, PeanoNat.Nat.compare n m = Eq < -> n = m\nPeanoNat.Nat.gcd_eq_0_l : forall n m : nat, PeanoNat.Nat.gcd n m = 0 -> n = 0\neq_add_S : forall n m : nat, S n = S m -> n = m\nPeanoNat.Nat.gcd_eq_0_r : forall n m : nat, PeanoNat.Nat.gcd n m = 0 -> m = 0"}, {"role": "assistant", "content": "```coq\nsimpl. reflexivity.\nQed.```"}], "original": "simpl. reflexivity.", "succ": true}]