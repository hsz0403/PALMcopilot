[{"history": {"proof": "intros A x y z H1 H2. rewrite H2. rewrite <- H1. reflexivity.", "repairs": ["", "", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall (A : Set) (x y z : A), y = z -> x = y -> x = z\n\nPremises:\nEqdepFacts.internal_eq_sym_internal : forall (A : Type) (x y : A), x = y -> y = x\nQArith_base.Qlt_trans : forall x y z : QArith_base.Q, QArith_base.Qlt x y -> QArith_base.Qlt y z -> QArith_base.Qlt x z\nQArith_base.Qle_trans : forall x y z : QArith_base.Q, QArith_base.Qle x y -> QArith_base.Qle y z -> QArith_base.Qle x z\nQArith_base.Qle_lt_trans : forall x y z : QArith_base.Q, QArith_base.Qle x y -> QArith_base.Qlt y z -> QArith_base.Qlt x z\nConstructiveCauchyReals.CRealLt_dec : forall x y z : ConstructiveCauchyReals.CReal, ConstructiveCauchyReals.CRealLt x y -> ConstructiveCauchyReals.CRealLt x z + ConstructiveCauchyReals.CRealLt z y\nQArith_base.Qplus_lt_le_compat : forall x y z t : QArith_base.Q, QArith_base.Qlt x y -> QArith_base.Qle z t -> QArith_base.Qlt (QArith_base.Qplus x z) (QArith_base.Qplus y t)\nQArith_base.Q_Setoid = {| RelationClasses.Equivalence_Reflexive := fun x : QArith_base.Q => QArith_base.Qeq_refl x; RelationClasses.Equivalence_Symmetric := fun (x y : QArith_base.Q) (H : QArith_base.Qeq x y) => QArith_base.Qeq_sym x y H; RelationClasses.Equivalence_Transitive := fun (x y z : QArith_base.Q) (H : QArith_base.Qeq x y) (H0 : QArith_base.Qeq y z) => QArith_base.Qeq_trans x y z H H0 |} : RelationClasses.Equivalence QArith_base.Qeq\nQArith_base.Qplus_le_r : forall x y z : QArith_base.Q, QArith_base.Qle (QArith_base.Qplus z x) (QArith_base.Qplus z y) < -> QArith_base.Qle x y\nQArith_base.Qplus_lt_r : forall x y z : QArith_base.Q, QArith_base.Qlt (QArith_base.Qplus z x) (QArith_base.Qplus z y) < -> QArith_base.Qlt x y\nQArith_base.Qplus_lt_l : forall x y z : QArith_base.Q, QArith_base.Qlt (QArith_base.Qplus x z) (QArith_base.Qplus y z) < -> QArith_base.Qlt x y\nEqdepFacts.internal_eq_sym_involutive : forall (A : Type) (x y : A) (H : x = y), EqdepFacts.internal_eq_sym_internal (EqdepFacts.internal_eq_sym_internal H) = H\nEqdepFacts.UIP_on_ : forall (U : Type) (x y : U), x = y -> Prop\nQArith_base.Qplus_assoc : forall x y z : QArith_base.Q, QArith_base.Qeq (QArith_base.Qplus x (QArith_base.Qplus y z)) (QArith_base.Qplus (QArith_base.Qplus x y) z)\nQArith_base.Qmult_plus_distr_l : forall x y z : QArith_base.Q, QArith_base.Qeq (QArith_base.Qmult (QArith_base.Qplus x y) z) (QArith_base.Qplus (QArith_base.Qmult x z) (QArith_base.Qmult y z))\nEqdep_dec.UIP_dec : forall A : Type, (forall x y : A, {x = y} + {x <> y}) -> forall (x y : A) (p1 p2 : x = y), p1 = p2\nZ_le_lt_eq_dec : forall x y : Z, (x <= y)%Z -> {(x < y)%Z} + {x = y}\nRabs_mult : forall x y : R, Rabs (x * y) = Rabs x * Rabs y\nZ.lt = fun x y : Z => (x ?= y)%Z = Lt : Z -> Z -> Prop Arguments Z.lt (_ _)%Z_scope\nN.lt = fun x y : N => (x ?= y)%N = Lt : N -> N -> Prop Arguments N.lt (_ _)%N_scope\nZ.gt = fun x y : Z => (x ?= y)%Z = Gt : Z -> Z -> Prop Arguments Z.gt (_ _)%Z_scope\nConstructiveEpsilon.constructive_ground_epsilon : forall (A : Type) (f : A -> nat) (g : nat -> A), (forall x : A, g (f x) = x) -> forall P : A -> Prop, (forall x : A, {P x} + {~ P x}) -> (exists x : A, P x) -> A\nUIP_nat : forall (x y : nat) (p1 p2 : x = y), p1 = p2\nList.in_dec : forall A : Type, (forall x y : A, {x = y} + {x <> y}) -> forall (a : A) (l : list A), {List.In a l} + {~ List.In a l}\nConstructiveEpsilon.constructive_indefinite_ground_description : forall (A : Type) (f : A -> nat) (g : nat -> A), (forall x : A, g (f x) = x) -> forall P : A -> Prop, (forall x : A, {P x} + {~ P x}) -> (exists x : A, P x) -> {x : A | P x}\nEqdep.EqdepTheory.UIP : forall (U : Type) (x y : U) (p1 p2 : x = y), p1 = p2\nClassical_Prop.EqdepTheory.UIP : forall (U : Type) (x y : U) (p1 p2 : x = y), p1 = p2\nRmin = fun x y : R => if Rle_dec x y then x else y : R -> R -> R Arguments Rmin (_ _)%R_scope\nIZR = fun z : Z => match z with | 0%Z => R0 | Z.pos n => IPR n | Z.neg n => - IPR n end : Z -> R Arguments IZR _%Z_scope : simpl never\nZ.le = fun x y : Z => (x ?= y)%Z <> Gt : Z -> Z -> Prop Arguments Z.le (_ _)%Z_scope\nPos.le = fun x y : positive => (x ?= y)%positive <> Gt : positive -> positive -> Prop Arguments Pos.le (_ _)%positive_scope\nList.app_removelast_last : forall (A : Type) (l : list A) (d : A), l <> nil -> l = (List.removelast l ++ List.last l d :: nil)%list\nZcompare_rec : forall (P : Set) (n m : Z), ((n ?= m)%Z = Eq -> P) -> ((n ?= m)%Z = Lt -> P) -> ((n ?= m)%Z = Gt -> P) -> P\nPropExtensionalityFacts.PredExt_imp_PropExt : (forall (A : Type) (P Q : A -> Prop), (forall x : A, P x <-> Q x) -> P = Q) -> forall A B : Prop, A < -> B -> A = B\nList.nodup : forall A : Type, (forall x y : A, {x = y} + {x <> y}) -> list A -> list A\nQArith_base.Qminus = fun x y : QArith_base.Q => QArith_base.Qplus x (QArith_base.Qopp y) : QArith_base.Q -> QArith_base.Q -> QArith_base.Q Arguments QArith_base.Qminus (_ _)%Q_scope\nQArith_base.Qdiv = fun x y : QArith_base.Q => QArith_base.Qmult x (QArith_base.Qinv y) : QArith_base.Q -> QArith_base.Q -> QArith_base.Q Arguments QArith_base.Qdiv (_ _)%Q_scope\nQArith_base.Qlt = fun x y : QArith_base.Q => (QArith_base.Qnum x * Z.pos (QArith_base.Qden y) < QArith_base.Qnum y * Z.pos (QArith_base.Qden x))%Z : QArith_base.Q -> QArith_base.Q -> Prop Arguments QArith_base.Qlt (_ _)%Q_scope\nQArith_base.Qeq_bool = fun x y : QArith_base.Q => Zeq_bool (QArith_base.Qnum x * Z.pos (QArith_base.Qden y)) (QArith_base.Qnum y * Z.pos (QArith_base.Qden x)) : QArith_base.Q -> QArith_base.Q -> bool Arguments QArith_base.Qeq_bool (_ _)%Q_scope\nQArith_base.Qle = fun x y : QArith_base.Q => (QArith_base.Qnum x * Z.pos (QArith_base.Qden y) <= QArith_base.Qnum y * Z.pos (QArith_base.Qden x))%Z : QArith_base.Q -> QArith_base.Q -> Prop Arguments QArith_base.Qle (_ _)%Q_scope\nQArith_base.Qmult = fun x y : QArith_base.Q => {| QArith_base.Qnum := QArith_base.Qnum x * QArith_base.Qnum y; QArith_base.Qden := QArith_base.Qden x * QArith_base.Qden y |} : QArith_base.Q -> QArith_base.Q -> QArith_base.Q Arguments QArith_base.Qmult (_ _)%Q_scope"}, {"role": "assistant", "content": "```  \nintros A x y z H1 H2.\nrewrite H2.\nrewrite <- H1.\nreflexivity. \n```"}], "original": "intros A x y z H1 H2. rewrite H2. rewrite <- H1. reflexivity.", "succ": true}]