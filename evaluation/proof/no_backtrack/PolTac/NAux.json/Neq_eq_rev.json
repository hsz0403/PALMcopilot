[{"history": {"proof": "intros n m H. rewrite H. reflexivity.", "repairs": ["", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall n m : N, n = m -> N.to_nat n = N.to_nat m\n\nPremises:\nInductive N : Set := N0 : N | Npos : positive -> N Arguments Npos _%positive_scope\nNat.max_r : forall n m : nat, (n <= m)%nat -> Nat.max n m = m\nNat.min_r : forall n m : nat, (m <= n)%nat -> Nat.min n m = m\nNat.eq_le_incl : forall n m : nat, n = m -> (n <= m)%nat\nNat.max_l : forall n m : nat, (m <= n)%nat -> Nat.max n m = n\nNat.min_l : forall n m : nat, (n <= m)%nat -> Nat.min n m = n\nNat.add_sub_eq_l : forall n m p : nat, (m + p)%nat = n -> (n - m)%nat = p\nBinNatDef.N.add = fun n m : N => match n with | 0 => m | N.pos p => match m with | 0 => n | N.pos q => N.pos (p + q) end end : N -> N -> N Arguments BinNatDef.N.add (_ _)%N_scope\nNat.sub_0_le : forall n m : nat, (n - m)%nat = 0%nat < -> (n <= m)%nat\nBinNatDef.N.compare = fun n m : N => match n with | 0 => match m with | 0 => Eq | N.pos _ => Lt end | N.pos n' => match m with | 0 => Gt | N.pos m' => (n' ?= m')%positive end end : N -> N -> comparison Arguments BinNatDef.N.compare (_ _)%N_scope\nN2Nat.inj : forall a a' : N, N.to_nat a = N.to_nat a' -> a = a'\nBinNatDef.N.mul = fun n m : N => match n with | 0 => 0 | N.pos p => match m with | 0 => 0 | N.pos q => N.pos (p * q) end end : N -> N -> N Arguments BinNatDef.N.mul (_ _)%N_scope\nNat.lt_le_incl : forall n m : nat, (n < m)%nat -> (n <= m)%nat\nBinNatDef.N.sub = fun n m : N => match n with | 0 => 0 | N.pos n' => match m with | 0 => n | N.pos m' => match Pos.sub_mask n' m' with | Pos.IsPos p => N.pos p | _ => 0 end end end : N -> N -> N Arguments BinNatDef.N.sub (_ _)%N_scope\nN2Nat.inj_iff : forall a a' : N, N.to_nat a = N.to_nat a' < -> a = a'\nN2Nat.inj_double : forall a : N, N.to_nat (N.double a) = (2 * N.to_nat a)%nat\nN2Nat.inj_succ_double : forall a : N, N.to_nat (N.succ_double a) = S (2 * N.to_nat a)\nNat2N.id : forall n : nat, N.to_nat (N.of_nat n) = n\nN2Nat.inj_add : forall a a' : N, N.to_nat (a + a') = (N.to_nat a + N.to_nat a')%nat\nN2Nat.inj_mul : forall a a' : N, N.to_nat (a * a') = (N.to_nat a * N.to_nat a')%nat\nN2Nat.inj_sub : forall a a' : N, N.to_nat (a - a') = (N.to_nat a - N.to_nat a')%nat\nZ_N_nat : forall n : Z, N.to_nat (Z.to_N n) = Z.to_nat n\nZabs_N_nat : forall n : Z, N.to_nat (Z.abs_N n) = Z.abs_nat n\nN2Nat.inj_pred : forall a : N, N.to_nat (N.pred a) = Nat.pred (N.to_nat a)\nN2Nat.inj_div2 : forall a : N, N.to_nat (N.div2 a) = Nat.div2 (N.to_nat a)\nN2Nat.inj_succ : forall a : N, N.to_nat (N.succ a) = S (N.to_nat a)\nN2Nat.inj_compare : forall a a' : N, (a ?= a') = (N.to_nat a ?= N.to_nat a')%nat\nN2Nat.inj_max : forall a a' : N, N.to_nat (N.max a a') = Nat.max (N.to_nat a) (N.to_nat a')\nN2Nat.inj_min : forall a a' : N, N.to_nat (N.min a a') = Nat.min (N.to_nat a) (N.to_nat a')\nN.pred_sub : forall n : N, N.pred n = n - 1\npositive_N_nat : forall p : positive, N.to_nat (N.pos p) = Pos.to_nat p\nByte.to_nat_via_N : forall x : Byte.byte, Byte.to_nat x = N.to_nat (Byte.to_N x)\nNat.sub_0_r : forall n : nat, (n - 0)%nat = n\nNat.sub_1_r : forall n : nat, (n - 1)%nat = Nat.pred n\nNat.div2_double : forall n : nat, Nat.div2 (2 * n) = n\nSuccNat2Pos.id_succ : forall n : nat, Pos.to_nat (Pos.of_succ_nat n) = S n\nNat.div2_succ_double : forall n : nat, Nat.div2 (S (2 * n)) = n\nNat.sub_diag : forall n : nat, (n - n)%nat = 0%nat\nBinNatDef.N.min = fun n n' : N => match n ?= n' with | Gt => n' | _ => n end : N -> N -> N Arguments BinNatDef.N.min (_ _)%N_scope\nBinNatDef.N.max = fun n n' : N => match n ?= n' with | Gt => n | _ => n' end : N -> N -> N Arguments BinNatDef.N.max (_ _)%N_scope\nPos.sub_mask_pos' : forall p q : positive, (q < p)%positive -> exists r : positive, Pos.sub_mask p q = Pos.IsPos r /\\ (q + r)%positive = p"}, {"role": "assistant", "content": "```intros n m H. rewrite H. reflexivity.```"}], "original": "intros n m H. rewrite H. reflexivity.", "succ": true}]