[{"history": {"proof": "intros A B h H. apply (H h eq_refl).", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall (A B : Set) (h : A), (forall u : A, u = h -> B) -> B\n\nPremises:\nInductive GFormula (TA TX AA AF : Type) : Type := TT : Tauto.GFormula | FF : Tauto.GFormula | X : TX -> Tauto.GFormula | A : TA -> AA -> Tauto.GFormula | Cj : Tauto.GFormula -> Tauto.GFormula -> Tauto.GFormula | D : Tauto.GFormula -> Tauto.GFormula -> Tauto.GFormula | N : Tauto.GFormula -> Tauto.GFormula | I : Tauto.GFormula -> option AF -> Tauto.GFormula -> Tauto.GFormula Arguments Tauto.GFormula {TA TX AA AF}%type_scope Arguments Tauto.TT {TA TX AA AF}%type_scope Arguments Tauto.FF {TA TX AA AF}%type_scope Arguments Tauto.X {TA TX AA AF}%type_scope Arguments Tauto.A {TA TX AA AF}%type_scope Arguments Tauto.Cj {TA TX AA AF}%type_scope Arguments Tauto.D {TA TX AA AF}%type_scope Arguments Tauto.N {TA TX AA AF}%type_scope Arguments Tauto.I {TA TX AA AF}%type_scope\nList.map : forall A B : Type, (A -> B) -> list A -> list B\nList.ext_in_map : forall (A B : Type) (f g : A -> B) (l : list A), List.map f l = List.map g l -> forall a : A, List.In a l -> f a = g a\nfst = fun (A B : Type) (p : A * B) => let (x, _) := p in x : forall A B : Type, A * B -> A Arguments fst {A B}%type_scope\nsumbool_rec : forall (A B : Prop) (P : {A} + {B} -> Set), (forall a : A, P (left a)) -> (forall b : B, P (right b)) -> forall s : {A} + {B}, P s\nInductive prod (A B : Type) : Type := pair : A -> B -> A * B Arguments prod (_ _)%type_scope Arguments pair {A B}%type_scope\neq_sig_hprop : (forall (x : ?A) (p q : ?P x), p = q) -> forall u v : {a : ?A | ?P a}, proj1_sig u = proj1_sig v -> u = v where ?A : [ |- Type] ?P : [ |- ?A -> Prop]\nlist_ind : forall (A : Type) (P : list A -> Prop), P nil -> (forall (a : A) (l : list A), P l -> P (a :: l)%list) -> forall l : list A, P l\nproj1_sig_eq = fun (A : Type) (P : A -> Prop) (u v : {a : A | P a}) (p : u = v) => f_equal (proj1_sig (P:=fun a : A => P a)) p : forall (A : Type) (P : A -> Prop) (u v : {a : A | P a}), u = v -> proj1_sig u = proj1_sig v Arguments proj1_sig_eq {A}%type_scope {P}%function_scope {u v}\nsig_of_sig2_eq = fun (A : Type) (P Q : A -> Prop) (u v : {a : A | P a & Q a}) (p : u = v) => f_equal (sig_of_sig2 (Q:=fun a : A => Q a)) p : forall (A : Type) (P Q : A -> Prop) (u v : {a : A | P a & Q a}), u = v -> sig_of_sig2 u = sig_of_sig2 v Arguments sig_of_sig2_eq {A}%type_scope {P Q}%function_scope {u v}\nList.ext_in_filter : forall (A : Type) (f g : A -> bool) (l : list A), List.filter f l = List.filter g l -> forall a : A, List.In a l -> f a = g a\neq_sig_uncurried : forall u v : {a : ?A | ?P a}, {p : proj1_sig u = proj1_sig v | eq_rect (proj1_sig u) (fun a : ?A => ?P a) (proj2_sig u) (proj1_sig v) p = proj2_sig v} -> u = v where ?A : [ |- Type] ?P : [ |- ?A -> Prop]\nTauto.add_term_correct : forall (Env Term' Annot : Type) (unsat : Term' -> bool) (deduce : Term' -> Term' -> option Term') (eval' : Env -> Term' -> Prop), (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False) -> (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u) -> forall (env : Env) (t : Term' * Annot) (cl : Tauto.clause Term' Annot), Tauto.eval_opt_clause eval' env (Tauto.add_term unsat deduce t cl) < -> Tauto.eval_clause eval' env (t :: cl)%list\nproj1_sig_of_sig2_eq = fun (A : Type) (P Q : A -> Prop) (u v : {a : A | P a & Q a}) (p : u = v) => proj1_sig_eq (sig_of_sig2_eq p) : forall (A : Type) (P Q : A -> Prop) (u v : {a : A | P a & Q a}), u = v -> proj1_sig (sig_of_sig2 u) = proj1_sig (sig_of_sig2 v) Arguments proj1_sig_of_sig2_eq {A}%type_scope {P Q}%function_scope {u v}\nInductive sumbool (A B : Prop) : Set := left : A -> {A} + {B} | right : B -> {A} + {B} Arguments sumbool (_ _)%type_scope Arguments left {A B}%type_scope, [A] _ _ Arguments right {A B}%type_scope, _ [B] _\nTauto.or_clause_correct : forall (Env Term' Annot : Type) (unsat : Term' -> bool) (deduce : Term' -> Term' -> option Term') (eval' : Env -> Term' -> Prop), (forall (env : Env) (d : Term'), eval' env d \\/ ~ eval' env d) -> (forall t : Term', unsat t = true -> forall env : Env, eval' env t -> False) -> (forall t t' u : Term', deduce t t' = Some u -> forall env : Env, eval' env t -> eval' env t' -> eval' env u) -> forall (cl cl' : Tauto.clause Term' Annot) (env : Env), Tauto.eval_opt_clause eval' env (Tauto.or_clause unsat deduce cl cl') < -> Tauto.eval_clause eval' env cl \\/ Tauto.eval_clause eval' env cl'\neq_sig : forall (u v : {a : ?A | ?P a}) (p : proj1_sig u = proj1_sig v), eq_rect (proj1_sig u) (fun a : ?A => ?P a) (proj2_sig u) (proj1_sig v) p = proj2_sig v -> u = v where ?A : [ |- Type] ?P : [ |- ?A -> Prop]\nNat.pred = fun n : nat => match n with | 0 => n | S u => u end : nat -> nat Arguments Nat.pred _%nat_scope\nexist : forall (A : Type) (P : A -> Prop) (x : A), P x -> {x : A | P x}\nList.filter_map : forall (A : Type) (f g : A -> bool) (l : list A), List.filter f l = List.filter g l < -> List.map f l = List.map g l\nList.app_inj_tail : forall (A : Type) (x y : list A) (a b : A), (x ++ a :: nil)%list = (y ++ b :: nil)%list -> x = y /\\ a = b\nInductive sig (A : Type) (P : A -> Prop) : Type := exist : forall x : A, P x -> {x : A | P x} Arguments sig [A]%type_scope _%type_scope Arguments exist [A]%type_scope _%function_scope\nList.In_nth : forall (A : Type) (l : list A) (x d : A), List.In x l -> exists n : nat, n < length l /\\ List.nth n l d = x\nBinNums.positive_ind : forall P : BinNums.positive -> Prop, (forall p : BinNums.positive, P p -> P (BinNums.xI p)) -> (forall p : BinNums.positive, P p -> P (BinNums.xO p)) -> P BinNums.xH -> forall p : BinNums.positive, P p\nRefl.make_conj_cons : forall (A : Type) (eval : A -> Prop) (a : A) (l : list A), Refl.make_conj eval (a :: l) < -> eval a /\\ Refl.make_conj eval l\nInductive sig2 (A : Type) (P Q : A -> Prop) : Type := exist2 : forall x : A, P x -> Q x -> {x : A | P x & Q x} Arguments sig2 [A]%type_scope (_ _)%type_scope Arguments exist2 [A]%type_scope (_ _)%function_scope\nPeanoNat.Nat.bits_inj_0 : forall a : nat, (forall n : nat, PeanoNat.Nat.testbit a n = false) -> a = 0\nBinNat.N.log2_bits_unique : forall a n : BinNums.N, BinNat.N.testbit a n = true -> (forall m : BinNums.N, BinNat.N.lt n m -> BinNat.N.testbit a m = false) -> BinNat.N.log2 a = n\nBinInt.Z.bits_inj' : forall a b : BinNums.Z, (forall n : BinNums.Z, BinInt.Z.le BinNums.Z0 n -> BinInt.Z.testbit a n = BinInt.Z.testbit b n) -> a = b\nBinPos.Pos.peano_rect : forall P : BinNums.positive -> Type, P BinNums.xH -> (forall p : BinNums.positive, P p -> P (BinPos.Pos.succ p)) -> forall p : BinNums.positive, P p\nBinNat.N.peano_rect : forall P : BinNums.N -> Type, P BinNums.N0 -> (forall n : BinNums.N, P n -> P (BinNat.N.succ n)) -> forall n : BinNums.N, P n\nEnvRing.Mphi_morph : forall (R : Type) (rI : R) (rmul : R -> R -> R) (M : EnvRing.Mon) (e1 e2 : BinNums.positive -> R), (forall x : BinNums.positive, e1 x = e2 x) -> EnvRing.Mphi rI rmul e1 M = EnvRing.Mphi rI rmul e2 M\nRefl.make_conj : forall A : Type, (A -> Prop) -> list A -> Prop\nList.filter : forall A : Type, (A -> bool) -> list A -> list A\nPeanoNat.Nat.induction : forall A : nat -> Prop, Morphisms.Proper (Morphisms.respectful eq iff) A -> A 0 -> (forall n : nat, A n -> A (S n)) -> forall n : nat, A n\nproj1_sig : forall (A : Type) (P : A -> Prop), {x : A | P x} -> A\nList.app_cons_not_nil : forall (A : Type) (x y : list A) (a : A), nil <> (x ++ a :: y)%list\nBinNat.N.gcd_unique' : forall n m p : BinNums.N, BinNat.N.divide p n -> BinNat.N.divide p m -> (forall q : BinNums.N, BinNat.N.divide q n -> BinNat.N.divide q m -> BinNat.N.divide q p) -> BinNat.N.gcd n m = p\nPeanoNat.Nat.gcd_unique : forall n m p : nat, 0 <= p -> PeanoNat.Nat.divide p n -> PeanoNat.Nat.divide p m -> (forall q : nat, PeanoNat.Nat.divide q n -> PeanoNat.Nat.divide q m -> PeanoNat.Nat.divide q p) -> PeanoNat.Nat.gcd n m = p\nBinNat.N.gcd_unique : forall n m p : BinNums.N, BinNat.N.le BinNums.N0 p -> BinNat.N.divide p n -> BinNat.N.divide p m -> (forall q : BinNums.N, BinNat.N.divide q n -> BinNat.N.divide q m -> BinNat.N.divide q p) -> BinNat.N.gcd n m = p\nsig_of_sig2 : forall (A : Type) (P Q : A -> Prop), {x : A | P x & Q x} -> {x : A | P x}"}, {"role": "assistant", "content": "```coq\nintros A B h H.\napply (H h eq_refl).\nQed.```"}], "original": "intros A B h H. apply (H h eq_refl).", "succ": true}]