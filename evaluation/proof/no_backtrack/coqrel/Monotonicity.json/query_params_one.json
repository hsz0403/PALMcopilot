[{"history": {"proof": "intros. constructor.", "repairs": ["", ""], "exceptions": [{"ctx": ["intros.", "constructor."], "tactic": "constructor.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nA: Type\nB: Type\nC: Type\nh: A\np: nat\nm1: B\nm2: C\nn: nat\n\nGoal:\nParams h (p + n) -> QueryParams m1 m2 n\n\nPremises:\nRecord QueryParams (A B : Type) (m1 : A) (m2 : B) (n : nat) : Prop := Build_QueryParams { } Arguments QueryParams {A B}%type_scope _ _ _%nat_scope Arguments Build_QueryParams (_ _)%type_scope _ _ _%nat_scope\nRecord Params (A : Type) (of : A) (arity : nat) : Prop := Build_Params { } Arguments Params {A}%type_scope _ _%nat_scope Arguments Build_Params _%type_scope _ _%nat_scope\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nBuild_QueryParams : forall (A B : Type) (m1 : A) (m2 : B) (n : nat), QueryParams m1 m2 n\nFin.weak : forall p0 : nat, (Fin.t ?m -> Fin.t ?n) -> Fin.t (p0 + ?m) -> Fin.t (p0 + ?n) where ?m : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat] ?n : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat]\nVectorDef.take : forall p0 : nat, p0 <= ?n -> VectorDef.t ?A ?n -> VectorDef.t ?A p0 where ?A : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- Type] ?n : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat]\nVectorSpec.append_splitat : forall (v : VectorDef.t ?A ?n) (w : VectorDef.t ?A ?m) (vw : VectorDef.t ?A (?n + ?m)), VectorDef.splitat ?n vw = (v, w) -> vw = VectorDef.append v w where ?A : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- Type] ?n : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat] ?m : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat]\nVectorSpec.append_comm_cons : forall (v : VectorDef.t ?A ?n) (w : VectorDef.t ?A ?m) (a : ?A), VectorDef.cons ?A a (?n + ?m) (VectorDef.append v w) = VectorDef.append (VectorDef.cons ?A a ?n v) w where ?A : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- Type] ?n : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat] ?m : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat]\nVectorSpec.eta : forall v : VectorDef.t ?A (S ?n), v = VectorDef.cons ?A (VectorDef.hd v) ?n (VectorDef.tl v) where ?A : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- Type] ?n : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat]\nVectorSpec.take_app : forall (v : VectorDef.t ?A ?n) (m : nat) (w : VectorDef.t ?A m) (le : ?n <= ?n + m), VectorDef.take ?n le (VectorDef.append v w) = v where ?A : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- Type] ?n : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- nat]\nVectorDef.splitat : forall l r : nat, VectorDef.t ?A (l + r) -> VectorDef.t ?A l * VectorDef.t ?A r where ?A : [A : Type B : Type C : Type h : A p : nat m1 : B m2 : C n : nat |- Type]\nPeanoNat.Nat.add_max_distr_l : forall n m p : nat, PeanoNat.Nat.max (p + n) (p + m) = p + PeanoNat.Nat.max n m\nMax.plus_max_distr_l : forall n m p : nat, PeanoNat.Nat.max (p + n) (p + m) = p + PeanoNat.Nat.max n m\nNdigits.Pshiftl_nat_plus : forall (n m : nat) (p : BinNums.positive), BinPos.Pos.shiftl_nat p (m + n) = BinPos.Pos.shiftl_nat (BinPos.Pos.shiftl_nat p n) m\nrsat = fun (A B : Type) (P : B -> Prop) (_ : A) (y : B) => P y : forall A B : Type, (B -> Prop) -> rel A B Arguments rsat {A B}%type_scope _%function_scope\nrel_pull = fun (A B A' B' : Type) (f : A -> A') (g : B -> B') (R : rel A' B') (x : A) (y : B) => R (f x) (g y) : forall A B A' B' : Type, (A -> A') -> (B -> B') -> rel A' B' -> rel A B Arguments rel_pull {A B A' B'}%type_scope (_ _)%function_scope _%rel_scope\nrel_impl = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y -> R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_impl {A B}%type_scope (_ _)%rel_scope\nset_ge = fun (A B : Type) (R : rel A B) (sA : A -> Prop) (sB : B -> Prop) => forall b : B, sB b -> exists a : A, sA a /\\ R a b : forall A B : Type, rel A B -> rel (A -> Prop) (B -> Prop) Arguments set_ge {A B}%type_scope _%rel_scope\nset_le = fun (A B : Type) (R : rel A B) (sA : A -> Prop) (sB : B -> Prop) => forall a : A, sA a -> exists b : B, sB b /\\ R a b : forall A B : Type, rel A B -> rel (A -> Prop) (B -> Prop) Arguments set_le {A B}%type_scope _%rel_scope\nrel_inter = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y /\\ R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_inter {A B} (_ _)%rel_scope\nrel_union = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y \\/ R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_union {A B} (_ _)%rel_scope\nlsat = fun (A B : Type) (P : A -> Prop) (x : A) (_ : B) => P x : forall A B : Type, (A -> Prop) -> rel A B Arguments lsat {A B}%type_scope _%function_scope\nVectorDef.t_ind : forall (A : Type) (P : forall n : nat, VectorDef.t A n -> Prop), P 0 (VectorDef.nil A) -> (forall (h : A) (n : nat) (t : VectorDef.t A n), P n t -> P (S n) (VectorDef.cons A h n t)) -> forall (n : nat) (t : VectorDef.t A n), P n t\nrel_compose = fun (A B C : Type) (RAB : rel A B) (RBC : rel B C) (x : A) (z : C) => exists y : B, RAB x y /\\ RBC y z : forall A B C : Type, rel A B -> rel B C -> rel A C Arguments rel_compose {A B C}%type_scope (_ _)%rel_scope\nPeanoNat.Nat.testbit_unique : forall (a n : nat) (a0 : bool) (l h : nat), l < PeanoNat.Nat.pow 2 n -> a = l + (PeanoNat.Nat.b2n a0 + 2 * h) * PeanoNat.Nat.pow 2 n -> PeanoNat.Nat.testbit a n = a0\nrel_incr = fun (W A B : Type) (acc : rel W W) (R : W -> rel A B) (w : W) (a : A) (b : B) => exists w' : W, acc w w' /\\ R w' a b : forall W A B : Type, rel W W -> (W -> rel A B) -> W -> rel A B Arguments rel_incr {W A B}%type_scope _%rel_scope _%function_scope\nBinPosDef.Pos.size_nat = fix size_nat (p : BinNums.positive) : nat := match p with | BinNums.xI p0 | BinNums.xO p0 => S (size_nat p0) | BinNums.xH => 1 end : BinNums.positive -> nat Arguments BinPosDef.Pos.size_nat _%positive_scope\nMinus.le_plus_minus : forall n m : nat, n <= m -> m = n + (m - n)\nPeanoNat.Nat.add_mod_idemp_r : forall a b n : nat, n <> 0 -> PeanoNat.Nat.modulo (a + PeanoNat.Nat.modulo b n) n = PeanoNat.Nat.modulo (a + b) n\nInductive t : nat -> Set := F1 : forall n : nat, Fin.t (S n) | FS : forall n : nat, Fin.t n -> Fin.t (S n) Arguments Fin.t _%nat_scope Arguments Fin.F1 {n}%nat_scope Arguments Fin.FS {n}%nat_scope\nVectorDef.cons : forall A : Type, A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n)\nPeanoNat.Nat.lnot = fun a n : nat => PeanoNat.Nat.lxor a (PeanoNat.Nat.ones n) : nat -> nat -> nat Arguments PeanoNat.Nat.lnot (_ _)%nat_scope\nPeanoNat.Nat.ones = fun n : nat => PeanoNat.Nat.pred (PeanoNat.Nat.shiftl 1 n) : nat -> nat Arguments PeanoNat.Nat.ones _%nat_scope\nPeanoNat.Nat.land_lnot_diag_low : forall a n : nat, PeanoNat.Nat.log2 a < n -> PeanoNat.Nat.land a (PeanoNat.Nat.lnot a n) = 0\nPeanoNat.Nat.lor_lnot_diag_low : forall a n : nat, PeanoNat.Nat.log2 a < n -> PeanoNat.Nat.lor a (PeanoNat.Nat.lnot a n) = PeanoNat.Nat.ones n\nPeanoNat.Nat.sub_succ_l : forall n m : nat, n <= m -> S m - n = S (m - n)\nBinPos.Pos.sub_xI_xI : forall n m : BinNums.positive, BinPos.Pos.lt m n -> BinPos.Pos.sub (BinNums.xI n) (BinNums.xI m) = BinNums.xO (BinPos.Pos.sub n m)\nPeanoNat.Nat.gcd_add_diag_r : forall n m : nat, PeanoNat.Nat.gcd n (m + n) = PeanoNat.Nat.gcd n m\nInductive t (A : Type) : nat -> Type := nil : VectorDef.t A 0 | cons : A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n) Arguments VectorDef.t _%type_scope _%nat_scope Arguments VectorDef.nil _%type_scope Arguments VectorDef.cons _%type_scope _ _%nat_scope\nPeanoNat.Nat.odd_add : forall n m : nat, PeanoNat.Nat.odd (n + m) = xorb (PeanoNat.Nat.odd n) (PeanoNat.Nat.odd m)\nPeanoNat.Nat.even_add : forall n m : nat, PeanoNat.Nat.even (n + m) = Bool.eqb (PeanoNat.Nat.even n) (PeanoNat.Nat.even m)\nset_le_subrel_params = {| |} : Params (@set_le) 3\nsum_subrel_params = {| |} : Params (@sum_rel) 4"}, {"role": "assistant", "content": "```intros. constructor. constructor.```"}], "original": "intros. constructor. constructor.", "succ": true}]