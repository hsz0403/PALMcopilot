[{"history": {"proof": "intros. constructor.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nA: Type\nB: Type\nC: Type\nD: Type\nh1: A\nh2: B\np2: nat\np1: nat\nm1: C\nm2: D\nn: nat\n\nGoal:\nParams h1 (p1 + n) -> Params h2 (p2 + n) -> QueryParams m1 m2 n\n\nPremises:\nRecord QueryParams (A B : Type) (m1 : A) (m2 : B) (n : nat) : Prop := Build_QueryParams { } Arguments QueryParams {A B}%type_scope _ _ _%nat_scope Arguments Build_QueryParams (_ _)%type_scope _ _ _%nat_scope\nRecord Params (A : Type) (of : A) (arity : nat) : Prop := Build_Params { } Arguments Params {A}%type_scope _ _%nat_scope Arguments Build_Params _%type_scope _ _%nat_scope\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nquery_params_one : forall (h : ?A) (p : nat) (m3 : ?B) (m4 : ?C) (n0 : nat), Params h (p + n0) -> QueryParams m3 m4 n0 where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?B : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?C : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type]\nFin.weak : forall p : nat, (Fin.t ?m -> Fin.t ?n) -> Fin.t (p + ?m) -> Fin.t (p + ?n) where ?m : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat] ?n : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat]\nVectorDef.take : forall p : nat, p <= ?n -> VectorDef.t ?A ?n -> VectorDef.t ?A p where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?n : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat]\nVectorSpec.append_splitat : forall (v : VectorDef.t ?A ?n) (w : VectorDef.t ?A ?m) (vw : VectorDef.t ?A (?n + ?m)), VectorDef.splitat ?n vw = (v, w) -> vw = VectorDef.append v w where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?n : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat] ?m : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat]\nBuild_QueryParams : forall (A B : Type) (m1 : A) (m2 : B) (n : nat), QueryParams m1 m2 n\nVectorSpec.append_comm_cons : forall (v : VectorDef.t ?A ?n) (w : VectorDef.t ?A ?m) (a : ?A), VectorDef.cons ?A a (?n + ?m) (VectorDef.append v w) = VectorDef.append (VectorDef.cons ?A a ?n v) w where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?n : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat] ?m : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat]\nVectorDef.splitat : forall l r : nat, VectorDef.t ?A (l + r) -> VectorDef.t ?A l * VectorDef.t ?A r where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type]\nVectorSpec.eta : forall v : VectorDef.t ?A (S ?n), v = VectorDef.cons ?A (VectorDef.hd v) ?n (VectorDef.tl v) where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?n : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat]\nVectorSpec.take_app : forall (v : VectorDef.t ?A ?n) (m : nat) (w : VectorDef.t ?A m) (le : ?n <= ?n + m), VectorDef.take ?n le (VectorDef.append v w) = v where ?A : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- Type] ?n : [A : Type B : Type C : Type D : Type h1 : A h2 : B p1 : nat p2 : nat m1 : C m2 : D n : nat |- nat]\nPeanoNat.Nat.log2_shiftl : forall a n : nat, a <> 0 -> PeanoNat.Nat.log2 (PeanoNat.Nat.shiftl a n) = PeanoNat.Nat.log2 a + n\nInductive t : nat -> Set := F1 : forall n : nat, Fin.t (S n) | FS : forall n : nat, Fin.t n -> Fin.t (S n) Arguments Fin.t _%nat_scope Arguments Fin.F1 {n}%nat_scope Arguments Fin.FS {n}%nat_scope\nVectorDef.cons : forall A : Type, A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n)\nPeanoNat.Nat.sub_succ_l : forall n m : nat, n <= m -> S m - n = S (m - n)\nBinPos.Pos.sub_xI_xI : forall n m : BinNums.positive, BinPos.Pos.lt m n -> BinPos.Pos.sub (BinNums.xI n) (BinNums.xI m) = BinNums.xO (BinPos.Pos.sub n m)\nrel_pull = fun (A B A' B' : Type) (f : A -> A') (g : B -> B') (R : rel A' B') (x : A) (y : B) => R (f x) (g y) : forall A B A' B' : Type, (A -> A') -> (B -> B') -> rel A' B' -> rel A B Arguments rel_pull {A B A' B'}%type_scope (_ _)%function_scope _%rel_scope\nPeanoNat.Nat.add_max_distr_l : forall n m p : nat, PeanoNat.Nat.max (p + n) (p + m) = p + PeanoNat.Nat.max n m\nrsat = fun (A B : Type) (P : B -> Prop) (_ : A) (y : B) => P y : forall A B : Type, (B -> Prop) -> rel A B Arguments rsat {A B}%type_scope _%function_scope\nset_le = fun (A B : Type) (R : rel A B) (sA : A -> Prop) (sB : B -> Prop) => forall a : A, sA a -> exists b : B, sB b /\\ R a b : forall A B : Type, rel A B -> rel (A -> Prop) (B -> Prop) Arguments set_le {A B}%type_scope _%rel_scope\nset_ge = fun (A B : Type) (R : rel A B) (sA : A -> Prop) (sB : B -> Prop) => forall b : B, sB b -> exists a : A, sA a /\\ R a b : forall A B : Type, rel A B -> rel (A -> Prop) (B -> Prop) Arguments set_ge {A B}%type_scope _%rel_scope\nPeanoNat.Nat.gcd_add_diag_r : forall n m : nat, PeanoNat.Nat.gcd n (m + n) = PeanoNat.Nat.gcd n m\nrel_impl = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y -> R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_impl {A B}%type_scope (_ _)%rel_scope\nInductive t (A : Type) : nat -> Type := nil : VectorDef.t A 0 | cons : A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n) Arguments VectorDef.t _%type_scope _%nat_scope Arguments VectorDef.nil _%type_scope Arguments VectorDef.cons _%type_scope _ _%nat_scope\nZnat.Nat2Z.inj_add : forall n m : nat, BinInt.Z.of_nat (n + m) = BinInt.Z.add (BinInt.Z.of_nat n) (BinInt.Z.of_nat m)\nNnat.Nat2N.inj_add : forall n n' : nat, BinNat.N.of_nat (n + n') = BinNat.N.add (BinNat.N.of_nat n) (BinNat.N.of_nat n')\nlsat = fun (A B : Type) (P : A -> Prop) (x : A) (_ : B) => P x : forall A B : Type, (A -> Prop) -> rel A B Arguments lsat {A B}%type_scope _%function_scope\nPeanoNat.Nat.gcd_add_mult_diag_r : forall n m p : nat, PeanoNat.Nat.gcd n (m + p * n) = PeanoNat.Nat.gcd n m\nrel_union = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y \\/ R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_union {A B} (_ _)%rel_scope\nrel_inter = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y /\\ R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_inter {A B} (_ _)%rel_scope\nVectorDef.t_ind : forall (A : Type) (P : forall n : nat, VectorDef.t A n -> Prop), P 0 (VectorDef.nil A) -> (forall (h : A) (n : nat) (t : VectorDef.t A n), P n t -> P (S n) (VectorDef.cons A h n t)) -> forall (n : nat) (t : VectorDef.t A n), P n t\nrel_compose = fun (A B C : Type) (RAB : rel A B) (RBC : rel B C) (x : A) (z : C) => exists y : B, RAB x y /\\ RBC y z : forall A B C : Type, rel A B -> rel B C -> rel A C Arguments rel_compose {A B C}%type_scope (_ _)%rel_scope\nrel_pull_subrel_params = {| |} : Params (@rel_pull) 3\nrel_union_subrel_params = {| |} : Params (@rel_union) 4\nset_ge_subrel_params = {| |} : Params (@set_ge) 3\nset_le_subrel_params = {| |} : Params (@set_le) 3\nlsat_subrel_params = {| |} : Params (@lsat) 3\nrel_incr_subrel_params = {| |} : Params (@rel_incr) 4\nrel_inter_params = {| |} : Params (@rel_inter) 4\nsum_subrel_params = {| |} : Params (@sum_rel) 4\npsat_subrel_params = {| |} : Params (@psat) 3\nrsat_subrel_params = {| |} : Params (@rsat) 3"}, {"role": "assistant", "content": "```intros. constructor.```"}], "original": "intros. constructor.", "succ": true}]