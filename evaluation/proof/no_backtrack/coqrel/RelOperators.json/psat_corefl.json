[{"history": {"proof": "intros x y H. inversion H. reflexivity.", "repairs": ["used_var", "", ""], "exceptions": [{"ctx": [], "tactic": "intros A I x y H.", "exn": "A is already used.", "type": "used_var", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nA: Type\nI: A -> Prop\n\nGoal:\nCoreflexive (psat I)\n\nPremises:\nInductive psat (A : Type) (I : A -> Prop) (x : A) : A -> Prop := psat_intro : I x -> psat I x x Arguments psat {A}%type_scope _%function_scope Arguments psat_intro {A}%type_scope _%function_scope\nCoreflexive = fun (A : Type) (R : relation A) => forall x y : A, R x y -> x = y : forall A : Type, relation A -> Prop Arguments Coreflexive {A}%type_scope _%rel_scope\nprod_rel_corefl : forall (R1 : rel ?A ?A) (R2 : rel ?B ?B), Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 * R2) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nsum_rel_corefl : forall (R1 : rel ?A ?A) (R2 : rel ?B ?B), Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 + R2) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nrel_union_corefl : forall R1 R2 : rel ?A ?A, Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 \\/ R2) where ?A : [A : Type I : A -> Prop |- Type]\nrel_push_corefl : forall (f : ?A -> ?B) (R : rel ?A ?A), Coreflexive R -> Coreflexive R !! (f) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nrel_inter_corefl_r : forall R1 R2 : rel ?A ?A, Coreflexive R2 -> Coreflexive (R1 /\\ R2) where ?A : [A : Type I : A -> Prop |- Type]\nrel_inter_corefl_l : forall R1 R2 : rel ?A ?A, Coreflexive R1 -> Coreflexive (R1 /\\ R2) where ?A : [A : Type I : A -> Prop |- Type]\nreq_corefl : forall a : ?A, Coreflexive (req a) where ?A : [A : Type I : A -> Prop |- Type]\narrow_refl : forall (RA : relation ?A) (RB : relation ?B), Coreflexive RA -> Reflexive RB -> Reflexive (RA ++> RB) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nsubrel_eq : forall R : relation ?A, Coreflexive R -> Related R eq subrel where ?A : [A : Type I : A -> Prop |- Type]\nrelation = fun A : Type => A -> A -> Prop : Type -> Type Arguments relation _%type_scope\nreflexive : forall A : Type, relation A -> Prop\nsymmetric : forall A : Type, relation A -> Prop\ntransitive : forall A : Type, relation A -> Prop\nlist_rel_corefl = fun (A : Type) (R : relation A) (HR : Coreflexive R) (l1 l2 : list A) (Hl : list_rel R l1 l2) => list_rel_ind A A R (fun l3 l4 : list A => l3 = l4) (let H : A = A := eq_refl in (fun _ : A = A => eq_refl) H) (fun (x1 x2 : A) (Hx : R x1 x2) (l3 l4 : list A) (_ : list_rel R l3 l4) (IHl : l3 = l4) => let H : l3 = l4 := IHl in (let H0 : x1 = x2 := coreflexivity x1 x2 Hx in (let H1 : A = A := eq_refl in (fun (_ : A = A) (H3 : x1 = x2) (H4 : l3 = l4) => eq_trans (f_equal (fun f : list A -> list A => f l3) (eq_trans (f_equal (...\nRelated = fun (A B : Type) (f : A) (g : B) (R : rel A B) => R f g : forall A B : Type, A -> B -> rel A B -> Prop Arguments Related {A B}%type_scope _ _ _%rel_scope\ncoreflexivity : forall x y : ?A, x = y -> x = y where ?A : [A : Type I : A -> Prop |- Type]\npsat_intro : forall (I0 : ?A -> Prop) (x : ?A), I0 x -> psat I0 x x where ?A : [A : Type I : A -> Prop |- Type]\neq_corefl = fun (A : Type) (x y : A) (H : x = y) => H : forall A : Type, Coreflexive eq Arguments eq_corefl {A}%type_scope\nList.map : forall A B : Type, (A -> B) -> list A -> list B\npsat_ind : forall (A : Type) (I : A -> Prop) (x : A) (P : A -> Prop), (I x -> P x) -> forall y : A, psat I x y -> P y\npsat_rect : forall (A : Type) (I : A -> Prop) (x : A) (P : A -> Type), (I x -> P x) -> forall y : A, psat I x y -> P y\npsat_rec : forall (A : Type) (I : A -> Prop) (x : A) (P : A -> Set), (I x -> P x) -> forall y : A, psat I x y -> P y\npsat_sind : forall (A : Type) (I : A -> Prop) (x : A) (P : A -> SProp), (I x -> P x) -> forall y : A, psat I x y -> P y\nrel_inter = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y /\\ R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_inter {A B} (_ _)%rel_scope\nrel_union = fun (A B : Type) (R1 R2 : rel A B) (x : A) (y : B) => R1 x y \\/ R2 x y : forall A B : Type, rel A B -> rel A B -> rel A B Arguments rel_union {A B} (_ _)%rel_scope\nequiv_sym : forall (A : Type) (R : relation A), equivalence A R -> symmetric A R\nRecord equivalence (A : Type) (R : relation A) : Prop := Build_equivalence { equiv_refl : reflexive A R; equiv_trans : transitive A R; equiv_sym : symmetric A R } Arguments equivalence _%type_scope _%rel_scope Arguments Build_equivalence _%type_scope _%rel_scope\nssrfun.associative : forall S : Type, (S -> S -> S) -> Prop\narrow_pointwise_rel : forall A B1 B2 : Type, rel B1 B2 -> rel (A -> B1) (A -> B2)\nrel = fun A1 A2 : Type => A1 -> A2 -> Prop : Type -> Type -> Type Arguments rel (_ _)%type_scope\nsubrel = fun (A B : Type) (R1 R2 : rel A B) => forall (x : A) (y : B), R1 x y -> R2 x y : forall A B : Type, rel (rel A B) (rel A B) Arguments subrel {A B}%type_scope (R1 R2)%rel_scope : rename\nssrbool.transitive : forall T : Type, ssrbool.rel T -> Prop\nBinInt.Z.eqf = fun f g : BinNums.Z -> bool => forall n : BinNums.Z, f n = g n : (BinNums.Z -> bool) -> (BinNums.Z -> bool) -> Prop Arguments BinInt.Z.eqf (_ _)%function_scope\nBinInt.Z.le = fun x y : BinNums.Z => BinInt.Z.compare x y <> Gt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.le (_ _)%Z_scope\nBinInt.Z.lt = fun x y : BinNums.Z => BinInt.Z.compare x y = Lt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.lt (_ _)%Z_scope\nBinNat.N.le = fun x y : BinNums.N => BinNat.N.compare x y <> Gt : BinNums.N -> BinNums.N -> Prop Arguments BinNat.N.le (_ _)%N_scope\nBinInt.Z.gt = fun x y : BinNums.Z => BinInt.Z.compare x y = Gt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.gt (_ _)%Z_scope\nBinNat.N.lt = fun x y : BinNums.N => BinNat.N.compare x y = Lt : BinNums.N -> BinNums.N -> Prop Arguments BinNat.N.lt (_ _)%N_scope\nZnumtheory.rel_prime = fun a b : BinNums.Z => Znumtheory.Zis_gcd a b (BinNums.Zpos BinNums.xH) : BinNums.Z -> BinNums.Z -> Prop Arguments Znumtheory.rel_prime (_ _)%Z_scope\nSetoid.Seq_refl : forall (A : Type) (Aeq : relation A), Setoid.Setoid_Theory A Aeq -> forall x : A, Aeq x x"}, {"role": "assistant", "content": "``` \nintros A I x y H.\ninversion H.\nreflexivity.\n```"}], "original": "intros A I x y H. inversion H. reflexivity.", "succ": true}]