[{"history": {"proof": "intros n. induction n as [| n' IHn]. - split; reflexivity. - destruct IHn as [H1 H2]. shelve.", "repairs": ["", "", "", "", "", "", ""], "exceptions": [{"ctx": ["intros n.", "induction n as [| n' IHn].", "-", "split; reflexivity.", "-", "destruct IHn as [H1 H2]."], "tactic": "split; [rewrite opp_succZ, H2| rewrite opp_predZ, H1]; reflexivity.", "exn": "Found no subterm matching \"oppZ (succZ ?M1397)\" in the current goal.", "type": "no_subterm", "handled": false}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n\n\nPremises:\noppZ = fun x : Z => match x with | OZ => OZ | pos n => neg n | neg n => pos n end : Z -> Z\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nInductive Z : Set := OZ : Z | pos : nat -> Z | neg : nat -> Z Arguments pos _%nat_scope Arguments neg _%nat_scope\ntech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ\ntech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ\ntech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (Init.Nat.pred n)\ntech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m))\ntech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m))\ntech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n\nNat.min_spec : forall n m : nat, n < m /\\ Nat.min n m = n \\/ m <= n /\\ Nat.min n m = m\naddZ_opposite = fun (x : Z) (_ : IdZ x) => conj I (conj I (conj match x as z return (addZ z (oppZ z) = OZ) with | OZ => eq_refl | pos n => tech_add_pos_negZ n | neg n => tech_add_neg_posZ n end match x as z return (addZ (oppZ z) z = OZ) with | OZ => eq_refl | pos n => tech_add_neg_posZ n | neg n => tech_add_pos_negZ n end)) : opposite Z IdZ addZ OZ oppZ\nNnat.Nat2N.id : forall n : nat, BinNat.N.to_nat (BinNat.N.of_nat n) = n\nNat.pred_succ : forall n : nat, Nat.pred (S n) = n\nNat.div2_double : forall n : nat, Nat.div2 (2 * n) = n\nNat.ones_equiv : forall n : nat, Nat.ones n = Nat.pred (2 ^ n)\nNnat.Nat2N.inj_pred : forall n : nat, BinNat.N.of_nat (Nat.pred n) = BinNat.N.pred (BinNat.N.of_nat n)\nNat.lt_exists_pred : forall z n : nat, z < n -> exists k : nat, n = S k /\\ z <= k\nNat.setbit_eq : forall a n : nat, Nat.testbit (Nat.setbit a n) n = true\npredZ = fun x : Z => match x with | OZ => neg 0 | pos 0 => OZ | pos (S m) => pos m | neg n => neg (S n) end : Z -> Z\nsuccZ = fun x : Z => match x with | OZ => IZ | pos n => pos (S n) | neg 0 => OZ | neg (S m) => neg m end : Z -> Z\nNat.shiftr_lor : forall a b n : nat, Nat.shiftr (Nat.lor a b) n = Nat.lor (Nat.shiftr a n) (Nat.shiftr b n)\nNat.ones_spec_low : forall n m : nat, m < n -> Nat.testbit (Nat.ones n) m = true\nNat.ones_spec_high : forall n m : nat, n <= m -> Nat.testbit (Nat.ones n) m = false\nNat.ldiff_ones_l_low : forall a n : nat, Nat.log2 a < n -> Nat.ldiff (Nat.ones n) a = Nat.lnot a n\nopp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x)\nopp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x)\nabs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}\nabsZ = fun x : Z => match x with | OZ => OZ | pos n | neg n => pos n end : Z -> Z\nNat.shiftl_specif_high : forall a n m : nat, n <= m -> Nat.testbit (Nat.shiftl a n) m = Nat.testbit a (m - n)\nNat.testbit_true : forall a n : nat, Nat.testbit a n = true < -> (a / 2 ^ n) mod 2 = 1\naddZ_commutativity = fun x y : Z => Z_ind (fun x0 : Z => addZ x0 y = addZ y x0) (eq_sym (add_OZ y)) (fun n : nat => nat_ind (fun n0 : nat => addZ (pos n0) y = addZ y (pos n0)) (eq_sym (add_IZ_succZ y)) (fun (n0 : nat) (H : addZ (pos n0) y = addZ y (pos n0)) => eq_ind_r (fun z : Z => z = addZ y (pos (S n0))) (eq_ind_r (fun z : Z => succZ z = addZ y (pos (S n0))) (let H0 : succZ (pos n0) = pos (S n0) := eq_refl in (fun H1 : succZ (pos n0) = pos (S n0) => eq_ind (succZ (pos n0)) (fun z : Z => succZ (addZ y (pos n0)) = addZ y z) (eq_ind_r (fun z : Z =>...\nNat.setbit_iff : forall a n m : nat, Nat.testbit (Nat.setbit a n) m = true < -> n = m \\/ Nat.testbit a m = true\nNat.shiftr_spec' : forall a n m : nat, Nat.testbit (Nat.shiftr a n) m = Nat.testbit a (m + n)\nNdigits.Nshiftl_nat_equiv : forall a n : BinNums.N, BinNat.N.shiftl_nat a (BinNat.N.to_nat n) = BinNat.N.shiftl a n\ntech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2)\nNat.lt_exists_pred_strong : forall z n m : nat, z < m -> m <= n -> exists k : nat, m = S k /\\ z <= k\nNat.gcd_unique_alt : forall n m p : nat, 0 <= p -> (forall q : nat, Nat.divide q p <-> Nat.divide q n /\\ Nat.divide q m) -> Nat.gcd n m = p\nMax.plus_max_distr_l : forall n m p : nat, Nat.max (p + n) (p + m) = p + Nat.max n m\nNat.add_max_distr_l : forall n m p : nat, Nat.max (p + n) (p + m) = p + Nat.max n m\nNat.lnot_spec_high : forall a n m : nat, n <= m -> Nat.testbit (Nat.lnot a n) m = Nat.testbit a m\ntech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m\nNat.lnot_spec_low : forall a n m : nat, m < n -> Nat.testbit (Nat.lnot a n) m = negb (Nat.testbit a m)\nNat.divide_factor_r : forall n m : nat, Nat.divide n (m * n)"}, {"role": "assistant", "content": "```  \nintros n.\ninduction n as [| n' IHn].\n- split; reflexivity.\n- destruct IHn as [H1 H2].\n  split; [rewrite opp_succZ, H2| rewrite opp_predZ, H1]; reflexivity.\n```  "}], "original": "intros n. induction n as [| n' IHn]. - split; reflexivity. - destruct IHn as [H1 H2]. split; [rewrite opp_succZ, H2| rewrite opp_predZ, H1]; reflexivity.", "succ": false}]