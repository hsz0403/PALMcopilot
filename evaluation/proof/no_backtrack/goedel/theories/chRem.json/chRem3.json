[{"history": {"proof": "intros a b H. apply Nat2Z.inj. apply H.", "repairs": ["", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall a b : nat, Z.of_nat a = Z.of_nat b -> a = b\n\nPremises:\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nInductive Z : Set := Z0 : Z | Zpos : positive -> Z | Zneg : positive -> Z Arguments Zpos _%positive_scope Arguments Zneg _%positive_scope\nNat.mod_upper_bound : forall a b : nat, b <> 0 -> a mod b < b\nmodulo.modzmod : forall (a b : Z) (n : nat), modulo.Mod a b n -> modulo.ZMod a b (Z.of_nat n)\ndivzdiv : forall a b : Z, Divides (Z.abs_nat a) (Z.abs_nat b) -> ZDivides a b\nBinIntDef.Z.div = fun a b : Z => let (q, _) := BinIntDef.Z.div_eucl a b in q : Z -> Z -> Z Arguments BinIntDef.Z.div (_ _)%Z_scope\nBinIntDef.Z.modulo = fun a b : Z => let (_, r) := BinIntDef.Z.div_eucl a b in r : Z -> Z -> Z Arguments BinIntDef.Z.modulo (_ _)%Z_scope\nZdiv_unique : forall a b q r : Z, (0 <= r < b)%Z -> a = (b * q + r)%Z -> q = (a / b)%Z\nZmod_unique : forall a b q r : Z, (0 <= r < b)%Z -> a = (b * q + r)%Z -> r = (a mod b)%Z\nmodulo.moddivmin : forall (a b : Z) (n : nat), modulo.Mod a b n < -> Divides n (Z.abs_nat (a - b))\nmodulo.ZMod = fun a b n : Z => exists q : Z, a = (b + n * q)%Z : Z -> Z -> Z -> Prop Arguments modulo.ZMod (_ _ _)%Z_scope\nLinComb = fun c x y : Z => exists a b : Z, c = (x * a + y * b)%Z : Z -> Z -> Z -> Prop Arguments LinComb (_ _ _)%Z_scope\nmodulo.Mod = fun (a b : Z) (n : nat) => exists q : Z, a = (b + Z.of_nat n * q)%Z : Z -> Z -> nat -> Prop Arguments modulo.Mod (_ _)%Z_scope _%nat_scope\nCoPrime = fun a b : nat => gcd (Z.of_nat a) (Z.of_nat b) 1 : nat -> nat -> Prop Arguments CoPrime (_ _)%nat_scope\nZLinCombMod = fun c x y n : Z => exists a b : Z, modulo.ZMod c (x * a + y * b) n : Z -> Z -> Z -> Z -> Prop Arguments ZLinCombMod (_ _ _ _)%Z_scope\nLinCombMod = fun (c x y : Z) (n : nat) => exists a b : Z, modulo.Mod c (x * a + y * b) n : Z -> Z -> Z -> nat -> Prop Arguments LinCombMod (_ _ _)%Z_scope _%nat_scope\nNnat.N2Nat.id : forall a : N, N.of_nat (N.to_nat a) = a\nexp.inj_zexp : forall (n : nat) (a : Z), exp.ZExp a (Z.of_nat n) = exp.Exp a n\nprime_div_or_gcd1 : forall (p : nat) (a : Z), Prime p -> ZDivides (Z.of_nat p) a \\/ gcd (Z.of_nat p) a 1\nBinNatDef.N.to_nat = fun a : N => match a with | 0%N => 0 | N.pos p => Pos.to_nat p end : N -> nat Arguments BinNatDef.N.to_nat _%N_scope\ninj_eq : forall x y : nat, x = y -> Z.of_nat x = Z.of_nat y\nNat2Z.inj : forall n m : nat, Z.of_nat n = Z.of_nat m -> n = m\nexp.ZExp = fun a n : Z => match n with | 0%Z => 1%Z | Z.pos p | Z.neg p => exp.Exp a (Pos.to_nat p) end : Z -> Z -> Z Arguments exp.ZExp (_ _)%Z_scope\nNat2Z.inj_iff : forall n m : nat, Z.of_nat n = Z.of_nat m < -> n = m\ndiv_Zdiv : forall n m : nat, m <> 0 -> Z.of_nat (n / m) = (Z.of_nat n / Z.of_nat m)%Z\nmod_Zmod : forall n m : nat, m <> 0 -> Z.of_nat (n mod m) = (Z.of_nat n mod Z.of_nat m)%Z\nNat2Z.inj_sub : forall n m : nat, m <= n -> Z.of_nat (n - m) = (Z.of_nat n - Z.of_nat m)%Z\nZ_of_nat_complete : forall x : Z, (0 <= x)%Z -> exists n : nat, x = Z.of_nat n\ninj_minus2 : forall n m : nat, m > n -> Z.of_nat (n - m) = 0%Z\nNat2Z.inj_pred : forall n : nat, 0 < n -> Z.of_nat (Nat.pred n) = Z.pred (Z.of_nat n)\nNat2Z.inj_mul : forall n m : nat, Z.of_nat (n * m) = (Z.of_nat n * Z.of_nat m)%Z\nNat2Z.inj_add : forall n m : nat, Z.of_nat (n + m) = (Z.of_nat n + Z.of_nat m)%Z\nnat_N_Z : forall n : nat, Z.of_N (N.of_nat n) = Z.of_nat n\nisnat_inj_abs : forall (x : Z) (n : nat), x = Z.of_nat n -> n = Z.abs_nat x\ntwo_power_nat_equiv : forall n : nat, two_power_nat n = (2 ^ Z.of_nat n)%Z\nNat2Z.inj_succ : forall n : nat, Z.of_nat (S n) = Z.succ (Z.of_nat n)\nisnat_abs_inj : forall (x : Z) (n : nat), (0 <= x)%Z -> n = Z.abs_nat x -> x = Z.of_nat n\nNat2Z.inj_sub_max : forall n m : nat, Z.of_nat (n - m) = Z.max 0 (Z.of_nat n - Z.of_nat m)\nZ2Nat.id : forall n : Z, (0 <= n)%Z -> Z.of_nat (Z.to_nat n) = n\ninj_abs_pos : forall x : Z, (x >= 0)%Z -> Z.of_nat (Z.abs_nat x) = x\nNat2Z.inj_pred_max : forall n : nat, Z.of_nat (Nat.pred n) = Z.max 0 (Z.pred (Z.of_nat n))\nlist.list_ind : forall (A : Set) (P : list.list A -> Prop), P (list.Nil A) -> (forall (a : A) (l : list.list A), P l -> P (list.Cons A a l)) -> forall l : list.list A, P l"}, {"role": "assistant", "content": "``` \nintros a b H.\napply Nat2Z.inj.\napply H.\n```"}], "original": "intros a b H. apply Nat2Z.inj. apply H.", "succ": true}]