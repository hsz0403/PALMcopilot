[{"history": {"proof": "intros H1 H2. induction H2. - constructor. - eapply Forall_cons. + apply H1. * shelve. * shelve. + apply IHForall. shelve.", "repairs": ["", "", "", "", "", "", "", "", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "unfinished_bullet", "", "", ""], "exceptions": [{"ctx": ["intros H1 H2.", "induction H2.", "-", "constructor.", "-", "eapply Forall_cons.", "+", "apply H1."], "tactic": "apply H.", "exn": "In environment X : Type P, Q : X -> Prop x : X l : list X H1 : forall x0 : X, In x0 (x :: l) -> P x0 -> Q x0 H : P x H2 : Forall P l IHForall : (forall x : X, In x l -> P x -> Q x) -> Forall Q l Unable to unify \"P x\" with \"In x (x :: l)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H1 H2.", "induction H2.", "-", "constructor.", "-", "eapply Forall_cons.", "+", "apply H1."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nX: Type\nQ: X -> Prop\nP: X -> Prop\nll: list X\n\nGoal:\n(forall x : X, In x ll -> P x -> Q x) -> Forall P ll -> Forall Q ll\n\nPremises:\nForall : forall A : Type, (A -> Prop) -> list A -> Prop\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\nIn : forall A : Type, A -> list A -> Prop\nForall_and : forall (A : Type) (P Q : A -> Prop) (l : list A), Forall P l -> Forall Q l -> Forall (fun x : A => P x /\\ Q x) l\nlist_dec : forall (X : Type) (P Q : X -> Prop), (forall x : X, {P x} + {Q x}) -> forall l : list X, {x : X | In x l /\\ P x} + {forall x : X, In x l -> Q x}\nForall_and_inv : forall (A : Type) (P Q : A -> Prop) (l : list A), Forall (fun x : A => P x /\\ Q x) l -> Forall P l /\\ Forall Q l\nForall2_Forall : forall (X : Type) (R : X -> X -> Prop) (ll : list X), Forall2 R ll ll < -> Forall (fun x : X => R x x) ll\nForall_impl : forall (A : Type) (P Q : A -> Prop), (forall a : A, P a -> Q a) -> forall l : list A, Forall P l -> Forall Q l\nForall_rev : forall (X : Type) (P : X -> Prop) (ll : list X), Forall P ll -> Forall P (rev ll)\nmeasure_rect : forall (X : Type) (m : X -> nat) (P : X -> Type), (forall x : X, (forall y : X, m y < m x -> P y) -> P x) -> forall x : X, P x\nForall_rect : forall (A : Type) (P : A -> Prop) (Q : list A -> Type), Q nil -> (forall (b : A) (l : list A), P b -> Q (b :: l)) -> forall l : list A, Forall P l -> Q l\nForall_map : forall (X Y : Type) (f : X -> Y) (P : Y -> Prop) (ll : list X), Forall P (map f ll) < -> Forall (fun x : X => P (f x)) ll\nForall_cons_inv : forall (X : Type) (P : X -> Prop) (x : X) (ll : list X), Forall P (x :: ll) < -> P x /\\ Forall P ll\nZifyClasses.rew_iff : forall P Q : Prop, P < -> Q -> P -> Q\nForall_app : forall (X : Type) (P : X -> Prop) (ll mm : list X), Forall P (ll ++ mm) < -> Forall P ll /\\ Forall P mm\nlist_injective_rect : forall (X : Type) (P : list X -> Type), P nil -> (forall (x : X) (l : list X), ~ In x l -> P l -> P (x :: l)) -> forall l : list X, list_injective l -> P l\nForall_forall : forall (A : Type) (P : A -> Prop) (l : list A), Forall P l < -> (forall x : A, In x l -> P x)\nExists_Forall_neg : forall (A : Type) (P : A -> Prop) (l : list A), (forall x : A, P x \\/ ~ P x) -> Exists (fun x : A => ~ P x) l < -> ~ Forall P l\nneg_Forall_Exists_neg : forall (A : Type) (P : A -> Prop) (l : list A), (forall x : A, {P x} + {~ P x}) -> ~ Forall P l -> Exists (fun x : A => ~ P x) l\nForall_sind : forall (A : Type) (P : A -> Prop) (P0 : list A -> SProp), P0 nil -> (forall (x : A) (l : list A), P x -> Forall P l -> P0 l -> P0 (x :: l)) -> forall l : list A, Forall P l -> P0 l\nForall_ind : forall (A : Type) (P : A -> Prop) (P0 : list A -> Prop), P0 nil -> (forall (x : A) (l : list A), P x -> Forall P l -> P0 l -> P0 (x :: l)) -> forall l : list A, Forall P l -> P0 l\nForall_cons : forall (A : Type) (P : A -> Prop) (x : A) (l : list A), P x -> Forall P l -> Forall P (x :: l)\nlist_injective_inv : forall (X : Type) (x : X) (ll : list X), list_injective (x :: ll) -> ~ In x ll /\\ list_injective ll\nForallOrdPairs_ind : forall (A : Type) (R : A -> A -> Prop) (P : list A -> Prop), P nil -> (forall (a : A) (l : list A), Forall (R a) l -> ForallOrdPairs R l -> P l -> P (a :: l)) -> forall l : list A, ForallOrdPairs R l -> P l\nForallOrdPairs_sind : forall (A : Type) (R : A -> A -> Prop) (P : list A -> SProp), P nil -> (forall (a : A) (l : list A), Forall (R a) l -> ForallOrdPairs R l -> P l -> P (a :: l)) -> forall l : list A, ForallOrdPairs R l -> P l\nForall_forall_map : forall (X : Type) (f : nat -> X) (n : nat) (l : list X) (P : X -> Prop), l = map f (list_an 0 n) -> (forall i : nat, i < n -> P (f i)) < -> Forall P l\nexists_Forall : forall (A B : Type) (P : A -> B -> Prop) (l : list B), (exists k : A, Forall (P k) l) -> Forall (fun x : B => exists k : A, P k x) l\nNoDup_ind : forall (A : Type) (P : list A -> Prop), P nil -> (forall (x : A) (l : list A), ~ In x l -> NoDup l -> P l -> P (x :: l)) -> forall l : list A, NoDup l -> P l\nNoDup_sind : forall (A : Type) (P : list A -> SProp), P nil -> (forall (x : A) (l : list A), ~ In x l -> NoDup l -> P l -> P (x :: l)) -> forall l : list A, NoDup l -> P l\nForall_dec : forall (A : Type) (P : A -> Prop), (forall x : A, {P x} + {~ P x}) -> forall l : list A, {Forall P l} + {~ Forall P l}\nlist_in_map : forall (X Y : Type) (l : list X), (forall x : X, In x l -> Y) -> list Y\nincl_Forall : forall (A : Type) (P : A -> Prop) (l1 l2 : list A), incl l2 l1 -> Forall P l1 -> Forall P l2\nList.Forall_rev : forall (A : Type) (P : A -> Prop) (l : list A), Forall P l -> Forall P (rev l)\nPermutation_ind : forall (A : Type) (P : list A -> list A -> Prop), P nil nil -> (forall (x : A) (l l' : list A), l ~p l' -> P l l' -> P (x :: l) (x :: l')) -> (forall (x y : A) (l : list A), P (y :: x :: l) (x :: y :: l)) -> (forall l l' l'' : list A, l ~p l' -> P l l' -> l' ~p l'' -> P l' l'' -> P l l'') -> forall l l0 : list A, l ~p l0 -> P l l0\nExists_ind : forall (A : Type) (P : A -> Prop) (P0 : list A -> Prop), (forall (x : A) (l : list A), P x -> P0 (x :: l)) -> (forall (x : A) (l : list A), Exists P l -> P0 l -> P0 (x :: l)) -> forall l : list A, Exists P l -> P0 l\nForall_Exists_neg : forall (A : Type) (P : A -> Prop) (l : list A), Forall (fun x : A => ~ P x) l < -> ~ Exists P l\nForall_Exists_dec : forall (A : Type) (P : A -> Prop), (forall x : A, {P x} + {~ P x}) -> forall l : list A, {Forall P l} + {Exists (fun x : A => ~ P x) l}\nForall_inv_tail : forall (A : Type) (P : A -> Prop) (a : A) (l : list A), Forall P (a :: l) -> Forall P l\nRingMicromega.Psatz_ind : forall (C : Type) (P : RingMicromega.Psatz C -> Prop), (forall n : nat, P (RingMicromega.PsatzIn C n)) -> (forall p : RingMicromega.PolC C, P (RingMicromega.PsatzSquare p)) -> (forall (p : RingMicromega.PolC C) (p0 : RingMicromega.Psatz C), P p0 -> P (RingMicromega.PsatzMulC p p0)) -> (forall p : RingMicromega.Psatz C, P p -> forall p0 : RingMicromega.Psatz C, P p0 -> P (RingMicromega.PsatzMulE p p0)) -> (forall p : RingMicromega.Psatz C, P p -> forall p0 : RingMicromega.Psatz C, P p0 -> P (RingMicromega.PsatzAdd p p0)) ->...-> forall p : RingMicromega.Psatz C, P p\nlist_injective : forall X : Type, list X -> Prop\nAdd_ind : forall (A : Type) (a : A) (P : list A -> list A -> Prop), (forall l : list A, P l (a :: l)) -> (forall (x : A) (l l' : list A), Add a l l' -> P l l' -> P (x :: l) (x :: l')) -> forall l l0 : list A, Add a l l0 -> P l l0\nForall_nth : forall (A : Type) (P : A -> Prop) (l : list A), Forall P l < -> (forall (i : nat) (d : A), i < length l -> P (nth i l d))\nForall_inv : forall (A : Type) (P : A -> Prop) (a : A) (l : list A), Forall P (a :: l) -> P a"}, {"role": "assistant", "content": "``` \nintros H1 H2.\ninduction H2.\n- constructor.\n- eapply Forall_cons.\n  + apply H1. apply H. \n  + apply IHForall.\n```"}], "original": "intros H1 H2. induction H2. - constructor. - eapply Forall_cons. + apply H1. apply H. + apply IHForall.", "succ": false}]