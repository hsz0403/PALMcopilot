[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nX: Type\nY: Type\nf: X -> Y\nn: nat\nv: Vector.t nat n\ng: pos n -> X\n\nGoal:\nmap f (vec_map_list v g) = vec_map_list v (fun p : pos n => f (g p))\n\nPremises:\nvec_map_list : forall (X : Type) (n : nat), vec nat n -> (pos n -> X) -> list X\nNotation pos := Fin.t\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nmap : forall A B : Type, (A -> B) -> list A -> list B\nvec_map_list_plus : forall (X : Type) (n : nat) (v w : vec nat n) (f : pos n -> X), vec_map_list (vec_plus v w) f ~p vec_map_list v f ++ vec_map_list w f\nvec_nat_induction : forall (n : nat) (P : vec nat n -> Type), P vec_zero -> (forall p : pos n, P (vec_one p)) -> (forall v w : vec nat n, P v -> P w -> P (vec_plus v w)) -> forall v : vec nat n, P v\nmap_ext_in_iff : map ?f ?l = map ?g ?l < -> (forall a : ?A, In a ?l -> ?f a = ?g a) where ?A : [X : Type Y : Type f : X -> Y n : nat v : vec nat n g : pos n -> X |- Type] ?B : [X : Type Y : Type f : X -> Y n : nat v : vec nat n g : pos n -> X |- Type] ?f : [X : Type Y : Type f : X -> Y n : nat v : vec nat n g : pos n -> X |- ?A -> ?B] ?g : [X : Type Y : Type f : X -> Y n : nat v : vec nat n g : pos n -> X |- ?A -> ?B] ?l : [X : Type Y : Type f : X -> Y n : nat v : vec nat n g : pos n -> X |- list ?A]\npos_S_inv : forall p : pos (S ?n), (p = pos0) + {q : pos ?n | p = pos_nxt q} where ?n : [X : Type Y : Type f : X -> Y n : nat v : vec nat n g : pos n -> X |- nat]\nvec_map_list_one : forall (X : Type) (n : nat) (p : pos n) (f : pos n -> X), vec_map_list (vec_one p) f = f p :: nil\nvec_one = fun (n : nat) (p : pos n) => vec_set_pos (fun q : pos n => if pos_eq_dec p q then 1 else 0) : forall n : nat, pos n -> vec nat n Arguments vec_one {n}%nat_scope\nvec_plus = fun (n : nat) (v w : vec nat n) => vec_set_pos (fun p : pos n => (v#>p) + (w#>p)) : forall n : nat, vec nat n -> vec nat n -> vec nat n Arguments vec_plus {n}%nat_scope\nvec_pos_set : forall (X : Type) (n : nat) (g : pos n -> X) (p : pos n), vec_set_pos g#>p = g p\nvec_sum_is_nzero : forall (n : nat) (v : vec nat n), 0 < vec_sum v -> {p : pos n & {w : vec nat n | v = vec_plus (vec_one p) w}}\nvec_map_list_zero : forall (X : Type) (n : nat) (f : pos n -> X), vec_map_list vec_zero f = nil\nvec_pos_ext : forall (X : Type) (n : nat) (v w : vec X n), (forall p : pos n, v#>p = w#>p) -> v = w\nvec_zero = fun n : nat => vec_set_pos (fun _ : pos n => 0) : forall n : nat, vec nat n Arguments vec_zero {n}%nat_scope\nmap_map : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l\nvec_change : forall (X : Type) (n : nat), vec X n -> pos n -> X -> vec X n\nvec_plus_is_zero : forall (n : nat) (u v : vec nat n), vec_zero = vec_plus u v -> u = vec_zero /\\ v = vec_zero\nvec_change_pred : forall (n : nat) (v : vec nat n) (p : pos n) (u : nat), v#>p = S u -> v = vec_plus (vec_one p) (v[u/p])\nvec_sum_is_zero : forall (n : nat) (v : vec nat n), vec_sum v = 0 -> v = vec_zero\npos2nat : forall n : nat, pos n -> nat\nmap_pos_list_vec : forall (X : Type) (n : nat) (f : pos n -> X), map f (pos_list n) = vec_list (vec_set_pos f)\nvec_list_vec_set_pos : forall (X : Type) (n : nat) (f : pos n -> X), vec_list (vec_set_pos f) = map f (pos_list n)\nmap_app_inv : forall (X Y : Type) (f : X -> Y) (ll : list X) (m n : list Y), map f ll = m ++ n -> {l : list X & {r : list X | ll = l ++ r /\\ m = map f l /\\ n = map f r}}\nvec_pos : forall (X : Type) (n : nat), vec X n -> pos n -> X\nflat_map_single : forall (X Y : Type) (f : X -> Y) (l : list X), flat_map (fun x : X => f x :: nil) l = map f l\nForall2_map_both : forall (X Y X' Y' : Type) (R : X -> Y -> Prop) (f : X' -> X) (g : Y' -> Y) (ll : list X') (mm : list Y'), Forall2 R (map f ll) (map g mm) < -> Forall2 (fun (x : X') (y : Y') => R (f x) (g y)) ll mm\nInductive t : nat -> Set := F1 : forall n : nat, pos (S n) | FS : forall n : nat, pos n -> pos (S n) Arguments Fin.t _%nat_scope Arguments Fin.F1 {n}%nat_scope Arguments Fin.FS {n}%nat_scope\nFinFun.bFun = fun (n : nat) (f : nat -> nat) => forall x : nat, x < n -> f x < n : nat -> (nat -> nat) -> Prop Arguments FinFun.bFun _%nat_scope _%function_scope\nnat_bijection_Permutation : forall (n : nat) (f : nat -> nat), FinFun.bFun n f -> FinFun.Injective f -> let l := seq 0 n in map f l ~p l\nvec_change_succ : forall (n : nat) (v : vec nat n) (p : pos n), v[(S (v#>p))/p] = vec_plus (vec_one p) v\npos_nxt_inj : forall (n : nat) (p q : pos n), pos_nxt p = pos_nxt q -> p = q\nmap_ext_Forall : forall (A B : Type) (f g : A -> B) (l : list A), Forall (fun x : A => f x = g x) l -> map f l = map g l\nvec_pos_plus : forall (n : nat) (v w : vec nat n) (p : pos n), vec_plus v w#>p = (v#>p) + (w#>p)\nlist_fun_inv : forall (X : Type) (l : list X), X -> {f : nat -> X | l = map f (list_an 0 (length l))}\nFin.t_ind : forall P : forall n : nat, pos n -> Prop, (forall n : nat, P (S n) pos0) -> (forall (n : nat) (t : pos n), P n t -> P (S n) (pos_nxt t)) -> forall (n : nat) (t : pos n), P n t\nvec_change_eq : forall (X : Type) (n : nat) (v : vec X n) (p q : pos n) (x : X), p = q -> v[x/p]#>q = x\nmap_middle_inv : forall (X Y : Type) (f : X -> Y) (ll : list X) (m : list Y) (y : Y) (n : list Y), map f ll = m ++ y :: n -> {l : list X & {x : X & {r : list X | ll = l ++ x :: r /\\ map f l = m /\\ f x = y /\\ map f r = n}}}\nvec_one_spec_eq : forall (n : nat) (p q : pos n), p = q -> vec_one p#>q = 1\nForall_forall_map : forall (X : Type) (f : nat -> X) (n : nat) (l : list X) (P : X -> Prop), l = map f (list_an 0 n) -> (forall i : nat, i < n -> P (f i)) < -> Forall P l\nvec_head_tail : forall (X : Type) (n : nat) (v : vec X (S n)), v = vec_head v ## vec_tail v\nvec_zero_plus : forall (n : nat) (v : vec nat n), vec_plus vec_zero v = v\nvec_change_neq : forall (X : Type) (n : nat) (v : vec X n) (p q : pos n) (x : X), p <> q -> v[x/p]#>q = v#>q"}, {"role": "assistant", "content": "```  \ninduction v using vec_nat_induction.\n- reflexivity.\n- simpl. rewrite vec_map_list_plus, IHv. f_equal.\n  + apply vec_pos_ext. intro p. destruct (pos_S_inv p) as [Hp|Hp]; subst.\n    * rewrite vec_map_list_one, vec_map_list_one. reflexivity.\n    * rewrite !vec_map_list_one. reflexivity.\n  + apply map_ext_Forall. intros p. apply map_ext_Forall. intros q. apply vec_change_eq. apply pos_nxt_inj.\n```  "}], "original": "induction v using vec_nat_induction. - reflexivity. - simpl. rewrite vec_map_list_plus, IHv. f_equal. + apply vec_pos_ext. intro p. destruct (pos_S_inv p) as [Hp|Hp]; subst. * rewrite vec_map_list_one, vec_map_list_one. reflexivity. * rewrite !vec_map_list_one. reflexivity. + apply map_ext_Forall. intros p. apply map_ext_Forall. intros q. apply vec_change_eq. apply pos_nxt_inj.", "succ": false}]