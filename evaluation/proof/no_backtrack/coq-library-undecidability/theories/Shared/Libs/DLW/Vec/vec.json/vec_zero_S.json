[{"history": {"proof": "reflexivity.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nn: nat\n\nGoal:\nvec_zero = Vector.cons nat 0 n vec_zero\n\nPremises:\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nvec_zero = fun n : nat => vec_set_pos (fun _ : pos n => 0) : forall n : nat, vec nat n Arguments vec_zero {n}%nat_scope\nvec_plus_is_zero : forall (n : nat) (u v : vec nat n), vec_zero = vec_plus u v -> u = vec_zero /\\ v = vec_zero\nvec_zero_plus : forall (n : nat) (v : vec nat n), vec_plus vec_zero v = v\nNdigits.Bv2N = fix Bv2N (n : nat) (bv : Bvector.Bvector n) {struct bv} : BinNums.N := match bv with | vec_nil => BinNums.N0 | Vector.cons _ true n0 bv0 => BinNat.N.succ_double (Bv2N n0 bv0) | Vector.cons _ false n0 bv0 => BinNat.N.double (Bv2N n0 bv0) end : forall n : nat, Bvector.Bvector n -> BinNums.N Arguments Ndigits.Bv2N {n}%nat_scope, _ _\nVectorSpec.take_O : forall (le : 0 <= ?n) (v : vec ?A ?n), VectorDef.take 0 le v = vec_nil where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\ntail_plus = fix tail_plus (n m : nat) {struct n} : nat := match n with | 0 => m | S n0 => tail_plus n0 (S m) end : nat -> nat -> nat Arguments tail_plus (_ _)%nat_scope\nNat.log2_up = fun a : nat => match 1 ?= a with | Lt => S (Nat.log2 (Nat.pred a)) | _ => 0 end : nat -> nat Arguments Nat.log2_up _%nat_scope\nBinIntDef.Z.of_nat = fun n : nat => match n with | 0 => BinNums.Z0 | S n0 => BinNums.Zpos (BinPos.Pos.of_succ_nat n0) end : nat -> BinNums.Z Arguments BinIntDef.Z.of_nat _%nat_scope\nString.length = fix length (s : String.string) : nat := match s with | String.EmptyString => 0 | String.String _ s' => S (length s') end : String.string -> nat Arguments String.length _%string_scope\nVectorDef.case0 : forall P : vec ?A 0 -> Type, P vec_nil -> forall v : vec ?A 0, P v where ?A : [n : nat |- Type]\ncase0 : forall P : vec ?A 0 -> Type, P vec_nil -> forall v : vec ?A 0, P v where ?A : [n : nat |- Type]\nInductive t (A : Type) : nat -> Type := nil : vec A 0 | cons : A -> forall n : nat, vec A n -> vec A (S n) Arguments VectorDef.t _%type_scope _%nat_scope Arguments VectorDef.nil _%type_scope Arguments VectorDef.cons _%type_scope _ _%nat_scope\nvec_plus = fun (n : nat) (v w : vec nat n) => vec_set_pos (fun p : pos n => (v#>p) + (w#>p)) : forall n : nat, vec nat n -> vec nat n -> vec nat n Arguments vec_plus {n}%nat_scope\npos_O_inv = let pos_inv_t := fun n : nat => match n as x return (pos x -> Set) with | 0 => fun _ : pos 0 => False | S n0 => fun i : pos (S n0) => ((i = pos0) + {p : pos n0 | i = pos_nxt p})%type end in let pos_inv := fun (_tmp : nat) (p0 : pos _tmp) => match p0 as t in (pos n) return (pos_inv_t n t) with | @Fin.F1 n => inl eq_refl | @Fin.FS n p => inr (exist (fun p1 : pos n => pos_nxt p = pos_nxt p1) p eq_refl) end in pos_inv 0 : pos 0 -> False\nByteVector.to_Bvector = fix to_Bvector (n : nat) (v : ByteVector.ByteVector n) {struct v} : Bvector.Bvector (n * 8) := match v in (vec _ n0) return (Bvector.Bvector (n0 * 8)) with | vec_nil => vec_nil | Vector.cons _ (Ascii.Ascii b0 b1 b2 b3 b4 b5 b6 b7) n0 v' => b0 ## b1 ## b2 ## b3 ## b4 ## b5 ## b6 ## b7 ## to_Bvector n0 v' end : forall n : nat, ByteVector.ByteVector n -> Bvector.Bvector (n * 8) Arguments ByteVector.to_Bvector {n}%nat_scope\nVectorSpec.splitat_append : forall (v : vec ?A ?n) (w : vec ?A ?m), VectorDef.splitat ?n (VectorDef.append v w) = (v, w) where ?A : [n : nat |- Type] ?n : [n : nat |- nat] ?m : [n : nat |- nat]\nminus_n_O : forall n : nat, n = n - 0\nVectorDef.map2 : (?A -> ?B -> ?C) -> forall n0 : nat, vec ?A n0 -> vec ?B n0 -> vec ?C n0 where ?A : [n : nat |- Type] ?B : [n : nat |- Type] ?C : [n : nat |- Type]\nvec_map2 : (?A -> ?B -> ?C) -> forall n0 : nat, vec ?A n0 -> vec ?B n0 -> vec ?C n0 where ?A : [n : nat |- Type] ?B : [n : nat |- Type] ?C : [n : nat |- Type]\nNat.nle_succ_0 : forall n : nat, ~ S n <= 0\nVectorDef.rect2 : forall P : forall n0 : nat, vec ?A n0 -> vec ?B n0 -> Type, P 0 vec_nil vec_nil -> (forall (n0 : nat) (v1 : vec ?A n0) (v2 : vec ?B n0), P n0 v1 v2 -> forall (a : ?A) (b : ?B), P (S n0) (a ## v1) (b ## v2)) -> forall (n0 : nat) (v1 : vec ?A n0) (v2 : vec ?B n0), P n0 v1 v2 where ?A : [n : nat |- Type] ?B : [n : nat |- Type]\nrect2 : forall P : forall n0 : nat, vec ?A n0 -> vec ?B n0 -> Type, P 0 vec_nil vec_nil -> (forall (n0 : nat) (v1 : vec ?A n0) (v2 : vec ?B n0), P n0 v1 v2 -> forall (a : ?A) (b : ?B), P (S n0) (a ## v1) (b ## v2)) -> forall (n0 : nat) (v1 : vec ?A n0) (v2 : vec ?B n0), P n0 v1 v2 where ?A : [n : nat |- Type] ?B : [n : nat |- Type]\nVectorDef.fold_right2 : (?A -> ?B -> ?C -> ?C) -> ?C -> forall n0 : nat, vec ?A n0 -> vec ?B n0 -> ?C where ?A : [n : nat |- Type] ?B : [n : nat |- Type] ?C : [n : nat |- Type]\nVectorDef.fold_left2 : (?A -> ?B -> ?C -> ?A) -> ?A -> forall n0 : nat, vec ?B n0 -> vec ?C n0 -> ?A where ?A : [n : nat |- Type] ?B : [n : nat |- Type] ?C : [n : nat |- Type]\nVectorSpec.append_comm_cons : forall (v : vec ?A ?n) (w : vec ?A ?m) (a : ?A), a ## VectorDef.append v w = VectorDef.append (a ## v) w where ?A : [n : nat |- Type] ?n : [n : nat |- nat] ?m : [n : nat |- nat]\nFin.of_nat_ext : forall h h' : ?p < ?n, Fin.of_nat_lt h = Fin.of_nat_lt h' where ?p : [n : nat |- nat] ?n : [n : nat |- nat]\nVectorDef.nth_order : vec ?A ?n -> forall p : nat, p < ?n -> ?A where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\nByteVector.ByteNil = vec_nil : ByteVector.ByteVector 0\nVectorSpec.eta : forall v : vec ?A (S ?n), v = VectorDef.hd v ## VectorDef.tl v where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\nVectorSpec.append_splitat : forall (v : vec ?A ?n) (w : vec ?A ?m) (vw : vec ?A (?n + ?m)), VectorDef.splitat ?n vw = (v, w) -> vw = VectorDef.append v w where ?A : [n : nat |- Type] ?n : [n : nat |- nat] ?m : [n : nat |- nat]\nVectorEq.cast : vec ?A ?m -> forall n0 : nat, ?m = n0 -> vec ?A n0 where ?A : [n : nat |- Type] ?m : [n : nat |- nat]\nVectorDef.map : (?A -> ?B) -> forall n0 : nat, vec ?A n0 -> vec ?B n0 where ?A : [n : nat |- Type] ?B : [n : nat |- Type]\nVectorDef.take : forall p : nat, p <= ?n -> vec ?A ?n -> vec ?A p where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\nVectorSpec.uncons_cons : forall (a : ?A) (v : vec ?A ?n), VectorDef.uncons (a ## v) = (a, v) where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\nBvector.Bnil = vec_nil : vec bool 0\nRingMicromega.PsatzIn : forall C : Type, nat -> RingMicromega.Psatz C\nVectorDef.fold_right : (?A -> ?B -> ?B) -> forall n0 : nat, vec ?A n0 -> ?B -> ?B where ?A : [n : nat |- Type] ?B : [n : nat |- Type]\nVectorDef.replace_order : vec ?A ?n -> forall p : nat, p < ?n -> ?A -> vec ?A ?n where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\nVectorDef.trunc : forall p : nat, ?n > p -> vec ?A ?n -> vec ?A (?n - p) where ?A : [n : nat |- Type] ?n : [n : nat |- nat]\nVectorDef.fold_left : (?B -> ?A -> ?B) -> ?B -> forall n0 : nat, vec ?A n0 -> ?B where ?A : [n : nat |- Type] ?B : [n : nat |- Type]\nBvector.Bvector = vec bool : nat -> Set Arguments Bvector.Bvector _%nat_scope"}, {"role": "assistant", "content": "``` \nreflexivity.\n```"}], "original": "reflexivity.", "succ": true}]