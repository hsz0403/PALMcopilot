[{"history": {"proof": "induction x. - reflexivity. - rewrite <- bin_add_eq_00x. reflexivity.", "repairs": ["", "", "", "", "", ""], "exceptions": [{"ctx": ["induction x.", "-"], "tactic": "rewrite bin_add_eq_00x.", "exn": "Found no subterm matching \"bin_add \u27d8 \u27d8 ?M1518\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nx: bool\n\nGoal:\nbin_add \u27d8 x \u27d8 = (\u27d8, x)\n\nPremises:\nInductive bool : Set := true : bool | false : bool\nNotation bin_add := bool_add_with_rem\nbin_add_eq_00x : forall x : bool, bin_add \u27d8 \u27d8 x = (\u27d8, x)\nbool_add_with_rem = fun a b c : bool => if a then if b then if c then (\u27d9, \u27d9) else (\u27d9, \u27d8) else if c then (\u27d9, \u27d8) else (\u27d8, \u27d9) else if b then if c then (\u27d9, \u27d8) else (\u27d8, \u27d9) else if c then (\u27d8, \u27d9) else (\u27d8, \u27d8) : bool -> bool -> bool -> bool * bool Arguments bool_add_with_rem (_ _ _)%bool_scope\npartition_cons2 : forall (A : Type) (f : A -> bool) (a : A) (l l1 l2 : list A), partition f l = (l1, l2) -> f a = \u27d8 -> partition f (a :: l) = (l1, a :: l2)\nInductive ascii : Set := Ascii : bool -> bool -> bool -> bool -> bool -> bool -> bool -> bool -> Ascii.ascii Arguments Ascii.Ascii (_ _ _ _ _ _ _ _)%bool_scope\nVectorSpec.splitat_append : forall (v : VectorDef.t ?A ?n) (w : VectorDef.t ?A ?m), VectorDef.splitat ?n (VectorDef.append v w) = (v, w) where ?A : [x : bool |- Type] ?n : [x : bool |- nat] ?m : [x : bool |- nat]\nVectorSpec.uncons_cons : forall (a : ?A) (v : VectorDef.t ?A ?n), VectorDef.uncons (VectorDef.cons ?A a ?n v) = (a, v) where ?A : [x : bool |- Type] ?n : [x : bool |- nat]\nBinInt.Z.le = fun x y : BinNums.Z => BinInt.Z.compare x y <> Gt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.le (_ _)%Z_scope\ndiv2 = fix div2 (n : nat) : nat * bool := match n with | 0 => (0, \u27d8) | 1 => (0, \u27d9) | S (S n1) => let (p, b) := div2 n1 in (S p, b) end : nat -> nat * bool Arguments div2 _%nat_scope\nBinIntDef.Z.add = fun x y : BinNums.Z => match x with | BinNums.Z0 => y | BinNums.Zpos x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.add x' y') | BinNums.Zneg y' => BinIntDef.Z.pos_sub x' y' end | BinNums.Zneg x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinIntDef.Z.pos_sub y' x' | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.add x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.add (_ _)%Z_scope\nVectorDef.splitat : forall l r : nat, VectorDef.t ?A (l + r) -> VectorDef.t ?A l * VectorDef.t ?A r where ?A : [x : bool |- Type]\nInductive symprod (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) : A * B -> A * B -> Prop := left_sym : forall x x' : A, leA x x' -> forall y : B, Relation_Operators.symprod A B leA leB (x, y) (x', y) | right_sym : forall y y' : B, leB y y' -> forall x : A, Relation_Operators.symprod A B leA leB (x, y) (x, y') Arguments Relation_Operators.symprod (_ _)%type_scope (_ _)%function_scope Arguments Relation_Operators.left_sym (_ _)%type_scope (_ _)%function_scope Arguments Relation_Operators.right_sym (_ _)%type_scope (_ _)%function_scope\nLexicographic_Product.Acc_swapprod : forall (A : Type) (R : A -> A -> Prop) (x y : A), Acc R x -> Acc R y -> Acc (Relation_Operators.swapprod A R) (x, y)\nZMicromega.ZTautoChecker = fun (f : Tauto.BFormula (RingMicromega.Formula BinNums.Z)) (w : list ZMicromega.ZArithProof) => Tauto.tauto_checker ZMicromega.Zunsat ZMicromega.Zdeduce ZMicromega.normalise ZMicromega.negate (fun cl : list (RingMicromega.NFormula BinNums.Z * unit) => ZMicromega.ZChecker (map fst cl)) f w : Tauto.BFormula (RingMicromega.Formula BinNums.Z) -> list ZMicromega.ZArithProof -> bool Arguments ZMicromega.ZTautoChecker _ _%list_scope\nBinIntDef.Z.mul = fun x y : BinNums.Z => match x with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos x' => match y with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.mul x' y') | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.mul x' y') end | BinNums.Zneg x' => match y with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos y' => BinNums.Zneg (BinPos.Pos.mul x' y') | BinNums.Zneg y' => BinNums.Zpos (BinPos.Pos.mul x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.mul (_ _)%Z_scope\nRelation_Operators.right_sym : forall (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) (y y' : B), leB y y' -> forall x : A, Relation_Operators.symprod A B leA leB (x, y) (x, y')\nRelation_Operators.left_sym : forall (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) (x x' : A), leA x x' -> forall y : B, Relation_Operators.symprod A B leA leB (x, y) (x', y)\nLexicographic_Product.Acc_symprod : forall (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) (x : A), Acc leA x -> forall y : B, Acc leB y -> Acc (Relation_Operators.symprod A B leA leB) (x, y)\npartition : forall A : Type, (A -> bool) -> list A -> list A * list A\nVectorDef.cons : forall A : Type, A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n)\nZnat.Nat2Z.inj_mul : forall n m : nat, BinInt.Z.of_nat (n * m) = BinInt.Z.mul (BinInt.Z.of_nat n) (BinInt.Z.of_nat m)\nZMicromega.ZTautoChecker_sound : forall (f : Tauto.BFormula (RingMicromega.Formula BinNums.Z)) (w : list ZMicromega.ZArithProof), ZMicromega.ZTautoChecker f w = \u27d9 -> forall env : RingMicromega.PolEnv BinNums.Z, Tauto.eval_bf (ZMicromega.Zeval_formula env) f\nInductive positive : Set := xI : BinNums.positive -> BinNums.positive | xO : BinNums.positive -> BinNums.positive | xH : BinNums.positive Arguments BinNums.xI _%positive_scope Arguments BinNums.xO _%positive_scope\nVectorDef.t_ind : forall (A : Type) (P : forall n : nat, VectorDef.t A n -> Prop), P 0 (VectorDef.nil A) -> (forall (h : A) (n : nat) (t : VectorDef.t A n), P n t -> P (S n) (VectorDef.cons A h n t)) -> forall (n : nat) (t : VectorDef.t A n), P n t\nInductive swapprod (A : Type) (R : A -> A -> Prop) : A * A -> A * A -> Prop := sp_noswap : forall (x y : A) (p : A * A), Relation_Operators.symprod A A R R (x, y) p -> Relation_Operators.swapprod A R (x, y) p | sp_swap : forall (x y : A) (p : A * A), Relation_Operators.symprod A A R R (x, y) p -> Relation_Operators.swapprod A R (y, x) p Arguments Relation_Operators.swapprod _%type_scope _%function_scope Arguments Relation_Operators.sp_noswap _%type_scope _%function_scope Arguments Relation_Operators.sp_swap _%type_scope _%function_scope\nsplit_nth : forall (A B : Type) (l : list (A * B)) (n : nat) (d : A * B), nth n l d = (nth n (fst (split l)) (fst d), nth n (snd (split l)) (snd d))\nZnat.Nat2Z.inj_iff : forall n m : nat, BinInt.Z.of_nat n = BinInt.Z.of_nat m < -> n = m\nVarMap.find : forall A : Type, A -> VarMap.t A -> BinNums.positive -> A\ncombine_nth : forall (A B : Type) (l : list A) (l' : list B) (n : nat) (x : A) (y : B), length l = length l' -> nth n (combine l l') (x, y) = (nth n l x, nth n l' y)\nInductive Z : Set := Z0 : BinNums.Z | Zpos : BinNums.positive -> BinNums.Z | Zneg : BinNums.positive -> BinNums.Z Arguments BinNums.Zpos _%positive_scope Arguments BinNums.Zneg _%positive_scope\nVectorDef.uncons = fun (A : Type) (n : nat) (v : VectorDef.t A (S n)) => (VectorDef.hd v, VectorDef.tl v) : forall (A : Type) (n : nat), VectorDef.t A (S n) -> A * VectorDef.t A n Arguments VectorDef.uncons {A}%type_scope {n}%nat_scope\nRingMicromega.Build_Formula : forall T : Type, EnvRing.PExpr T -> RingMicromega.Op2 -> EnvRing.PExpr T -> RingMicromega.Formula T\ndiv2_2p0 : forall p : nat, div2 (2 * p) = (p, \u27d8)\nBinIntDef.Z.of_nat = fun n : nat => match n with | 0 => BinNums.Z0 | S n0 => BinNums.Zpos (BinPos.Pos.of_succ_nat n0) end : nat -> BinNums.Z Arguments BinIntDef.Z.of_nat _%nat_scope\nAscii.byte_of_ascii = fun a : Ascii.ascii => let (b0, b1, b2, b3, b4, b5, b6, b7) := a in Byte.of_bits (b0, (b1, (b2, (b3, (b4, (b5, (b6, b7))))))) : Ascii.ascii -> Byte.byte Arguments Ascii.byte_of_ascii _%char_scope\nZifyClasses.mkrel : forall (S T : Type) (R : S -> S -> Prop) (I : S -> T) (TR : T -> T -> Prop), (forall n m : S, R n m <-> TR (I n) (I m)) -> forall (s1 : S) (t1 : T), I s1 = t1 -> forall (s2 : S) (t2 : T), I s2 = t2 -> R s1 s2 < -> TR t1 t2\nInductive t (A : Type) : Type := Empty : VarMap.t A | Elt : A -> VarMap.t A | Branch : VarMap.t A -> A -> VarMap.t A -> VarMap.t A Arguments VarMap.t _%type_scope Arguments VarMap.Empty {A}%type_scope Arguments VarMap.Elt {A}%type_scope Arguments VarMap.Branch {A}%type_scope\nRecord Formula (T : Type) : Type := Build_Formula { Flhs : EnvRing.PExpr T; Fop : RingMicromega.Op2; Frhs : EnvRing.PExpr T } Arguments RingMicromega.Formula _%type_scope Arguments RingMicromega.Build_Formula [T]%type_scope\nInductive ZArithProof : Type := DoneProof : ZMicromega.ZArithProof | RatProof : ZMicromega.ZWitness -> ZMicromega.ZArithProof -> ZMicromega.ZArithProof | CutProof : ZMicromega.ZWitness -> ZMicromega.ZArithProof -> ZMicromega.ZArithProof | EnumProof : ZMicromega.ZWitness -> ZMicromega.ZWitness -> list ZMicromega.ZArithProof -> ZMicromega.ZArithProof | ExProof : BinNums.positive -> ZMicromega.ZArithProof -> ZMicromega.ZArithProof Arguments ZMicromega.EnumProof _ _ _%list_scope Arguments ZMicromega.ExProof _%positive_scope\nRelation_Operators.sp_noswap : forall (A : Type) (R : A -> A -> Prop) (x y : A) (p : A * A), Relation_Operators.symprod A A R R (x, y) p -> Relation_Operators.swapprod A R (x, y) p\nInductive t (A : Type) : nat -> Type := nil : VectorDef.t A 0 | cons : A -> forall n : nat, VectorDef.t A n -> VectorDef.t A (S n) Arguments VectorDef.t _%type_scope _%nat_scope Arguments VectorDef.nil _%type_scope Arguments VectorDef.cons _%type_scope _ _%nat_scope"}, {"role": "assistant", "content": "``` \ninduction x.\n- rewrite bin_add_eq_00x. reflexivity.\n- rewrite <- bin_add_eq_00x. reflexivity.\n```"}], "original": "induction x. - rewrite bin_add_eq_00x. reflexivity. - rewrite <- bin_add_eq_00x. reflexivity.", "succ": true}]