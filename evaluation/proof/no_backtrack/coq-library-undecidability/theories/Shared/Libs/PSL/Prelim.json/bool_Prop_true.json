[{"history": {"proof": "intros H. apply H.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nb: bool\n\nGoal:\nb = true -> b\n\nPremises:\nInductive bool : Set := true : bool | false : bool\neq_true_not_negb : forall b : bool, b <> true -> negb b = true\niff_reflect : forall (P : Prop) (b : bool), P < -> b = true -> reflect P b\nssrbool.implyP = fun b1 b2 : bool => if b1 as b return (reflect (b -> b2) (implb b b2)) then if b2 as b return (reflect (true -> b) (implb true b)) then ReflectT (true -> true) (fun H : true => H) else ReflectF (true -> false) (fun H : true -> false => ssrbool.not_false_is_true (H ssrbool.is_true_true)) else if b2 as b return (reflect (false -> b) (implb false b)) then ReflectT (false -> true) (fun _ : false => ssrbool.is_true_true) else ReflectT (false -> false) (fun H : false => H) : forall b1 b2 : bool, reflect (b1 -> b2) (implb b1 b2) Arguments ssrbool.implyP {b1 b2}%bool_scope\nVariant alt_spec (P : Prop) (b : bool) : bool -> Set := AltTrue : P -> ssrbool.alt_spec P b true | AltFalse : negb b -> ssrbool.alt_spec P b false Arguments ssrbool.alt_spec _%type_scope (_ _)%bool_scope Arguments ssrbool.AltTrue [P]%type_scope _%bool_scope Arguments ssrbool.AltFalse _%type_scope [b]%bool_scope\nssrbool.IfSpecTrue : forall (A : Type) (b : bool) (vT vF : A) (not_b : Prop), b -> ssrbool.if_spec b vT vF not_b true vT\nVariant if_spec (A : Type) (b : bool) (vT vF : A) (not_b : Prop) : bool -> A -> Set := IfSpecTrue : b -> ssrbool.if_spec b vT vF not_b true vT | IfSpecFalse : not_b -> ssrbool.if_spec b vT vF not_b false vF Arguments ssrbool.if_spec [A]%type_scope _%bool_scope _ _ _%type_scope _%bool_scope Arguments ssrbool.IfSpecTrue [A]%type_scope [b]%bool_scope _ _ _%type_scope Arguments ssrbool.IfSpecFalse [A]%type_scope _%bool_scope _ _ [not_b]%type_scope\nssrbool.AltTrue : forall (P : Prop) (b : bool), P -> ssrbool.alt_spec P b true\nssrbool.andb_id2l : forall a b c : bool, (a -> b = c) -> a && b = a && c\nssrbool.implyb_id2l : forall a b c : bool, (a -> b = c) -> implb a b = implb a c\nssrbool.andb_id2r : forall a b c : bool, (b -> a = c) -> a && b = c && b\nssrbool.andb_idl : forall a b : bool, (b -> a) -> a && b = b\nssrbool.orb_idl : forall a b : bool, (a -> b) -> a || b = b\nssrbool.implyb_idl : forall a b : bool, (negb a -> b) -> implb a b = b\nssrbool.contraFF : forall c b : bool, (c -> b) -> b = false -> c = false\nssrbool.prop_congr : forall b b' : bool, b = b' -> b = b'\nssrbool.contraTF : forall c b : bool, (c -> negb b) -> b -> c = false\nssrbool.contraFN : forall c b : bool, (c -> b) -> b = false -> negb c\nssrbool.contraNF : forall c b : bool, (c -> b) -> negb b -> c = false\nssrbool.contraFT : forall c b : bool, (negb c -> b) -> b = false -> c\nssrbool.negbT : forall b : bool, b = false -> negb b\nssrbool.negbFE : forall b : bool, negb b = false -> b\nssrbool.negbTE : forall b : bool, negb b -> b = false\nssrbool.andb_idr : forall a b : bool, (a -> b) -> a && b = a\nssrbool.orb_idr : forall a b : bool, (b -> a) -> a || b = a\nssrbool.classically = fun P : Type => forall b : bool, (P -> b) -> b : Type -> Prop Arguments ssrbool.classically _%type_scope\nssrbool.implyb_idr : forall a b : bool, (b -> negb a) -> implb a b = negb a\nssrbool.wlog_neg : forall b : bool, (negb b -> b) -> b\nssrbool.contraT : forall b : bool, (negb b -> false) -> b\nssrbool.introTF : forall (P : Prop) (b c : bool), reflect P b -> (if c then P else ~ P) -> b = c\nssrbool.elimTF : forall (P : Prop) (b c : bool), reflect P b -> b = c -> if c then P else ~ P\nssrbool.contraL : forall c b : bool, (c -> negb b) -> b -> negb c\nssrbool.contraNT : forall c b : bool, (negb c -> b) -> negb b -> c\nssrbool.contraNN : forall c b : bool, (c -> b) -> negb b -> negb c\nssrbool.contra : forall c b : bool, (c -> b) -> negb b -> negb c\nssrbool.contraLR : forall c b : bool, (negb c -> negb b) -> b -> c\nssrbool.contraR : forall c b : bool, (negb c -> b) -> negb b -> c\nssrbool.contraTT : forall c b : bool, (negb c -> negb b) -> b -> c\nssrbool.contraTN : forall c b : bool, (c -> negb b) -> b -> negb c\nIs_true = fun b : bool => if b then True else False : bool -> Prop Arguments Is_true _%bool_scope\nssrbool.idP = fun b1 : bool => if b1 as b return (reflect b b) then ReflectT true ssrbool.is_true_true else ReflectF false ssrbool.not_false_is_true : forall b1 : bool, reflect b1 b1 Arguments ssrbool.idP {b1}%bool_scope"}, {"role": "assistant", "content": "``` \nintros H.\nexact H.\n```"}], "original": "intros H. apply H.", "succ": true}]