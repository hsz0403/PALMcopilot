[{"history": {"proof": "simpl. reflexivity.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nn: nat\nx: pos n\ni: nat\n\nGoal:\nlength empty_stack = 3\n\nPremises:\nNotation pos := Fin.t\nlength : forall A : Type, list A -> nat\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nempty_stack = POP x i (3 + i) :: PUSH x Zero :: POP x i i :: nil : list (bsm_instr n)\npartition_length : forall (A : Type) (f : A -> bool) (l l1 l2 : list A), partition f l = (l1, l2) -> length l = length l1 + length l2\nlist_app_inj : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 /\\ r1 = r2\napp_length : forall (A : Type) (l l' : list A), length (l ++ l') = length l + length l'\nnth_ext : forall (A : Type) (l l' : list A) (d d' : A), length l = length l' -> (forall n : nat, n < length l -> nth n l d = nth n l' d') -> l = l'\npos_S_inv : forall p : pos (S ?n), (p = pos0) + {q : pos ?n | p = pos_nxt q} where ?n : [n : nat x : pos n i : nat |- nat]\nrev_length : forall (A : Type) (l : list A), length (rev l) = length l\ncombine_split : forall (A B : Type) (l : list A) (l' : list B), length l = length l' -> split (combine l l') = (l, l')\nprod_length : forall (A B : Type) (l : list A) (l' : list B), length (list_prod l l') = length l * length l'\nsplit_length_r : forall (A B : Type) (l : list (A * B)), length (snd (split l)) = length l\nPermutation.Permutation_length : forall (A : Type) (l l' : list A), l ~p l' -> length l = length l'\nsplit_length_l : forall (A B : Type) (l : list (A * B)), length (fst (split l)) = length l\nFin.cast : pos ?m -> forall n0 : nat, ?m = n0 -> pos n0 where ?m : [n : nat x : pos n i : nat |- nat]\nlength_nil : forall X : Type, length nil = 0\nlength_zero_iff_nil : forall (A : Type) (l : list A), length l = 0 < -> l = nil\nskipn_length : forall (A : Type) (n : nat) (l : list A), length (skipn n l) = length l - n\nvec_one_spec_eq : forall (n : nat) (p q : pos n), p = q -> vec_one p#>q = 1\npos_list_length : forall n : nat, length (pos_list n) = n\nvec_pos_set : forall (X : Type) (n : nat) (g : pos n -> X) (p : pos n), vec_set_pos g#>p = g p\nmap_length : forall (A B : Type) (f : A -> B) (l : list A), length (map f l) = length l\nfirstn_length_le : forall (A : Type) (l : list A) (n : nat), n <= length l -> length (firstn n l) = n\npos_O_inv = let pos_inv_t := fun n : nat => match n as x return (pos x -> Set) with | 0 => fun _ : pos 0 => False | S n0 => fun i : pos (S n0) => ((i = pos0) + {p : pos n0 | i = pos_nxt p})%type end in let pos_inv := fun (_tmp : nat) (p0 : pos _tmp) => match p0 as t in (pos n) return (pos_inv_t n t) with | @Fin.F1 n => inl eq_refl | @Fin.FS n p => inr (exist (fun p1 : pos n => pos_nxt p = pos_nxt p1) p eq_refl) end in pos_inv 0 : pos 0 -> False\nlist_split_length : forall (X : Type) (ll : list X) (k : nat), k <= length ll -> {l : list X & {r : list X | ll = l ++ r /\\ length l = k}}\nlist_an_length : forall a n : nat, length (list_an a n) = n\nseq_length : forall len start : nat, length (seq start len) = len\nvec_sum_one : forall (n : nat) (p : pos n), vec_sum (vec_one p) = 1\nvec_one = fun (n : nat) (p : pos n) => vec_set_pos (fun q : pos n => if pos_eq_dec p q then 1 else 0) : forall n : nat, pos n -> vec nat n Arguments vec_one {n}%nat_scope\nPermutation.Permutation_nth_error : forall (A : Type) (l l' : list A), l ~p l' < -> length l = length l' /\\ (exists f : nat -> nat, FinFun.Injective f /\\ (forall n : nat, nth_error l' n = nth_error l (f n)))\nnth_split : forall (A : Type) (n : nat) (l : list A) (d : A), n < length l -> exists l1 l2 : list A, l = l1 ++ nth n l d :: l2 /\\ length l1 = n\nlist_pick : forall (X : Type) (ll : list X) (k : nat), k < length ll -> {x : X & {l : list X & {r : list X | ll = l ++ x :: r /\\ length l = k}}}\npos2nat_nxt : forall (n : nat) (p : pos n), pos2nat (pos_nxt p) = S (pos2nat p)\nnth_error_app2 : forall (A : Type) (l l' : list A) (n : nat), length l <= n -> nth_error (l ++ l') n = nth_error l' (n - length l)\ncombine_nth : forall (A B : Type) (l : list A) (l' : list B) (n : nat) (x : A) (y : B), length l = length l' -> nth n (combine l l') (x, y) = (nth n l x, nth n l' y)\nvec_one_nxt : forall (n : nat) (p : pos n), vec_one (pos_nxt p) = 0 ## vec_one p\npos_eq_dec : forall (n : nat) (x y : pos n), {x = y} + {x <> y}\nrepeat_length : forall (A : Type) (x : A) (n : nat), length (repeat x n) = n\nlist_repeat_length : forall (X : Type) (x : X) (n : nat), length (list_repeat x n) = n\nvec_list_length : forall (X : Type) (n : nat) (v : vec X n), length (vec_list v) = n\nlength_cons : forall (X : Type) (x : X) (l : list X), length (x :: l) = S (length l)\nnth_error_split : forall (A : Type) (l : list A) (n : nat) (a : A), nth_error l n = Some a -> exists l1 l2 : list A, l = l1 ++ a :: l2 /\\ length l1 = n\nfirstn_length : forall (A : Type) (n : nat) (l : list A), length (firstn n l) = Init.Nat.min n (length l)"}, {"role": "assistant", "content": "``` \nsimpl. reflexivity.\n```"}], "original": "simpl. reflexivity.", "succ": true}]