[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": [{"ctx": [], "tactic": "constructor.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\n\n\nGoal:\ndiscrete bool\n\nPremises:\ndiscrete = fun X : Type => decidable (fun '(x, y) => x = y) : Type -> Prop Arguments discrete _%type_scope\nInductive bool : Set := true : bool | false : bool\ndiscrete_iff : forall X : Type, discrete X < -> inhabited (eq_dec X)\nInductive ascii : Set := Ascii : bool -> bool -> bool -> bool -> bool -> bool -> bool -> bool -> Ascii.ascii Arguments Ascii.Ascii (_ _ _ _ _ _ _ _)%bool_scope\nBool.lt = fun b1 b2 : bool => if b1 then False else b2 = true : bool -> bool -> Prop Arguments Bool.lt (_ _)%bool_scope\nBvector.BshiftL : forall n : nat, Bvector.Bvector (S n) -> bool -> Vector.t bool (S n)\nPeanoNat.Nat.b2n = fun b : bool => if b then 1 else 0 : bool -> nat Arguments PeanoNat.Nat.b2n _%bool_scope\nBinInt.Z.b2z = fun b : bool => if b then BinNums.Zpos BinNums.xH else BinNums.Z0 : bool -> BinNums.Z Arguments BinInt.Z.b2z _%bool_scope\nBinNat.N.b2n = fun b : bool => if b then BinNums.Npos BinNums.xH else BinNums.N0 : bool -> BinNums.N Arguments BinNat.N.b2n _%bool_scope\nInitialRing.NotConstant = false : bool\nssrbool.orbAC = fun __top_assumption_ : bool => (fun (_evar_0_ : (fun b : bool => forall y z : bool, (b || y || z)%bool = (b || z || y)%bool) true) (_evar_0_0 : (fun b : bool => forall y z : bool, (b || y || z)%bool = (b || z || y)%bool) false) => if __top_assumption_ as b return ((fun b0 : bool => forall y z : bool, (b0 || y || z)%bool = (b0 || z || y)%bool) b) then _evar_0_ else _evar_0_0) (fun __top_assumption_0 : bool => (fun (_evar_0_ : (fun b : bool => forall z : bool, (true || b || z)%bool = (true || z || b)%bool) true) (_evar_0_0 : (fun b : bool => forall z : bool, (true || b || z)%bool = (true || z || b)%bool)...\nBvector.Bvector = Vector.t bool : nat -> Set Arguments Bvector.Bvector _%nat_scope\nList.existsb : forall A : Type, (A -> bool) -> list A -> bool\nssrbool.simpl_pred = fun T : Type => ssrfun.simpl_fun T bool : Type -> Type Arguments ssrbool.simpl_pred _%type_scope\nRingMicromega.cneqb : forall C : Type, (C -> C -> bool) -> C -> C -> bool\nssrbool.pred = fun T : Type => T -> bool : Type -> Type Arguments ssrbool.pred _%type_scope\nssreflect.not_locked_false_eq_true = (fun _evar_0_ : (fun u : unit => (let 'tt := u in fun x : bool => x) false <> true) tt => match ssreflect.master_key as u return ((fun u0 : unit => (let 'tt := u0 in fun x : bool => x) false <> true) u) with | tt => _evar_0_ end) (fun H : false = true => let H0 : False := eq_ind false (fun e : bool => if e then False else True) I true H in False_ind False H0) : ssreflect.locked false <> true\nRingMicromega.check_inconsistent : forall C : Type, C -> (C -> C -> bool) -> (C -> C -> bool) -> RingMicromega.NFormula C -> bool\nSumbool.bool_eq_rec : forall (b : bool) (P : bool -> Set), (b = true -> P true) -> (b = false -> P false) -> P b\nBinPosDef.Pos.leb = fun x y : BinNums.positive => match BinPosDef.Pos.compare x y with | Gt => false | _ => true end : BinNums.positive -> BinNums.positive -> bool Arguments BinPosDef.Pos.leb (_ _)%positive_scope\nBinNatDef.N.leb = fun x y : BinNums.N => match BinNatDef.N.compare x y with | Gt => false | _ => true end : BinNums.N -> BinNums.N -> bool Arguments BinNatDef.N.leb (_ _)%N_scope\nBinNatDef.N.ltb = fun x y : BinNums.N => match BinNatDef.N.compare x y with | Lt => true | _ => false end : BinNums.N -> BinNums.N -> bool Arguments BinNatDef.N.ltb (_ _)%N_scope\nBinPosDef.Pos.ltb = fun x y : BinNums.positive => match BinPosDef.Pos.compare x y with | Lt => true | _ => false end : BinNums.positive -> BinNums.positive -> bool Arguments BinPosDef.Pos.ltb (_ _)%positive_scope\nBinNatDef.N.testbit = fun a n : BinNums.N => match a with | BinNums.N0 => false | BinNums.Npos p => BinPos.Pos.testbit p n end : BinNums.N -> BinNums.N -> bool Arguments BinNatDef.N.testbit (_ _)%N_scope\nBinIntDef.Z.even = fun z : BinNums.Z => match z with | BinNums.Z0 | BinNums.Zpos (BinNums.xO _) | BinNums.Zneg (BinNums.xO _) => true | _ => false end : BinNums.Z -> bool Arguments BinIntDef.Z.even _%Z_scope\nssrbool.in_mem = fun (T : Type) (x : T) (mp : ssrbool.mem_pred T) => ssrbool.pred_of_mem mp x : forall T : Type, T -> ssrbool.mem_pred T -> bool Arguments ssrbool.in_mem {T}%type_scope : simpl never\nBinIntDef.Z.odd = fun z : BinNums.Z => match z with | BinNums.Z0 | BinNums.Zpos (BinNums.xO _) | BinNums.Zneg (BinNums.xO _) => false | _ => true end : BinNums.Z -> bool Arguments BinIntDef.Z.odd _%Z_scope\nInductive reflect (P : Prop) : bool -> Set := ReflectT : P -> Bool.reflect P true | ReflectF : ~ P -> Bool.reflect P false Arguments Bool.reflect _%type_scope _%bool_scope Arguments Bool.ReflectT _%type_scope Arguments Bool.ReflectF _%type_scope\nFin.eqb = fix eqb (m n : nat) (p : Fin.t m) (q : Fin.t n) {struct p} : bool := match p with | @Fin.F1 m' => match q with | @Fin.F1 n' => PeanoNat.Nat.eqb m' n' | Fin.FS _ => false end | @Fin.FS n0 p' => match q with | Fin.F1 => false | @Fin.FS n1 q' => eqb n0 n1 p' q' end end : forall m n : nat, Fin.t m -> Fin.t n -> bool Arguments Fin.eqb {m n}%nat_scope\nBinNatDef.N.eqb = fun n m : BinNums.N => match n with | BinNums.N0 => match m with | BinNums.N0 => true | BinNums.Npos _ => false end | BinNums.Npos p => match m with | BinNums.N0 => false | BinNums.Npos q => BinPos.Pos.eqb p q end end : BinNums.N -> BinNums.N -> bool Arguments BinNatDef.N.eqb (_ _)%N_scope\nBinIntDef.Z.testbit = fun a n : BinNums.Z => match n with | BinNums.Z0 => BinIntDef.Z.odd a | BinNums.Zpos p => match a with | BinNums.Z0 => false | BinNums.Zpos a0 => BinPos.Pos.testbit a0 (BinNums.Npos p) | BinNums.Zneg a0 => negb (BinNat.N.testbit (BinPos.Pos.pred_N a0) (BinNums.Npos p)) end | BinNums.Zneg _ => false end : BinNums.Z -> BinNums.Z -> bool Arguments BinIntDef.Z.testbit (_ _)%Z_scope\nBinIntDef.Z.eqb = fun x y : BinNums.Z => match x with | BinNums.Z0 => match y with | BinNums.Z0 => true | _ => false end | BinNums.Zpos p => match y with | BinNums.Zpos q => BinPos.Pos.eqb p q | _ => false end | BinNums.Zneg p => match y with | BinNums.Zneg q => BinPos.Pos.eqb p q | _ => false end end : BinNums.Z -> BinNums.Z -> bool Arguments BinIntDef.Z.eqb (_ _)%Z_scope\nByte.eqb = fun a b : Byte.byte => let '(a0, (a1, (a2, (a3, (a4, (a5, (a6, a7))))))) := Byte.to_bits a in let '(b0, (b1, (b2, (b3, (b4, (b5, (b6, b7))))))) := Byte.to_bits b in (Bool.eqb a0 b0 && Bool.eqb a1 b1 && Bool.eqb a2 b2 && Bool.eqb a3 b3 && Bool.eqb a4 b4 && Bool.eqb a5 b5 && Bool.eqb a6 b6 && Bool.eqb a7 b7)%bool : Byte.byte -> Byte.byte -> bool Arguments Byte.eqb (_ _)%byte_scope\nAscii.eqb = fun a b : Ascii.ascii => match a with | Ascii.Ascii a0 a1 a2 a3 a4 a5 a6 a7 => match b with | Ascii.Ascii b0 b1 b2 b3 b4 b5 b6 b7 => if if if if if if if Bool.eqb a0 b0 then Bool.eqb a1 b1 else false then Bool.eqb a2 b2 else false then Bool.eqb a3 b3 else false then Bool.eqb a4 b4 else false then Bool.eqb a5 b5 else false then Bool.eqb a6 b6 else false then Bool.eqb a7 b7 else false end end : Ascii.ascii -> Ascii.ascii -> bool Arguments Ascii.eqb (_ _)%char_scope\nTauto.cnf_tt : forall Term' Annot : Type, Tauto.cnf Term' Annot\nBinInt.Z.eqb_neq : forall x y : BinNums.Z, BinInt.Z.eqb x y = false < -> x <> y\nssreflect.locked : forall A : Type, A -> A\nBinNatDef.N.log2 = fun n : BinNums.N => match n with | BinNums.Npos (BinNums.xI p) | BinNums.Npos (BinNums.xO p) => BinNums.Npos (BinPos.Pos.size p) | _ => BinNums.N0 end : BinNums.N -> BinNums.N Arguments BinNatDef.N.log2 _%N_scope\nRing_polynom.Pmul : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> Ring_polynom.Pol C -> Ring_polynom.Pol C -> Ring_polynom.Pol C\nBinIntDef.Z.sub = fun m n : BinNums.Z => BinIntDef.Z.add m (BinIntDef.Z.opp n) : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.sub (_ _)%Z_scope\nBinInt.Z.div_small : forall a b : BinNums.Z, BinInt.Z.le BinNums.Z0 a /\\ BinInt.Z.lt a b -> BinInt.Z.div a b = BinNums.Z0\nBinInt.Z.two_succ = eq_refl : BinNums.Zpos (BinNums.xO BinNums.xH) = BinInt.Z.succ (BinNums.Zpos BinNums.xH)"}, {"role": "assistant", "content": "```intros. constructor.```"}], "original": "intros. constructor.", "succ": false}]