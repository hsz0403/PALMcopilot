[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\nT2: poset\nT1: poset\n\nGoal:\nmonotone snd\n\nPremises:\nmonotone : forall T1 T2 : poset, (T1 -> T2) -> Prop\nsnd = fun (A B : Type) (p : A * B) => let (_, y) := p in y : forall A B : Type, A * B -> B Arguments snd {A B}%type_scope\nNotation poset := Poset.type\ncomp_mono = fun (T1 T2 T3 : poset) (f1 : T2 -> T1) (f2 : T3 -> T2) (M1 : monotone f1) (M2 : monotone f2) (x y : T3) (H : x <== y) => M1 (f2 x) (f2 y) (M2 x y H) : forall (T1 T2 T3 : poset) (f1 : T2 -> T1) (f2 : T3 -> T2), monotone f1 -> monotone f2 -> monotone (f1 \\o f2) Arguments comp_mono {T1 T2 T3} {f1 f2}%function_scope\nunzip2 = fun S T : Type => map snd : forall S T : Type, seq (S * T) -> seq T Arguments unzip2 {S T}%type_scope _%seq_scope\nproj1_mono : forall T1 T2 : poset, monotone fst\ntarski_gfp_fixed : forall (T : lattice) (f : T -> T), monotone f -> f (tarski_gfp f) = tarski_gfp f\ntarski_lfp_fixed : forall (T : lattice) (f : T -> T), monotone f -> f (tarski_lfp f) = tarski_lfp f\nid_mono = fun (T : poset) (x y : T) => id : forall T : poset, monotone id Arguments id_mono {T}\nconst_mono = fun (T1 T2 : poset) (y : T2) (x y0 : T1) => fun=> poset_refl y : forall (T1 T2 : poset) (y : T2), monotone (fun=> y) Arguments const_mono {T1 T2 y}\nBinNat.N.leb_spec : forall x y : BinNums.N, BoolSpec (BinNat.N.le x y) (BinNat.N.lt y x) (BinNat.N.leb x y)\ndfun_trans : forall (A : Type) (B : A -> poset) (x : forall x : A, B x) (y z : forall x0 : A, B x0), dfun_leq x y -> dfun_leq y z -> dfun_leq x z\npair_supM : forall (A B : lattice) (s : Pred (A * B)) (p : A * B), (forall q : A * B, q \\In s -> q <== p) -> pair_sup s <== p\nEquality.sort = fun t : eqType => let (sort, _) := t in sort : eqType -> Type Equality.sort is a coercion\nRing_polynom.radd_ext_Proper : forall (R : Type) (radd rmul : R -> R -> R) (ropp : R -> R) (req : R -> R -> Prop), ring_eq_ext radd rmul ropp req -> Morphisms.Proper (Morphisms.respectful req (Morphisms.respectful req req)) radd\nsub_leq : forall (T : poset) (s : Pred T), {x : T | x \\In s} -> {x : T | x \\In s} -> Prop\nBinIntDef.Z.succ_double = fun x : BinNums.Z => match x with | BinNums.Z0 => BinNums.Zpos BinNums.xH | BinNums.Zpos p => BinNums.Zpos (BinNums.xI p) | BinNums.Zneg p => BinNums.Zneg (BinPos.Pos.pred_double p) end : BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.succ_double _%Z_scope\nRing_polynom.Pinj : forall C : Type, BinNums.positive -> Ring_polynom.Pol C -> Ring_polynom.Pol C\nallpairsPdep : reflect (exists (x : ?S) (y : ?T x), [/\\ x \\in ?s, y \\in ?t x & ?z = ?f x y]) (?z \\in [seq ?f x y | x <- ?s, y <- ?t x]) where ?S : [T1 : poset T2 : poset |- eqType] ?T : [T1 : poset T2 : poset |- ?S -> eqType] ?R : [T1 : poset T2 : poset |- eqType] ?f : [T1 : poset T2 : poset |- forall x : ?S, ?T x -> ?R] ?s : [T1 : poset T2 : poset |- seq ?S] ?t : [T1 : poset T2 : poset |- forall x : ?S, seq (?T x)] ?z : [T1 : poset T2 : poset |- Equality.sort ?R]\nRecord mixin_of (T : poset) : Type := Mixin { mx_sup : Pred T -> T; _ : forall (s : Pred T) (x : T), x \\In s -> x <== mx_sup s; _ : forall (s : Pred T) (x : T), (forall y : T, y \\In s -> y <== x) -> mx_sup s <== x } Arguments Lattice.Mixin [T] [mx_sup]%function_scope (_ _)%function_scope\nSimplPred : forall T : Type, Pred T -> Simpl_Pred T\nList.tl : forall A : Type, seq A -> seq A\nBinPos.Pos.ggcd_gcd : forall a b : BinNums.positive, (BinPos.Pos.ggcd a b).1 = BinPos.Pos.gcd a b\ndfun_leq : forall (A : Type) (B : A -> poset), (forall x : A, B x) -> (forall x : A, B x) -> Prop\nRing_polynom.mkVmon = fun (i : BinNums.positive) (M : Ring_polynom.Mon) => match M with | Ring_polynom.mon0 => Ring_polynom.vmon i Ring_polynom.mon0 | Ring_polynom.zmon j m => Ring_polynom.vmon i (Ring_polynom.zmon_pred j m) | Ring_polynom.vmon i' m => Ring_polynom.vmon (BinPos.Pos.add i i') m end : BinNums.positive -> Ring_polynom.Mon -> Ring_polynom.Mon Arguments Ring_polynom.mkVmon _%positive_scope\nandbCA = fun __top_assumption_ : bool => (fun (_evar_0_ : (fun b : bool => forall y z : bool, [&& b, y & z] = [&& y, b & z]) true) (_evar_0_0 : (fun b : bool => forall y z : bool, [&& b, y & z] = [&& y, b & z]) false) => if __top_assumption_ as b return ((fun b0 : bool => forall y z : bool, [&& b0, y & z] = [&& y, b0 & z]) b) then _evar_0_ else _evar_0_0) (fun __top_assumption_0 : bool => (fun (_evar_0_ : (fun b : bool => forall z : bool, [&& true, b & z] = [&& b, true & z]) true) (_evar_0_0 : (fun b : bool => forall z : bool, [&& true, b & z] = [&& b, true & z]) false) => if __top_ass...\nBinIntDef.Z.ggcd = fun a b : BinNums.Z => match a with | BinNums.Z0 => (BinIntDef.Z.abs b, (BinNums.Z0, BinIntDef.Z.sgn b)) | BinNums.Zpos a0 => match b with | BinNums.Z0 => (BinIntDef.Z.abs a, (BinIntDef.Z.sgn a, BinNums.Z0)) | BinNums.Zpos b0 => let '(g, (aa, bb)) := BinPos.Pos.ggcd a0 b0 in (BinNums.Zpos g, (BinNums.Zpos aa, BinNums.Zpos bb)) | BinNums.Zneg b0 => let '(g, (aa, bb)) := BinPos.Pos.ggcd a0 b0 in (BinNums.Zpos g, (BinNums.Zpos aa, BinNums.Zneg bb)) end | BinNums.Zneg a0 => match b with | BinNums.Z0 => (BinIntDef.Z.abs a, (BinIntDef.Z.sgn a, BinNums.Z0)) | BinNums.Zpos...\nsupM : forall (T : lattice) (s : Pred T) (x : T), (forall y : T, y \\In s -> y <== x) -> sup s <== x\nid_val : forall (T : poset) (P : T), ideal P -> T\nposet_trans : forall (T : poset) (y x z : T), x <== y -> y <== z -> x <== z\nBinIntDef.Z.quotrem = fun a b : BinNums.Z => match a with | BinNums.Z0 => (BinNums.Z0, BinNums.Z0) | BinNums.Zpos a0 => match b with | BinNums.Z0 => (BinNums.Z0, a) | BinNums.Zpos b0 => let (q, r) := BinNat.N.pos_div_eucl a0 (BinNums.Npos b0) in (BinIntDef.Z.of_N q, BinIntDef.Z.of_N r) | BinNums.Zneg b0 => let (q, r) := BinNat.N.pos_div_eucl a0 (BinNums.Npos b0) in (BinIntDef.Z.opp (BinIntDef.Z.of_N q), BinIntDef.Z.of_N r) end | BinNums.Zneg a0 => match b with | BinNums.Z0 => (BinNums.Z0, a) | BinNums.Zpos b0 => let (q, r) := BinNat.N.pos_div_eucl a0 (BinNums.Npos b0...\nBinPos.Pos.le_succ_l : forall n m : BinNums.positive, BinPos.Pos.le (BinPos.Pos.succ n) m < -> BinPos.Pos.lt n m\npair_leq : forall A B : poset, A * B -> A * B -> Prop\nBinIntDef.Z.sub = fun m n : BinNums.Z => BinIntDef.Z.add m (BinIntDef.Z.opp n) : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.sub (_ _)%Z_scope\nPred = fun T : Type => T -> Prop : Type -> Type Arguments Pred _%type_scope\nBinNatDef.N.succ_double = fun x : BinNums.N => match x with | BinNums.N0 => BinNums.Npos BinNums.xH | BinNums.Npos p => BinNums.Npos (BinNums.xI p) end : BinNums.N -> BinNums.N Arguments BinNatDef.N.succ_double _%N_scope\nPred_of_Simpl : forall T : Type, Simpl_Pred T -> Pred T\nPoset.clone : forall (T : Type) (cT : poset) (c : Poset.class_of T), phant_id (Poset.class cT) c -> poset\nBinPos.Pos.compare_xI_xO : forall p q : BinNums.positive, BinPos.Pos.compare (BinNums.xI p) (BinNums.xO q) = BinPos.Pos.switch_Eq Gt (BinPos.Pos.compare p q)\nnth_zip_cond : forall (S0 T : Type) (p : S0 * T) (s : seq S0) (t : seq T) (i : nat), nth p (zip s t) i = (if i < size (zip s t) then (nth p.1 s i, nth p.2 t i) else p)\nBinInt.Z.lt = fun x y : BinNums.Z => BinInt.Z.compare x y = Lt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.lt (_ _)%Z_scope\nBinIntDef.Z.leb = fun x y : BinNums.Z => match BinIntDef.Z.compare x y with | Gt => false | _ => true end : BinNums.Z -> BinNums.Z -> bool Arguments BinIntDef.Z.leb (_ _)%Z_scope\nBinPos.Pos.mul_comm : forall p q : BinNums.positive, BinPos.Pos.mul p q = BinPos.Pos.mul q p"}, {"role": "assistant", "content": "``` \napply comp_mono with (T1 := prod_poset T1 T2) (T2 := T1) (T3 := T2) (f1 := fst) (f2 := snd); intros x y H; destruct x as [x1 x2]; destruct y as [y1 y2]; simpl in *; auto.\napply snd.\n```  "}], "original": "apply comp_mono with (T1 := prod_poset T1 T2) (T2 := T1) (T3 := T2) (f1 := fst) (f2 := snd); intros x y H; destruct x as [x1 x2]; destruct y as [y1 y2]; simpl in *; auto. apply snd.", "succ": false}]