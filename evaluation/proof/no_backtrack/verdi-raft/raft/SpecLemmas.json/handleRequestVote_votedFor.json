[{"history": {"proof": "intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm. unfold handleRequestVote in HhandleRequestVote. destruct (t <? currentTerm d) eqn:Heq1. - inversion HhandleRequestVote. shelve. - destruct (advanceCurrentTerm d t) eqn:Heq2. right. inversion HhandleRequestVote. shelve.", "repairs": ["", "", "", "", "", "unfinished_bullet", "", "", "", "", "unfinished_bullet"], "exceptions": [{"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2."], "tactic": "destruct (leaderId r) eqn:Heq3.", "exn": "The reference r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2."], "tactic": "injection HhandleRequestVote as Heq4 Heq5.", "exn": "Nothing to inject.", "type": "nothing_inject", "handled": false}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2."], "tactic": "intros Heq6.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params pDst : name t : nat cid : fin N lli, llt : nat d : RaftState.raft_data term name entry logIndex serverType data clientId output d' : raft_data m : msg Heq1 : (t <? Raft.currentTerm d) = false currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq2 : advanceCurrentTerm d t = mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories HhandleRequestVote : (if (if Raft.leaderId (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories) then false else true) && moreUpToDate llt lli (maxTerm (Raft.log (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories))) (maxIndex (Raft.log (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories))) then match Raft.votedFor (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories) with | Some candidateId' => (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) (if fin_eq_dec N cid candidateId' then true else false)) | None => ({[mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories with votedFor := Some cid]}, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) true) end else (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) false)) = (d', m) HcurrentTerm : Raft.currentTerm d = Raft.currentTerm d' Unable to unify \"Raft.votedFor d'\" with \"Raft.votedFor d\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right."], "tactic": "destruct (votedFor r) eqn:Heq4.", "exn": "The reference r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": false}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params pDst : name t : nat cid : fin N lli, llt : nat d : RaftState.raft_data term name entry logIndex serverType data clientId output d' : raft_data m : msg Heq1 : (t <? Raft.currentTerm d) = false currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq2 : advanceCurrentTerm d t = mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories HhandleRequestVote : (if (if Raft.leaderId (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories) then false else true) && moreUpToDate llt lli (maxTerm (Raft.log (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories))) (maxIndex (Raft.log (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories))) then match Raft.votedFor (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories) with | Some candidateId' => (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) (if fin_eq_dec N cid candidateId' then true else false)) | None => ({[mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories with votedFor := Some cid]}, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) true) end else (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) false)) = (d', m) HcurrentTerm : Raft.currentTerm d = Raft.currentTerm d' Unable to unify \"Raft.votedFor d'\" with \"Raft.votedFor d\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": false}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params pDst : name t : nat cid : fin N lli, llt : nat d : RaftState.raft_data term name entry logIndex serverType data clientId output d' : raft_data m : msg Heq1 : (t <? Raft.currentTerm d) = false currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq2 : advanceCurrentTerm d t = mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories HhandleRequestVote : (if (if Raft.leaderId (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories) then false else true) && moreUpToDate llt lli (maxTerm (Raft.log (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories))) (maxIndex (Raft.log (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories))) then match Raft.votedFor (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories) with | Some candidateId' => (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) (if fin_eq_dec N cid candidateId' then true else false)) | None => ({[mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories with votedFor := Some cid]}, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) true) end else (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories, RequestVoteReply (Raft.currentTerm (mkRaft_data currentTerm votedFor leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend votesReceived type clientCache electoralVictories)) false)) = (d', m) HcurrentTerm : Raft.currentTerm d = Raft.currentTerm d' Unable to unify \"Raft.votedFor d'\" with \"Raft.votedFor d\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right.", "inversion HhandleRequestVote."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm d) eqn:Heq1.", "-", "inversion HhandleRequestVote.", "shelve.", "-", "destruct (advanceCurrentTerm d t) eqn:Heq2.", "right.", "inversion HhandleRequestVote.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros pDst t cid lli llt d d' m HhandleRequestVote HcurrentTerm. unfold handleRequestVote in HhandleRequestVote. destruct (t <? currentTerm d) eqn:Heq1. - inversion HhandleRequestVote. - destruct (advanceCurrentTerm d t) eqn:Heq2. + destruct (leaderId r) eqn:Heq3. * injection HhandleRequestVote as Heq4 Heq5. subst. intros Heq6. right. reflexivity. * destruct (votedFor r) eqn:Heq4. { right. reflexivity. } { left. reflexivity. } + inversion HhandleRequestVote. - apply HcurrentTerm. Qed.", "succ": false}]