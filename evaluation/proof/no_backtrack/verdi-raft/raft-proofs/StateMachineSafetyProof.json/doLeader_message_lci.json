[{"history": {"proof": "intros st h os st' ms m t n pli plt es ci H1 H2 H3. unfold doLeader in H1. destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1. destruct (shouldSend) eqn:Heq2. - inversion H1. shelve. - inversion H1. subst. clear H1. unfold advanceCommitIndex in Heq1. injection Heq1 as Heq4 Heq5. destruct H as [h' [Hneq HEq]]. shelve.", "repairs": ["", "", "", "", "", "", "unfinished_bullet", "", "", "", "", "", "", "", ""], "exceptions": [{"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-"], "tactic": "destruct (RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output st1 false) as [st'0 replicaMessages] eqn:Heq3.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface st : raft_data h : name os : list raft_output st' : raft_data ms : list (name * msg) m : name * msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st1 : term shouldSend, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend0 : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq2 : shouldSend = None Heq1 : advanceCommitIndex st h = mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories H1 : match Raft.type st with | Leader => if Raft.shouldSend (mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories) then ([], RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output (mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories) false, map (replicaMessage (RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output (mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories) false) h) (filter (fun h0 : name => if name_eq_dec h h0 then false else true) nodes)) else ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, st', ms) H2 : In m ms H3 : snd m = AppendEntries t n pli plt es ci The term \"st1\" has type \"term\" while it is expected to have type \"RaftState.raft_data term name entry logIndex serverType data clientId output\".", "type": "wrong_type", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "subst st'0.", "exn": "No such hypothesis: st'0", "type": "no_hypos", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "assert (Hms: ms = []) by (eapply doLeader_spec; eauto).", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface st : raft_data h : name os : list raft_output st' : raft_data ms : list (name * msg) m : name * msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st1 : term leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend0 : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq1 : advanceCommitIndex st h = mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories H2 : In m ms H3 : snd m = AppendEntries t n pli plt es ci H0 : match Raft.type st with | Leader => if shouldSend0 then ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h) (filter (fun h0 : name => if name_eq_dec h h0 then false else true) nodes)) else ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, st', ms) Unable to unify \"?M12000 = ?M11997 /\\\\ ?M12001 = [] \\\\/ Raft.type ?M11997 = Leader /\\\\ Raft.log ?M12000 = Raft.log ?M11997 /\\\\ Raft.type ?M12000 = Raft.type ?M11997 /\\\\ currentTerm ?M12000 = currentTerm ?M11997 /\\\\ Raft.nextIndex ?M12000 = Raft.nextIndex ?M11997 /\\\\ Raft.commitIndex ?M12000 = Raft.commitIndex (advanceCommitIndex ?M11997 ?M11998) /\\\\ (forall m : name * msg, In m ?M12001 -> exists h : name, h <> ?M11998 /\\\\ m = replicaMessage (advanceCommitIndex ?M11997 ?M11998) ?M11998 h)\" with \"ms = []\".", "type": "cannot_unify", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "subst ms.", "exn": "Cannot find any non-recursive equality over ms.", "type": "cannot_subst", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "apply and_comm.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface st : raft_data h : name os : list raft_output st' : raft_data ms : list (name * msg) m : name * msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st1 : term leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend0 : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq1 : advanceCommitIndex st h = mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories H2 : In m ms H3 : snd m = AppendEntries t n pli plt es ci H0 : match Raft.type st with | Leader => if shouldSend0 then ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h) (filter (fun h0 : name => if name_eq_dec h h0 then false else true) nodes)) else ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, st', ms) Unable to unify \"(?M11997 /\\\\ ?M11998 -> ?M11998 /\\\\ ?M11997) /\\\\ (?M11998 /\\\\ ?M11997 -> ?M11997 /\\\\ ?M11998)\" with \"ci = Raft.commitIndex st'\".", "type": "cannot_unify", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "apply and_comm in H2.", "exn": "Unable to apply lemma of type \"forall A B : Prop, A /\\\\ B <-> B /\\\\ A\" on hypothesis of type \"In m ms\".", "type": "cannot_apply_in", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "apply and_comm in H3.", "exn": "Unable to apply lemma of type \"forall A B : Prop, A /\\\\ B <-> B /\\\\ A\" on hypothesis of type \"snd m = AppendEntries t n pli plt es ci\".", "type": "cannot_apply_in", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1."], "tactic": "split; try split; try reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface st : raft_data h : name os : list raft_output st' : raft_data ms : list (name * msg) m : name * msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st1 : term leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend0 : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq1 : advanceCommitIndex st h = mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories H2 : In m ms H3 : snd m = AppendEntries t n pli plt es ci H0 : match Raft.type st with | Leader => if shouldSend0 then ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h) (filter (fun h0 : name => if name_eq_dec h h0 then false else true) nodes)) else ([], mkRaft_data st1 None leaderId log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, st', ms) Unable to unify \"Raft.commitIndex st'\" with \"ci\".", "type": "cannot_unify", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1.", "unfold advanceCommitIndex in Heq1.", "injection Heq1 as Heq4 Heq5."], "tactic": "subst st1 shouldSend.", "exn": "No such hypothesis: shouldSend", "type": "no_hypos", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1.", "unfold advanceCommitIndex in Heq1.", "injection Heq1 as Heq4 Heq5."], "tactic": "intros m' HIn.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": false}, {"ctx": ["intros st h os st' ms m t n pli plt es ci H1 H2 H3.", "unfold doLeader in H1.", "destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.", "destruct (shouldSend) eqn:Heq2.", "-", "inversion H1.", "shelve.", "-", "inversion H1.", "subst.", "clear H1.", "unfold advanceCommitIndex in Heq1.", "injection Heq1 as Heq4 Heq5.", "destruct H as [h' [Hneq HEq]]."], "tactic": "split; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface st : raft_data h : name os : list raft_output st' : raft_data ms : list (name * msg) m : name * msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st1 : term log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend0 : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) Heq4 : currentTerm st = st1 Heq5 : votedFor st = None H1 : Raft.log st = log H4 : fold_left Init.Nat.max (map eIndex (filter (fun e : entry => (currentTerm st =? eTerm e) && (Raft.commitIndex st <? eIndex e) && haveQuorum st h (eIndex e)) (findGtIndex (Raft.log st) (Raft.commitIndex st)))) (Raft.commitIndex st) = commitIndex H5 : Raft.lastApplied st = lastApplied H6 : Raft.stateMachine st = stateMachine H7 : Raft.nextIndex st = nextIndex H8 : Raft.matchIndex st = matchIndex H9 : shouldSend st = shouldSend0 H10 : Raft.votesReceived st = votesReceived H11 : Raft.type st = type H12 : Raft.clientCache st = clientCache H13 : Raft.electoralVictories st = electoralVictories H2 : In m ms H3 : snd m = AppendEntries t n pli plt es ci H0 : match Raft.type st with | Leader => if shouldSend0 then ([], mkRaft_data st1 None (leaderId st) log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories, map (replicaMessage (mkRaft_data st1 None (leaderId st) log commitIndex lastApplied stateMachine nextIndex matchIndex false votesReceived type clientCache electoralVictories) h) (filter (fun h0 : name => if name_eq_dec h h0 then false else true) nodes)) else ([], mkRaft_data st1 None (leaderId st) log commitIndex lastApplied stateMachine nextIndex matchIndex shouldSend0 votesReceived type clientCache electoralVictories, []) | _ => ([], st, []) end = (os, st', ms) Unable to unify \"Raft.commitIndex st'\" with \"ci\".", "type": "cannot_unify", "handled": false}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof, without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```simpl. rewrite <- IHn. auto.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```intros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.```\n\nSovle This Proof State:\n\nHypotheses:\norig_base_params: BaseParams\none_node_params: OneNodeParams orig_base_params\nraft_params: RaftParams orig_base_params\nrri: raft_refinement_interface\nsi: sorted_interface\nlmi: log_matching_interface\nsmspi: state_machine_safety'interface\nrlmli: refined_log_matching_lemmas_interface\npllsi: prevLog_leader_sublog_interface\nctgt0: current_term_gt_zero_interface\nlalcii: lastApplied_le_commitIndex_interface\nmiaei: match_index_all_entries_interface\nlhlli: leaders_have_leaderLogs_interface\nlci: leader_completeness_interface\nlsi: leader_sublog_interface\ntaifoli: terms_and_indices_from_one_log_interface\nglci: ghost_log_correct_interface\nlphogli: log_properties_hold_on_ghost_logs_interface\nglemi: ghost_log_entries_match_interface\ntci: transitive_commit_interface\ntsi: term_sanity_interface\nlhllsi: leaders_have_leaderLogs_strong_interface\nollpti: one_leaderLog_per_term_interface\nrmri: raft_msg_refinement_interface\n\nGoal:\nforall (st : raft_data) (h : name) (os : list raft_output) (st' : raft_data) (ms : list (name * msg)) (m : name * msg) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex), doLeader st h = (os, st', ms) -> In m ms -> snd m = AppendEntries t n pli plt es ci -> ci = commitIndex st'\n\nPremises:\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\nterm = nat : Set\nRecord ghost_log_entries_match_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_ghost_log_entries_match_interface { ghost_log_entries_match_invariant : forall net : network, msg_refined_raft_intermediate_reachable net -> ghost_log_entries_match_host net } Arguments ghost_log_entries_match_interface {orig_base_params one_node_params raft_params} Arguments Build_ghost_log_entries_match_interface {orig_base_params one_node_params raft_params} _%function_scope\nInductive raft_output (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) : Type := NotLeader : clientId -> nat -> raft_output | ClientResponse : clientId -> nat -> output -> raft_output Arguments raft_output {orig_base_params raft_params} Arguments NotLeader {orig_base_params raft_params} _ _%nat_scope Arguments ClientResponse {orig_base_params raft_params} _ _%nat_scope\nRecord current_term_gt_zero_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_current_term_gt_zero_interface { current_term_gt_zero_invariant : forall net : network, raft_intermediate_reachable net -> current_term_gt_zero net } Arguments current_term_gt_zero_interface {orig_base_params one_node_params raft_params} Arguments Build_current_term_gt_zero_interface {orig_base_params one_node_params raft_params} _%function_scope\nsnd = fun (A B : Type) (p : A * B) => let (_, y) := p in y : forall A B : Type, A * B -> B Arguments snd {A B}%type_scope\nRecord raft_msg_refinement_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_raft_msg_refinement_interface { msg_refined_raft_net_invariant : forall (P : network -> Prop) (net : network), msg_refined_raft_net_invariant_init P -> msg_refined_raft_net_invariant_client_request P -> msg_refined_raft_net_invariant_timeout P -> msg_refined_raft_net_invariant_append_entries P -> msg_refined_raft_net_invariant_append_entries\nRecord leader_sublog_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_leader_sublog_interface { leader_sublog_invariant_invariant : forall net : network, raft_intermediate_reachable net -> leader_sublog_invariant net } Arguments leader_sublog_interface {orig_base_params one_node_params raft_params} Arguments Build_leader_sublog_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord sorted_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_sorted_interface { handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState\ndoLeader = fun (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) (state : raft_data) (me : name) => match type state with | Leader => let state' := advanceCommitIndex state me in if shouldSend state' then let state'0 := RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output state' false in let replicaMessages := map (replicaMessage state'0 me) (filter (fun h : name => if name_eq_dec me h then false else true) nodes) in ([], state'\nRecord lastApplied_le_commitIndex_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_lastApplied_le_commitIndex_interface { lastApplied_le_commitIndex_invariant : forall net : network, raft_intermediate_reachable net -> lastApplied_le_commitIndex net } Arguments lastApplied_le_commitIndex_interface {orig_base_params one_node_params raft_params} Arguments Build_lastApplied_le_commitIndex_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord prevLog_leader_sublog_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_prevLog_leader_sublog_interface { prevLog_leader_sublog_invariant : forall net : network, raft_intermediate_reachable net -> prevLog_leader_sublog net } Arguments prevLog_leader_sublog_interface {orig_base_params one_node_params raft_params} Arguments Build_prevLog_leader_sublog_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord OneNodeParams (P : BaseParams) : Type := Build_OneNodeParams { init : data; handler : input -> data -> output * data } Arguments Build_OneNodeParams _ _ _%function_scope\nRecord BaseParams : Type := Build_BaseParams { data : Type; input : Type; output : Type } Arguments Build_BaseParams (_ _ _)%type_scope\nNotation commitIndex := (RaftState.commitIndex term name entry logIndex serverType data clientId output)\nRecord leaders_have_leaderLogs_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_leaders_have_leaderLogs_interface { leaders_have_leaderLogs_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaders_have_leaderLogs net } Arguments leaders_have_leaderLogs_interface {orig_base_params one_node_params raft_params} Arguments Build_leaders_have_leaderLogs_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord RaftParams (orig_base_params : BaseParams) : Type := Build_RaftParams { N : nat; input_eq_dec : forall x y : input, {x = y} + {x <> y}; output_eq_dec : forall x y : output, {x = y} + {x <> y}; clientId : Type; clientId_eq_dec : forall x y : clientId, {x = y} + {x <> y} } Arguments Build_RaftParams _ _%nat_scope (_ _)%function_scope [clientId]%type_scope _%function_scope\nRecord one_leaderLog_per_term_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_one_leaderLog_per_term_interface { one_leaderLog_per_term_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term net; one_leaderLog_per_term_log_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_log net; one_leaderLog_per_term_host_invariant : forall net : network, refined_raft\nRecord log_properties_hold_on_ghost_logs_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_log_properties_hold_on_ghost_logs_interface { log_properties_hold_on_ghost_logs_invariant : forall net : network, msg_refined_raft_intermediate_reachable net -> log_properties_hold_on_ghost_logs net } Arguments log_properties_hold_on_ghost_logs_interface {orig_base_params one_node_params raft_params} Arguments Build_log_properties_hold_on_ghost_logs_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord raft_refinement_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_raft_refinement_interface { refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined\nRecord match_index_all_entries_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_match_index_all_entries_interface { match_index_all_entries_invariant : forall net : network, refined_raft_intermediate_reachable net -> match_index_all_entries net } Arguments match_index_all_entries_interface {orig_base_params one_node_params raft_params} Arguments Build_match_index_all_entries_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord entry (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) : Type := mkEntry { eAt : name; eClient : clientId; eId : nat; eIndex : logIndex; eTerm : term; eInput : input } Arguments entry {orig_base_params raft_params} Arguments mkEntry {orig_base_params raft_params} _ _ _%nat_scope\nRecord ghost_log_correct_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_ghost_log_correct_interface { ghost_log_correct_invariant : forall net : network, msg_refined_raft_intermediate_reachable net -> ghost_log_correct net } Arguments ghost_log_correct_interface {orig_base_params one_node_params raft_params} Arguments Build_ghost_log_correct_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord log_matching_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_log_matching_interface { log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net } Arguments log_matching_interface {orig_base_params one_node_params raft_params} Arguments Build_log_matching_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord transitive_commit_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_transitive_commit_interface { transitive_commit_invariant : forall net : network, refined_raft_intermediate_reachable net -> transitive_commit net } Arguments transitive_commit_interface {orig_base_params one_node_params raft_params} Arguments Build_transitive_commit_interface {orig_base_params one_node_params raft_params} _%function_scope\nname = fun (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) => fin N : forall orig_base_params : BaseParams, RaftParams orig_base_params -> Type Arguments name {orig_base_params raft_params}\nRecord leader_completeness_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_leader_completeness_interface { leader_completeness_invariant : forall net : network, refined_raft_intermediate_reachable net -> leader_completeness net } Arguments leader_completeness_interface {orig_base_params one_node_params raft_params} Arguments Build_leader_completeness_interface {orig_base_params one_node_params raft_params} _%function_scope\nIn : forall A : Type, A -> list A -> Prop\nlogIndex = nat : Set\nraft_data = fun (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) => RaftState.raft_data term name entry logIndex serverType data clientId output : forall orig_base_params : BaseParams, RaftParams orig_base_params -> Type Arguments raft_data {orig_base_params raft_params}\nRecord term_sanity_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_term_sanity_interface { no_entries_past_current_term_invariant : forall net : network, raft_intermediate_reachable net -> no_entries_past_current_term net } Arguments term_sanity_interface {orig_base_params one_node_params raft_params} Arguments Build_term_sanity_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord state_machine_safety'interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_state_machine_safety'interface { state_machine_safety'_invariant : forall net : network, refined_raft_intermediate_reachable net -> state_machine_safety' net } Arguments state_machine_safety'interface {orig_base_params one_node_params raft_params} Arguments Build_state_machine_safety'interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord terms_and_indices_from_one_log_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_terms_and_indices_from_one_log_interface { terms_and_indices_from_one_log_invariant : forall net : network, raft_intermediate_reachable net -> terms_and_indices_from_one_log net; terms_and_indices_from_one_log_nw_invariant : forall net : network, raft_intermediate_reachable net -> terms_and_indices_from_one_log_nw net } Arguments terms_and_indices_from_one_log_interface {orig_base_params one\nRecord leaders_have_leaderLogs_strong_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_leaders_have_leaderLogs_strong_interface { leaders_have_leaderLogs_strong_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaders_have_leaderLogs_strong net } Arguments leaders_have_leaderLogs_strong_interface {orig_base_params one_node_params raft_params} Arguments Build_leaders_have_leaderLogs_strong_interface {orig_base_params one_node_params raft_params} _%function_scope\nRecord refined_log_matching_lemmas_interface (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : Prop := Build_refined_log_matching_lemmas_interface { entries_contiguous_nw_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_contiguous_nw net; entries_gt_0_nw_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_gt_0_nw net; entries_sorted_nw_invariant : forall net : network, refined_\nInductive msg (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) : Type := RequestVote : term -> name -> logIndex -> term -> msg | RequestVoteReply : term -> bool -> msg | AppendEntries : term -> name -> logIndex -> term -> list entry -> logIndex -> msg | AppendEntriesReply : term -> list entry -> bool -> msg Arguments msg {orig_base_params raft_params} Arguments RequestVote {orig_base_params raft_params} Arguments RequestVoteReply {orig_base_params raft_params} _ _%bool_scope Arguments AppendEntries {orig_base_params raft_params}\ndoLeader_message_entries : forall (st : raft_data) (h : name) (os : list raft_output) (st' : raft_data) (ms : list (name * msg)) (m : name * msg) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (e : entry), doLeader st h = (os, st', ms) -> In m ms -> snd m = AppendEntries t n pli plt es ci -> In e es -> In e (log st)\ndoLeader_messages : forall (st : raft_data) (h : name) (os : list raft_output) (st' : raft_data) (ms : list (name * msg)) (m : name * msg) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex), doLeader st h = (os, st', ms) -> In m ms -> snd m = AppendEntries t n pli plt es ci -> t = currentTerm st /\\ log st' = log st /\\ type st = Leader /\\ (plt = 0 \\/ (exists e : entry, findAtIndex (log st) pli = Some e /\\ eTerm e = plt))\nhandleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st')\nhandleTimeout_messages : forall (out : list raft_output) (st : raft_data) (l : list (name * msg)) (h : name) (mi : logIndex) (mt : term) (m : name * msg) (st' : raft_data) (t : term) (n : name), handleTimeout h st = (out, st', l) -> In m l -> snd m = RequestVote t n mi mt -> maxIndex (log st') = mi /\\ maxTerm (log st') = mt /\\ t = currentTerm st'\ndoLeader_spec : forall (st : raft_data) (n : name) (os : list raft_output) (st' : raft_data) (ms : list (name * msg)), doLeader st n = (os, st', ms) -> st' = st /\\ ms = [] \\/ type st = Leader /\\ log st' = log st /\\ type st' = type st /\\ currentTerm st' = currentTerm st /\\ nextIndex st' = nextIndex st /\\ commitIndex st' = commitIndex (advanceCommitIndex st n) /\\ (forall m : name * msg, In m ms -> exists h : name, h <> n /\\ m = replicaMessage (advanceCommitIndex st n) n h)\ndoLeader_same_commitIndex : forall (st : raft_data) (n : name) (os : list raft_output) (st' : raft_data) (ms : list (name * msg)), doLeader st n = (os, st', ms) -> sorted (log st) -> commitIndex st <= maxIndex (log st) -> commitIndex st' <= maxIndex (log st')\nhandleAppendEntries_log_detailed : forall (h : name) (st : raft_data) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (ps : msg), handleAppendEntries h st t n pli plt es ci = (st', ps) -> commitIndex st' = commitIndex st /\\ log st' = log st \\/ leaderId st' <> None /\\ currentTerm st' = t /\\ commitIndex st' = Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex es)) /\\ es <> [] /\\ pli = 0 /\\ t >= currentTerm st...\ndoGenericServer_commitIndex : forall (h : name) (st : raft_data) (out : list raft_output) (st' : raft_data) (ms : list (name * msg)), doGenericServer h st = (out, st', ms) -> commitIndex st' = commitIndex st\nSpecLemmas.handleAppendEntries_log_detailed : forall (h : name) (st : raft_data) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (ps : msg), handleAppendEntries h st t n pli plt es ci = (st', ps) -> commitIndex st' = commitIndex st /\\ log st' = log st \\/ leaderId st' <> None /\\ currentTerm st' = t /\\ commitIndex st' = Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex es)) /\\ es <> [] /\\ pli = 0 /\\ t...\ndoGenericServer_lastApplied : forall (h : name) (st : raft_data) (out : list raft_output) (st' : raft_data) (ms : list (name * msg)), doGenericServer h st = (out, st', ms) -> lastApplied st' = lastApplied st \\/ lastApplied st < commitIndex st /\\ lastApplied st' = commitIndex st\nhandleClientRequest_commitIndex : forall (h : name) (st : raft_data) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st' : raft_data) (ms : list (name * msg)), handleClientRequest h st client id c = (out, st', ms) -> commitIndex st' = commitIndex st\nhandleAppendEntriesReply_same_commitIndex : forall (n : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (src : name) (t : nat) (es : list entry) (b : bool) (st' : raft_data) (l : list (name * msg)), handleAppendEntriesReply n st src t es b = (st', l) -> commitIndex st' = commitIndex st\nhandleTimeout_commitIndex : forall (h : name) (st : raft_data) (out : list raft_output) (st' : raft_data) (l : list (name * msg)), handleTimeout h st = (out, st', l) -> commitIndex st' = commitIndex st\nCommonTheorems.handleClientRequest_commitIndex : forall (h : name) (st : raft_data) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st' : raft_data) (l : list (name * msg)), handleClientRequest h st client id c = (out, st', l) -> commitIndex st' = commitIndex st\nhandleRequestVote_same_commitIndex : forall (n : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (t : nat) (c : fin N) (li lt : nat) (st' : raft_data) (ms : msg), handleRequestVote n st t c li lt = (st', ms) -> commitIndex st' = commitIndex st\nterms_and_indices_from_one_log_nw = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (p : packet) (t : term) (leaderId : name) (prevLogIndex : logIndex) (prevLogTerm : term) (entries : list entry) (leaderCommit : logIndex), In p (nwPackets net) -> pBody p = AppendEntries t leaderId prevLogIndex prevLogTerm entries leaderCommit ->...-> Prop Arguments terms_and_indices_from_one_log_nw {orig_base_params one_node_params raft_params}\nghost_log_correct = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (p : packet) (l : ghost_msg) (t : term) (leaderId : name) (prevLogIndex : logIndex) (prevLogTerm : term) (entries : list entry) (leaderCommit : logIndex), In p (nwPackets net) -> snd (pBody p) = AppendEntries t leaderId prevLogIndex prevLogTerm entries leaderCommit -> fst (pBody p) = l ->...-> Prop Arguments ghost_log_correct {orig_base_params one_node_params raft_params}\nhandleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st)\nInductive raft_intermediate_reachable (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : network -> Prop := RIR_init : raft_intermediate_reachable step_async_init | RIR_step_failure : forall (failed : list Net.name) (net : network) (failed' : list Net.name) (net' : network) (out : list (Net.name * (input + list output))), raft_intermediate_reachable net -> step_failure (failed, net) (failed', net') out -> raft_intermediate_reachable net' | RIR_handleInput : forall (net : network) (h : name) (inp : raft_input) (out...\nprevLog_leader_sublog = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (leader : Net.name) (p : packet) (t : term) (leaderId : name) (prevLogIndex : logIndex) (prevLogTerm : term) (entries : list entry) (leaderCommit : logIndex), type (nwState net leader) = Leader -> In p (nwPackets net) -> pBody p = AppendEntries t leaderId prevLogIndex prevLogTerm entries leaderCommit ->...-> Prop Arguments prevLog_leader_sublog {orig_base_params one_node_params raft_params}\nInductive refined_raft_intermediate_reachable (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : network -> Prop := RRIR_init : refined_raft_intermediate_reachable step_async_init | RRIR_step_failure : forall (failed : list Net.name) (net : network) (failed' : list Net.name) (net' : network) (out : list (Net.name * (input + list output))), refined_raft_intermediate_reachable net -> step_failure (failed, net) (failed', net') out -> refined_raft_intermediate_reachable net' | RRIR_handleInput : forall (net : network) (h : name)...\nInductive msg_refined_raft_intermediate_reachable (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) : network -> Prop := MRRIR_init : msg_refined_raft_intermediate_reachable step_async_init | MRRIR_step_failure : forall (failed : list Net.name) (net : network) (failed' : list Net.name) (net' : network) (out : list (Net.name * (input + list output))), msg_refined_raft_intermediate_reachable net -> step_failure (failed, net) (failed', net') out -> msg_refined_raft_intermediate_reachable net' | MRRIR_handleInput :...\nhandleRequestVoteReply_same_commitIndex : forall (n : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (src : name) (t : nat) (v : bool), commitIndex (handleRequestVoteReply n st src t v) = commitIndex st\ndoGenericServer = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (h : name) (state : raft_data) => let (out, state0) := applyEntries h state (rev (filter (fun x : entry => (lastApplied state <? eIndex x) && (eIndex x <=? commitIndex state)) (findGtIndex (log state) (lastApplied state)))) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output state0 (if lastApplied state0 <? commitIndex state0 then commitIndex state0 else lastApplied state0), []) : forall orig...\napplyEntries = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) => fix applyEntries (h : name) (st : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st) | e :: es => let (out, st0) := cacheApplyEntry st e in let out0 := if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else [] in let (out', state) := applyEntries h st0 es in (out0 ++...\none_leaderLog_per_term = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (h h' : Net.name) (t : term) (ll ll' : list entry), In (t, ll) (leaderLogs (fst (nwState net h))) -> In (t, ll') (leaderLogs (fst (nwState net h'))) ->...-> Prop Arguments one_leaderLog_per_term {orig_base_params one_node_params raft_params}\none_leaderLog_per_term_host = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (h h' : Net.name) (t : term) (ll ll' : list entry), In (t, ll) (leaderLogs (fst (nwState net h))) -> In (t, ll') (leaderLogs (fst (nwState net h'))) ->...-> Prop Arguments one_leaderLog_per_term_host {orig_base_params one_node_params raft_params}\nhandleTimeout = fun (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) (me : name) (state : raft_data) => match type state with | Leader => ([], RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output state true, []) | _ => tryToBecomeLeader me state end : forall (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params), name -> raft_data -> list raft_output * raft_data * list (name * msg) Arguments handleTimeout {orig_base_params raft_params}\nhaveNewEntries_true : forall (st : raft_data) (es : list entry), haveNewEntries st es = true -> es <> [] /\\ (findAtIndex (log st) (maxIndex es) = None \\/ (exists e : entry, findAtIndex (log st) (maxIndex es) = Some e /\\ eTerm e <> maxTerm es))\nltb_true_lt : forall m n : nat, (m <? n) = true -> m < n\nltb_false_le : forall m n : nat, (m <? n) = false -> n <= m\none_leaderLog_per_term_log = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (h h' : Net.name) (t : term) (ll ll' : list entry), In (t, ll) (leaderLogs (fst (nwState net h))) -> In (t, ll') (leaderLogs (fst (nwState net h'))) ->...-> Prop Arguments one_leaderLog_per_term_log {orig_base_params one_node_params raft_params}\nZegal_left : forall n m : Z, n = m -> (n + - m)%Z = 0%Z\ncommitted = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) (e : entry) (t : term) => exists (h : Net.name) (e' : entry), eTerm e' <= t /\\ directly_committed net e' /\\ eIndex e <= eIndex e' /\\ In e (log (snd (nwState net h))) /\\ In e' (log (snd (nwState net h))) : forall (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params), network -> entry -> term -> Prop Arguments committed {...\nhaveQuorum = fun (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params) (state : raft_data) (_ : name) (N : logIndex) => div2 (length nodes) <? length (filter (fun h : name => N <=? assoc_default name_eq_dec (matchIndex state) h 0) nodes) : forall (orig_base_params : BaseParams) (raft_params : RaftParams orig_base_params), raft_data -> name -> logIndex -> bool Arguments haveQuorum {orig_base_params raft_params}\nfast_Zplus_assoc_reverse : forall (n m p : Z) (P : Z -> Prop), P (n + (m + p))%Z -> P (n + m + p)%Z\ntransitive_commit = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall (h : Net.name) (e e' : entry) (t : term), In e (log (snd (nwState net h))) -> In e' (log (snd (nwState net h))) -> eIndex e <= eIndex e' -> committed net e' t -> committed net e t : forall (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params), network -> Prop Arguments transitive_commit {orig_base_params one_node_params raft_params}\nlifted_committed = fun (net : ghost_log_network) (e : entry) (t : term) => exists (h : Net.name) (e' : entry), eTerm e' <= t /\\ lifted_directly_committed net e' /\\ eIndex e <= eIndex e' /\\ In e (log (snd (nwState net h))) /\\ In e' (log (snd (nwState net h))) : ghost_log_network -> entry -> term -> Prop\nleaders_have_leaderLogs_strong = fun (orig_base_params : BaseParams) (one_node_params : OneNodeParams orig_base_params) (raft_params : RaftParams orig_base_params) (net : network) => forall h : Net.name, type (snd (nwState net h)) = Leader ->...-> Prop Arguments leaders_have_leaderLogs_strong {orig_base_params one_node_params raft_params}\nadvanceCurrentTerm_term : forall (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (t : nat), currentTerm st <= t -> currentTerm (advanceCurrentTerm st t) = t"}, {"role": "assistant", "content": "```coq\nintros st h os st' ms m t n pli plt es ci H1 H2 H3.\nunfold doLeader in H1. destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1.\ndestruct (shouldSend) eqn:Heq2.\n- inversion H1.\n- destruct (RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output st1 false) as [st'0 replicaMessages] eqn:Heq3.\n  inversion H1. subst. clear H1.\n  assert (Hst: st' = st'0) by (eapply doLeader_spec; eauto).\n  subst st'0.\n  assert (Hms: ms = []) by (eapply doLeader_spec; eauto).\n  subst ms.\n  apply and_comm.\n  apply and_comm in H2. apply and_comm in H3.\n  apply RaftState.set_raft_data_shouldSend_spec in Heq3 as [Hstilt Heq3].\n  split; try split; try reflexivity.\n  + unfold advanceCommitIndex in Heq1. injection Heq1 as Heq4 Heq5.\n    subst st1 shouldSend. apply Heq3.\n  + intros m' HIn.\n    apply RaftState.set_raft_data_shouldSend_spec in Heq3 as [H _].\n    specialize (H _ HIn).\n    destruct H as [h' [Hneq HEq]].\n    exists h'. split; auto.\nQed.\n```"}], "original": "intros st h os st' ms m t n pli plt es ci H1 H2 H3. unfold doLeader in H1. destruct (advanceCommitIndex st h) as [st1 shouldSend] eqn:Heq1. destruct (shouldSend) eqn:Heq2. - inversion H1. - destruct (RaftState.set_raft_data_shouldSend term name entry logIndex serverType data clientId output st1 false) as [st'0 replicaMessages] eqn:Heq3. inversion H1. subst. clear H1. assert (Hst: st' = st'0) by (eapply doLeader_spec; eauto). subst st'0. assert (Hms: ms = []) by (eapply doLeader_spec; eauto). subst ms. apply and_comm. apply and_comm in H2. apply and_comm in H3. apply RaftState.set_raft_data_shouldSend_spec in Heq3 as [Hstilt Heq3]. split; try split; try reflexivity. + unfold advanceCommitIndex in Heq1. injection Heq1 as Heq4 Heq5. subst st1 shouldSend. apply Heq3. + intros m' HIn. apply RaftState.set_raft_data_shouldSend_spec in Heq3 as [H _]. specialize (H _ HIn). destruct H as [h' [Hneq HEq]]. exists h'. split; auto.", "succ": false}]