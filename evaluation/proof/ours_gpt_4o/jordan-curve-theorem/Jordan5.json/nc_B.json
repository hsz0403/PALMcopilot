[{"history": {"proof": "qsimpl time: 1 use: eqc_dec,A. qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "repairs": ["wrong_type", "cannot_unify"], "exceptions": [{"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x)."], "tactic": "assert (H_eqc_dec: eqc_dec m0 x (A m k x) = eqc_dec m x (A m k x)).", "exn": "In environment m : fmap k : dim x : dart H_inv : inv_hmap m H_succ : succ m k x m0 := B m k x : fmap The term \"eqc_dec m x (A m k x)\" has type \"{eqc m x (A m k x)} + {~ eqc m x (A m k x)}\" while it is expected to have type \"{eqc m0 x (A m k x)} + {~ eqc m0 x (A m k x)}\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A."], "tactic": "apply eqc_B_CS with (m := m) (k := k) (x := x); auto.", "exn": "In environment d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap k : dim x : dart H_inv : inv_hmap m H_succ : succ m k x e : eqc (B m k x) x (d m k x) Heqs0 : s (B m k x) x (d m k x) = left e Unable to unify \"(fix eqc (m : fmap) (x y : dart) {struct m} : Prop := match m with | V => False | I m0 x0 _ _ => x = x0 /\\\\ y = x0 \\\\/ eqc m0 x y | L m0 _ x0 y0 => eqc m0 x y \\\\/ eqc m0 x x0 /\\\\ eqc m0 y0 y \\\\/ eqc m0 x y0 /\\\\ eqc m0 x0 y end) m ?M3072 ?M3073\" with \"nc (B m k x) = nc m + 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc."], "tactic": "destruct (eqc_dec m0 x (A m k x)).", "exn": "The reference m0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-"], "tactic": "rewrite H_eqc_dec.", "exn": "The reference H_eqc_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+"], "tactic": "destruct (eqc_dec (B m k x) d d0); simpl; auto with zarith.", "exn": "In environment H0 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} H : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (A m k x) t \\\\/ eqc (B m k x) z (A m k x) /\\\\ eqc (B m k x) x t -> eqc m z t d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap d0 : dart t : tag p : point k : dim x : dart H_inv : inv_hmap m /\\\\ prec_I m d0 H_succ : succ (I m d0 t p) k x e : x = d0 /\\\\ d (I m d0 t p) k x = d0 \\\\/ eqc (B m k x) x (d (I m d0 t p) k x) Heqs0 : s (I (B m k x) d0 t p) x (d (I m d0 t p) k x) = left e H2 : dart The term \"d\" has type \"fmap -> dim -> dart -> dart\" while it is expected to have type \"dart\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+"], "tactic": "destruct (eq_dim_dec d k).", "exn": "In environment H0 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} H : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (A m k x) t \\\\/ eqc (B m k x) z (A m k x) /\\\\ eqc (B m k x) x t -> eqc m z t d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap d0 : dim d1, d2 : dart k : dim x : dart H_inv : inv_hmap m /\\\\ prec_L m d0 d1 d2 H_succ : succ (L m d0 d1 d2) k x e : eqc (if eq_dim_dec d0 k then if eq_dart_dec d1 x then m else L (B m k x) d0 d1 d2 else L (B m k x) d0 d1 d2) x (d (L m d0 d1 d2) k x) Heqs0 : s (if eq_dim_dec d0 k then if eq_dart_dec d1 x then m else L (B m k x) d0 d1 d2 else L (B m k x) d0 d1 d2) x (d (L m d0 d1 d2) k x) = left e H2 : dart The term \"d\" has type \"fmap -> dim -> dart -> dart\" while it is expected to have type \"dim\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+"], "tactic": "rewrite H_eqc_dec.", "exn": "The reference H_eqc_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+"], "tactic": "destruct (eqc_dec (B m k x) d d0); simpl; auto with zarith.", "exn": "The reference d0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+"], "tactic": "destruct (eq_dim_dec d k).", "exn": "In environment H0 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} H : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (A m k x) t \\\\/ eqc (B m k x) z (A m k x) /\\\\ eqc (B m k x) x t -> eqc m z t d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap k : dim x : dart H_inv : inv_hmap m H_succ : succ m k x e : eqc (B m k x) x (d m k x) Heqs0 : s (B m k x) x (d m k x) = left e H2 : dart The term \"d\" has type \"fmap -> dim -> dart -> dart\" while it is expected to have type \"dim\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+"], "tactic": "qsimpl time: 1 use: eq_dim_dec,auto,A,qsimpl,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "destruct (eq_dart_dec d0 x).", "exn": "In environment s0 : forall n m : nat, {n = m} + {n = m -> False} H4 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} d0 : fmap -> dim -> dart -> dart H3 : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (d0 m k x) t \\\\/ eqc (B m k x) z (d0 m k x) /\\\\ eqc (B m k x) x t -> eqc m z t H1 : forall i k : dim, {i = k} + {i = k -> False} H0 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} H : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (A m k x) t \\\\/ eqc (B m k x) z (A m k x) /\\\\ eqc (B m k x) x t -> eqc m z t d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap k : dim x : dart H_inv : inv_hmap m H_succ : succ m k x e : eqc (B m k x) x (d m k x) Heqs0 : s (B m k x) x (d m k x) = left e H2 : dart n : nat _x : (n <= ndN m)%nat e0 : le_lt_dec n (ndN m) = left _x _x0 : H2 = Iter (MA1.f m) n H2 -> False e1 : s0 H2 (Iter (MA1.f m) n H2) = right _x0 _x1 : n = ndN m -> False e2 : Nat.eq_dec n (ndN m) = right _x1 H6 : (n + 1)%nat = MA1.degree_aux m H2 (n + 1) H7 : fmap The term \"d0\" has type \"fmap -> dim -> dart -> dart\" while it is expected to have type \"nat\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "qsimpl time: 1 use: eq_dim_dec,auto,A,qsimpl,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "rewrite <- H_eqc_dec.", "exn": "The reference H_eqc_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "destruct (eqc_dec m0 d d0); auto with zarith.", "exn": "The reference m0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "destruct (eqc_dec (B m k x) d d0); auto with zarith.", "exn": "In environment H10 : forall n m : nat, {n = m} + {n = m -> False} H9 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} d1 : fmap -> dim -> dart -> dart H8 : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (d1 m k x) t \\\\/ eqc (B m k x) z (d1 m k x) /\\\\ eqc (B m k x) x t -> eqc m z t H5 : forall i k : dim, {i = k} + {i = k -> False} s0 : forall n m : nat, {n = m} + {n = m -> False} H4 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} d0 : fmap -> dim -> dart -> dart H3 : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (d0 m k x) t \\\\/ eqc (B m k x) z (d0 m k x) /\\\\ eqc (B m k x) x t -> eqc m z t H1 : forall i k : dim, {i = k} + {i = k -> False} H0 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} H : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (A m k x) t \\\\/ eqc (B m k x) z (A m k x) /\\\\ eqc (B m k x) x t -> eqc m z t d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap k : dim x : dart H_inv : inv_hmap m H_succ : succ m k x e : eqc (B m k x) x (d m k x) Heqs0 : s (B m k x) x (d m k x) = left e H2 : dart n : nat _x : (n <= ndN m)%nat e0 : le_lt_dec n (ndN m) = left _x _x0 : H2 = Iter (MA1.f m) n H2 -> False e1 : s0 H2 (Iter (MA1.f m) n H2) = right _x0 _x1 : n = ndN m -> False e2 : Nat.eq_dec n (ndN m) = right _x1 H6 : (n + 1)%nat = MA1.degree_aux m H2 (n + 1) H7, H12 : fmap The term \"d\" has type \"fmap -> dim -> dart -> dart\" while it is expected to have type \"dart\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "qsimpl time: 1 use: eq_dim_dec,auto,A,qsimpl,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "destruct (eqc_dec (B m k x) d d0); auto with zarith.", "exn": "In environment H15 : forall n m : nat, {n = m} + {n = m -> False} H14 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} d2 : fmap -> dim -> dart -> dart H13 : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (d2 m k x) t \\\\/ eqc (B m k x) z (d2 m k x) /\\\\ eqc (B m k x) x t -> eqc m z t H11 : forall i k : dim, {i = k} + {i = k -> False} H10 : forall n m : nat, {n = m} + {n = m -> False} H9 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} d1 : fmap -> dim -> dart -> dart H8 : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (d1 m k x) t \\\\/ eqc (B m k x) z (d1 m k x) /\\\\ eqc (B m k x) x t -> eqc m z t H5 : forall i k : dim, {i = k} + {i = k -> False} s0 : forall n m : nat, {n = m} + {n = m -> False} H4 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} d0 : fmap -> dim -> dart -> dart H3 : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (d0 m k x) t \\\\/ eqc (B m k x) z (d0 m k x) /\\\\ eqc (B m k x) x t -> eqc m z t H1 : forall i k : dim, {i = k} + {i = k -> False} H0 : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} H : forall (m : fmap) (k : dim) (x z t : dart), inv_hmap m -> succ m k x -> eqc (B m k x) z t \\\\/ eqc (B m k x) z x /\\\\ eqc (B m k x) (A m k x) t \\\\/ eqc (B m k x) z (A m k x) /\\\\ eqc (B m k x) x t -> eqc m z t d : fmap -> dim -> dart -> dart s : forall (m : fmap) (x y : dart), {eqc m x y} + {eqc m x y -> False} m : fmap k : dim x : dart H_inv : inv_hmap m H_succ : succ m k x e : eqc (B m k x) x (d m k x) Heqs0 : s (B m k x) x (d m k x) = left e H2 : dart n : nat _x : (n <= ndN m)%nat e0 : le_lt_dec n (ndN m) = left _x _x0 : H2 = Iter (MA1.f m) n H2 -> False e1 : s0 H2 (Iter (MA1.f m) n H2) = right _x0 _x1 : n = ndN m -> False e2 : Nat.eq_dec n (ndN m) = right _x1 H6 : (n + 1)%nat = MA1.degree_aux m H2 (n + 1) H7, H12, H17 : fmap The term \"d\" has type \"fmap -> dim -> dart -> dart\" while it is expected to have type \"dart\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m k x H_inv H_succ.", "set (m0 := B m k x).", "qsimpl time: 1 use: eqc_dec,A.", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,A.", "unfold nc.", "-", "rewrite MA1.degree_aux_rect.", "destruct m; simpl in *; auto with zarith.", "+", "qsimpl time: 1 use: eqc_B_CS,eqc_dec,B,A.", "shelve.", "+", "shelve.", "+", "destruct m; simpl in *; auto with zarith.", "+", "shelve.", "+", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "qsimpl time: 1 use: eq_dim_dec,A,eqc_B_CS,eqc_dec,eq_dart_dec,B."], "tactic": "qsimpl time: 1 use: eq_dim_dec,auto,A,qsimpl,eqc_B_CS,eqc_dec,eq_dart_dec,B.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros m k x H_inv H_succ. set (m0 := B m k x). assert (H_eqc_dec: eqc_dec m0 x (A m k x) = eqc_dec m x (A m k x)). { apply eqc_B_CS with (m := m) (k := k) (x := x); auto. } unfold nc. destruct (eqc_dec m0 x (A m k x)). - rewrite H_eqc_dec. simpl. destruct m; simpl in *; auto with zarith. + destruct (eqc_dec (B m k x) d d0); simpl; auto with zarith. + destruct (eq_dim_dec d k). * destruct (eq_dart_dec d0 x). -- simpl. rewrite <- H_eqc_dec. simpl. destruct (eqc_dec m0 d d0); auto with zarith. -- simpl. destruct (eqc_dec (B m k x) d d0); auto with zarith. * simpl. destruct (eqc_dec (B m k x) d d0); auto with zarith. - rewrite H_eqc_dec. simpl. destruct m; simpl in *; auto with zarith. + destruct (eqc_dec (B m k x) d d0); simpl; auto with zarith. + destruct (eq_dim_dec d k). * destruct (eq_dart_dec d0 x). -- simpl. rewrite <- H_eqc_dec. simpl. destruct (eqc_dec m0 d d0); auto with zarith. -- simpl. destruct (eqc_dec (B m k x) d d0); auto with zarith. * simpl. destruct (eqc_dec (B m k x) d d0); auto with zarith.", "back_times": 0, "succ": false, "time": 171.73767352104187}]