[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "intros m x y z i Hinv Hexd. assert (inv_hmap m) as Hinv_m. { destruct m; simpl in Hinv; tauto. } assert (Hc1: cF (L m zero x y) z = if eq_dart_dec (cA m zero x) z then cF m (cF m y) else if eq_dart_dec y z then cA_1 m one x else cF m z). { apply cF_L0_1; auto; apply between_expf_L0_1; auto. } assert (Hc2: cF (L m zero x y) (Iter (cF (L m zero x y)) i z) = Iter (cF (L m zero x y)) (S i) z). { symmetry. apply Iter_cF_L_B with (m := m) (k := zero) (x := x); auto; try apply B.convex_hmap_inv_hmap; auto. } assert (Hc3: expf (L m zero x y) (cA_1 m one x) (Iter (cF (L m zero x y)) i z)). { apply expf_expf_L0_2; auto; intro; subst; apply not_expf_expfo in Hinv; auto. } assert (Hcase: expf m (cA_1 m one x) y \\/ ~ expf m (cA_1 m one x) y). { apply classic. } destruct Hcase as [Hexpf_m_xy|Hnexpf_m_xy]. - assert (Hexpf_L_z_t: expf (L m zero x y) z (Iter (cF (L m zero x y)) i z)). { apply expf_expf_L0_1; auto. } left. split. + apply between_expf_L0_1; auto. + right. apply between_expf_L0_2; auto. - assert (Hc4: cF (L m zero x y) x = y). { apply cF_L0_2; auto; apply between_expf_L0_2. } assert (Hiexpf: iter_exp z t i). { apply expfo_expf_compose with y x y; auto. } assert (Hbcc: betweenf m (cA_1 m one x) z (cA m zero x)). { apply between_expf_L0; auto. } right. split. + left. split; auto. + apply expf_expf_L0_2_bis; auto.", "back_times": 0, "succ": false, "time": 123.29901695251465}]