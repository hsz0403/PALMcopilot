[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H."], "tactic": "specialize (H Hinv Hsucc).", "exn": "In environment m : fmap x : dart Hinv : inv_hmap m Hsucc : succ m zero x m0 : fmap Heqm0 : m0 = B m zero x y : dart Heqy : y = A m zero x Hplanar : planar m H := eqc_B m zero x : forall z t : dart, inv_hmap m -> succ m zero x -> let xk := A m zero x in let m0 := B m zero x in eqc m z t <-> eqc m0 z t \\\\/ eqc m0 z x /\\\\ eqc m0 xk t \\\\/ eqc m0 z xk /\\\\ eqc m0 x t The term \"Hinv\" has type \"inv_hmap m\" while it is expected to have type \"dart\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H."], "tactic": "qsimpl time: 1 use: eqc_B,auto,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H."], "tactic": "destruct H as [H1 | [H1 | H1]]; apply H1.", "exn": "Unable to find an instance for the variables m, k, x, z, t.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H."], "tactic": "qsimpl time: 1 use: eqc_B,auto,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--"], "tactic": "split; apply expf_B0_CS_1_c; auto; unfold cA_1; unfold eqc in H.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--"], "tactic": "qsimpl time: 1 use: auto,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "destruct H as [H1 | [H1 | H1]]; apply H1.", "exn": "Unable to find an instance for the variables m, k, x, z, t.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "qsimpl time: 1 use: auto,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "-", "exn": "Wrong bullet -: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex]."], "tactic": "assert (Hinvm0: inv_hmap m0) by (apply Hinv; auto).", "exn": "In environment m : fmap x : dart Hinv : inv_hmap m Hsucc : succ m zero x m0 : fmap Heqm0 : m0 = B m zero x y : dart Heqy : y = A m zero x Hpl0 : planar ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero x) Hex : ~ eqc ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero x) x ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m zero x) \\\\/ expf ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero x) (cA_1 ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero x) one x) ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m zero x) Unable to unify \"inv_hmap m\" with \"inv_hmap m0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex]."], "tactic": "qsimpl time: 1 use: auto,inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "assert (Hsuccm0: succ m0 zero y) by (apply Hsucc; auto).", "exn": "The reference y was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "apply planarity_criteria_0; auto.", "exn": "The reference planarity_criteria_0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto."], "tactic": "destruct Hex as [Hneq | Hexpf].", "exn": "The reference Hex was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto.", "destruct ndN as [Hneq | ndNpf].", "+"], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto.", "destruct ndN as [Hneq | ndNpf].", "+"], "tactic": "qsimpl time: 1 use: auto,inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto.", "destruct ndN as [Hneq | ndNpf].", "+", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "apply not_eqc_planar_0 with m0 y; auto.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto.", "destruct ndN as [Hneq | ndNpf].", "+", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "+"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto.", "destruct ndN as [Hneq | ndNpf].", "+", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "+"], "tactic": "qsimpl time: 1 use: auto,inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x Hinv Hsucc.", "unfold B.", "unfold A.", "remember (B m zero x) as m0.", "remember (A m zero x) as y.", "split.", "-", "intro Hplanar.", "split.", "+", "shelve.", "+", "pose (eqc_B m zero x) as H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "right.", "apply expf_B0_CS_2_aux; auto.", "--", "unfold eqc in H.", "qsimpl time: 1 use: eqc_B,planarity_crit_0.", "shelve.", "--", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "qsimpl time: 1 use: eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "shelve.", "-", "intros [Hpl0 Hex].", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "apply fast_Zred_factor6; auto.", "destruct ndN as [Hneq | ndNpf].", "+", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0.", "+", "qsimpl time: 1 use: inv_hmap,eqc_B,eqc,expf_B0_CS_1_c,cA_1,planarity_crit_0."], "tactic": "apply expf_planar_0 with m0 y; auto.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}]}, "chat": [], "original": "intros m x Hinv Hsucc. unfold B. unfold A. remember (B m zero x) as m0. remember (A m zero x) as y. split. - intro Hplanar. split. + apply planarity_crit_0 with m y; auto. apply eqc_B; auto. simpl. left. auto. + pose (eqc_B m zero x) as H. specialize (H Hinv Hsucc). simpl in H. right. apply expf_B0_CS_2_aux; auto. -- unfold cA_1. unfold eqc in H. destruct H as [H1 | [H1 | H1]]; apply H1. -- split; apply expf_B0_CS_1_c; auto; unfold cA_1; unfold eqc in H. destruct H as [H1 | [H1 | H1]]; apply H1. - intros [Hpl0 Hex]. assert (Hinvm0: inv_hmap m0) by (apply Hinv; auto). assert (Hsuccm0: succ m0 zero y) by (apply Hsucc; auto). apply planarity_criteria_0; auto. destruct Hex as [Hneq | Hexpf]. + left. apply not_eqc_planar_0 with m0 y; auto. + right. apply expf_planar_0 with m0 y; auto.", "back_times": 0, "succ": false, "time": 404.8161790370941}]