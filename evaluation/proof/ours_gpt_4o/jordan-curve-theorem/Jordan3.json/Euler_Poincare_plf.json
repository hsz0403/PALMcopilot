[{"history": {"proof": "srun best use: Zegal_left, planar_plf, Z.two_succ unfold: genus, BinIntDef.Z.div, BinIntDef.Z.sub.", "repairs": [], "exceptions": [{"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I]."], "tactic": "apply IH.", "exn": "In environment m : fmap x : dart t : tag p : point Hinv_Hm : inv_hmap m Hprec_I : prec_I m x IH : inv_hmap m -> ec m / 2 = nc m -> plf m Unable to unify \"ec m / 2 = nc m -> plf m\" with \"ec (I m x t p) / 2 = nc m + 1 -> plf m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1."], "tactic": "apply Hinv_Hm.", "exn": "In environment m : fmap x : dart t : tag p : point Hinv_Hm : inv_hmap m H : ec (I m x t p) / 2 = nc m + 1 H0 : ec m / 2 = nc m -> plf m H1 : x = nil -> False H2 : exd m x -> False Unable to unify \"inv_hmap m\" with \"plf m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1."], "tactic": "apply Hinv_Hm.", "exn": "In environment m : fmap x : dart t : tag p : point Hinv_Hm : inv_hmap m H : ec (I m x t p) / 2 = nc m + 1 H0 : ec m / 2 = nc m -> plf m H1 : x = nil -> False H2 : exd m x -> False Unable to unify \"inv_hmap m\" with \"plf m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1."], "tactic": "apply plf_Euler_Poincare.", "exn": "In environment m : fmap x : dart t : tag p : point Hinv_Hm : inv_hmap m H : ec (I m x t p) / 2 = nc m + 1 H0 : ec m / 2 = nc m -> plf m H1 : x = nil -> False H2 : exd m x -> False Unable to unify \"ec ?M2606 / 2 = nc ?M2606\" with \"(fix plf (m : fmap) : Prop := match m with | V => True | I m0 _ _ _ => plf m0 | L m0 zero x y => plf m0 /\\\\ (~ eqc m0 x y \\\\/ expf m0 (cA_1 m0 one x) y) | L m0 one x y => plf m0 /\\\\ (~ eqc m0 x y \\\\/ expf m0 x (cA m0 zero y)) end) m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare."], "tactic": "apply Hinv_Hm.", "exn": "In environment H3 : forall m : fmap, inv_hmap m -> plf m -> ec m / 2 = nc m m : fmap x : dart t : tag p : point Hinv_Hm : inv_hmap m H : ec (I m x t p) / 2 = nc m + 1 H0 : ec m / 2 = nc m -> plf m H1 : x = nil -> False H2 : exd m x -> False Unable to unify \"inv_hmap m\" with \"plf m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare."], "tactic": "apply IH.", "exn": "The reference IH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect."], "tactic": "apply Hinv_Hm.", "exn": "In environment H4 : forall m : fmap, inv_hmap m -> plf m -> ec m / 2 = nc m m : fmap x : dart t : tag p : point Hinv_Hm : inv_hmap m H : ec (I m x t p) / 2 = nc m + 1 H0 : ec m / 2 = nc m -> plf m H1 : x = nil -> False H2 : exd m x -> False Unable to unify \"inv_hmap m\" with \"plf V\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+"], "tactic": "apply IH.", "exn": "In environment m : fmap x, y : dart Hinv_Hm : inv_hmap m Hprec_L : prec_L m zero x y IH : inv_hmap m -> ec m / 2 = nc m -> plf m Unable to unify \"ec m / 2 = nc m -> plf m\" with \"ec (L m zero x y) / 2 = nc m - (if eqc_dec m x y then 0 else 1) -> plf m /\\\\ (~ eqc m x y \\\\/ expf m (cA_1 m one x) y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*"], "tactic": "apply Hinv_Hm.", "exn": "In environment H : forall m : fmap, inv_hmap m -> plf m -> ec m / 2 = nc m m : fmap x, y : dart Hinv_Hm : inv_hmap m e : eqc m x y Heqs : eqc_dec m x y = left e H0 : ec (L m zero x y) / 2 = nc m - 0 H1 : ec m / 2 = nc m -> plf m H2 : exd m x H4 : exd m y H3 : succ m zero x -> False H5 : pred m zero y -> False H7 : cA m zero x = y -> False Unable to unify \"inv_hmap m\" with \"plf m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare."], "tactic": "apply Hinv_Hm.", "exn": "In environment H6 : forall m : fmap, inv_hmap m -> plf m -> ec m / 2 = nc m m : fmap x, y : dart Hinv_Hm : inv_hmap m n : eqc m x y -> False Heqs : eqc_dec m x y = right n H0 : ec (L m zero x y) / 2 = nc m - 1 H1 : ec m / 2 = nc m -> plf m H2 : exd m x H4 : exd m y H3 : succ m zero x -> False H5 : pred m zero y -> False H7 : cA m zero x = y -> False Unable to unify \"inv_hmap m\" with \"plf m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm."], "tactic": "apply Z.le_antisymm.", "exn": "In environment H : forall m : fmap, inv_hmap m -> plf m -> ec m / 2 = nc m m : fmap x, y : dart Hinv_Hm : 2 * nc m >= ec m n : eqc m x y -> False Heqs : eqc_dec m x y = right n H0 : ec (L m zero x y) / 2 = nc m - 1 H1 : ec m / 2 = nc m -> plf m H2 : exd m x H4 : exd m y H3 : succ m zero x -> False H5 : pred m zero y -> False H7 : cA m zero x = y -> False Unable to unify \"?M6382 = ?M6383\" with \"(fix plf (m : fmap) : Prop := match m with | V => True | I m0 _ _ _ => plf m0 | L m0 zero x y => plf m0 /\\\\ (~ eqc m0 x y \\\\/ expf m0 (cA_1 m0 one x) y) | L m0 one x y => plf m0 /\\\\ (~ eqc m0 x y \\\\/ expf m0 x (cA m0 zero y)) end) m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare."], "tactic": "apply Z.max_r.", "exn": "In environment H6 : forall m : fmap, inv_hmap m -> plf m -> ec m / 2 = nc m m : fmap x, y : dart Heqz : nc m = 0 Hinv_Hm : 0 >= ec m n : eqc m x y -> False Heqs : eqc_dec m x y = right n H0 : ec (L m zero x y) / 2 = -1 H1 : ec m / 2 = 0 -> plf m H2 : exd m x H4 : exd m y H3 : succ m zero x -> False H5 : pred m zero y -> False H7 : cA m zero x = y -> False Unable to unify \"Z.max ?M8389 ?M8390 = ?M8390\" with \"(fix plf (m : fmap) : Prop := match m with | V => True | I m0 _ _ _ => plf m0 | L m0 zero x y => plf m0 /\\\\ (~ eqc m0 x y \\\\/ expf m0 (cA_1 m0 one x) y) | L m0 one x y => plf m0 /\\\\ (~ eqc m0 x y \\\\/ expf m0 x (cA m0 zero y)) end) m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare.", "qsimpl time: 1 use: Z,max_r,plf_Euler_Poincare."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare.", "qsimpl time: 1 use: Z,max_r,plf_Euler_Poincare.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare.", "qsimpl time: 1 use: Z,max_r,plf_Euler_Poincare.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply IH.", "exn": "The reference IH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare.", "qsimpl time: 1 use: Z,max_r,plf_Euler_Poincare.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply fast_Zred_factor0."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare.", "qsimpl time: 1 use: Z,max_r,plf_Euler_Poincare.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply fast_Zred_factor0.", "--", "shelve.", "--", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m Hinv_hec.", "induction m as [|m IH x t p|m IH k x y].", "-", "simpl.", "auto.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_I].", "qsimpl time: 1.", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply fmap_rect.", "qsimpl time: 1 use: plf_Euler_Poincare.", "+", "shelve.", "+", "shelve.", "-", "simpl in *.", "destruct Hinv_hec as [Hinv_Hm Hprec_L].", "destruct k.", "+", "qsimpl time: 1 use: plf_Euler_Poincare.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "shelve.", "*", "qsimpl time: 1 use: plf_Euler_Poincare.", "qsimpl time: 1 use: plf_Euler_Poincare.", "apply genus_theorem in Hinv_Hm.", "qsimpl time: 1 use: Z,plf_Euler_Poincare.", "qsimpl time: 1 use: Z,max_r,plf_Euler_Poincare.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply fast_Zred_factor0.", "--", "shelve.", "--", "shelve.", "+"], "tactic": ["apply Hinv_Hm.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "intros m Hinv_hec. induction m as [|m IH x t p|m IH k x y]. - simpl. auto. - simpl in *. destruct Hinv_hec as [Hinv_Hm Hprec_I]. apply IH. + apply Hinv_Hm. + split. * apply Hinv_Hm. * apply plf_Euler_Poincare. apply Hinv_Hm. apply IH. apply Hinv_Hm. - simpl in *. destruct Hinv_hec as [Hinv_Hm Hprec_L]. destruct k. + apply IH. * apply Hinv_Hm. * split. -- apply Hinv_Hm. -- apply genus_theorem in Hinv_Hm. apply Z.le_antisymm. apply Z.max_r. auto. + apply IH. * apply Hinv_Hm. * split. -- apply Hinv_Hm. -- apply genus_theorem in Hinv_Hm. apply Z.le_antisymm. apply Z.max_r. auto.", "back_times": 0, "succ": true, "time": 215.86885523796082}]