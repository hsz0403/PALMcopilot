[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*"], "tactic": "apply A_cA with (m := (B m j z)); auto.", "exn": "In environment m : fmap j : dim z : dart Hm : inv_hmap m Hsucc : succ m j z Heq3 : cA_1 (B m j z) j (A m j z) = z Unable to unify \"cA (B m j z) ?M2296 ?M2297 = ?M2298\" with \"(fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j z = cA m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B."], "tactic": "apply inv_hmap_L_B with (x := x); auto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B."], "tactic": "apply (exd_L_B m j x z); auto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*"], "tactic": "rewrite <- Heq3 in *.", "exn": "The reference Heq3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*"], "tactic": "apply A_1_cA_1_inv with (m := (B m j z)); auto.", "exn": "The reference A_1_cA_1_inv was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*"], "tactic": "apply inv_hmap_L_B with (x := x); auto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*"], "tactic": "apply (exd_L_B m j x z); auto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*"], "tactic": "apply A_cA with (m := (B m j z)); auto.", "exn": "In environment m : fmap j : dim x, z : dart Hm : inv_hmap m Hsucc : succ m j x Hneq2 : x <> z Heq3 : cA_1 (B m j z) j (A m j z) = z Unable to unify \"cA (B m j z) ?M2686 ?M2687 = ?M2688\" with \"(if eq_dart_dec (cA_1 (B m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x)) z then cA (B m j x) j x else cA (B m j x) j z) = cA m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++"], "tactic": "apply inv_hmap_L_B with (x := x); auto.", "exn": "In environment f : fmap -> dim -> dart -> fmap H : forall (m : fmap) (k : dim) (x y : dart), inv_hmap m -> exd m x -> exd m y -> A m k x = y -> cA m k x = y m : fmap j : dim x : dart Hm : inv_hmap m Hsucc : succ m j x Heq3 : cA_1 (B m j (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x))) j (A m j (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x))) = cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x) Hneq2 : x = cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x) -> False Heqs : eq_dart_dec (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x)) (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x)) = left eq_refl Unable to unify \"(fix inv_hmap (m : fmap) : Prop := match m with | V => True | I m0 x _ _ => inv_hmap m0 /\\\\ prec_I m0 x | L m0 k0 x y => inv_hmap m0 /\\\\ prec_L m0 k0 x y end) (B ?M4014 ?M4015 x) /\\\\ prec_L (B ?M4014 ?M4015 x) ?M4015 x (A ?M4014 ?M4015 x)\" with \"cA (f m j x) j x = cA m j (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++"], "tactic": "apply (exd_L_B m j x z); auto.", "exn": "In environment f : fmap -> dim -> dart -> fmap H : forall (m : fmap) (k : dim) (x y : dart), inv_hmap m -> exd m x -> exd m y -> A m k x = y -> cA m k x = y m : fmap j : dim x, z : dart Hm : inv_hmap m Hsucc : succ m j x Hneq2 : x = z -> False Heq3 : cA_1 (B m j z) j (A m j z) = z n : cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x) = z -> False Heqs : eq_dart_dec (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x)) z = right n Unable to unify \"let y := A m j x in exd (L (B m j x) j x y) z <-> exd m z\" with \"cA (f m j x) j z = cA m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B."], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*"], "tactic": "rewrite <- Heq3 in *.", "exn": "The reference Heq3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*"], "tactic": "apply A_1_cA_1_inv with (m := (B m j z)); auto.", "exn": "The reference A_1_cA_1_inv was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*"], "tactic": "apply inv_hmap_L_B with (x := x); auto.", "exn": "In environment m : fmap j : dim x, z : dart Hm : inv_hmap m Hsucc : succ m j x Hneq2 : x <> z Hneq3 : cA_1 (B m j z) j (A m j z) <> z Unable to unify \"(fix inv_hmap (m : fmap) : Prop := match m with | V => True | I m0 x _ _ => inv_hmap m0 /\\\\ prec_I m0 x | L m0 k0 x y => inv_hmap m0 /\\\\ prec_L m0 k0 x y end) (B ?M7213 ?M7214 x) /\\\\ prec_L (B ?M7213 ?M7214 x) ?M7214 x (A ?M7213 ?M7214 x)\" with \"(if eq_dart_dec (cA_1 (B m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x)) z then cA (B m j x) j x else cA (B m j x) j z) = cA m j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "++"], "tactic": "apply (exd_L_B m j x z); auto.", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "++"], "tactic": "-", "exn": "Wrong bullet -: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "++", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "++", "shelve.", "++"], "tactic": "eapply cA_cA_1_B_ter in Hneq; eauto.", "exn": "No such hypothesis: Hneq", "type": "no_hypos", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "++", "shelve.", "++", "qsimpl time: 1 use: A_cA,cA_cA_1_B_ter,inv_hmap_L_B,exd_L_B,B."], "tactic": "destruct Hneq as [H1 _].", "exn": "The reference Hneq was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hm Hsucc.", "simpl.", "unfold A in *.", "destruct (eq_dim_dec k j) as [Heq | Hneq].", "-", "subst.", "destruct (eq_dart_dec x z) as [Heq2 | Hneq2].", "+", "subst.", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3].", "*", "qsimpl time: 1 use: A_cA,B.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B.", "shelve.", "++", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "shelve.", "*", "qsimpl time: 1 use: inv_hmap_L_B,A_cA,B,exd_L_B.", "++", "shelve.", "++", "qsimpl time: 1 use: A_cA,cA_cA_1_B_ter,inv_hmap_L_B,exd_L_B,B."], "tactic": "apply H1.", "exn": "In environment H4 : forall (m : fmap) (k : dim) (x y : dart), inv_hmap m -> exd m x -> exd m y -> A m k x = y -> cA m k x = y f : fmap -> dim -> dart -> fmap m : fmap j : dim x, z : dart Hm : inv_hmap m Hsucc : succ m j x Hneq2 : x = z -> False Hneq3 : cA_1 (B m j z) j (A m j z) = z -> False H1 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> exd m z -> exd (f m k x) z H2 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> exd (f m k x) z -> exd m z H : forall (m : fmap) (k : dim) (x : dart), inv_hmap m -> succ m k x -> prec_L (B m k x) k x (A m k x) H3 : forall (m : fmap) (k : dim) (x : dart), inv_hmap m -> succ m k x -> inv_hmap (B m k x) n : cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x) = z -> False Heqs : eq_dart_dec (cA_1 (f m j x) j ((fix A (m : fmap) (k : dim) (x : dart) {struct m} : dart := match m with | V => nil | I m0 _ _ _ => A m0 k x | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then y0 else A m0 k x else A m0 k x end) m j x)) z = right n H9 : fmap H0 : forall (m : fmap) (k j : dim) (x z : dart), inv_hmap m -> (k = j -> False) -> cA_1 (B m k x) j z = cA_1 m j z H5 : forall (m : fmap) (k j : dim) (x z : dart), inv_hmap m -> (k = j -> False) -> cA (B m k x) j z = cA m j z H7 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> exd m z -> exd (B m k x) z H8 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> exd (B m k x) z -> exd m z Unable to unify \"(fix exd (m : fmap) (x : dart) {struct m} : Prop := match m with | V => False | I m0 x0 _ _ => x0 = x \\\\/ exd m0 x | L m0 _ _ _ => exd m0 x end) (f ?M13703 ?M13704 ?M13705) ?M13706\" with \"cA (f m j x) j z = cA m j z\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m k j x z Hm Hsucc. simpl. unfold A in *. destruct (eq_dim_dec k j) as [Heq | Hneq]. - subst. destruct (eq_dart_dec x z) as [Heq2 | Hneq2]. + subst. destruct (eq_dart_dec z z) as [_|Hf]; try contradiction. destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3]. * apply A_cA with (m := (B m j z)); auto. ++ apply inv_hmap_L_B with (x := x); auto. ++ apply (exd_L_B m j x z); auto. * rewrite <- Heq3 in *. apply A_1_cA_1_inv with (m := (B m j z)); auto. ++ apply inv_hmap_L_B with (x := x); auto. ++ apply (exd_L_B m j x z); auto. + destruct (eq_dart_dec (cA_1 (B m j z) j (A m j z)) z) as [Heq3 | Hneq3]. * apply A_cA with (m := (B m j z)); auto. ++ apply inv_hmap_L_B with (x := x); auto. ++ apply (exd_L_B m j x z); auto. * rewrite <- Heq3 in *. apply A_1_cA_1_inv with (m := (B m j z)); auto. ++ apply inv_hmap_L_B with (x := x); auto. ++ apply (exd_L_B m j x z); auto. - eapply cA_cA_1_B_ter in Hneq; eauto. destruct Hneq as [H1 _]. apply H1.", "back_times": 1, "succ": false, "time": 439.1341004371643}]