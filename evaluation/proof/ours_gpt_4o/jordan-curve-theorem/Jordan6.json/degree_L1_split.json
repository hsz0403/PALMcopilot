[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-"], "tactic": "rewrite <- Heqm1.", "exn": "Found no subterm matching \"L m one x y\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1."], "tactic": "apply expf_L1_x_y0.", "exn": "In environment m : fmap x, y : dart Unable to unify \"inv_hmap (L ?M2882 one ?M2883 ?M2884) /\\\\ MF.expo (L ?M2882 one ?M2883 ?M2884) ?M2883 (cA ?M2882 zero ?M2884)\" with \"(fix inv_hmap (m : fmap) : Prop := match m with | V => True | I m0 x _ _ => inv_hmap m0 /\\\\ prec_I m0 x | L m0 k0 x y => inv_hmap m0 /\\\\ prec_L m0 k0 x y end) m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+"], "tactic": "apply H_inv.", "exn": "The reference H_inv was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "unfold expf in H_expf.", "exn": "No such hypothesis: H_expf", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf."], "tactic": "destruct H_expf as [_ H_mexpo].", "exn": "The reference H_expf was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf."], "tactic": "apply expf_y0_y_1 with m; auto.", "exn": "In environment m : fmap x, y : dart X0 : Prop H : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> (expf m x (cA m zero y) -> False) -> expf (L m one x y) x (cA m zero y) The term \"m\" has type \"fmap\" while it is expected to have type \"nat\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf."], "tactic": "split; [apply H_inv | apply H_mexpo].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+"], "tactic": "assert (H_not_expf_y0_y_1 : ~ expf m x y0).", "exn": "The reference y0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x)."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+"], "tactic": "intro H_contra.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+"], "tactic": "unfold expf in H_contra.", "exn": "No such hypothesis: H_contra", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+"], "tactic": "qsimpl time: 1 use: all,auto,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "destruct H_contra as [_ H_mexpo_contra].", "exn": "The reference H_contra was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "assert (H_expf_12 : expf m y0 y_1).", "exn": "The reference y_1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "apply expf_L1_y0.", "exn": "In environment H2 : forall (m : fmap) (x y z : dart), inv_hmap m -> prec_L m one x y -> cF (L m one x y) z = (if eq_dart_dec (cA m zero y) z then x else if eq_dart_dec (cF_1 m x) z then cA_1 m one y else cF m z) H0 : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> expf m (cA m zero y) (cA_1 m one y) X : forall A : Type, (A -> Prop) -> Prop m : fmap x, y : dart H : succ m one x X1 : Prop H1 : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> (expf m x (cA m zero y) -> False) -> expf (L m one x y) x (cA m zero y) Unable to unify \"inv_hmap (L ?M4750 one ?M4751 ?M4752) /\\\\ MF.expo (L ?M4750 one ?M4751 ?M4752) (cA ?M4750 zero ?M4752) ?M4753\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "qsimpl time: 1 use: all,expf_L1_y0,auto,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+"], "tactic": "rewrite <- Heqm1.", "exn": "The reference Heqm1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+"], "tactic": "apply H_inv.", "exn": "The reference H_inv was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+"], "tactic": "apply H_expf.", "exn": "The reference H_expf was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0."], "tactic": "unfold expf in H_expf_12.", "exn": "No such hypothesis: H_expf_12", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0."], "tactic": "qsimpl time: 1 use: all,expf_L1_y0,auto,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "destruct H_expf_12 as [_ H_mexpo_12].", "exn": "The reference H_expf_12 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "unfold expf in H_mexpo.", "exn": "No such hypothesis: H_mexpo", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "qsimpl time: 1 use: all,expf_L1_y0,auto,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+"], "tactic": "assert (H_dx_plus_dy0 : MF.degree m1 x = MF.degree m x + MF.degree m y_1).", "exn": "The reference m1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+"], "tactic": "rewrite Heqy0.", "exn": "The reference Heqy0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1."], "tactic": "apply degree_L1_merge_y_1; auto.", "exn": "In environment m : fmap x, y : dart Unable to unify \"MF.degree (L ?M6544 one ?M6545 ?M6546) ?M6545 = MF.degree ?M6544 ?M6545 + MF.degree ?M6544 (cA_1 ?M6544 one ?M6546)\" with \"(fix exd (m : fmap) (x : dart) {struct m} : Prop := match m with | V => False | I m0 x0 _ _ => x0 = x \\\\/ exd m0 x | L m0 _ _ _ => exd m0 x end) m (McF.f_1 m x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1."], "tactic": "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,auto,expf_y0_y_1,expf_L1_x_y0,tauto,cF_L1,expf.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1."], "tactic": "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,tauto,cF_L1,expf.", "exn": "The reference tauto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1.", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "apply H_not_expf_y0_y_1.", "exn": "The reference H_not_expf_y0_y_1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1.", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "apply Decidable.dec_not_not.", "*"], "tactic": "rewrite H_dx_plus_dy0 in H.", "exn": "The reference H_dx_plus_dy0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1.", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "apply Decidable.dec_not_not.", "*"], "tactic": "apply degree_L1_split_y_1 with (j := 0) in H.", "exn": "Unable to apply lemma of type \"forall (m : fmap) (x y : dart) (j : nat), let m1 := L m one x y in let y0 := cA m zero y in let y_1 := cA_1 m one y in let dx := MF.degree m x in y0 = Iter (cF m) j x -> j < dx - 1 -> expf m x y0 -> inv_hmap m1 -> MF.degree m1 y_1 = dx - (j + 1)\" on hypothesis of type \"forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> (expf m x (cA_1 m one y) -> False) -> MF.degree (L m one x y) x = MF.degree m x + MF.degree m (cA_1 m one y)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1.", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "apply Decidable.dec_not_not.", "*"], "tactic": "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,degree_L1_split_y_1,auto,expf_y0_y_1,expf_L1_x_y0,tauto,cF_L1,expf.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1.", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "apply Decidable.dec_not_not.", "*"], "tactic": "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,degree_L1_split_y_1,expf_y0_y_1,expf_L1_x_y0,tauto,cF_L1,expf.", "exn": "The reference tauto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "intros H_inv H_expf.", "assert (H : expf m1 x y0).", "-", "qsimpl time: 1.", "qsimpl time: 1 use: expf_L1_x_y0.", "+", "apply fast_Zred_factor0.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: expf_L1_x_y0,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "qsimpl time: 1 use: expf_L1_x_y0,expf_y0_y_1,expf.", "shelve.", "+", "assert (H_not_expf_x_y_1 : ~ expf m x x).", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: all,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "apply H.", "shelve.", "+", "apply fast_Zred_factor0.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "qsimpl time: 1 use: all,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "shelve.", "+", "rewrite MF.exd_f_1.", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: all,degree_L1_merge_y_1,expf_L1_y0,degree_L1_split_y_1,expf_y0_y_1,expf_L1_x_y0,cF_L1,expf."], "tactic": "2: auto.", "exn": "No such goal. The current bullet * is unfinished.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros m x y. remember (L m one x y) as m1. remember (cA m zero y) as y0. remember (cA_1 m one y) as y_1. intros H_inv H_expf. assert (H : expf m1 x y0). - rewrite <- Heqm1. apply expf_L1_x_y0. + apply H_inv. + unfold expf in H_expf. destruct H_expf as [_ H_mexpo]. apply expf_y0_y_1 with m; auto. * split; [apply H_inv | apply H_mexpo]. * rewrite expf_y0_y_1 with m x y; auto. apply cF_L1. all:auto. - assert (H_not_expf_y0_y_1 : ~ expf m x y0). + intro H_contra. unfold expf in H_contra. destruct H_contra as [_ H_mexpo_contra]. assert (H_expf_12 : expf m y0 y_1). { apply expf_L1_y0. - rewrite <- Heqm1. apply H_inv. - apply H_expf. } unfold expf in H_expf_12. destruct H_expf_12 as [_ H_mexpo_12]. unfold expf in H_mexpo. tauto. + assert (H_dx_plus_dy0 : MF.degree m1 x = MF.degree m x + MF.degree m y_1). * rewrite Heqy0. apply degree_L1_merge_y_1; auto. apply H_not_expf_y0_y_1. * rewrite H_dx_plus_dy0 in H. apply degree_L1_split_y_1 with (j := 0) in H. 2: auto. simpl in H. lia.", "back_times": 0, "succ": false, "time": 308.622766494751}]