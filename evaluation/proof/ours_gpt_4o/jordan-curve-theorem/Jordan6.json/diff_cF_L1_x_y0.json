[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x y i j IH Hprec.", "destruct Hprec as [Hex_l [Hex_r [Hsuc [Hpred Hneq]]]].", "intros Hiter_exp Hexpf."], "tactic": ["intros [H_i [H_j Hd]].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros m x y i j IH Hprec. destruct Hprec as [Hex_l [Hex_r [Hsuc [Hpred Hneq]]]]. intros Hiter_exp Hexpf. intros [H_i [H_j Hd]]. pose (y0 := cA m zero y). pose (m1 := L m one x y). pose (dx := MF.degree m x). assert (Hexpf_m1 : expf m1 x y0). apply (expf_L1_x_y0 m x y); auto. assert (Hdegree: dx = MF.degree m x). reflexivity. pose (y0 := cA m zero y). destruct (expf_dec m x y0) as [Hexpf | Hnexpf]. - subst m1. destruct (lt_eq_lt_dec i j) as [[Hlt | Heq] | Hgt]. + specialize (cF_L1_x_y0 m x y i j IH). intros Hiter. rewrite Hiter in *; auto. apply Iter_f_eq in Hiter_exp as [k [Hk1 [Hk2 Hk3]]]. existential Hk1. assert (j < dx - 1); auto. apply (MF.degree_unicity m x y); try auto. * rewrite Hk3 in Hiter_exp. assert (i = j) by lia; subst; clear Hk1 Hk3 Hlt. auto. * apply Iter_f_eq in Hiter_exp as [l [Hl1 [Hl2 Hl3]]]. assert (Hdepth := Hl2).", "back_times": 0, "succ": false, "time": 145.01109170913696}]