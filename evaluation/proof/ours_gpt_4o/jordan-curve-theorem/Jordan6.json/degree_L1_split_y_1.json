[{"history": {"proof": "qsimpl time: 1 use: degree_L1_split_x_y0. qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux. qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux. qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1. qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1. qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1. qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "repairs": ["not_evaluable", "not_evaluable", "not_evaluable", "not_evaluable", "not_inductive_product", "not_inductive_product", "cannot_unify"], "exceptions": [{"ctx": ["intros m x y j.", "unfold expf."], "tactic": "unfold degree_L1_split_x_y0.", "exn": "Cannot coerce degree_L1_split_x_y0 to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0."], "tactic": "unfold degree_L1_split_x_aux.", "exn": "Cannot coerce degree_L1_split_x_aux to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux."], "tactic": "unfold degree_L1_split_y_1_aux.", "exn": "Cannot coerce degree_L1_split_y_1_aux to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux."], "tactic": "unfold degree_L1_split_x_y_1.", "exn": "Cannot coerce degree_L1_split_x_y_1 to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx."], "tactic": "intros H0 H1 H2 H3.", "exn": "H0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx."], "tactic": "intros H0' H1 H2 H3.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx."], "tactic": "intros H0' H1' H2 H3.", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx."], "tactic": "intros H0' H1' H2' H3.", "exn": "H3 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx."], "tactic": "intros H0' H1' H2' H3'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m)."], "tactic": "destruct H3 as [H3' _].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1."], "tactic": "apply H3'.", "exn": "The reference H3' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y)."], "tactic": "destruct H2 as [H2 [H2' H2'']].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1."], "tactic": "apply H2'.", "exn": "The reference H2' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0."], "tactic": "assert (j < dx - 1).", "exn": "The reference dx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1)."], "tactic": "apply H1.", "exn": "In environment H14 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H12 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat H0' : cA m zero y = Iter (cF m) j x H1 : j < MF.degree m x - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j Unable to unify \"j < MF.degree m x - 1\" with \"j < x0 - 1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1."], "tactic": "apply degree_y0_y_1.", "exn": "In environment H11 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H10 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat H0' : cA m zero y = Iter (cF m) j x H1 : j < MF.degree m x - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j Unable to unify \"MF.degree ?M15066 (cA ?M15066 zero ?M15068) = MF.degree ?M15066 (cA_1 ?M15066 one ?M15068)\" with \"S j <= x0 - 1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--"], "tactic": "apply H4.", "exn": "In environment H15 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H13 : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> MF.degree m (cA m zero y) = MF.degree m (cA_1 m one y) H0 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat H0' : cA m zero y = Iter (cF m) j x H1 : j < MF.degree m x - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j Unable to unify \"Iter (MF.f m) x0 x = cA m zero y\" with \"j < x0 - 1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y)."], "tactic": "destruct H3 as [_ H3''].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux."], "tactic": "apply H3''.", "exn": "The reference H3'' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux."], "tactic": "apply H.", "exn": "In environment H14 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H12 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat H0' : cA m zero y = Iter (cF m) j x H1 : j < MF.degree m x - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j H0 : j < x0 - 1 H10 : prec_L m one x y Unable to unify \"MF.degree (L ?M19673 one ?M19674 ?M19675) ?M19674 = ?M19676 + 1\" with \"Z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux."], "tactic": "++", "exn": "Wrong bullet ++: Expecting --.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--"], "tactic": "apply H5.", "exn": "In environment H14 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H12 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat H0' : cA m zero y = Iter (cF m) j x H1 : j < MF.degree m x - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j Unable to unify \"False\" with \"exists i : nat, Iter (MF.f m) i x = y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro."], "tactic": "apply (cF_L1_x_y0 m x y 0 j).", "exn": "In environment H13 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H10 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat H0' : cA m zero y = (fix Iter (g : dart -> dart) (n : nat) (z : dart) {struct n} : dart := match n with | 0 => z | S n0 => g (Iter g n0 z) end) (fun z : dart => cA_1 m one (cA_1 m zero z)) j x dx : nat Heqdx : dx = MF.degree m x H1 : j < dx - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j m1 : fmap Heqm1 : m1 = L m one x y y_1 : dart Heqy_1 : y_1 = cA_1 m one y H11 : inv_hmap m H0 : expf m x y H12 : y_1 = x Unable to unify \"Iter (cF (L m one x y)) 0 x = Iter (cF m) 0 x\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux."], "tactic": "apply H4.", "exn": "In environment H19 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H18 : forall (m : fmap) (x y : dart) (i j : nat), inv_hmap m -> prec_L m one x y -> cA m zero y = Iter (cF m) j x -> expf m x (cA m zero y) -> i <= j < MF.degree m x - 1 -> Iter (cF (L m one x y)) i x = Iter (cF m) i x H16 : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> MF.degree m (cA m zero y) = MF.degree m (cA_1 m one y) H14 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap y : dart j : nat H1 : j < MF.degree m (cA_1 m one y) - 1 H0' : cA m zero y = (fix Iter (g : dart -> dart) (n : nat) (z : dart) {struct n} : dart := match n with | 0 => z | S n0 => g (Iter g n0 z) end) (fun z : dart => cA_1 m one (cA_1 m zero z)) j (cA_1 m one y) H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m (cA_1 m one y) H6 : exd m y H5 : succ m one (cA_1 m one y) -> False H7 : pred m one y -> False H9 : cA m one (cA_1 m one y) = y -> False x0 : nat H4 : Iter (MF.f m) x0 (cA_1 m one y) = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j x : nat H11 : Iter (MF.f m) x (cA_1 m one y) = y Unable to unify \"Iter (MF.f m) x0 (cA_1 m one y) = cA m zero y\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux."], "tactic": "apply H3.", "exn": "In environment H17 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H15 : forall (m : fmap) (x y : dart) (i j : nat), inv_hmap m -> prec_L m one x y -> cA m zero y = Iter (cF m) j x -> expf m x (cA m zero y) -> i <= j < MF.degree m x - 1 -> Iter (cF (L m one x y)) i x = Iter (cF m) i x H12 : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> MF.degree m (cA m zero y) = MF.degree m (cA_1 m one y) H0 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap y : dart j : nat H1 : j < MF.degree m (cA_1 m one y) - 1 H0' : cA m zero y = (fix Iter (g : dart -> dart) (n : nat) (z : dart) {struct n} : dart := match n with | 0 => z | S n0 => g (Iter g n0 z) end) (fun z : dart => cA_1 m one (cA_1 m zero z)) j (cA_1 m one y) H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m (cA_1 m one y) H6 : exd m y H5 : succ m one (cA_1 m one y) -> False H7 : pred m one y -> False H9 : cA m one (cA_1 m one y) = y -> False x0 : nat H4 : Iter (MF.f m) x0 (cA_1 m one y) = cA m zero y H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (fun z : dart => cA_1 m one (cA_1 m zero z)) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j x : nat H11 : Iter (MF.f m) x (cA_1 m one y) = y Unable to unify \"exd m (cA_1 m one y)\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux."], "tactic": "exists x.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "apply H5."], "tactic": "apply expf0.", "exn": "The reference expf0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "apply H5.", "apply fast_Zred_factor0."], "tactic": "lia.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "apply H5.", "apply fast_Zred_factor0."], "tactic": ["rewrite <- H6.", "transform_curly"], "exn": "Cannot find an homogeneous relation to rewrite.", "type": "no_rewrite_homo", "handled": false}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "apply H5.", "apply fast_Zred_factor0."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "apply H5.", "apply fast_Zred_factor0.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--"], "tactic": "apply H2.", "exn": "In environment H13 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> j + 1 + i < MF.degree m x -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) (cA_1 m one y) (MF.degree m x - (j + 1 + i)) = MF.degree m x - (j + 1) H10 : forall (m : fmap) (x y : dart) (j i : nat), cA m zero y = Iter (cF m) j x -> i < j < MF.degree m x - 1 -> expf m x (cA m zero y) -> inv_hmap m /\\\\ prec_L m one x y -> MF.degree_aux (L m one x y) x (j - i) = j + 1 m : fmap x, y : dart j : nat y0 : dart Heqy0 : y0 = cA m zero y H0 : y0 = Iter (cF m) j x dx : nat Heqdx : dx = MF.degree m x H1 : j < dx - 1 H2 : inv_hmap m H : forall (m : fmap) (x y : dart) (j : nat), cA m zero y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> j < MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j + 1 H3 : exd m x H6 : exd m y H5 : succ m one x -> False H7 : pred m one y -> False H9 : cA m one x = y -> False x0 : nat H4 : Iter (MF.f m) x0 x = y0 H8 : forall (m : fmap) (x y : dart) (j : nat), cA_1 m one y = Iter (cF m) j x -> inv_hmap m -> prec_L m one x y -> 1 <= j <= MF.degree m x - 1 -> expf m x (cA m zero y) -> MF.degree (L m one x y) x = j m1 : fmap Heqm1 : m1 = L m one x y y_1 : dart Heqy_1 : y_1 = cA_1 m one y H11 : inv_hmap m Unable to unify \"inv_hmap m\" with \"MF.degree m1 y_1 = dx - (j + 1)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x y j.", "unfold expf.", "qsimpl time: 1 use: degree_L1_split_x_y0.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "remember (L m one x y) as m1.", "remember (cA m zero y) as y0.", "remember (cA_1 m one y) as y_1.", "remember (MF.degree m x) as dx.", "assert (inv_hmap m).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "rename H0 into H0'.", "assert (expf m x y).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "apply fast_Zred_factor0.", "assert (j < x0 - 1).", "qsimpl time: 1 use: degree_L1_split_x_y0,degree_L1_split_x_aux,degree_L1_split_y_1_aux,degree_L1_split_x_y_1.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (prec_L m one x y).", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "apply BinIntDef.Z.sub.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "--", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,degree_L1_split_y_1_aux.", "shelve.", "--", "assert (y_1 <> x).", "unfold cF in *.", "subst y0.", "unfold Iter in H0'.", "intro.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "qsimpl time: 1 use: degree_L1_split_x_aux,degree_L1_split_x_y0,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux.", "apply H5.", "apply fast_Zred_factor0.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--"], "tactic": "qsimpl time: 1 use: degree_L1_split_x_aux,diff_cF_L1_x_y0,degree_L1_split_x_y0,lia,degree_y0_y_1,degree_L1_split_x_y_1,cF_L1_x_y0,degree_L1_split_y_1_aux,expf.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros m x y j. unfold expf. unfold degree_L1_split_x_y0. unfold degree_L1_split_x_aux. unfold degree_L1_split_y_1_aux. unfold degree_L1_split_x_y_1. remember (L m one x y) as m1. remember (cA m zero y) as y0. remember (cA_1 m one y) as y_1. remember (MF.degree m x) as dx. intros H0 H1 H2 H3. assert (inv_hmap m). { destruct H3 as [H3' _]. apply H3'. } rename H0 into H0'. assert (expf m x y). { unfold expf in H2. destruct H2 as [H2 [H2' H2'']]. apply H2'. } assert (j < dx - 1). { apply H1. } apply degree_y0_y_1. -- apply H4. -- assert (prec_L m one x y). { destruct H3 as [_ H3'']. apply H3''. } unfold inv_hmap. split. ++ apply H. ++ apply H5. -- assert (y_1 <> x). { unfold cF in *. subst y0. unfold Iter in H0'. intro. apply (cF_L1_x_y0 m x y 0 j). apply H4. unfold prec_L. apply H3. exists x. split. apply H5. unfold expf. apply expf0. lia. rewrite <- H6. reflexivity. } apply diff_cF_L1_x_y0 with (j := j). apply H. apply H3. exists x. split. apply H5. unfold expf. apply expf0. lia. -- unfold expf. apply H2.", "back_times": 0, "succ": false, "time": 443.65683102607727}]