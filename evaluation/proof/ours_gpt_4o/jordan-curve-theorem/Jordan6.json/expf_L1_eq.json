[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-"], "tactic": "intros [H1 H2].", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-"], "tactic": "intros [H1' H2].", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+"], "tactic": ["destruct H1 as [Hm1_hexpo].", ""], "exn": "Expects a disjunctive pattern with 0 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-"], "tactic": "intros [H1 H2].", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-"], "tactic": "intros [H1' H2].", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H2."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H2.", "shelve.", "+", "destruct H2."], "tactic": "apply MF.expo_symm in H1.", "exn": "Unable to apply lemma of type \"forall (m : fmap) (z t : dart), inv_hmap m -> MF.expo m z t -> MF.expo m t z\" on hypothesis of type \"~ (inv_hmap m /\\\\ MF.expo m x z)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H2.", "shelve.", "+", "destruct H2."], "tactic": "qsimpl time: 1 use: expo_symm,auto,not_expf_L1_y0,MF,expf_L1_x_y0.", "exn": "The reference expo_symm was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H2.", "shelve.", "+", "destruct H2."], "tactic": "qsimpl time: 1 use: auto,not_expf_L1_y0,MF,expf_L1_x_y0.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H2.", "shelve.", "+", "destruct H2."], "tactic": "qsimpl time: 1 use: not_expf_L1_y0,MF,expf_L1_x_y0.", "exn": "The reference MF was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x y z t.", "set (m1 := L m one x y).", "set (y0 := cA m zero y).", "split.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H1.", "shelve.", "+", "shelve.", "-", "intros [H1' H2'].", "unfold expf in *.", "split.", "+", "destruct H2.", "shelve.", "+", "destruct H2.", "qsimpl time: 1 use: not_expf_L1_y0,expf_L1_x_y0."], "tactic": ["apply MF.expo_trans with (x := x) (y := z); auto.", ""], "exn": "No such bound variable x (possible names are: m, z, t and u).", "type": "no_such_bound", "handled": false}]}, "chat": [], "original": "intros m x y z t. set (m1 := L m one x y). set (y0 := cA m zero y). split. - intros [H1 H2]. unfold expf in *. split. + destruct H1. auto. + destruct H1 as [Hm1_hexpo]. apply MF.expo_symm. * apply inv_hmap_morph with (m := m1); auto. * apply not_expf_L1_y0 with (x := x) (z := z) (y := y); auto. apply MF.expo_symm; auto. * apply MF.expo_symm in H2. apply expf_L1_x_y0 with (x := x) (y := y); auto. - intros [H1 H2]. unfold expf in *. split. + destruct H2. auto. + destruct H2. apply MF.expo_symm in H1. apply MF.expo_trans with (x := x) (y := z); auto. apply MF.expo_symm; auto. apply expf_L1_x_y0; auto. apply MF.expo_symm. auto.", "back_times": 0, "succ": false, "time": 345.1636896133423}]