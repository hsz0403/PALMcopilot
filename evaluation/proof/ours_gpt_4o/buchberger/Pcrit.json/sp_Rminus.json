[{"history": {"proof": "qsimpl time: 1 use: eqTerm_spolyf_red2.", "repairs": ["cannot_unify"], "exceptions": [{"ctx": ["intros a b nZb p q can_a can_b."], "tactic": "apply eqTerm_spolyf_red2.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) a, b : Term A n nZb : ~ zeroP A0 eqA (n:=n) b p, q : list (Term A n) can_a : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) can_b : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q) Unable to unify \"eqP ?M2280 ?M2283 ?M2291 (mults ?M2287 (divTerm ?M2288 ?M2297 (b:=ppc ?M2282 ?M2295 ?M2296) ?M2300) (spolyf ?M2280 ?M2281 ?M2282 ?M2283 ?M2285 ?M2286 ?M2287 ?M2288 ?M2290 ?M2291 ?M2292 ?M2293 (pX ?M2295 ?M2303) (pX ?M2296 ?M2304) ?M2306 ?M2307)) (minuspf ?M2280 ?M2281 ?M2282 ?M2283 ?M2285 ?M2286 ?M2287 ?M2290 ?M2291 ?M2292 ?M2293 (spminusf ?M2280 ?M2281 ?M2282 ?M2283 ?M2285 ?M2286 ?M2287 ?M2288 ?M2290 ?M2291 ?M2292 ?M2293 ?M2297 ?M2296 ?M2299 ?M2305 ?M2304) (spminusf ?M2280 ?M2281 ?M2282 ?M2283 ?M2285 ?M2286 ?M2287 ?M2288 ?M2290 ?M2291 ?M2292 ?M2293 ?M2297 ?M2295 ?M2298 ?M2305 ?M2303))\" with \"eqP A eqA n (Rminus b nZb (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) b p) (mults multA (n:=n) a q)) (pX (A:=A) (n:=n) b q) (mults multA (n:=n) b p)) (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) a p) q))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-"], "tactic": "apply eqA_dec.", "exn": "In environment H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZppab : zeroP A0 eqA (n:=n) (ppc A1 (n:=n) a b) -> False), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:= ppc A1 (n:=n) a b) nZppab) (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q)))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) H0 : olist (A:=A) ltM (pX (A:=A) (n:=n) b q) H2 : nZterm A0 eqA (n:=n) q H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H5 : nZterm A0 eqA (n:=n) p H6 : zeroP A0 eqA (n:=n) a -> False M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M6131 ?M6132} + {eqA ?M6131 ?M6132 -> False}\" with \"forall x : list (Term A n), eqP A eqA n x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-"], "tactic": "apply mults_comp_minuspf.", "exn": "In environment H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZppab : zeroP A0 eqA (n:=n) (ppc A1 (n:=n) a b) -> False), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:= ppc A1 (n:=n) a b) nZppab) (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q)))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) H0 : olist (A:=A) ltM (pX (A:=A) (n:=n) b q) H2 : nZterm A0 eqA (n:=n) q H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H5 : nZterm A0 eqA (n:=n) p H6 : zeroP A0 eqA (n:=n) a -> False M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M9246 ?M9249 ?M9257 (minuspf ?M9246 ?M9247 ?M9248 ?M9249 ?M9251 ?M9252 ?M9253 ?M9256 ?M9257 ?M9258 ?M9259 (mults ?M9253 ?M9261 ?M9262) (mults ?M9253 ?M9261 ?M9263)) (mults ?M9253 ?M9261 (minuspf ?M9246 ?M9247 ?M9248 ?M9249 ?M9251 ?M9252 ?M9253 ?M9256 ?M9257 ?M9258 ?M9259 ?M9262 ?M9263))\" with \"eqP A eqA n (mults multA (n:=n) (invA A1, M1 n) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a q) (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q))) (Rminus b nZb (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) b p) (mults multA (n:=n) a q)) (pX (A:=A) (n:=n) b q) (mults multA (n:=n) b p))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+"], "tactic": "apply eqA_dec.", "exn": "In environment H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZppab : zeroP A0 eqA (n:=n) (ppc A1 (n:=n) a b) -> False), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:= ppc A1 (n:=n) a b) nZppab) (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q)))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)) H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) H0 : olist (A:=A) ltM (pX (A:=A) (n:=n) b q) H2 : nZterm A0 eqA (n:=n) q H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H5 : nZterm A0 eqA (n:=n) p H6 : zeroP A0 eqA (n:=n) a -> False M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M12186 ?M12187} + {eqA ?M12186 ?M12187 -> False}\" with \"forall x : list (Term A n), eqP A eqA n x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+"], "tactic": "apply spoly_is_minus.", "exn": "In environment H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZppab : zeroP A0 eqA (n:=n) (ppc A1 (n:=n) a b) -> False), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:= ppc A1 (n:=n) a b) nZppab) (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q)))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)) H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) H0 : olist (A:=A) ltM (pX (A:=A) (n:=n) b q) H2 : nZterm A0 eqA (n:=n) q H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H5 : nZterm A0 eqA (n:=n) p H6 : zeroP A0 eqA (n:=n) a -> False M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M15733 ?M15736 ?M15744 (spolyf ?M15733 ?M15734 ?M15735 ?M15736 ?M15738 ?M15739 ?M15740 ?M15741 ?M15743 ?M15744 ?M15745 ?M15746 (pX ?M15748 ?M15752) (pX ?M15749 ?M15753) ?M15754 ?M15755) (minuspf ?M15733 ?M15734 ?M15735 ?M15736 ?M15738 ?M15739 ?M15740 ?M15743 ?M15744 ?M15745 ?M15746 (mults ?M15740 (divTerm ?M15741 (ppc ?M15735 ?M15748 ?M15749) ?M15750) (pX ?M15748 ?M15752)) (mults ?M15740 (divTerm ?M15741 (ppc ?M15735 ?M15748 ?M15749) ?M15751) (pX ?M15749 ?M15753)))\" with \"eqP A eqA n (Rminus b nZb (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) b p) (mults multA (n:=n) a q)) (pX (A:=A) (n:=n) b q) (mults multA (n:=n) b p)) (mults multA (n:=n) (invA A1, M1 n) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a q) (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*"], "tactic": "apply eqA_dec.", "exn": "In environment H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZppab : zeroP A0 eqA (n:=n) (ppc A1 (n:=n) a b) -> False), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:= ppc A1 (n:=n) a b) nZppab) (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q)))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), eqP A eqA n (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=a) nZa) a) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=a) nZa) p)) (pX (A:=A) (n:=n) (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=b) nZb) b) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=b) nZb) q))) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) H0 : olist (A:=A) ltM (pX (A:=A) (n:=n) b q) H2 : nZterm A0 eqA (n:=n) q H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H5 : nZterm A0 eqA (n:=n) p H6 : zeroP A0 eqA (n:=n) a -> False M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M19053 ?M19054} + {eqA ?M19053 ?M19054 -> False}\" with \"forall x : list (Term A n), eqP A eqA n x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*", "apply Build_preorder."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*"], "tactic": "apply multlm_comp_canonical.", "exn": "In environment H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZppab : zeroP A0 eqA (n:=n) (ppc A1 (n:=n) a b) -> False), divP A A0 eqA multA divA n c a -> divP A A0 eqA multA divA n c b -> forall (p q r : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), canonical A0 eqA ltM r -> eqP A eqA n (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) c (b:= ppc A1 (n:=n) a b) nZppab) (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q)))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c b nZb r q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec c a nZa r p)) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZa : zeroP A0 eqA (n:=n) a -> False) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)) (Cpxa : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), eqP A eqA n (LetP (Term A n) (list (Term A n)) (ppc A1 (n:=n) a b) (fun (u : Term A n) (_ : u = ppc A1 (n:=n) a b) => minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=a) (canonical_nzeroP A A0 eqA n ltM a p Cpxa)) p) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) u (b:=b) (canonical_nzeroP A A0 eqA n ltM b q Cpxb)) q))) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=a) nZa) a) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=a) nZa) p)) (pX (A:=A) (n:=n) (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=b) nZb) b) (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (ppc A1 (n:=n) a b) (b:=b) nZb) q))) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) H0 : olist (A:=A) ltM (pX (A:=A) (n:=n) b q) H2 : nZterm A0 eqA (n:=n) q H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H5 : nZterm A0 eqA (n:=n) p H6 : zeroP A0 eqA (n:=n) a -> False M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"olist ?M23084 (pX (multTerm ?M23079 ?M23088 ?M23087) (mults ?M23079 ?M23088 ?M23086)) /\\\\ nZterm ?M23073 ?M23075 (pX (multTerm ?M23079 ?M23088 ?M23087) (mults ?M23079 ?M23088 ?M23086))\" with \"eqP A eqA n (mults multA (n:=n) (invA A1, M1 n) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a q) (multpf A A0 eqA plusA multA eqA_dec n ltM ltM_dec p q))) (Rminus b nZb (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) b p) (mults multA (n:=n) a q)) (pX (A:=A) (n:=n) b q) (mults multA (n:=n) b p))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,multlm_comp_canonical,eqTerm_spolyf_red2."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a b nZb p q can_a can_b.", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "apply Build_equivalence.", "-", "qsimpl time: 1 use: eqTerm_spolyf_red2.", "shelve.", "-", "apply Build_preorder.", "+", "shelve.", "+", "shelve.", "-", "shelve.", "-", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "+", "apply Build_preorder.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,eqTerm_spolyf_red2.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "*", "qsimpl time: 1 use: spoly_is_minus,mults_comp_minuspf,multlm_comp_canonical,eqTerm_spolyf_red2.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros a b nZb p q can_a can_b. apply eqTerm_spolyf_red2. - apply cs. - apply eqA_dec. - apply os. - auto. - apply mults_comp_minuspf. + apply cs. + apply eqA_dec. + apply os. + auto. + apply spoly_is_minus. * apply cs. * apply eqA_dec. * apply os. * auto. - apply multlm_comp_canonical. + apply cs. + apply eqA_dec. + auto. - apply spolyf_def. + apply cs. + apply eqA_dec. + apply os. + apply mults_dist1. * apply cs. * apply eqA_dec. * auto.", "back_times": 0, "succ": false, "time": 178.75683617591858}]