[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-"], "tactic": "apply SpolyQ_imp_ConfluentReduce.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"ConfluentReduce ?M2250 ?M2251 ?M2252 ?M2253 ?M2255 ?M2256 ?M2257 ?M2258 ?M2260 ?M2261 ?M2262 ?M2263 ?M2265\" with \"CoefStructure A A0 A1 eqA plusA invA minusA multA divA\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-"], "tactic": "apply Grobner_imp_SpolyQ.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"SpolyQ ?M2262 ?M2263 ?M2264 ?M2265 ?M2267 ?M2268 ?M2269 ?M2270 ?M2272 ?M2273 ?M2274 ?M2275 ?M2277\" with \"OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-"], "tactic": "apply buch_Grobner.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"Grobner ?M2274 ?M2275 ?M2276 ?M2277 ?M2278 ?M2279 ?M2280 ?M2281 ?M2282 ?M2284 ?M2285 ?M2286 ?M2287 (buch ?M2274 ?M2275 ?M2276 ?M2277 ?M2278 ?M2279 ?M2280 ?M2281 ?M2282 ?M2283 ?M2284 ?M2285 ?M2286 ?M2287 ?M2288 ?M2289)\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce."], "tactic": "apply buch_Stable.", "exn": "In environment H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"stable ?M6609 ?M6610 ?M6612 ?M6613 ?M6616 ?M6619 ?M6620 ?M6621 ?M6622 ?M6624 (buch ?M6609 ?M6610 ?M6611 ?M6612 ?M6613 ?M6614 ?M6615 ?M6616 ?M6617 ?M6618 ?M6619 ?M6620 ?M6621 ?M6622 ?M6623 ?M6624)\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce."], "tactic": "apply OBuch_Stable.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"stable ?M11876 ?M11877 ?M11879 ?M11880 ?M11883 ?M11886 ?M11887 ?M11888 ?M11889 ?M11891 ?M11893\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable."], "tactic": "apply reds0.", "exn": "In environment H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"reds ?M18275 ?M18276 ?M18277 ?M18278 ?M18279 ?M18280 ?M18281 ?M18282 ?M18283 ?M18284 ?M18285 ?M18286 ?M18287 ?M18288 ?M18289 ?M18291 ?M18292 ?M18290\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable."], "tactic": "apply reds_com.", "exn": "In environment H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"reds ?M25750 ?M25751 ?M25752 ?M25753 ?M25754 ?M25755 ?M25756 ?M25757 ?M25758 ?M25759 ?M25760 ?M25761 ?M25762 ?M25763 ?M25764 ?M25767 ?M25766 ?M25765\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable."], "tactic": "apply redInInclQ.", "exn": "In environment H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"redIn ?M34301 ?M34302 ?M34303 ?M34304 ?M34305 ?M34306 ?M34307 ?M34308 ?M34309 ?M34310 ?M34311 ?M34312 ?M34313 ?M34314 ?M34315 ?M34319 ?M34320 ?M34316 ?M34322 ?M34318\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable."], "tactic": "apply redIn1.", "exn": "In environment H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"redIn ?M44152 ?M44153 ?M44154 ?M44155 ?M44156 ?M44157 ?M44158 ?M44159 ?M44160 ?M44161 ?M44162 ?M44163 ?M44164 ?M44165 ?M44166 ?M44170 ?M44171 ?M44167 ?M44168 ?M44169\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable."], "tactic": "apply redIn2.", "exn": "In environment H15 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"redIn ?M55191 ?M55192 ?M55193 ?M55194 ?M55195 ?M55196 ?M55197 ?M55198 ?M55199 ?M55200 ?M55201 ?M55202 ?M55203 ?M55204 ?M55205 ?M55209 ?M55210 ?M55206 ?M55207 ?M55208\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable."], "tactic": "apply redIn0b.", "exn": "In environment H17 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"redIn ?M67642 ?M67643 ?M67644 ?M67645 ?M67646 ?M67647 ?M67648 ?M67649 ?M67650 ?M67651 ?M67652 ?M67653 ?M67654 ?M67655 ?M67656 ?M67660 ?M67661 ?M67657 ?M67658 ?M67659\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable."], "tactic": "apply redIn0.", "exn": "In environment H19 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H18 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H15 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"redIn ?M81281 ?M81282 ?M81283 ?M81284 ?M81285 ?M81286 ?M81287 ?M81288 ?M81289 ?M81290 ?M81291 ?M81292 ?M81293 ?M81294 ?M81295 ?M81299 ?M81300 ?M81296 ?M81297 ?M81298\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable."], "tactic": "apply foreigner_red.", "exn": "In environment H21 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H20 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H17 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), In (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) Q -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"reducestar ?M96108 ?M96109 ?M96110 ?M96111 ?M96113 ?M96114 ?M96115 ?M96116 ?M96118 ?M96119 ?M96120 ?M96121 ?M96125 (s2p ?M96108 ?M96109 ?M96111 ?M96119 ?M96120 (spolyp ?M96108 ?M96109 ?M96110 ?M96111 ?M96112 ?M96113 ?M96114 ?M96115 ?M96116 ?M96117 ?M96118 ?M96119 ?M96120 ?M96121 ?M96122 ?M96123 ?M96124)) (pO ?M96108 ?M96119)\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable."], "tactic": "apply reduceplus_cb.", "exn": "In environment H23 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H22 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H19 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H18 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H15 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), In (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) Q -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), foreigner A A0 A1 eqA multA n ltM a b -> In a P -> In b P -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"CombLinear ?M112123 ?M112124 ?M112126 ?M112127 ?M112130 ?M112133 ?M112134 ?M112135 ?M112136 ?M112140 ?M112139\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reduceplus_cb,reds_com,redIn2,buch_Stable."], "tactic": "apply reducestar_cb.", "exn": "In environment H25 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H24 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H21 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H20 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q b H17 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), In (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) Q -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), foreigner A A0 A1 eqA multA n ltM a b -> In a P -> In b P -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"CombLinear ?M129326 ?M129327 ?M129329 ?M129330 ?M129333 ?M129336 ?M129337 ?M129338 ?M129339 ?M129343 ?M129342\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reduceplus_cb,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,reducestar_cb,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reduceplus_cb,reds_com,redIn2,buch_Stable."], "tactic": "apply Reducef.", "exn": "In environment H27 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H26 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H23 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H22 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q b H19 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H18 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H15 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), In (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) Q -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q b H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), foreigner A A0 A1 eqA multA n ltM a b -> In a P -> In b P -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"{q : poly ?M147718 ?M147720 ?M147729 | reducestar ?M147717 ?M147718 ?M147719 ?M147720 ?M147722 ?M147723 ?M147724 ?M147725 ?M147727 ?M147728 ?M147729 ?M147730 ?M147732 (s2p ?M147717 ?M147718 ?M147720 ?M147728 ?M147729 ?M147733) (s2p ?M147717 ?M147718 ?M147720 ?M147728 ?M147729 q)}\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P.", "apply ConfluentReduce_imp_Grobner.", "-", "qsimpl time: 1 use: SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "-", "qsimpl time: 1 use: buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Stable,buch_Grobner,Grobner_imp_SpolyQ,SpolyQ_imp_ConfluentReduce.", "qsimpl time: 1 use: buch_Grobner,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reduceplus_cb,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,reducestar_cb,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reduceplus_cb,reds_com,redIn2,buch_Stable.", "qsimpl time: 1 use: buch_Grobner,reds0,redIn0b,foreigner_red,SpolyQ_imp_ConfluentReduce,redInInclQ,redIn1,Reducef,reducestar_cb,redIn0,OBuch_Stable,Grobner_imp_SpolyQ,reduceplus_cb,reds_com,redIn2,buch_Stable."], "tactic": "apply red_incl.", "exn": "In environment H28 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) H25 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b c : poly A0 eqA ltM), In c P -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a c P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b c P Q R -> divp A A0 eqA multA divA n ltM (ppcp A A0 A1 eqA plusA invA minusA multA divA cs n ltM a b) c -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H24 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P H21 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q b H20 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H17 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)), OBuch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P Q R -> (forall a : poly A0 eqA ltM, In a Q -> Cb A A0 eqA plusA multA eqA_dec n ltM ltM_dec a P) -> stable A A0 eqA plusA multA eqA_dec n ltM ltM_dec P R H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), In (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) Q -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : list (Term A n)) (Q : list (poly A0 eqA ltM)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q a b -> canonical A0 eqA ltM a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q a -> CombLinear A A0 eqA plusA multA eqA_dec n ltM ltM_dec Q b X : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p : poly A0 eqA ltM), {q : poly A0 eqA ltM | reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (s2p A A0 eqA n ltM p) (s2p A A0 eqA n ltM q)} H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R -> forall Q1 : list (poly A0 eqA ltM), incl Q Q1 -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q1 R H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall Q : list (poly A0 eqA ltM), SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (a b : poly A0 eqA ltM) (P : list (poly A0 eqA ltM)), foreigner A A0 A1 eqA multA n ltM a b -> In a P -> In b P -> red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P Q R : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os b a P Q R -> redIn A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P Q R H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)) (a b : poly A0 eqA ltM), red A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (spolyp A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b) P -> reds A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a b P H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)) (P : list (poly A0 eqA ltM)), Grobner A A0 A1 eqA plusA invA minusA multA divA eqA_dec n ltM ltM_dec (buch A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os P) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) P : list (poly A0 eqA ltM) Unable to unify \"reducestar ?M167072 ?M167073 ?M167074 ?M167075 ?M167077 ?M167078 ?M167079 ?M167080 ?M167082 ?M167083 ?M167084 ?M167085 ?M167089 (s2p ?M167072 ?M167073 ?M167075 ?M167083 ?M167084 ?M167087) (pO ?M167072 ?M167083)\" with \"ConfluentReduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (redbuch P)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros P. apply ConfluentReduce_imp_Grobner. - apply SpolyQ_imp_ConfluentReduce. + apply Grobner_imp_SpolyQ. * apply buch_Grobner. { apply buch_Stable. { apply OBuch_Stable. } } * apply reds0. { apply reds_com. { apply redInInclQ. { apply redIn1. { apply redIn2. { apply redIn0b. { apply redIn0. } } } } } } + apply foreigner_red. * apply reduceplus_cb. * apply reducestar_cb. + apply Reducef. * apply red_incl.", "back_times": 0, "succ": false, "time": 130.12869930267334}]