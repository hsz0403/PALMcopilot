[{"history": {"proof": "qsimpl time: 1 use: nf_divp. qsimpl time: 1 use: nf_divp. qsimpl time: 1 use: in_inv,nf_divp. qsimpl time: 1 use: in_inv,nf_divp. qsimpl time: 1 use: in_inv,nf_divp. qsimpl time: 1 use: in_inv,nf_divp.", "repairs": ["cannot_apply_in", "no_instance_var", "no_hypos", "no_instance_var", "not_inductive_goal", "not_inductive_goal"], "exceptions": [{"ctx": ["intros p L H1 H2."], "tactic": "apply nf_divp in H2 as [q [H3 [H4 H5]]].", "exn": "Unable to apply lemma of type \"forall (p : poly A0 eqA ltM) (L : list (poly A0 eqA ltM)), ~ zerop A A0 eqA n ltM p -> ~ zerop A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p L) -> exists q : poly A0 eqA ltM, In q (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p L :: L) /\\\\ divp A A0 eqA multA divA n ltM p q /\\\\ ~ zerop A A0 eqA n ltM q\" on hypothesis of type \"zerop A A0 eqA n ltM (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os p L)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp."], "tactic": "exists q.", "exn": "The reference q was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: nf_divp."], "tactic": "apply in_inv in H3.", "exn": "No such hypothesis: H3", "type": "no_hypos", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp."], "tactic": "destruct H3 as [H3 | H3].", "exn": "Unable to find an instance for the variables p, L.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros p L H1 H2.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp.", "qsimpl time: 1 use: in_inv,nf_divp."], "tactic": ["apply get_is_correct with (p:=p) (L:=L).", ""], "exn": "No such bound variable p (possible names are: A, A0, A1, eqA, plusA, invA, minusA, multA, divA, cs, eqA_dec, n, ltM, ltM_dec, os, a, b and P).", "type": "no_such_bound", "handled": false}]}, "chat": [], "original": "intros p L H1 H2. apply nf_divp in H2 as [q [H3 [H4 H5]]]. exists q. split. - apply in_inv in H3. destruct H3 as [H3 | H3]. + left. auto. + right. apply get_is_correct with (p:=p) (L:=L). auto. - split; auto.", "back_times": 0, "succ": false, "time": 79.72473096847534}]