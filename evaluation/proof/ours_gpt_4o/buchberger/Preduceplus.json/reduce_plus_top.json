[{"history": {"proof": "qsimpl time: 1 use: pluspf,spminusf. qsimpl time: 1 use: pluspf,spminusf. qsimpl time: 1 use: Rstar_n,pluspf,spminusf,pX. qsimpl time: 1 use: Rstar_n,pluspf,reducetop_sp,spminusf,pX. qsimpl time: 1 use: reduce_eqp_com,Rstar_n,pluspf,reducetop_sp,spminusf,pX. qsimpl time: 1 use: reduce_eqp_com,Rstar_n,pluspf,reducetop_sp,spminusf,pX,eqp_spminusf_com.", "repairs": ["wrong_type", "no_instance_var", "wrong_type", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP."], "tactic": "exists (pluspf A0 eqA plusA eqA_dec (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r).", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) r : list (Term A n) Hcanon_r : canonical A0 eqA ltM r a, b : Term A n nZb : ~ zeroP A0 eqA (n:=n) b p, q : list (Term A n) HinP : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q HQ : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) HdivP : divP A A0 eqA multA divA n a b The term \"eqA\" has type \"A -> A -> Prop\" while it is expected to have type \"A -> A -> A\" (cannot unify \"Prop\" and \"A\").", "type": "wrong_type", "handled": true}, {"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP.", "qsimpl time: 1 use: pluspf,spminusf."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: pluspf,spminusf."], "tactic": "apply Rstar_n with (x := pluspf A0 eqA plusA eqA_dec (ltM:=ltM) ltM_dec (pX a p) r).", "exn": "In environment X0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinP : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb0 : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb0) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) The term \"eqA\" has type \"A -> A -> Prop\" while it is expected to have type \"A -> A -> A\" (cannot unify \"Prop\" and \"A\").", "type": "wrong_type", "handled": true}, {"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: Rstar_n,pluspf,spminusf,pX."], "tactic": "apply reducetop_sp.", "exn": "In environment l1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H4 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z X0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinP : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb0 : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb0) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduce ?M20967 ?M20968 ?M20969 ?M20970 ?M20972 ?M20973 ?M20974 ?M20975 ?M20977 ?M20978 ?M20979 ?M20980 ?M20981 (pX ?M20982 ?M20985) (spminusf ?M20967 ?M20968 ?M20969 ?M20970 ?M20972 ?M20973 ?M20974 ?M20975 ?M20977 ?M20978 ?M20979 ?M20980 ?M20982 ?M20983 ?M20984 ?M20985 ?M20986)\" with \"exists s : list (Term A n), reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l1 A n a p) r) s /\\\\ reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: Rstar_n,pluspf,spminusf,pX.", "qsimpl time: 1 use: Rstar_n,pluspf,reducetop_sp,spminusf,pX."], "tactic": "apply reduce_eqp_com.", "exn": "In environment X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) X3 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H6 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z l1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinP : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb0 : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb0) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduce ?M28787 ?M28788 ?M28789 ?M28790 ?M28792 ?M28793 ?M28794 ?M28795 ?M28797 ?M28798 ?M28799 ?M28800 ?M28802 ?M28805 ?M28806\" with \"exists s : list (Term A n), reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l1 A n a p) r) s /\\\\ reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: Rstar_n,pluspf,spminusf,pX.", "qsimpl time: 1 use: Rstar_n,pluspf,reducetop_sp,spminusf,pX.", "qsimpl time: 1 use: reduce_eqp_com,Rstar_n,pluspf,reducetop_sp,spminusf,pX."], "tactic": "apply eqp_spminusf_com.", "exn": "In environment X8 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X7 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H8 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X3 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinP : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb0 : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb0) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M38207 ?M38210 ?M38218 (spminusf ?M38207 ?M38208 ?M38209 ?M38210 ?M38212 ?M38213 ?M38214 ?M38215 ?M38217 ?M38218 ?M38219 ?M38220 ?M38222 ?M38224 ?M38225 ?M38226 ?M38228) (spminusf ?M38207 ?M38208 ?M38209 ?M38210 ?M38212 ?M38213 ?M38214 ?M38215 ?M38217 ?M38218 ?M38219 ?M38220 ?M38223 ?M38224 ?M38225 ?M38227 ?M38228)\" with \"exists s : list (Term A n), reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l1 A n a p) r) s /\\\\ reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon_r a b nZb p q HinP HQ HdivP.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: pluspf,spminusf.", "qsimpl time: 1 use: Rstar_n,pluspf,spminusf,pX.", "qsimpl time: 1 use: Rstar_n,pluspf,reducetop_sp,spminusf,pX.", "qsimpl time: 1 use: reduce_eqp_com,Rstar_n,pluspf,reducetop_sp,spminusf,pX.", "qsimpl time: 1 use: reduce_eqp_com,Rstar_n,pluspf,reducetop_sp,spminusf,pX,eqp_spminusf_com."], "tactic": "apply Rstar_n with (x := spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r).", "exn": "In environment l2 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> eqTerm eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (l2 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) (l2 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc q r) X10 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) X9 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H7 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s X8 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X7 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X3 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) X : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> Term A n -> forall b : Term A n, (zeroP A0 eqA (n:=n) b -> False) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n nZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinP : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb0 : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb0) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduceplus ?M49291 (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r) ?M49294\" with \"exists s : list (Term A n), reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l1 A n a p) r) s /\\\\ reduceplus Q (l A A0 eqA plusA eqA_dec n ltM ltM_dec (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros Q r Hcanon_r a b nZb p q HinP HQ HdivP. exists (pluspf A0 eqA plusA eqA_dec (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r). split. - apply Rstar_n with (x := pluspf A0 eqA plusA eqA_dec (ltM:=ltM) ltM_dec (pX a p) r). + apply reducetop_sp. auto. + apply reduce_eqp_com. apply eqp_spminusf_com. auto. - apply Rstar_n with (x := spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r). + apply reduce_eqp_com. apply eqptail_spminusf_com. auto. + apply Rstar_0. apply eqP_refl.", "back_times": 0, "succ": false, "time": 80.0663685798645}]