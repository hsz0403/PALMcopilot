[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0."], "tactic": "eapply reduce_eqp_com.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) r) Hcan : canonical A0 eqA ltM r Unable to unify \"reduce ?M2209 ?M2210 ?M2211 ?M2212 ?M2214 ?M2215 ?M2216 ?M2217 ?M2219 ?M2220 ?M2221 ?M2222 ?M2224 ?M2227 ?M2228\" with \"eqP A eqA n r (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+"], "tactic": "apply eqA_dec.", "exn": "In environment H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) H1 : olist (A:=A) ltM r H2 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M6175 ?M6176} + {eqA ?M6175 ?M6176 -> False}\" with \"forall x : list (Term A n), eqP A eqA n x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+"], "tactic": "eapply mults_dist_minuspf.", "exn": "In environment H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) H1 : olist (A:=A) ltM r H2 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M9286 ?M9289 ?M9297 (mults ?M9293 ?M9303 (minuspf ?M9286 ?M9287 ?M9288 ?M9289 ?M9291 ?M9292 ?M9293 ?M9296 ?M9297 ?M9298 ?M9299 ?M9301 ?M9302)) (minuspf ?M9286 ?M9287 ?M9288 ?M9289 ?M9291 ?M9292 ?M9293 ?M9296 ?M9297 ?M9298 ?M9299 (mults ?M9293 ?M9303 ?M9301) (mults ?M9293 ?M9303 ?M9302))\" with \"eqP A eqA n (mults multA (n:=n) (invA A1, M1 n) y) r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*"], "tactic": "apply eqA_dec.", "exn": "In environment H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) H1 : olist (A:=A) ltM r H2 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M12246 ?M12247} + {eqA ?M12246 ?M12247 -> False}\" with \"forall x : list (Term A n), eqP A eqA n x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "eapply minuspf_is_pluspf_mults.", "exn": "In environment H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) H1 : olist (A:=A) ltM r H2 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M15789 ?M15792 ?M15800 (minuspf ?M15789 ?M15790 ?M15791 ?M15792 ?M15794 ?M15795 ?M15796 ?M15799 ?M15800 ?M15801 ?M15802 ?M15804 ?M15805) (pluspf ?M15790 ?M15793 ?M15799 ?M15802 ?M15804 (mults ?M15796 (invTerm ?M15794 (T1 ?M15791 ?M15800)) ?M15805))\" with \"forall x y : list (Term A n), eqP A eqA n x y -> eqP A eqA n y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--"], "tactic": "apply eqA_dec.", "exn": "In environment H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) H1 : olist (A:=A) ltM r H2 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M21067 ?M21068} + {eqA ?M21067 ?M21068 -> False}\" with \"forall x : list (Term A n), eqP A eqA n x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--"], "tactic": "-", "exn": "Wrong bullet -: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*"], "tactic": "eapply Rstar_n.", "exn": "In environment H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) x, y : list (Term A n) H : eqP A eqA n x y r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) H1 : olist (A:=A) ltM r H2 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduceplus ?M24962 ?M24963 ?M24965\" with \"eqP A eqA n r (mults multA (n:=n) (invA A1, M1 n) y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-"], "tactic": "eapply reduce_mults_inv_lem.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) r) Hcan : canonical A0 eqA ltM r IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) r) -> reduceplus Q r (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) z) Unable to unify \"reduce ?M28258 ?M28259 ?M28260 ?M28261 ?M28263 ?M28264 ?M28265 ?M28266 ?M28268 ?M28269 ?M28270 ?M28271 ?M28273 ?M28277 (mults ?M28265 (invTerm ?M28263 (T1 ?M28260 ?M28269)) ?M28275)\" with \"reduceplus Q r (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) z)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*"], "tactic": "apply eqA_dec.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M36970 ?M36971} + {eqA ?M36970 ?M36971 -> False}\" with \"forall x : list (Term A n), reduceplus Q x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply H.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y\" with \"symmetric (list (Term A n)) (reduceplus Q)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "apply IHreduceplus.", "exn": "In environment H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H10 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z)\" with \"symmetric (list (Term A n)) (reduceplus Q)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*"], "tactic": "eapply reduce_eqp_com.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduce ?M58329 ?M58330 ?M58331 ?M58332 ?M58334 ?M58335 ?M58336 ?M58337 ?M58339 ?M58340 ?M58341 ?M58342 ?M58344 ?M58347 ?M58348\" with \"reduceplus Q (mults multA (n:=n) (invA A1, M1 n) z) r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--"], "tactic": "apply eqA_dec.", "exn": "In environment H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H10 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M63689 ?M63690} + {eqA ?M63689 ?M63690 -> False}\" with \"forall x : list (Term A n), reduceplus Q x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--"], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--"], "tactic": "eapply mults_dist_minuspf.", "exn": "In environment H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H10 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M69748 ?M69751 ?M69759 (mults ?M69755 ?M69765 (minuspf ?M69748 ?M69749 ?M69750 ?M69751 ?M69753 ?M69754 ?M69755 ?M69758 ?M69759 ?M69760 ?M69761 ?M69763 ?M69764)) (minuspf ?M69748 ?M69749 ?M69750 ?M69751 ?M69753 ?M69754 ?M69755 ?M69758 ?M69759 ?M69760 ?M69761 (mults ?M69755 ?M69765 ?M69763) (mults ?M69755 ?M69765 ?M69764))\" with \"reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++"], "tactic": "apply eqA_dec.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M75108 ?M75109} + {eqA ?M75108 ?M75109 -> False}\" with \"forall x : list (Term A n), reduceplus Q x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "eapply minuspf_is_pluspf_mults.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M81167 ?M81170 ?M81178 (minuspf ?M81167 ?M81168 ?M81169 ?M81170 ?M81172 ?M81173 ?M81174 ?M81177 ?M81178 ?M81179 ?M81180 ?M81182 ?M81183) (pluspf ?M81168 ?M81171 ?M81177 ?M81180 ?M81182 (mults ?M81174 (invTerm ?M81172 (T1 ?M81169 ?M81178)) ?M81183))\" with \"forall x y : list (Term A n), reduceplus Q x y -> reduceplus Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "**"], "tactic": "apply eqA_dec.", "exn": "In environment H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> forall r : list (Term A n), canonical A0 eqA ltM r -> p = mults multA (n:=n) (invA A1, M1 n) r -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r (mults multA (n:=n) (invA A1, M1 n) q) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H10 : forall (Q : list (poly A0 eqA ltM)) (x y z : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y -> reduceplus Q y z -> reduceplus Q x z H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q r s : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> eqP A eqA n p r -> eqP A eqA n q s -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall p q : list (Term A n), eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (mults multA (n:=n) (invA A1, M1 n) q)) plusA : A -> A -> A Q : list (poly A0 eqA ltM) x, y, z : list (Term A n) H : reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q x y H0 : reduceplus Q y z r : list (Term A n) Heq : eqP A eqA n x (mults multA (n:=n) (invA A1, M1 n) r) IHreduceplus : eqP A eqA n y (mults multA (n:=n) (invA A1, M1 n) r) -> reduceplus Q r (mults multA (n:=n) (invA A1, M1 n) z) H6 : olist (A:=A) ltM r H7 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M88853 ?M88854} + {eqA ?M88853 ?M88854 -> False}\" with \"forall x : list (Term A n), reduceplus Q x x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "**", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem."], "tactic": "**", "exn": "Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "**", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "**"], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "**", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "**", "apply Build_preorder."], "tactic": "**", "exn": "Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "**", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "**", "apply Build_preorder.", "---", "shelve.", "---", "shelve.", "**"], "tactic": "*", "exn": "Wrong bullet *: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Q p q H r Heq Hcan.", "induction H.", "-", "eapply Rstar_0.", "qsimpl time: 1 use: reduce_eqp_com.", "apply Build_equivalence.", "+", "qsimpl time: 1 use: reduce_eqp_com.", "shelve.", "+", "apply Build_equivalence.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: reduce_eqp_com,mults_dist_minuspf.", "shelve.", "*", "apply Build_equivalence.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "--", "apply Build_equivalence.", "++", "shelve.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: Rstar_n,reduce_eqp_com,minuspf_is_pluspf_mults,mults_dist_minuspf.", "shelve.", "-", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "apply Build_preorder.", "--", "shelve.", "--", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "*", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "--", "apply Build_preorder.", "++", "shelve.", "++", "shelve.", "--", "shelve.", "--", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "++", "apply Build_preorder.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "apply Build_equivalence.", "**", "qsimpl time: 1 use: minuspf_is_pluspf_mults,reduce_eqp_com,Rstar_n,mults_dist_minuspf,reduce_mults_inv_lem.", "shelve.", "**", "apply Build_preorder.", "---", "shelve.", "---", "shelve.", "**", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting ++.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros Q p q H r Heq Hcan. induction H. - eapply Rstar_0. eapply reduce_eqp_com. + apply cs. + apply eqA_dec. + apply os. + auto. + eapply mults_dist_minuspf. * apply cs. * apply eqA_dec. * apply os. * eapply minuspf_is_pluspf_mults. -- apply cs. -- apply eqA_dec. -- apply os. -- auto. - eapply Rstar_n. + eapply reduce_mults_inv_lem. * apply cs. * apply eqA_dec. * apply os. * apply H. + apply IHreduceplus. * eapply reduce_eqp_com. -- apply cs. -- apply eqA_dec. -- apply os. -- auto. -- eapply mults_dist_minuspf. ++ apply cs. ++ apply eqA_dec. ++ apply os. ++ eapply minuspf_is_pluspf_mults. ** apply cs. ** apply eqA_dec. ** apply os. ** auto. * auto.", "back_times": 0, "succ": false, "time": 342.1152858734131}]