[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros cs ms H ms_eq H_in H_bad.", "exn": "cs is already used.", "type": "used_var", "handled": true}]}, "chat": [], "original": "intros cs ms H ms_eq H_in H_bad. revert cs H. induction ms as [|m ms IHms]. - intros cs H. apply Acc_intro. intros y Hy. destruct y as [|y ys]. + constructor. + inversion Hy. - intros cs H. apply Acc_intro. intros y Hy. destruct y as [|y ys]. + constructor. + inversion Hy. subst. destruct (eqA_dec (nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os (f := a) (g := poly A0 eqA ltM ys)) A0). ++ apply H_in with (f := a). * rewrite in_rev. simpl. left. reflexivity. * intro H0. inversion H0. ++ assert (Acc RO (cs ++ nf A A0 A1 eqA plusA invA minusA multA divA cs eqA_dec n ltM ltM_dec os a ys :: nil)). ** apply IHms; auto. -- intros. rewrite ms_eq. rewrite get_monL_cons. simpl. f_equal; auto. -- intros. destruct H3. + subst. contradiction. + apply H_in; auto. ** inversion H3. apply H6. constructor. auto.", "back_times": 0, "succ": false, "time": 76.55882048606873}]