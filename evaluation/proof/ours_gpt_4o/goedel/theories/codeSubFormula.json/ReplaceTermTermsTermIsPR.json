[{"history": {"proof": "qsimpl time: 1 use: filter10IsPR. qsimpl time: 1 use: filter10IsPR,codeTermInj. qsimpl time: 1 use: filter10IsPR,codeTermInj. qsimpl time: 1 use: filter10IsPR,codeTermInj.", "repairs": ["cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["unfold ReplaceTermTermsTerm."], "tactic": "apply filter10IsPR.", "exn": "In environment L : Language codeF : Functions L -> nat codeR : Relations L -> nat var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L codeFormula := code.codeFormula L codeF codeR : fol.Formula L -> nat codeTerm := code.codeTerm L codeF : fol.Term L -> nat Unable to unify \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a _ : nat => ?M1475 a)}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (evalStrongRec 1 (fun t recs s : nat => cPair (switchPR (cPairPi1 t) (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))) (cPair 0 s)) (switchPR t (S (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (Init.Nat.pred t))) recs)) (cPairPi2 (codeNth (t - S (cPairPi2 (Init.Nat.pred t))) recs)))) 0)))}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR."], "tactic": "apply RecIsPR.", "exn": "The reference RecIsPR was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR."], "tactic": "apply swap_lem.", "exn": "The reference swap_lem was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR.", "apply swapIsPR."], "tactic": "apply comp_lem.", "exn": "The reference comp_lem was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR."], "tactic": "apply const_lem.", "exn": "The reference const_lem was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR."], "tactic": "apply id_lem.", "exn": "The reference id_lem was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR."], "tactic": "apply codeTermInj.", "exn": "In environment H : forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a _ : nat => g a) L : Language codeF : Functions L -> nat codeR : Relations L -> nat Unable to unify \"?M1612 = ?M1613\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun y x : nat => evalStrongRec 1 (fun t recs s : nat => cPair (switchPR (cPairPi1 t) (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))) (cPair 0 s)) (switchPR t (S (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (Init.Nat.pred t))) recs)) (cPairPi2 (codeNth (t - S (cPairPi2 (Init.Nat.pred t))) recs)))) 0)) x y)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "qsimpl time: 1 use: filter10IsPR,codeTermInj."], "tactic": "apply codeF.", "exn": "In environment H1 : forall (L : Language) (codeF : Functions L -> nat), (forall f g : Functions L, codeF f = codeF g -> f = g) -> forall t s : fol.Term L, code.codeTerm L codeF t = code.codeTerm L codeF s -> t = s H0, H : forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a _ : nat => g a) L : Language codeF : Functions L -> nat codeR : Relations L -> nat Unable to unify \"nat\" with \"isPR 2 (fun y x : nat => evalStrongRec 1 (fun t recs s : nat => cPair (switchPR (cPairPi1 t) (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))) (cPair 0 s)) (switchPR t (S (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (Init.Nat.pred t))) recs)) (cPairPi2 (codeNth (t - S (cPairPi2 (Init.Nat.pred t))) recs)))) 0)) x y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold ReplaceTermTermsTerm.", "qsimpl time: 1 use: filter10IsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "qsimpl time: 1 use: filter10IsPR,codeTermInj.", "qsimpl time: 1 use: filter10IsPR,codeTermInj."], "tactic": "apply codeR.", "exn": "In environment H3 : forall (L : Language) (codeF : Functions L -> nat), (forall f g : Functions L, codeF f = codeF g -> f = g) -> forall t s : fol.Term L, code.codeTerm L codeF t = code.codeTerm L codeF s -> t = s H2, H0, H : forall g : nat -> nat, isPR 1 g -> isPR 2 (fun a _ : nat => g a) L : Language codeF : Functions L -> nat codeR : Relations L -> nat Unable to unify \"nat\" with \"isPR 2 (fun y x : nat => evalStrongRec 1 (fun t recs s : nat => cPair (switchPR (cPairPi1 t) (cPair (cPairPi1 t) (cPairPi2 (codeNth (t - S (cPairPi2 t)) recs))) (cPair 0 s)) (switchPR t (S (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (Init.Nat.pred t))) recs)) (cPairPi2 (codeNth (t - S (cPairPi2 (Init.Nat.pred t))) recs)))) 0)) x y)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold ReplaceTermTermsTerm. apply filter10IsPR. apply RecIsPR. apply swap_lem. apply comp_lem. apply const_lem. apply id_lem. apply codeTermInj. apply codeF. apply codeR.", "back_times": 0, "succ": false, "time": 240.03223490715027}]