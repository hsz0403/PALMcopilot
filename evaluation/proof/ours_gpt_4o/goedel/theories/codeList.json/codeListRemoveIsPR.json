[{"history": {"proof": "qsimpl time: 1 use: ind2ParamIsPR. qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR. qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR. qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR. qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR. qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR. qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,filter011IsPR,pi2_2IsPR. qsimpl time: 1 use: sumToN,filter110IsPR,ind2ParamIsPR,pi1_2IsPR,filter011IsPR,pi2_2IsPR,compose2_2IsPR.", "repairs": ["cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["unfold codeListRemove."], "tactic": "apply ind2ParamIsPR.", "exn": "Unable to unify \"{p : PrimRec 3 | extEqual 3 (evalPrimRec 3 p) (fun a b c : nat => nat_rec (fun _ : nat => nat) (?M1433 b c) (fun x y : nat => ?M1431 x y b c) a)}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (charFunction 2 Nat.eqb (cPairPi1 (Init.Nat.pred n)) p1) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) (codeList nil)) l a)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR."], "tactic": "apply compose2_4IsPR with (f1 := fun _ b => b) (f2 := fun _ _ => cPairPi1 (Init.Nat.pred b)) (f3 := fun _ _ => cPairPi2 (Init.Nat.pred b)) (f4 := fun a b => sumToN (a + b)).", "exn": "The reference b was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR."], "tactic": "apply pi2_2IsPR.", "exn": "In environment H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) Unable to unify \"isPR 2 (fun _ b : nat => b)\" with \"isPR 2 (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR."], "tactic": "apply filter110IsPR.", "exn": "In environment H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 Unable to unify \"{p : PrimRec 3 | extEqual 3 (evalPrimRec 3 p) (fun a b _ : nat => ?M2124 a b)}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR."], "tactic": "apply pi1_2IsPR.", "exn": "In environment H3 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H1 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 x0 : PrimRec 2 H5 : forall c c0 : nat, evalPrimRec 2 x0 c c0 = c0 Unable to unify \"isPR 2 (fun a _ : nat => a)\" with \"isPR 2 (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR."], "tactic": "apply filter110IsPR.", "exn": "In environment H6 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H4 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H3 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H1 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 x0 : PrimRec 2 H5 : forall c c0 : nat, evalPrimRec 2 x0 c c0 = c0 x1 : PrimRec 2 H9 : forall c c0 : nat, evalPrimRec 2 x1 c c0 = c x2 : PrimRec 2 H7 : forall c c0 : nat, evalPrimRec 2 x2 c c0 = c0 Unable to unify \"{p : PrimRec 3 | extEqual 3 (evalPrimRec 3 p) (fun a b _ : nat => ?M5444 a b)}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR."], "tactic": "apply pi2_2IsPR.", "exn": "In environment H10 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H8 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H6 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H4 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H3 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H1 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 x0 : PrimRec 2 H5 : forall c c0 : nat, evalPrimRec 2 x0 c c0 = c0 x1 : PrimRec 2 H9 : forall c c0 : nat, evalPrimRec 2 x1 c c0 = c x2 : PrimRec 2 H7 : forall c c0 : nat, evalPrimRec 2 x2 c c0 = c0 x3 : PrimRec 2 H13 : forall c c0 : nat, evalPrimRec 2 x3 c c0 = c x4 : PrimRec 2 H11 : forall c c0 : nat, evalPrimRec 2 x4 c c0 = c0 Unable to unify \"isPR 2 (fun _ b : nat => b)\" with \"isPR 2 (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR."], "tactic": "apply filter011IsPR.", "exn": "In environment H14 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H12 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H10 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H8 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H6 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H4 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H3 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H1 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 x0 : PrimRec 2 H5 : forall c c0 : nat, evalPrimRec 2 x0 c c0 = c0 x1 : PrimRec 2 H9 : forall c c0 : nat, evalPrimRec 2 x1 c c0 = c x2 : PrimRec 2 H7 : forall c c0 : nat, evalPrimRec 2 x2 c c0 = c0 x3 : PrimRec 2 H13 : forall c c0 : nat, evalPrimRec 2 x3 c c0 = c x4 : PrimRec 2 H11 : forall c c0 : nat, evalPrimRec 2 x4 c c0 = c0 x5 : PrimRec 2 H17 : forall c c0 : nat, evalPrimRec 2 x5 c c0 = c x6 : PrimRec 2 H15 : forall c c0 : nat, evalPrimRec 2 x6 c c0 = c0 Unable to unify \"{p : PrimRec 3 | extEqual 3 (evalPrimRec 3 p) (fun _ b c : nat => ?M12982 b c)}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,filter011IsPR,pi2_2IsPR."], "tactic": "apply compose2_2IsPR with (f := fun a _ => a) (g := fun a b => sumToN (a + b)).", "exn": "In environment H20 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun _ b c : nat => g b c) H18 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H16 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H14 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H12 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H10 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H8 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H6 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H4 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H3 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H1 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 x0 : PrimRec 2 H5 : forall c c0 : nat, evalPrimRec 2 x0 c c0 = c0 x1 : PrimRec 2 H9 : forall c c0 : nat, evalPrimRec 2 x1 c c0 = c x2 : PrimRec 2 H7 : forall c c0 : nat, evalPrimRec 2 x2 c c0 = c0 x3 : PrimRec 2 H13 : forall c c0 : nat, evalPrimRec 2 x3 c c0 = c x4 : PrimRec 2 H11 : forall c c0 : nat, evalPrimRec 2 x4 c c0 = c0 x5 : PrimRec 2 H17 : forall c c0 : nat, evalPrimRec 2 x5 c c0 = c x6 : PrimRec 2 H15 : forall c c0 : nat, evalPrimRec 2 x6 c c0 = c0 x7 : PrimRec 2 H22 : forall c c0 : nat, evalPrimRec 2 x7 c c0 = c x8 : PrimRec 2 H19 : forall c c0 : nat, evalPrimRec 2 x8 c c0 = c0 Unable to unify \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun x y : nat => ?M18422 x (sumToN (x + y)))}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold codeListRemove.", "qsimpl time: 1 use: ind2ParamIsPR.", "qsimpl time: 1 use: ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,pi2_2IsPR.", "qsimpl time: 1 use: filter110IsPR,ind2ParamIsPR,pi1_2IsPR,filter011IsPR,pi2_2IsPR.", "qsimpl time: 1 use: sumToN,filter110IsPR,ind2ParamIsPR,pi1_2IsPR,filter011IsPR,pi2_2IsPR,compose2_2IsPR."], "tactic": "apply pi1_2IsPR.", "exn": "In environment H28 : forall f : nat -> nat -> nat, isPR 2 f -> forall g : nat -> nat -> nat, isPR 2 g -> forall h : nat -> nat -> nat, isPR 2 h -> isPR 2 (fun x y : nat => h (f x y) (g x y)) H26 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun _ b c : nat => g b c) H24 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H23 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H20 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun _ b c : nat => g b c) H18 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H16 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H14 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H12 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H10 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H8 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H6 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H4 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H3 : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) H1 : forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b _ : nat => g a b) H0, H : forall f : nat -> nat -> nat -> nat -> nat, isPR 4 f -> forall g : nat -> nat -> nat, isPR 2 g -> isPR 3 (fun a b c : nat => nat_rec (fun _ : nat => nat) (g b c) (fun x y : nat => f x y b c) a) x : PrimRec 2 H2 : forall c c0 : nat, evalPrimRec 2 x c c0 = c0 x0 : PrimRec 2 H5 : forall c c0 : nat, evalPrimRec 2 x0 c c0 = c0 x1 : PrimRec 2 H9 : forall c c0 : nat, evalPrimRec 2 x1 c c0 = c x2 : PrimRec 2 H7 : forall c c0 : nat, evalPrimRec 2 x2 c c0 = c0 x3 : PrimRec 2 H13 : forall c c0 : nat, evalPrimRec 2 x3 c c0 = c x4 : PrimRec 2 H11 : forall c c0 : nat, evalPrimRec 2 x4 c c0 = c0 x5 : PrimRec 2 H17 : forall c c0 : nat, evalPrimRec 2 x5 c c0 = c x6 : PrimRec 2 H15 : forall c c0 : nat, evalPrimRec 2 x6 c c0 = c0 x7 : PrimRec 2 H22 : forall c c0 : nat, evalPrimRec 2 x7 c c0 = c x8 : PrimRec 2 H19 : forall c c0 : nat, evalPrimRec 2 x8 c c0 = c0 x9 : PrimRec 2 H21 : forall c c0 : nat, evalPrimRec 2 x9 c c0 = c x10 : PrimRec 2 H25 : forall c c0 : nat, evalPrimRec 2 x10 c c0 = c0 Unable to unify \"isPR 2 (fun a _ : nat => a)\" with \"isPR 2 (fun a l : nat => evalStrongRec 1 (fun n Hrecs p1 : nat => switchPR n (switchPR (if cPairPi1 (Init.Nat.pred n) =? p1 then 1 else 0) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs) (S (cPair (cPairPi1 (Init.Nat.pred n)) (codeNth (n - S (cPairPi2 (Init.Nat.pred n))) Hrecs)))) 0) l a)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold codeListRemove. apply ind2ParamIsPR. - apply compose2_4IsPR with (f1 := fun _ b => b) (f2 := fun _ _ => cPairPi1 (Init.Nat.pred b)) (f3 := fun _ _ => cPairPi2 (Init.Nat.pred b)) (f4 := fun a b => sumToN (a + b)). -- apply pi2_2IsPR. -- apply filter110IsPR. apply pi1_2IsPR. -- apply filter110IsPR. apply pi2_2IsPR. -- apply filter011IsPR. apply compose2_2IsPR with (f := fun a _ => a) (g := fun a b => sumToN (a + b)). ++ apply pi1_2IsPR. ++ apply compose2_1IsPR with (g := sumToN). ** apply plusIsPR. ** apply sumToNIsPR. - apply pi1_3IsPR.", "back_times": 0, "succ": false, "time": 66.25032830238342}]