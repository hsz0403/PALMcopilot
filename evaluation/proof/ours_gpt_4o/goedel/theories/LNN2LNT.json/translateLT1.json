[{"history": {"proof": "qsimpl time: 1 use: subAllFormula. qsimpl time: 1 use: Plus,subAllFormula,LNN. qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula. qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula. qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "repairs": ["no_rewrite_relation", "no_rewrite_relation", "cannot_unify", "no_rewrite_relation", "cannot_unify"], "exceptions": [{"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl."], "tactic": "rewrite subAllFormula.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term."], "tactic": "rewrite LNN.Plus.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN."], "tactic": "f_equal; apply subAllSubAllTerm; intros x; simpl.", "exn": "In environment l : Language X0, X : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L a, a0 : fol.Term LNN b0 : fol.Terms LNN 0 Unable to unify \"subAllTerm ?M1853 (subAllTerm ?M1853 ?M1854 ?M1855) ?M1856 = subAllTerm ?M1853 ?M1854 (fun n : nat => subAllTerm ?M1853 (?M1855 n) ?M1856)\" with \"sig_rec (fun _ : {t : fol.Term l * fol.Terms l 1 | Tcons l 1 (fst t) (snd t) = Tcons l 1 a (Tcons l 0 a0 b0)} => Formula) (fun (x : fol.Term l * fol.Terms l 1) (p : Tcons l 1 (fst x) (snd x) = Tcons l 1 a (Tcons l 0 a0 b0)) => prod_rec (fun x0 : fol.Term l * fol.Terms l 1 => Tcons l 1 (fst x0) (snd x0) = Tcons l 1 a (Tcons l 0 a0 b0) -> Formula) (fun (a1 : fol.Term l) (b : fol.Terms l 1) (_ : Tcons l 1 a1 b = Tcons l 1 a (Tcons l 0 a0 b0)) => sig_rec (fun _ : {t : fol.Term l * fol.Terms l 0 | Tcons l 0 (fst t) (snd t) = b} => Formula) (fun (x0 : fol.Term l * fol.Terms l 0) (p1 : Tcons l 0 (fst x0) (snd x0) = b) => prod_rec (fun x1 : fol.Term l * fol.Terms l 0 => Tcons l 0 (fst x1) (snd x1) = b -> Formula) (fun (a0 : fol.Term l) (b0 : fol.Terms l 0) (_ : Tcons l 0 a0 b0 = b) => fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))) x0 p1) (consTerms l 0 b)) x p) (consTerms l 1 (Tcons l 1 a (Tcons l 0 a0 b0))) = fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "destruct x; [reflexivity | f_equal; destruct x; reflexivity].", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "destruct x.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "reflexivity.", "exn": "In environment X2 : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L H0 : forall (L : Language) (t : fol.Term L) (m1 m2 : nat -> fol.Term L), subAllTerm L (subAllTerm L t m1) m2 = subAllTerm L t (fun n : nat => subAllTerm L (m1 n) m2) X1 : Language H : forall (A B : Type) (f : A -> B) (x y : A), x = y -> f x = f y l : Language X0, X : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L a, a0 : fol.Term LNN b0 : fol.Terms LNN 0 Unable to unify \"fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))\" with \"sig_rec (fun _ : {t : fol.Term l * fol.Terms l 1 | Tcons l 1 (fst t) (snd t) = Tcons l 1 a (Tcons l 0 a0 b0)} => Formula) (fun (x : fol.Term l * fol.Terms l 1) (p : Tcons l 1 (fst x) (snd x) = Tcons l 1 a (Tcons l 0 a0 b0)) => prod_rec (fun x0 : fol.Term l * fol.Terms l 1 => Tcons l 1 (fst x0) (snd x0) = Tcons l 1 a (Tcons l 0 a0 b0) -> Formula) (fun (a1 : fol.Term l) (b : fol.Terms l 1) (_ : Tcons l 1 a1 b = Tcons l 1 a (Tcons l 0 a0 b0)) => sig_rec (fun _ : {t : fol.Term l * fol.Terms l 0 | Tcons l 0 (fst t) (snd t) = b} => Formula) (fun (x0 : fol.Term l * fol.Terms l 0) (p1 : Tcons l 0 (fst x0) (snd x0) = b) => prod_rec (fun x1 : fol.Term l * fol.Terms l 0 => Tcons l 0 (fst x1) (snd x1) = b -> Formula) (fun (a0 : fol.Term l) (b0 : fol.Terms l 0) (_ : Tcons l 0 a0 b0 = b) => fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))) x0 p1) (consTerms l 0 b)) x p) (consTerms l 1 (Tcons l 1 a (Tcons l 0 a0 b0)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "destruct x; [simpl; reflexivity | simpl; reflexivity].", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "rewrite LNN.Plus.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "repeat f_equal; apply subAllSubAllTerm; intros x; simpl.", "exn": "In environment X4 : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L H2 : forall (L : Language) (t : fol.Term L) (m1 m2 : nat -> fol.Term L), subAllTerm L (subAllTerm L t m1) m2 = subAllTerm L t (fun n : nat => subAllTerm L (m1 n) m2) X3 : Language H1 : forall (A B : Type) (f : A -> B) (x y : A), x = y -> f x = f y X2 : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L X1, l : Language X0, X : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L a, a0 : fol.Term LNN b0 : fol.Terms LNN 0 Unable to unify \"subAllTerm ?M2925 (subAllTerm ?M2925 ?M2926 ?M2927) ?M2928 = subAllTerm ?M2925 ?M2926 (fun n : nat => subAllTerm ?M2925 (?M2927 n) ?M2928)\" with \"sig_rec (fun _ : {t : fol.Term l * fol.Terms l 1 | Tcons l 1 (fst t) (snd t) = Tcons l 1 a (Tcons l 0 a0 b0)} => Formula) (fun (x : fol.Term l * fol.Terms l 1) (p : Tcons l 1 (fst x) (snd x) = Tcons l 1 a (Tcons l 0 a0 b0)) => prod_rec (fun x0 : fol.Term l * fol.Terms l 1 => Tcons l 1 (fst x0) (snd x0) = Tcons l 1 a (Tcons l 0 a0 b0) -> Formula) (fun (a1 : fol.Term l) (b : fol.Terms l 1) (_ : Tcons l 1 a1 b = Tcons l 1 a (Tcons l 0 a0 b0)) => sig_rec (fun _ : {t : fol.Term l * fol.Terms l 0 | Tcons l 0 (fst t) (snd t) = b} => Formula) (fun (x0 : fol.Term l * fol.Terms l 0) (p1 : Tcons l 0 (fst x0) (snd x0) = b) => prod_rec (fun x1 : fol.Term l * fol.Terms l 0 => Tcons l 0 (fst x1) (snd x1) = b -> Formula) (fun (a0 : fol.Term l) (b0 : fol.Terms l 0) (_ : Tcons l 0 a0 b0 = b) => fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))) x0 p1) (consTerms l 0 b)) x p) (consTerms l 1 (Tcons l 1 a (Tcons l 0 a0 b0))) = fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "destruct x; [reflexivity | f_equal; destruct x; reflexivity].", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "destruct x.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "reflexivity.", "exn": "In environment X6 : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L H0 : forall (L : Language) (t : fol.Term L) (m1 m2 : nat -> fol.Term L), subAllTerm L (subAllTerm L t m1) m2 = subAllTerm L t (fun n : nat => subAllTerm L (m1 n) m2) X5 : Language H : forall (A B : Type) (f : A -> B) (x y : A), x = y -> f x = f y X4 : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L X3 : Language X2 : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L X1, l : Language X0, X : forall L : Language, fol.Formula L -> (nat -> fol.Term L) -> fol.Formula L a, a0 : fol.Term LNN b0 : fol.Terms LNN 0 Unable to unify \"fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))\" with \"sig_rec (fun _ : {t : fol.Term l * fol.Terms l 1 | Tcons l 1 (fst t) (snd t) = Tcons l 1 a (Tcons l 0 a0 b0)} => Formula) (fun (x : fol.Term l * fol.Terms l 1) (p : Tcons l 1 (fst x) (snd x) = Tcons l 1 a (Tcons l 0 a0 b0)) => prod_rec (fun x0 : fol.Term l * fol.Terms l 1 => Tcons l 1 (fst x0) (snd x0) = Tcons l 1 a (Tcons l 0 a0 b0) -> Formula) (fun (a1 : fol.Term l) (b : fol.Terms l 1) (_ : Tcons l 1 a1 b = Tcons l 1 a (Tcons l 0 a0 b0)) => sig_rec (fun _ : {t : fol.Term l * fol.Terms l 0 | Tcons l 0 (fst t) (snd t) = b} => Formula) (fun (x0 : fol.Term l * fol.Terms l 0) (p1 : Tcons l 0 (fst x0) (snd x0) = b) => prod_rec (fun x1 : fol.Term l * fol.Terms l 0 => Tcons l 0 (fst x1) (snd x1) = b -> Formula) (fun (a0 : fol.Term l) (b0 : fol.Terms l 0) (_ : Tcons l 0 a0 b0 = b) => fol.notH LNT (fol.forallH LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil)) (fol.notH LNT (fol.equal LNT (apply LNT Languages.Plus (Tcons LNT 1 ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) (Tcons LNT 0 (apply LNT Languages.Succ (Tcons LNT 0 (fol.var LNT (newVar (0 :: 2 :: 1 :: freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a1) ++ freeVarTerm LNT ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0) ++ nil))) (Tnil LNT))) (Tnil LNT)))) ((fix LNN2LNT_term (t : fol.Term l) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (arity l (inr f)) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms l n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) a0))))) x0 p1) (consTerms l 0 b)) x p) (consTerms l 1 (Tcons l 1 a (Tcons l 0 a0 b0)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a a0 b0.", "unfold translateLT.", "simpl.", "qsimpl time: 1 use: subAllFormula.", "unfold LNN2LNT_term.", "qsimpl time: 1 use: Plus,subAllFormula,LNN.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula.", "qsimpl time: 1 use: f_equal,LNN,subAllSubAllTerm,Plus,subAllFormula."], "tactic": "destruct x; [simpl; reflexivity | simpl; reflexivity].", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros a a0 b0. unfold translateLT. simpl. rewrite subAllFormula. f_equal. - unfold LNN2LNT_term. rewrite LNN.Plus. f_equal; apply subAllSubAllTerm; intros x; simpl. + destruct x; [reflexivity | f_equal; destruct x; reflexivity]. + destruct x. * simpl. reflexivity. * destruct x; [simpl; reflexivity | simpl; reflexivity]. - unfold LNN2LNT_term. rewrite LNN.Plus. repeat f_equal; apply subAllSubAllTerm; intros x; simpl. + destruct x; [reflexivity | f_equal; destruct x; reflexivity]. + destruct x. * simpl. reflexivity. * destruct x; [simpl; reflexivity | simpl; reflexivity].", "back_times": 0, "succ": false, "time": 184.54764461517334}]