[{"history": {"proof": "qsimpl time: 1 use: addPairwiseEquals.", "repairs": ["cannot_unify"], "exceptions": [{"ctx": ["intros T r ts ss H."], "tactic": "apply addPairwiseEquals with (f0 := iffH (atomic r ts) (atomic r ss)).", "exn": "In environment L : Language var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L equal := fol.equal L : fol.Term L -> fol.Term L -> fol.Formula L atomic := fol.atomic L : forall r : Relations L, fol.Terms L (arity L (inl r)) -> fol.Formula L impH := fol.impH L : fol.Formula L -> fol.Formula L -> fol.Formula L notH := fol.notH L : fol.Formula L -> fol.Formula L forallH := fol.forallH L : nat -> fol.Formula L -> fol.Formula L orH := fol.orH L : fol.Formula L -> fol.Formula L -> fol.Formula L andH := fol.andH L : fol.Formula L -> fol.Formula L -> fol.Formula L existH := fol.existH L : nat -> fol.Formula L -> fol.Formula L iffH := fol.iffH L : fol.Formula L -> fol.Formula L -> fol.Formula L ifThenElseH := fol.ifThenElseH L : fol.Formula L -> fol.Formula L -> fol.Formula L -> fol.Formula L Prf := folProof.Prf L : fol.Formulas L -> fol.Formula L -> Set SysPrf := folProof.SysPrf L : fol.System L -> fol.Formula L -> Prop termsMap := fun (m : nat) (ts ss : fol.Terms L m) => nat_rec (fun m0 : nat => fol.Terms L m0 -> fol.Terms L m0 -> nat -> fol.Term L) (fun (_ _ : fol.Terms L 0) (n : nat) => var n) (fun (m0 : nat) (Hrecm : fol.Terms L m0 -> fol.Terms L m0 -> nat -> fol.Term L) (ts0 ss0 : fol.Terms L (S m0)) => let s := consTerms L m0 ts0 in sig_rec (fun _ : {t : fol.Term L * fol.Terms L m0 | Tcons L m0 (fst t) (snd t) = ts0} => nat -> fol.Term L) (fun (x : fol.Term L * fol.Terms L m0) (p : Tcons L m0 (fst x) (snd x) = ts0) => prod_rec (fun x0 : fol.Term L * fol.Terms L m0 => Tcons L m0 (fst x0) (snd x0) = ts0 -> nat -> fol.Term L) (fun (a : fol.Term L) (b : fol.Terms L m0) (_ : Tcons L m0 (fst (a, b)) (snd (a, b)) = ts0) => let s0 := consTerms L m0 ss0 in sig_rec (fun _ : {t : fol.Term L * fol.Terms L m0 | Tcons L m0 (fst t) (snd t) = ss0} => nat -> fol.Term L) (fun (x0 : fol.Term L * fol.Terms L m0) (p1 : Tcons L m0 (fst x0) (snd x0) = ss0) => prod_rec (fun x1 : fol.Term L * fol.Terms L m0 => Tcons L m0 (fst x1) (snd x1) = ss0 -> nat -> fol.Term L) (fun (a0 : fol.Term L) (b0 : fol.Terms L m0) (_ : Tcons L m0 (fst (a0, b0)) (snd (a0, b0)) = ss0) (n : nat) => if Nat.eq_dec n (m0 + m0) then a else if Nat.eq_dec n (S (m0 + m0)) then a0 else Hrecm b b0 n) x0 p1) s0) x p) s) m ts ss : forall m : nat, fol.Terms L m -> fol.Terms L m -> nat -> fol.Term L T : fol.System L r : Relations L ts, ss : fol.Terms L (arity L (inl r)) H : PairwiseEqual T (arity L (inl r)) ts ss Unable to unify \"exists (Axm : fol.Formulas L) (_ : folProof.Prf L Axm (subAllFormula L (iffH (atomic r ts) (atomic r ss)) ?M1425)), forall g : fol.Formula L, In g Axm -> mem (fol.Formula L) ?M1420 g\" with \"exists (Axm : fol.Formulas L) (_ : folProof.Prf L Axm (iffH (atomic r ts) (atomic r ss))), forall g : fol.Formula L, In g Axm -> mem (fol.Formula L) T g\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T r ts ss H.", "qsimpl time: 1 use: addPairwiseEquals."], "tactic": "apply H.", "exn": "In environment L : Language var := fol.var L : nat -> fol.Term L equal := fol.equal L : fol.Term L -> fol.Term L -> fol.Formula L SysPrf := folProof.SysPrf L : fol.System L -> fol.Formula L -> Prop H0 : forall (T : fol.System L) (n : nat) (ts ss : fol.Terms L n), PairwiseEqual T n ts ss -> forall m0 : nat -> fol.Term L, (forall q : nat, q < n + n -> m0 q = nat_rec (fun m : nat => fol.Terms L m -> fol.Terms L m -> nat -> fol.Term L) (fun (_ _ : fol.Terms L 0) (n0 : nat) => var n0) (fun (m : nat) (Hrecm : fol.Terms L m -> fol.Terms L m -> nat -> fol.Term L) (ts0 ss0 : fol.Terms L (S m)) => sig_rec (fun _ : {t : fol.Term L * fol.Terms L m | Tcons L m (fst t) (snd t) = ts0} => nat -> fol.Term L) (fun (x : fol.Term L * fol.Terms L m) (p : Tcons L m (fst x) (snd x) = ts0) => prod_rec (fun x0 : fol.Term L * fol.Terms L m => Tcons L m (fst x0) (snd x0) = ts0 -> nat -> fol.Term L) (fun (a : fol.Term L) (b : fol.Terms L m) (_ : Tcons L m a b = ts0) => sig_rec (fun _ : {t : fol.Term L * fol.Terms L m | Tcons L m (fst t) (snd t) = ss0} => nat -> fol.Term L) (fun (x0 : fol.Term L * fol.Terms L m) (p1 : Tcons L m (fst x0) (snd x0) = ss0) => prod_rec (fun x1 : fol.Term L * fol.Terms L m => Tcons L m (fst x1) (snd x1) = ss0 -> nat -> fol.Term L) (fun (a0 : fol.Term L) (b0 : fol.Terms L m) (_ : Tcons L m a0 b0 = ss0) (n0 : nat) => if Nat.eq_dec n0 (m + m) then a else if Nat.eq_dec n0 (S (m + m)) then a0 else Hrecm b b0 n0) x0 p1) (consTerms L m ss0)) x p) (consTerms L m ts0)) n ts ss q) -> forall f0 : fol.Formula L, folProof.SysPrf L T (subAllFormula L (nat_rec (fun _ : nat => fol.Formula L) f0 (fun (n0 : nat) (Hrecn : fol.Formula L) => fol.impH L (fol.equal L (fol.var L (n0 + n0)) (fol.var L (S (n0 + n0)))) Hrecn) n) m0) -> folProof.SysPrf L T (subAllFormula L f0 m0) T : fol.System L r : Relations L ts, ss : fol.Terms L (arity L (inl r)) H : PairwiseEqual T (arity L (inl r)) ts ss Unable to unify \"PairwiseEqual T (arity L (inl r)) ts ss\" with \"folProof.SysPrf L T (fol.iffH L (fol.atomic L r ts) (fol.atomic L r ss))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros T r ts ss H. apply addPairwiseEquals with (f0 := iffH (atomic r ts) (atomic r ss)). - apply H. - intros q Hq. unfold termsMap. destruct (le_lt_dec (arity L (inl r)) q); reflexivity. - apply SysPrf.", "back_times": 0, "succ": false, "time": 64.99163389205933}]