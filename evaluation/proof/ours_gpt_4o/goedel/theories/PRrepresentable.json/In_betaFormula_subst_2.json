[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-"], "tactic": "apply in_or_app.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecSigmaFormula := fun (n : nat) (SigA SigB : Formula) => existH (S (S n)) (andH (minimize (primRecSigmaFormulaHelp n SigA SigB) (primRecPiFormulaHelp n SigA SigB) (S (S n)) (S (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 (var (S n)))) : nat -> Formula -> Formula -> Formula a : Term v : nat Unable to unify \"(fix In (a : ?M1517) (l : list ?M1517) {struct l} : Prop := match l with | nil => False | b :: m => b = a \\\\/ In a m end) ?M1520 (?M1518 ++ ?M1519)\" with \"(fix In (a : nat) (l : list nat) {struct l} : Prop := match l with | nil => False | b :: m => b = a \\\\/ In a m end) v (freeVarFormula LNN (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 a) 2 (var 1)) 0 (var 0)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-"], "tactic": "destruct H as [H1 | [H1 | H1]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-"], "tactic": "qsimpl time: 1 use: auto,in_or_app,qsimpl.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left."], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left."], "tactic": "qsimpl time: 1 use: auto,in_or_app,qsimpl.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left.", "qsimpl time: 1 use: in_or_app."], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left.", "qsimpl time: 1 use: in_or_app."], "tactic": "qsimpl time: 1 use: auto,in_or_app,qsimpl.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left.", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app.", "+"], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left.", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app.", "+"], "tactic": "qsimpl time: 1 use: auto,in_or_app,qsimpl.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left.", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app.", "+", "qsimpl time: 1 use: in_or_app."], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a v.", "destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v).", "-", "shelve.", "-", "qsimpl time: 1 use: in_or_app.", "-", "left.", "qsimpl time: 1 use: in_or_app.", "qsimpl time: 1 use: in_or_app.", "+", "qsimpl time: 1 use: in_or_app."], "tactic": "qsimpl time: 1 use: auto,in_or_app,qsimpl.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros a v. destruct (In_betaFormula_subst_1_2_0 a (var 1) (var 0) v). - apply in_or_app. left. auto. - destruct H as [H1 | [H1 | H1]]. + left. auto. + right. left. auto. + right. right. auto.", "back_times": 1, "succ": false, "time": 144.7576196193695}]