[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n f.", "induction f.", "-", "simpl."], "tactic": "apply RepresentableAlternate with succFormula.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecSigmaFormula := fun (n : nat) (SigA SigB : Formula) => existH (S (S n)) (andH (minimize (primRecSigmaFormulaHelp n SigA SigB) (primRecPiFormulaHelp n SigA SigB) (S (S n)) (S (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 (var (S n)))) : nat -> Formula -> Formula -> Formula Unable to unify \"(fix RepresentableHelp (n : nat) : naryFunc n -> Formula -> Prop := match n as n0 return (naryFunc n0 -> Formula -> Prop) with | 0 => fun (f : naryFunc 0) (A : Formula) => SysPrf NN (iffH A (equal (var 0) (natToTerm f))) | S m => fun (f : naryFunc (S m)) (A : Formula) => forall a : nat, RepresentableHelp m (f a) (substituteFormula LNN A (S m) (natToTerm a)) end) ?M1517 ?M1518 ?M1520\" with \"(forall v : nat, In v (freeVarFormula LNN succFormula) -> v <= 1) /\\\\ expressible.RepresentableHelp NN 1 S succFormula\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply SysPrf_refl.", "exn": "The reference SysPrf_refl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "unfold RepresentableHelp.", "exn": "The reference RepresentableHelp was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply expressible.RepresentableHelp with zeroFormula.", "exn": "The reference zeroFormula was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply SysPrf_refl.", "exn": "The reference SysPrf_refl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply expressible.RepresentableHelp with succFormula.", "exn": "The reference succFormula was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply SysPrf_refl.", "exn": "The reference SysPrf_refl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply expressible.RepresentableHelp_S.", "exn": "The reference expressible.RepresentableHelp_S was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl."], "tactic": "apply RepresentableAlternate with zeroFormula.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecSigmaFormula := fun (n : nat) (SigA SigB : Formula) => existH (S (S n)) (andH (minimize (primRecSigmaFormulaHelp n SigA SigB) (primRecPiFormulaHelp n SigA SigB) (S (S n)) (S (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 (var (S n)))) : nat -> Formula -> Formula -> Formula Unable to unify \"(fix RepresentableHelp (n : nat) : naryFunc n -> Formula -> Prop := match n as n0 return (naryFunc n0 -> Formula -> Prop) with | 0 => fun (f : naryFunc 0) (A : Formula) => SysPrf NN (iffH A (equal (var 0) (natToTerm f))) | S m => fun (f : naryFunc (S m)) (A : Formula) => forall a : nat, RepresentableHelp m (f a) (substituteFormula LNN A (S m) (natToTerm a)) end) ?M2048 ?M2049 ?M2051\" with \"(forall v : nat, In v (freeVarFormula LNN zeroFormula) -> v <= 0) /\\\\ expressible.RepresentableHelp NN 0 0 zeroFormula\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply SysPrf_refl.", "exn": "The reference SysPrf_refl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply expressible.RepresentableHelp with zeroFormula.", "exn": "The reference zeroFormula was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply SysPrf_refl.", "exn": "The reference SysPrf_refl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply expressible.RepresentableHelp_S0.", "exn": "The reference expressible.RepresentableHelp_S0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl."], "tactic": "apply RepresentableAlternate with (projFormula m).", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecSigmaFormula := fun (n : nat) (SigA SigB : Formula) => existH (S (S n)) (andH (minimize (primRecSigmaFormulaHelp n SigA SigB) (primRecPiFormulaHelp n SigA SigB) (S (S n)) (S (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 (var (S n)))) : nat -> Formula -> Formula -> Formula n, m : nat l : m < n Unable to unify \"(fix RepresentableHelp (n : nat) : naryFunc n -> Formula -> Prop := match n as n0 return (naryFunc n0 -> Formula -> Prop) with | 0 => fun (f : naryFunc 0) (A : Formula) => SysPrf NN (iffH A (equal (var 0) (natToTerm f))) | S m => fun (f : naryFunc (S m)) (A : Formula) => forall a : nat, RepresentableHelp m (f a) (substituteFormula LNN A (S m) (natToTerm a)) end) ?M2521 ?M2522 ?M2524\" with \"(forall v : nat, In v (freeVarFormula LNN (projFormula m)) -> v <= n) /\\\\ expressible.RepresentableHelp NN n (evalProjFunc n m l) (projFormula m)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply SysPrf_refl.", "exn": "The reference SysPrf_refl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "apply expressible.RepresentableHelp_proj.", "exn": "The reference expressible.RepresentableHelp_proj was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl."], "tactic": "apply composeSigmaRepresentable.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S x' + w) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecSigmaFormula := fun (n : nat) (SigA SigB : Formula) => existH (S (S n)) (andH (minimize (primRecSigmaFormulaHelp n SigA SigB) (primRecPiFormulaHelp n SigA SigB) (S (S n)) (S (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 (var (S n)))) : nat -> Formula -> Formula -> Formula n, m : nat g : PrimRecs n m f : PrimRec m IHf : Representable m (evalPrimRec m f) (primRecFormula m f) Unable to unify \"(forall v : nat, In v (freeVarFormula LNN (composeSigmaFormula ?M2678 ?M2679 ?M2680 ?M2682 ?M2683)) -> v <= ?M2678) /\\\\ expressible.RepresentableHelp NN ?M2678 (evalComposeFunc ?M2678 ?M2680 (FormulasToFuncs ?M2678 ?M2680 ?M2682) ?M2684) (composeSigmaFormula ?M2678 ?M2679 ?M2680 ?M2682 ?M2683)\" with \"(forall v : nat, In v (freeVarFormula LNN (composeSigmaFormula n n m (primRecsFormula n m g) (primRecFormula m f))) -> v <= n) /\\\\ expressible.RepresentableHelp NN n (evalComposeFunc n m (evalPrimRecs n m g) (evalPrimRec m f)) (composeSigmaFormula n n m (primRecsFormula n m g) (primRecFormula m f))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1 use: composeSigmaRepresentable."], "tactic": "apply I.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop composeSigmaFormula := fun (n w m : nat) (A : Vector.t (Formula * naryFunc n) m) (B : Formula) => addExists (S w) m (andH (FormulasToFormula n w m A) (subAllFormula LNN B (fun x : nat => match x with | 0 => var 0 | S x' => var (S (x' + w)) end))) : forall n : nat, nat -> forall m : nat, Vector.t (Formula * naryFunc n) m -> Formula -> Formula H : forall n w m : nat, n <= w -> forall (A : Vector.t (Formula * naryFunc n) m) (B : Formula) (g : naryFunc m), RepresentablesHelp n m A -> Vector.t_rect (Formula * naryFunc n) (fun (n0 : nat) (_ : Vector.t (Formula * naryFunc n) n0) => Prop) True (fun (pair : Formula * naryFunc n) (m0 : nat) (_ : Vector.t (Formula * naryFunc n) m0) (rec : Prop) => (forall v0 : nat, In v0 (freeVarFormula LNN (fst pair)) -> v0 <= n) /\\\\ rec) m A -> Representable m g B -> Representable n (evalComposeFunc n m (FormulasToFuncs n m A) g) (composeSigmaFormula n w m A B) RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A succFormula := equal (var 0) (Succ (var 1)) : Formula zeroFormula := equal (var 0) Zero : Formula projFormula := fun m : nat => equal (var 0) (var (S m)) : nat -> Formula minimize := fun (A B : Formula) (v x : nat) => andH A (forallH x (impH (LT (var x) (var v)) (notH (substituteFormula LNN B v (var x))))) : Formula -> Formula -> nat -> nat -> Formula primRecSigmaFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (existH 0 (andH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (existH 0 (existH (S n) (andH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (andH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecPiFormulaHelp := fun (n : nat) (SigA SigB : Formula) => andH (forallH 0 (impH SigA (substituteFormula LNN (substituteFormula LNN betaFormula 1 Zero) 2 (var (S (S n)))))) (forallH (S (S (S n))) (impH (LT (var (S (S (S n)))) (var (S n))) (forallH 0 (forallH (S n) (impH (substituteFormula LNN (substituteFormula LNN (substituteFormula LNN betaFormula 1 (var (S (S (S n))))) 2 (var (S (S n)))) 0 (var (S n))) (impH (substituteFormula LNN SigB (S (S n)) (var (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 1 (Succ (var (S (S (S n)))))) 2 (var (S (S n)))))))))) : nat -> Formula -> Formula -> Formula primRecSigmaFormula := fun (n : nat) (SigA SigB : Formula) => existH (S (S n)) (andH (minimize (primRecSigmaFormulaHelp n SigA SigB) (primRecPiFormulaHelp n SigA SigB) (S (S n)) (S (S (S (S n))))) (substituteFormula LNN (substituteFormula LNN betaFormula 2 (var (S (S n)))) 1 (var (S n)))) : nat -> Formula -> Formula -> Formula n, m : nat g : PrimRecs n m f : PrimRec m H0 : forall v : nat, In v (freeVarFormula LNN (primRecFormula m f)) -> v <= m H1 : expressible.RepresentableHelp NN m (evalPrimRec m f) (primRecFormula m f) Unable to unify \"True\" with \"Representable n (evalComposeFunc n m (evalPrimRecs n m g) (evalPrimRec m f)) (composeSigmaFormula n n m (primRecsFormula n m g) (primRecFormula m f))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1 use: composeSigmaRepresentable.", "qsimpl time: 1 use: composeSigmaRepresentable,I."], "tactic": "apply IHf2.", "exn": "The reference IHf2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1 use: composeSigmaRepresentable.", "qsimpl time: 1 use: composeSigmaRepresentable,I."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n f.", "induction f.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1.", "shelve.", "-", "simpl.", "qsimpl time: 1 use: composeSigmaRepresentable.", "qsimpl time: 1 use: composeSigmaRepresentable,I.", "shelve.", "-", "simpl.", "apply primRecSigmaRepresentable.", "+", "apply IHf1.", "+", "apply IHf2."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros n f. induction f. - simpl. apply RepresentableAlternate with succFormula. + apply SysPrf_refl. + unfold RepresentableHelp. unfold evalPrimRec. simpl. apply expressible.RepresentableHelp with zeroFormula. -- apply SysPrf_refl. -- apply expressible.RepresentableHelp with succFormula. * apply SysPrf_refl. * apply expressible.RepresentableHelp_S. - simpl. apply RepresentableAlternate with zeroFormula. + apply SysPrf_refl. + apply expressible.RepresentableHelp with zeroFormula. -- apply SysPrf_refl. -- apply expressible.RepresentableHelp_S0. - simpl. apply RepresentableAlternate with (projFormula m). + apply SysPrf_refl. + apply expressible.RepresentableHelp_proj. - simpl. apply composeSigmaRepresentable. + apply I. + intros. apply IHf2. - simpl. apply primRecSigmaRepresentable. + apply IHf1. + apply IHf2. + apply I. + apply expressible.RepresentableHelp_S.", "back_times": 0, "succ": false, "time": 162.5190007686615}]