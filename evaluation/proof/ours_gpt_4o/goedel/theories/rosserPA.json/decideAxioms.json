[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros H Decider."], "tactic": "induction x as [| a x IHx].", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H Decider.", "induction natToTerm as [| a natToTerm IHnatToTerm].", "--", "left.", "intros g HIn."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H Decider.", "induction natToTerm as [| a natToTerm IHnatToTerm].", "--", "left.", "intros g HIn.", "shelve.", "--"], "tactic": "destruct IHx as [IH1 | IH2].", "exn": "The reference IHx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H Decider.", "induction natToTerm as [| a natToTerm IHnatToTerm].", "--", "left.", "intros g HIn.", "shelve.", "--", "destruct natToTerm as [IH1 | IH2].", "++"], "tactic": "destruct (H a) as [HTa | HNa].", "exn": "In environment T : System extendsPA : Included Formula PA T repT : Formula v0 : nat freeVarRepT : forall v : nat, In v (freeVarFormula LNT repT) -> v = v0 expressT1 : forall f : Formula, mem (fol.Formula LNT) T f -> SysPrf T (substituteFormula LNT repT v0 (natToTerm (codeFormula f))) expressT2 : forall f : Formula, ~ mem (fol.Formula LNT) T f -> SysPrf T (notH (substituteFormula LNT repT v0 (natToTerm (codeFormula f)))) H : forall x : Formula, mem (fol.Formula LNT) T x \\\\/ ~ mem (fol.Formula LNT) T x Decider : Formulas a : Functions LNT The term \"a\" has type \"Functions LNT\" while it is expected to have type \"Formula\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros H Decider.", "induction natToTerm as [| a natToTerm IHnatToTerm].", "--", "left.", "intros g HIn.", "shelve.", "--", "destruct natToTerm as [IH1 | IH2].", "++", "qsimpl time: 1.", "left.", "intros g HIn."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H Decider.", "induction natToTerm as [| a natToTerm IHnatToTerm].", "--", "left.", "intros g HIn.", "shelve.", "--", "destruct natToTerm as [IH1 | IH2].", "++", "qsimpl time: 1.", "left.", "intros g HIn.", "shelve.", "++", "right."], "tactic": ["destruct IH2 as [g [H1 H2]].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros H Decider. induction x as [| a x IHx]. -- left. intros g HIn. inversion HIn. -- destruct IHx as [IH1 | IH2]. ++ destruct (H a) as [HTa | HNa]. ** left. intros g HIn. inversion HIn. --- subst. auto. --- apply IH1. auto. ** right. exists a. split. --- constructor. reflexivity. --- auto. ++ right. destruct IH2 as [g [H1 H2]]. exists g. split. ** constructor 2. auto. ** auto.", "back_times": 1, "succ": false, "time": 230.5817346572876}]