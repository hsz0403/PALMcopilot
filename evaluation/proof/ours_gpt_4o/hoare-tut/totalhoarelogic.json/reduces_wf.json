[{"history": {"proof": "qsimpl time: 1 use: Acc_intro_generator. qsimpl time: 1 use: Acc_intro_generator.", "repairs": ["wrong_type", "not_inductive_product"], "exceptions": [{"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1)."], "tactic": "apply (Acc_intro_generator _ R).", "exn": "In environment cond : E.Expr bool p : ImpProg R := fun e1 e0 : E.Env => exists n : nat, execn n e0 (Iwhile cond p) e1 : E.Env -> E.Env -> Prop The term \"R\" has type \"E.Env -> E.Env -> Prop\" while it is expected to have type \"well_founded ?R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "apply Wf_nat.well_founded_ltof with (f := fun e0 : E.Env => S (execn_size (Iwhile cond p) e0)).", "exn": "The reference execn_size was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0."], "tactic": "induction e0 as [|e0 IH].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "apply Wf_nat.ltof_witness with (x := execn_size (Iwhile cond p) e0).", "exn": "The reference Wf_nat.ltof_witness was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "intros e1 [n Hn].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "destruct (exec_execn e0 (Iwhile cond p) e1 Hn) as [m Hm].", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "exists m.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "set (n := execn_size (Iwhile cond p) e0).", "exn": "The reference execn_size was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "exists n.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros cond p.", "set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1).", "qsimpl time: 1 use: Acc_intro_generator.", "intros e0.", "qsimpl time: 1 use: Acc_intro_generator."], "tactic": "apply IH.", "exn": "The reference IH was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros cond p. set (R := fun e1 e0 : E.Env => exists (n : nat), execn n e0 (Iwhile cond p) e1). apply (Acc_intro_generator _ R). apply Wf_nat.well_founded_ltof with (f := fun e0 : E.Env => S (execn_size (Iwhile cond p) e0)). intros e0. induction e0 as [|e0 IH]. - apply Wf_nat.ltof_witness with (x := execn_size (Iwhile cond p) e0). intros e1 [n Hn]. destruct (exec_execn e0 (Iwhile cond p) e1 Hn) as [m Hm]. exists m. auto. - set (n := execn_size (Iwhile cond p) e0). exists n. apply IH. Defined.", "back_times": 0, "succ": false, "time": 163.15033984184265}]