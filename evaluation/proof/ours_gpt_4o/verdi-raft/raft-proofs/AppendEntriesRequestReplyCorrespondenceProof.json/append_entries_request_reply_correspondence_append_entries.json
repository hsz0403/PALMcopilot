[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros net st' ps' d os d' ms h H_doGenericServer H_P H_reachable H_nwState H_st' H_ps'."], "tactic": ["apply append_entries_request_reply_correspondence_invariant.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "intros net st' ps' d os d' ms h H_doGenericServer H_P H_reachable H_nwState H_st' H_ps'. apply append_entries_request_reply_correspondence_invariant. - auto. - intros p t es H_inPackets H_pBody. unfold doGenericServer in H_doGenericServer. destruct (applyEntries h d (rev (filter (fun x : entry => (lastApplied d <? eIndex x) && (eIndex x <=? commitIndex d)) (findGtIndex (log d) (lastApplied d))))) as [outputs st0] eqn:H_applyEntries. injection H_doGenericServer as H_os H_ms H_d'. subst os d' ms. eapply CommonTheorems.applyEntries_spec_ind with (P := fun st' => P {| nwPackets := ps'; nwState := st' |}). + apply H_applyEntries. + intros. assert (H_eq_st: forall h', st' h' = update (nwState net) h (RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output st0 (if lastApplied st0 <? commitIndex st0 then commitIndex st0 else lastApplied st0)) h'). { intros h'. specialize (H_st' h'). unfold update at 1. destruct (name_eq_dec h h'). * subst. reflexivity. * rewrite H_st'. unfold update. destruct (name_eq_dec h h'); congruence. } assert (H_eq_ps: forall p, In p ps' -> In p (nwPackets net) \\/ In p (send_packets h [])). { intros p H_in_ps. specialize (H_ps' p H_in_ps). destruct H_ps'; [left | right]; auto. } apply H_P with (st' := st'). * auto. * eapply raft_net_invariant_state_same_packet_subset; eauto. -- intros; rewrite H_eq_st; auto. -- intros; apply H_eq_ps; auto.", "back_times": 0, "succ": false, "time": 84.71126508712769}]