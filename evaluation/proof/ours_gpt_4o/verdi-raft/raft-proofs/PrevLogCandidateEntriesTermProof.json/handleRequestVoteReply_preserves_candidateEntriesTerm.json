[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros net h d t out l Hreachable HhandleTimeout HcandidateEntriesTerm.", "unfold candidateEntriesTerm."], "tactic": ["destruct HcandidateEntriesTerm as [h' [HwonElection HcurrentTerm]].", ""], "exn": "Expects a disjunctive pattern with 6 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros net h d t out l Hreachable HhandleTimeout HcandidateEntriesTerm. unfold candidateEntriesTerm. destruct HcandidateEntriesTerm as [h' [HwonElection HcurrentTerm]]. exists h'. split. - unfold nwState. simpl. destruct (name_eq_dec h' h). + subst h'. rewrite update_eq. apply update_elections_data_timeout_cronies with (h := h) (out := out) (d' := d) (l := l). * auto. * right. do 2 (split; auto). apply RRIR_doLeader with (h := h) (ps' := []). -- auto. -- unfold handleTimeout in *. destruct (type (snd (nwState net h))) eqn:Htype. ++ eapply doLeader_preserves_candidateEntries. ** reflexivity. ** auto. ** auto. ++ rewrite HhandleTimeout. eapply doLeader_preserves_candidateEntries. ** reflexivity. ** apply HhandleTimeout. ** auto. -- unfold update. intros h''. destruct (name_eq_dec h h''). ** subst h''. apply f_equal. destruct (name_eq_dec h h). *** reflexivity. *** contradiction. ** rewrite update_neq; auto. + rewrite update_neq; auto. apply candidateEntriesTerm_same with (st := nwState net). * auto. * intros. unfold nwState. simpl. rewrite update_neq; auto. * intros. unfold nwState. simpl. rewrite update_neq; auto. * intros. unfold nwState. simpl. rewrite update_neq; auto. - intros. apply HcurrentTerm. unfold nwState. simpl. rewrite update_neq; auto.", "back_times": 0, "succ": false, "time": 128.2680859565735}]