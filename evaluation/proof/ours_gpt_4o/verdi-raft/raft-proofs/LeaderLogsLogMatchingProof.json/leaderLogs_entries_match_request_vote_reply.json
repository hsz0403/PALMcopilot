[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros x xs ys Hsorted_xs Hsorted_ys Hx_gt_maxIndex_xs Hx_gt_maxTerm_ys Hentries_match.", "intros e e' e'' HeIndex_eq HeTerm_eq Hin_e Hin_e'."], "tactic": ["destruct Hin_e as [Heq | Hin_e_xs].", ""], "exn": "Expects a disjunctive pattern with 1 branch or a conjunctive pattern made of 2 patterns.", "type": "num_branch_both", "handled": false}]}, "chat": [], "original": "intros x xs ys Hsorted_xs Hsorted_ys Hx_gt_maxIndex_xs Hx_gt_maxTerm_ys Hentries_match. intros e e' e'' HeIndex_eq HeTerm_eq Hin_e Hin_e'. simpl in Hin_e. destruct Hin_e as [Heq | Hin_e_xs]. - subst. pose proof (maxIndex_is_max _ _ Hsorted_xs Hin_e_xs) as HmaxIndex_xs. pose proof (maxTerm_is_max _ _ Hsorted_ys Hin_e') as HmaxTerm_ys. assert (HeIndex : eIndex e'' <= eIndex x). { apply Nat.max_lub_iff in Hx_gt_maxIndex_xs. destruct Hx_gt_maxIndex_xs. apply Nat.lt_le_incl, H. } split; intros Hin. + right. apply Hentries_match with e e'; auto. + destruct (eq_nat_dec (eIndex e'') (eIndex x)) as [Heq_x | Hneq_x]. * left. symmetry. auto. * right. apply Hentries_match with e e'; auto.", "back_times": 0, "succ": false, "time": 127.58834528923035}]