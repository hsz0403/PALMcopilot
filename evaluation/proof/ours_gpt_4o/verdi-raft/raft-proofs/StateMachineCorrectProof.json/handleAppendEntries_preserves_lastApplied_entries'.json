[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p net d m t n pli plt es ci xs ys ps' st' e Hreach1 Hreach2 Heq1 Heq2 Hhandle Hpackets Heq3 Hindex Hin.", "unfold handleAppendEntries in Hhandle.", "destruct (t <? currentTerm (nwState net (pDst p))) eqn:Hterm.", "-", "inversion Hhandle.", "subst.", "auto.", "-", "destruct (pli =? 0) eqn:Hprev.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:Hnew.", "*", "inversion Hhandle.", "subst."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p net d m t n pli plt es ci xs ys ps' st' e Hreach1 Hreach2 Heq1 Heq2 Hhandle Hpackets Heq3 Hindex Hin.", "unfold handleAppendEntries in Hhandle.", "destruct (t <? currentTerm (nwState net (pDst p))) eqn:Hterm.", "-", "inversion Hhandle.", "subst.", "auto.", "-", "destruct (pli =? 0) eqn:Hprev.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:Hnew.", "*", "inversion Hhandle.", "subst.", "shelve.", "*", "inversion Hhandle.", "subst."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p net d m t n pli plt es ci xs ys ps' st' e Hreach1 Hreach2 Heq1 Heq2 Hhandle Hpackets Heq3 Hindex Hin.", "unfold handleAppendEntries in Hhandle.", "destruct (t <? currentTerm (nwState net (pDst p))) eqn:Hterm.", "-", "inversion Hhandle.", "subst.", "auto.", "-", "destruct (pli =? 0) eqn:Hprev.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:Hnew.", "*", "inversion Hhandle.", "subst.", "shelve.", "*", "inversion Hhandle.", "subst.", "shelve.", "+"], "tactic": "destruct (prevLogMatch (nwState net (pDst p)) pli plt) eqn:Hmatch.", "exn": "The reference prevLogMatch was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p net d m t n pli plt es ci xs ys ps' st' e Hreach1 Hreach2 Heq1 Heq2 Hhandle Hpackets Heq3 Hindex Hin.", "unfold handleAppendEntries in Hhandle.", "destruct (t <? currentTerm (nwState net (pDst p))) eqn:Hterm.", "-", "inversion Hhandle.", "subst.", "auto.", "-", "destruct (pli =? 0) eqn:Hprev.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:Hnew.", "*", "inversion Hhandle.", "subst.", "shelve.", "*", "inversion Hhandle.", "subst.", "shelve.", "+", "simpl in Hhandle."], "tactic": "destruct (applyEntries (nwState net (pDst p)) n pli plt es ci) eqn:Happly.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params si : sorted_interface misi : max_index_sanity_interface smsi : state_machine_safety_interface lmi : log_matching_interface p : packet net : network d : raft_data m : msg t : term n : name pli : logIndex plt : term es : list entry ci : logIndex xs, ys, ps' : list packet st' : Net.name -> data e : entry Hreach1 : raft_intermediate_reachable net Hreach2 : raft_intermediate_reachable {| nwPackets := ps'; nwState := st' |} Heq1 : forall h : name, st' h = update name_eq_dec (nwState net) (pDst p) d h Heq2 : forall p' : packet, In p' ps' -> In p' (xs ++ ys) \\\\/ p' = {| pSrc := pDst p; pDst := pSrc p; pBody := m |} Hterm : (t <? currentTerm (nwState net (pDst p))) = false Hprev : (pli =? 0) = false Hhandle : match findAtIndex (log (nwState net (pDst p))) pli with | Some e => if negb (plt =? eTerm e) then (nwState net (pDst p), AppendEntriesReply (currentTerm (nwState net (pDst p))) es false) else if haveNewEntries (nwState net (pDst p)) es then (mkRaft_data (currentTerm (advanceCurrentTerm (nwState net (pDst p)) t)) (votedFor (advanceCurrentTerm (nwState net (pDst p)) t)) (Some n) (es ++ removeAfterIndex (log (nwState net (pDst p))) pli) (Init.Nat.max (commitIndex (nwState net (pDst p))) (Init.Nat.min ci (maxIndex (es ++ removeAfterIndex (log (nwState net (pDst p))) pli)))) (lastApplied (advanceCurrentTerm (nwState net (pDst p)) t)) (stateMachine (advanceCurrentTerm (nwState net (pDst p)) t)) (nextIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (matchIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (shouldSend (advanceCurrentTerm (nwState net (pDst p)) t)) (votesReceived (advanceCurrentTerm (nwState net (pDst p)) t)) Follower (clientCache (advanceCurrentTerm (nwState net (pDst p)) t)) (electoralVictories (advanceCurrentTerm (nwState net (pDst p)) t)), AppendEntriesReply t es true) else (mkRaft_data (currentTerm (advanceCurrentTerm (nwState net (pDst p)) t)) (votedFor (advanceCurrentTerm (nwState net (pDst p)) t)) (Some n) (log (advanceCurrentTerm (nwState net (pDst p)) t)) (commitIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (lastApplied (advanceCurrentTerm (nwState net (pDst p)) t)) (stateMachine (advanceCurrentTerm (nwState net (pDst p)) t)) (nextIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (matchIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (shouldSend (advanceCurrentTerm (nwState net (pDst p)) t)) (votesReceived (advanceCurrentTerm (nwState net (pDst p)) t)) Follower (clientCache (advanceCurrentTerm (nwState net (pDst p)) t)) (electoralVictories (advanceCurrentTerm (nwState net (pDst p)) t)), AppendEntriesReply t es true) | None => (nwState net (pDst p), AppendEntriesReply (currentTerm (nwState net (pDst p))) es false) end = (d, m) Hpackets : nwPackets net = xs ++ p :: ys Heq3 : pBody p = AppendEntries t n pli plt es ci Hindex : eIndex e <= lastApplied (nwState net (pDst p)) Hin : In e (log (nwState net (pDst p))) The term \"nwState net (pDst p)\" has type \"data\" while it is expected to have type \"name\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros p net d m t n pli plt es ci xs ys ps' st' e Hreach1 Hreach2 Heq1 Heq2 Hhandle Hpackets Heq3 Hindex Hin. unfold handleAppendEntries in Hhandle. destruct (t <? currentTerm (nwState net (pDst p))) eqn:Hterm. - inversion Hhandle. subst. auto. - destruct (pli =? 0) eqn:Hprev. + destruct (haveNewEntries (nwState net (pDst p)) es) eqn:Hnew. * inversion Hhandle. subst. auto. * inversion Hhandle. subst. auto. + destruct (prevLogMatch (nwState net (pDst p)) pli plt) eqn:Hmatch. * simpl in Hhandle. destruct (applyEntries (nwState net (pDst p)) n pli plt es ci) eqn:Happly. inversion Hhandle. subst. destruct (log d) eqn:Hlogd. -- exfalso. eapply applyEntries_preserves_log; eauto. -- simpl in Hlogd. assert (sorted (log d)) by (apply handleAppendEntries_logs_sorted with (p:=p); auto). destruct l; subst; auto. * inversion Hhandle. subst. auto.", "back_times": 0, "succ": false, "time": 231.7131805419922}]