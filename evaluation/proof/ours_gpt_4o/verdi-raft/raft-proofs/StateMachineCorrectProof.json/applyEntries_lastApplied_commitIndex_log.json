[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros l h st os st' H.", "induction l as [| entry l' IHl].", "-", "simpl in H.", "inversion H.", "subst.", "auto.", "-", "simpl in H.", "destruct (cacheApplyEntry st entry) as [out st0] eqn:Hcache.", "destruct (applyEntries h st0 l') as [out' state] eqn:Happly.", "inversion H.", "subst.", "pose proof IHl as IH."], "tactic": "apply IH in Happly.", "exn": "Unable to apply lemma of type \"applyEntries h st l' = ((if name_eq_dec (eAt entry) h then map (fun o : output => ClientResponse (eClient entry) (eId entry) o) out else []) ++ out', st') -> lastApplied st' = lastApplied st /\\\\ commitIndex st' = commitIndex st /\\\\ log st' = log st\" on hypothesis of type \"applyEntries h st0 l' = (out', st')\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros l h st os st' H. induction l as [| entry l' IHl]. - simpl in H. inversion H. subst. auto. - simpl in H. destruct (cacheApplyEntry st entry) as [out st0] eqn:Hcache. destruct (applyEntries h st0 l') as [out' state] eqn:Happly. inversion H. subst. pose proof IHl as IH. apply IH in Happly. destruct (name_eq_dec (eAt entry) h). + destruct Happly as [Hlast [Hcommit Hlog]]. split; auto. + auto.", "back_times": 0, "succ": false, "time": 322.84353399276733}]