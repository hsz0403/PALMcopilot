[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros h s t n prevT prevI entries c d m e Hhandle HIn.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "apply handleAppendEntries_log in Hhandle.", "exn": "No such hypothesis: Hhandle", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log."], "tactic": "destruct Hhandle as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "exn": "The reference Hhandle was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left."], "tactic": "rewrite <- Hlog.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-"], "tactic": "destruct Hlog as [_ Hlog].", "exn": "The reference Hlog was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage]."], "tactic": "right.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log."], "tactic": "apply in_or_app.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H0 : forall (h : name) (st : raft_data) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (ps : msg), handleAppendEntries h st t n pli plt es ci = (st', ps) -> log st' = log st \\\\/ currentTerm st <= t /\\\\ (es = [] -> False) /\\\\ pli = 0 /\\\\ log st' = es \\\\/ (currentTerm st <= t /\\\\ (es = [] -> False) /\\\\ (pli = 0 -> False) /\\\\ (exists e : entry, In e (log st) /\\\\ eIndex e = pli /\\\\ eTerm e = plt)) /\\\\ log st' = es ++ removeAfterIndex (log st) pli one_node_params : OneNodeParams orig_base_params h : name d : raft_data m0 : name t : term n : name prevT : logIndex prevI : term entries : list entry c : logIndex H1 : In (m0, AppendEntries t n prevT prevI entries c) (map (fun node : name => (node, RequestVote (S (currentTerm d)) h (maxIndex (log d)) (maxTerm (log d)))) (filter (fun h0 : name => if name_eq_dec h h0 then false else true) nodes)) UniqueIndices_invariant : forall net : network, raft_intermediate_reachable net -> UniqueIndices net leader_sublog_invariant_invariant : forall net : network, raft_intermediate_reachable net -> leader_sublog_invariant net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net Unable to unify \"(fix In (a : ?M5883) (l : list ?M5883) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) ?M5886 (?M5884 ++ ?M5885)\" with \"(fix fin (n : nat) : Type := match n with | 0 => False | S n' => option (fin n') end) N\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-"], "tactic": "destruct Hlog as [_ [Hlog | (_ & _ & Hlog)]].", "exn": "The reference Hlog was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+"], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log."], "tactic": "rewrite <- Hlog.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "+"], "tactic": "rewrite Hlog in HIn.", "exn": "No such hypothesis: HIn", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log."], "tactic": "apply in_app_or in HIn.", "exn": "No such hypothesis: HIn", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log,in_app_or."], "tactic": "destruct HIn as [Hleft | Hright].", "exn": "The reference HIn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log,in_app_or.", "destruct N as [Hleft | Hright].", "*"], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log,in_app_or.", "destruct N as [Hleft | Hright].", "*", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log,in_app_or."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: handleAppendEntries_log.", "destruct wonElection as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]].", "-", "left.", "-", "destruct handleMessage as [_ handleMessage].", "qsimpl time: 1 use: handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "auto.", "shelve.", "-", "destruct Build_unique_indices_interface as [_ [Build_unique_indices_interface | (_ & _ & Build_unique_indices_interface)]].", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "+", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log.", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log,in_app_or.", "destruct N as [Hleft | Hright].", "*", "qsimpl time: 1 use: in_or_app,handleAppendEntries_log,in_app_or.", "shelve.", "*"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros h s t n prevT prevI entries c d m e Hhandle HIn. apply handleAppendEntries_log in Hhandle. destruct Hhandle as [Hlog | [(Hleq, Hnonempty) | (Hleq2, (Hexists, Hlog))]]. - left. rewrite <- Hlog. auto. - destruct Hlog as [_ Hlog]. right. apply in_or_app. right. auto. - destruct Hlog as [_ [Hlog | (_ & _ & Hlog)]]. + left. rewrite <- Hlog. auto. + rewrite Hlog in HIn. apply in_app_or in HIn. destruct HIn as [Hleft | Hright]. * left. auto. * right. auto.", "back_times": 0, "succ": false, "time": 206.086008310318}]