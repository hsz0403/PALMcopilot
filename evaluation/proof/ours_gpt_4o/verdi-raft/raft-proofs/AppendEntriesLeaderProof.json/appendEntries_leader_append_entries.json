[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st t n pli plt es ci st' ps H."], "tactic": "pose proof handleAppendEntries_type_term _ _ _ _ _ _ _ _ _ _ H.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface aecfli : append_entries_came_from_leaders_interface ollpti : one_leaderLog_per_term_interface lltsi : leaderLogs_term_sanity_interface olpti : one_leader_per_term_interface h : list packet st : packet t : list packet n : network pli : name -> data plt : list packet es : electionsData ci : raft_data st' : msg ps : term H : name The term \"H\" has type \"name\" while it is expected to have type \"handleAppendEntries ?h ?st ?t ?n ?pli ?plt ?es ?ci = (?st', ?ps)\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "destruct H0 as [[Htype Hterm] | [Hfollower Hterm_ge]].", "exn": "Unable to find an instance for the variables h, st, t, n, pli, plt, es, ci, st', ps.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "apply Htype.", "exn": "The reference Htype was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "apply Hterm.", "exn": "The reference Hterm was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "intros e He.", "exn": "e is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "intros e' He.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term."], "tactic": "pose proof handleAppendEntries_log _ _ _ _ _ _ _ _ _ _ H.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H2 : forall (h : name) (st : raft_data) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (ps : msg), handleAppendEntries h st t n pli plt es ci = (st', ps) -> type st' = type st /\\\\ currentTerm st' = currentTerm st \\\\/ type st' = Follower /\\\\ currentTerm st' >= currentTerm st one_node_params : OneNodeParams orig_base_params h : list packet st : packet t : list packet n : network pli : name -> electionsData * raft_data plt : list packet ci : raft_data st' : msg ps : term H : name pli0 : logIndex plt0 : term es0 : list entry ci0 : logIndex H1 : handleAppendEntries (pDst st) (snd (nwState n (pDst st))) ps H pli0 plt0 es0 ci0 = (ci, st') H3 : pBody st = AppendEntries ps H pli0 plt0 es0 ci0 H4 : appendEntries_leader n H5 : refined_raft_intermediate_reachable n H6 : nwPackets n = h ++ st :: t H7 : forall h : name, pli h = update name_eq_dec (nwState n) (pDst st) (update_elections_data_appendEntries (pDst st) (nwState n (pDst st)) ps H pli0 plt0 es0 ci0, ci) h H8 : forall p' : packet, In p' plt -> In p' (h ++ t) \\\\/ p' = {| pSrc := pDst st; pDst := pSrc st; pBody := st' |} one_leader_per_term_invariant : forall net : network, raft_intermediate_reachable net -> one_leader_per_term net leaderLogs_term_sanity_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaderLogs_term_sanity net leaderLogs_currentTerm_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaderLogs_currentTerm_sanity net leaderLogs_currentTerm_sanity_candidate_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaderLogs_currentTerm_sanity_candidate net one_leaderLog_per_term_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term net one_leaderLog_per_term_log_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_log net one_leaderLog_per_term_host_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_host net append_entries_came_from_leaders_invariant : forall net : network, refined_raft_intermediate_reachable net -> append_entries_came_from_leaders net refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Hst'_Leader : packet leaderId : name prevLogIndex : logIndex prevLogTerm : term entries : list entry leaderCommit : logIndex h0 : name e : entry H9 : In Hst'_Leader plt H10 : pBody Hst'_Leader = AppendEntries (currentTerm (snd (pli h0))) leaderId prevLogIndex prevLogTerm entries leaderCommit H11 : In e entries H13 : type (snd (pli h0)) = Leader The term \"H\" has type \"name\" while it is expected to have type \"handleAppendEntries ?h ?st ?t ?n ?pli ?plt ?es ?ci = (?st', ?ps)\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term."], "tactic": "destruct H2 as [Hlog_eq | [H_fail _]].", "exn": "The reference H2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++"], "tactic": "rewrite Hlog_eq.", "exn": "The reference Hlog_eq was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++", "shelve.", "++"], "tactic": "destruct H_fail as [_ [_ [_ _log_es]]].", "exn": "The reference H_fail was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++", "shelve.", "++", "destruct Build_one_leader_per_term_interface as [_ [_ [_ _log_es]]]."], "tactic": "inversion _log_es.", "exn": "No such hypothesis: _log_es", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++", "shelve.", "++", "destruct Build_one_leader_per_term_interface as [_ [_ [_ _log_es]]].", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term."], "tactic": "intros Hst'_Leader.", "exn": "Hst'_Leader is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++", "shelve.", "++", "destruct Build_one_leader_per_term_interface as [_ [_ [_ _log_es]]].", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term."], "tactic": "intros Hst'_Leader'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "intros Hst'_Leader.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_type_term.", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "destruct votesWithLog as [Hlog_eq | [H_fail _]].", "++", "shelve.", "++", "destruct Build_one_leader_per_term_interface as [_ [_ [_ _log_es]]].", "qsimpl time: 1 use: handleAppendEntries_log,handleAppendEntries_type_term.", "exfalso."], "tactic": "rewrite <- Hst'_Leader in Hfollower.", "exn": "No such hypothesis: Hfollower", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros h st t n pli plt es ci st' ps H. pose proof handleAppendEntries_type_term _ _ _ _ _ _ _ _ _ _ H. destruct H0 as [[Htype Hterm] | [Hfollower Hterm_ge]]. - unfold type_term_log_monotonic. intros Hst'_Leader. split. + apply Htype. + split. * apply Hterm. * intros e He. pose proof handleAppendEntries_log _ _ _ _ _ _ _ _ _ _ H. destruct H2 as [Hlog_eq | [H_fail _]]. ++ rewrite Hlog_eq. auto. ++ destruct H_fail as [_ [_ [_ _log_es]]]. inversion _log_es. - unfold type_term_log_monotonic. intros Hst'_Leader. exfalso. rewrite <- Hst'_Leader in Hfollower. discriminate.", "back_times": 0, "succ": false, "time": 201.84725189208984}]