[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st t n pli plt es ci st' ps H."], "tactic": "apply handleAppendEntries_type in H.", "exn": "Unable to apply lemma of type \"forall (h0 : name) (st0 : raft_data) (t0 : term) (n0 : name) (pli0 : logIndex) (plt0 : term) (es0 : list entry) (ci0 : logIndex) (st'0 : raft_data) (ps0 : msg), handleAppendEntries h0 st0 t0 n0 pli0 plt0 es0 ci0 = (st'0, ps0) -> type st'0 = type st0 /\\\\ currentTerm st'0 = currentTerm st0 \\\\/ type st'0 = Follower\" on hypothesis of type \"handleClientRequest h (nwState st h) ci st' ps = (pli, plt, es)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "qsimpl time: 1 use: handleAppendEntries_type."], "tactic": ["destruct H as [[Htype Hterm] | Hfollower].", ""], "exn": "Expects a disjunctive pattern with 1 branch or a conjunctive pattern made of 0 patterns.", "type": "num_branch_both", "handled": false}]}, "chat": [], "original": "intros h st t n pli plt es ci st' ps H. apply handleAppendEntries_type in H. destruct H as [[Htype Hterm] | Hfollower]. - split. + apply Htype. + exfalso. unfold hasLog. destruct (t <? currentTerm st) eqn:Heq. * apply Nat.ltb_lt in Heq. apply handleAppendEntries_not_append_entries in H. contradiction. * destruct (prevLogIndex =? 0) eqn:Hpli. -- simpl in *. lia. -- apply handleAppendEntries_log in H as [Hlog | [Hcur [Hes [_ [Hltf Hlog']]]]]. ++ rewrite Hlog. split. ** apply Nat.le_refl. ** intros. reflexivity. ++ destruct Hlog' as [Hcum [Hpresent Hlog'']]. exists Hcum, Hpresent. auto. - split. + unfold type. right. apply Hfollower. + intros. split. * reflexivity. * intros. reflexivity.", "back_times": 0, "succ": false, "time": 78.61533737182617}]