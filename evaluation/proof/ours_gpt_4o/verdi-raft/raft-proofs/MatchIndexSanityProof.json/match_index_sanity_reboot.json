[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st st' m t es res h' H H0."], "tactic": "apply handleAppendEntriesReply_log_term_type in H.", "exn": "Unable to apply lemma of type \"forall (h0 : name) (st0 : RaftState.raft_data term name entry logIndex serverType data clientId output) (n : name) (t0 : nat) (es0 : list entry) (r : bool) (st'0 : raft_data) (ps : list (name * msg)), handleAppendEntriesReply h0 st0 n t0 es0 r = (st'0, ps) -> log st'0 = log st0 /\\\\ currentTerm st'0 = currentTerm st0 /\\\\ type st'0 = type st0 \\\\/ type st'0 = Follower\" on hypothesis of type \"nwState h m = st'\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type."], "tactic": "destruct H as [[H1 [H2 H3]] | H4].", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-"], "tactic": "split; [auto |].", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type."], "tactic": "apply handleAppendEntriesReply_matchIndex_leader_preserved in H.", "exn": "Unable to apply lemma of type \"forall (h0 : name) (st0 : RaftState.raft_data term name entry logIndex serverType data clientId output) (d : raft_data) (m0 : list (name * msg)) (t : nat) (es : list entry) (res0 : bool) (h'0 : name), handleAppendEntriesReply h0 st0 h'0 t es res0 = (d, m0) -> matchIndex_preserved_except_at_host h'0 st0 d\" on hypothesis of type \"forall (h : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (n : name) (t : nat) (es : list entry) (r : bool) (st' : raft_data) (ps : list (name * msg)), handleAppendEntriesReply h st n t es r = (st', ps) -> log st' = log st /\\\\ currentTerm st' = currentTerm st /\\\\ type st' = type st \\\\/ type st' = Follower\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type."], "tactic": "unfold matchIndex_preserved_except_at_host in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type."], "tactic": "destruct H as [H4 H5].", "exn": "Unable to find an instance for the variables h, st, d, m, t, es, res, h'.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type."], "tactic": "split; auto.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type."], "tactic": "right.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H4 : forall (h : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (n : name) (t : nat) (es : list entry) (r : bool) (st' : raft_data) (ps : list (name * msg)), handleAppendEntriesReply h st n t es r = (st', ps) -> log st' = log st /\\\\ currentTerm st' = currentTerm st /\\\\ type st' = type st \\\\/ type st' = Follower H : forall (h : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (d : raft_data) (m : list (name * msg)) (t : nat) (es : list entry) (res : bool) (h' : name), handleAppendEntriesReply h st h' t es res = (d, m) -> matchIndex_preserved_except_at_host h' st d one_node_params : OneNodeParams orig_base_params h, st : network m : name res : match_index_sanity h h' : raft_intermediate_reachable h H0 : forall h' : name, nwState st h' = update name_eq_dec (nwState h) m (reboot (nwState h m)) h' H2 : nwPackets h = nwPackets st handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net append_entries_reply_sublog_invariant : forall net : network, raft_intermediate_reachable net -> append_entries_reply_sublog net H1 : RaftState.raft_data term name entry logIndex serverType data clientId output -> Prop leader : Net.name h0 : name H3 : type (nwState st leader) = Leader Unable to unify \"?M12993 <= S ?M12994\" with \"assoc_default name_eq_dec (matchIndex (nwState st leader)) h0 0 <= maxIndex (log (nwState st leader))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type."], "tactic": "split; [| split; auto].", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type."], "tactic": "apply handleAppendEntriesReply_currentTerm in H0.", "exn": "Unable to apply lemma of type \"forall (h0 : name) (st0 : RaftState.raft_data term name entry logIndex serverType data clientId output) (h'0 : name) (t : nat) (es : list entry) (r : bool) (st' : raft_data) (ms : list (name * msg)), handleAppendEntriesReply h0 st0 h'0 t es r = (st', ms) -> currentTerm st0 <= currentTerm st'\" on hypothesis of type \"forall h' : name, nwState st h' = update name_eq_dec (nwState h) m (reboot (nwState h m)) h'\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type,handleAppendEntriesReply_currentTerm."], "tactic": "lia.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st st' m t es res h' H H0.", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "destruct nodes as [[nodes1 [nodes2 nodes3]] | nodes4].", "-", "qsimpl time: 1 use: handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type.", "qsimpl time: 1 use: handleAppendEntriesReply_matchIndex_leader_preserved,matchIndex_preserved_except_at_host,handleAppendEntriesReply_log_term_type,handleAppendEntriesReply_currentTerm."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros h st st' m t es res h' H H0. apply handleAppendEntriesReply_log_term_type in H. destruct H as [[H1 [H2 H3]] | H4]. - subst. split; [auto |]. apply handleAppendEntriesReply_matchIndex_leader_preserved in H. unfold matchIndex_preserved_except_at_host in H. destruct H as [H4 H5]. split; auto. right. split; [| split; auto]. apply handleAppendEntriesReply_currentTerm in H0. lia. - subst. discriminate.", "back_times": 0, "succ": false, "time": 112.79861068725586}]