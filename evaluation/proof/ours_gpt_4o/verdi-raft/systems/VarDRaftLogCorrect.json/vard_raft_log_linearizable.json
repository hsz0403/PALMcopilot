[{"history": {"proof": "qsimpl time: 1 use: raft_linearizable.", "repairs": ["cannot_apply_in"], "exceptions": [{"ctx": ["intros failed net tr H_input_correct H_step."], "tactic": "apply raft_linearizable in H_step; auto.", "exn": "Unable to apply lemma of type \"forall (failed0 : list Net.name) (net0 : network) (tr0 : list (name * (raft_input + list raft_output))), input_correct tr0 -> step_failure_star step_failure_init (failed0, net0) tr0 -> exists (l : list (IR key)) (tr1 : list (input * output)) (st : data), equivalent key (import tr0) l /\\\\ exported (get_input tr0) (get_output tr0) l tr1 /\\\\ step_1_star init st tr1\" on hypothesis of type \"step_failure_disk_ops_star step_failure_disk_ops_init (failed, net) tr\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros failed net tr H_input_correct H_step.", "qsimpl time: 1 use: raft_linearizable."], "tactic": ["destruct H_step as [l [tr1 [st [H_equivalent [H_exported H_step1]]]]].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros failed net tr H_input_correct H_step. apply raft_linearizable in H_step; auto. destruct H_step as [l [tr1 [st [H_equivalent [H_exported H_step1]]]]]. exists l, tr1, st. split; [| split]; auto.", "back_times": 0, "succ": false, "time": 164.96948957443237}]