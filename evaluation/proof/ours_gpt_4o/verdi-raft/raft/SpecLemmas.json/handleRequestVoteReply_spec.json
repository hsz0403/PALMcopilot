[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output h' : name t : nat r : bool st' : raft_data eq : st' = handleRequestVoteReply h st h' t r Unable to unify \"log st\" with \"log (advanceCurrentTerm st t)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl.", "shelve.", "+", "split.", "*", "intros v Hin.", "simpl."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl.", "shelve.", "+", "split.", "*", "intros v Hin.", "simpl.", "shelve.", "*", "split.", "right."], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl.", "shelve.", "+", "split.", "*", "intros v Hin.", "simpl.", "shelve.", "*", "split.", "right.", "--", "shelve.", "--", "shelve.", "-", "simpl.", "destruct (t <? currentTerm st).", "+", "split.", "*", "reflexivity.", "*", "split.", "intros v Hin.", "auto.", "split."], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl.", "shelve.", "+", "split.", "*", "intros v Hin.", "simpl.", "shelve.", "*", "split.", "right.", "--", "shelve.", "--", "shelve.", "-", "simpl.", "destruct (t <? currentTerm st).", "+", "split.", "*", "reflexivity.", "*", "split.", "intros v Hin.", "auto.", "split.", "--", "shelve.", "--", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl.", "shelve.", "+", "split.", "*", "intros v Hin.", "simpl.", "shelve.", "*", "split.", "right.", "--", "shelve.", "--", "shelve.", "-", "simpl.", "destruct (t <? currentTerm st).", "+", "split.", "*", "reflexivity.", "*", "split.", "intros v Hin.", "auto.", "split.", "--", "shelve.", "--", "shelve.", "+"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st h' t r st' eq.", "rewrite eq.", "unfold handleRequestVoteReply.", "destruct (currentTerm st <? t).", "-", "split.", "+", "simpl.", "shelve.", "+", "split.", "*", "intros v Hin.", "simpl.", "shelve.", "*", "split.", "right.", "--", "shelve.", "--", "shelve.", "-", "simpl.", "destruct (t <? currentTerm st).", "+", "split.", "*", "reflexivity.", "*", "split.", "intros v Hin.", "auto.", "split.", "--", "shelve.", "--", "shelve.", "+", "qsimpl time: 1."], "tactic": "reflexivity.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros h st h' t r st' eq. rewrite eq. unfold handleRequestVoteReply. destruct (currentTerm st <? t). - split. + simpl. reflexivity. + split. * intros v Hin. simpl. auto. * split. { right. reflexivity. } { intros [Hneq Hleader]. inversion Hleader. } - simpl. destruct (t <? currentTerm st). + split. * reflexivity. * split. { intros v Hin. auto. } { split. - right. reflexivity. - intros [Hneq _]. contradiction. } + simpl. split. * reflexivity. * split. { intros v Hin. destruct r. - simpl. right. auto. - auto. } { simpl. destruct (type st). - split. + left. split; reflexivity. + intros [Hneq _]. contradiction. - split. + right. reflexivity. + intros [Hneq _]. contradiction. - destruct (voteGranted && wonElection (dedup name_eq_dec (h' :: votesReceived st))); intros [Hneq Hleader]. * split. { destruct (wonElection (dedup name_eq_dec (h' :: votesReceived st'))); try discriminate. split; auto. apply wonElection_one_in_common in H; try auto. destruct H as [x [HinVotes HinVotes']]. split. - subst. auto. - split; auto. } { apply wonElection_dedup_spec in Hleader. destruct Hleader as [quorum [NoDupQ [LenQ InQ]]]. exists quorum. split; [assumption|]. split; [assumption|]. intros v HIn. destruct (name_eq_dec v h'). - subst. simpl. left. reflexivity. - simpl. right. apply InQ. auto. } * split. { left. split; reflexivity. } { intros [Hneq _]. inversion Hleader. } } }", "back_times": 4, "succ": false, "time": 363.177561044693}]