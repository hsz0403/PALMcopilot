[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-"], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-", "qsimpl time: 1."], "tactic": "apply U1.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st0 : electionsData st1 : raft_data out : list raft_output st' : raft_data e : entry U1 : allEntries (update_elections_data_client_request h (st0, st1) (eClient e) (eId e) (eInput e)) = allEntries st0 H : handleClientRequest h st1 (eClient e) (eId e) (eInput e) = (out, st', []) H1 : log st' = e :: log st1 H0 : eIndex e = S (maxIndex (log st1)) H2 : eTerm e = currentTerm st1 H7 : type st1 = Leader refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Unable to unify \"allEntries (update_elections_data_client_request h (st0, st1) (eClient e) (eId e) (eInput e)) = allEntries st0\" with \"allEntries (update_elections_data_client_request h (st0, st1) (eClient e) (eId e) (eInput e)) = allEntries st0 /\\\\ log st' = log st1 \\\\/ type st1 = Leader /\\\\ (exists e0 : entry, eIndex e0 = S (maxIndex (log st1)) /\\\\ eTerm e0 = currentTerm st1 /\\\\ eClient e0 = eClient e /\\\\ eInput e0 = eInput e /\\\\ eId e0 = eId e /\\\\ type st1 = Leader /\\\\ allEntries (update_elections_data_client_request h (st0, st1) (eClient e) (eId e) (eInput e)) = (currentTerm st', e0) :: allEntries st0 /\\\\ log st' = e0 :: log st1)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-", "qsimpl time: 1."], "tactic": "destruct L as [_ [L1 | L2]].", "exn": "The reference L was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-", "qsimpl time: 1.", "destruct H1 as [_ [H11 | H12]]."], "tactic": "apply L1.", "exn": "The reference L1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-", "qsimpl time: 1.", "destruct H1 as [_ [H11 | H12]].", "apply fast_Zred_factor6.", "*"], "tactic": "destruct L2 as [e [L [I J]]].", "exn": "The reference L2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-", "qsimpl time: 1.", "destruct H1 as [_ [H11 | H12]].", "apply fast_Zred_factor6.", "*"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st client id c out st' ms H.", "pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U.", "pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L.", "destruct U as [U1 | U2].", "-", "qsimpl time: 1.", "destruct H1 as [_ [H11 | H12]].", "apply fast_Zred_factor6.", "*", "qsimpl time: 1."], "tactic": "split; [apply J |].", "exn": "No such goal. Focus next goal with bullet *.", "type": "next_goal", "handled": true}]}, "chat": [], "original": "intros h st client id c out st' ms H. pose proof (update_elections_data_client_request_allEntries h st client id c out st' ms H) as U. pose proof (handleClientRequest_log h (snd st) client id c out st' ms H) as L. destruct U as [U1 | U2]. - split. + apply U1. + destruct L as [_ [L1 | L2]]. * apply L1. * destruct L2 as [e [L [I J]]]. right. split; [apply J |]. exists e. do 6 (try split; auto). - right. destruct U2 as [e [U2_1 U2_rest]]. destruct L as [[_ [L1 | L2]] | [st_leader [e' [log_st' [eIndex_eq [eTerm_eq [eClient_eq [eInput_eq eId_eq]]]]]]]]; auto. + exfalso. rewrite L1 in U2_1. inversion U2_1. + destruct e' as [e'_index e'_term e'_client e'_id e'_input]. rewrite eIndex_eq, eTerm_eq, eClient_eq, eInput_eq, eId_eq in *. assert (e = mkEntry e'_client e'_id e'_index e'_term e'_input) by (do 6 (try split; auto)). subst. eapply f_equal. rewrite <- !app_comm_cons. inversion eId_eq. inversion eTerm_eq. inversion eClient_eq. auto.", "back_times": 0, "succ": false, "time": 250.61924648284912}]