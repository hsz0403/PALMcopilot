[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st t h' pli plt es ci st' t' es' H.", "assert (H1 := handleAppendEntries_log h st t h' pli plt es ci st' (AppendEntriesReply t' es' true) H).", "assert (H2 := handleAppendEntries_term_votedFor h st t h' pli plt es ci st' (AppendEntriesReply t' es' true) h' H)."], "tactic": ["destruct H1 as [H1 | [H1 [H3 [H4 [H5 H6]]]]].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros h st t h' pli plt es ci st' t' es' H. assert (H1 := handleAppendEntries_log h st t h' pli plt es ci st' (AppendEntriesReply t' es' true) H). assert (H2 := handleAppendEntries_term_votedFor h st t h' pli plt es ci st' (AppendEntriesReply t' es' true) h' H). destruct H1 as [H1 | [H1 [H3 [H4 [H5 H6]]]]]. - rewrite H1. repeat split; auto. intros e Hin. right. split. + unfold haveNewEntries. destruct (findAtIndex (log st) (maxIndex es)) eqn:Heq; auto. exfalso. destruct e0; simpl in H6. * apply not_eq_0_l in Heq. injection Heq as Heq. assert (maxIndex es = eIndex e0) by (apply maxIndex_eq). congruence. * simpl in H6. congruence. + reflexivity. - destruct H3 as [e [Hin Heq]]. left. apply in_or_app. right. apply removeAfterIndex_spec with (pli := pli); auto. apply (handleAppendEntries_currentTerm_leaderId h st t h' pli plt es ci st' (AppendEntriesReply t' es' true) H) in H1. rewrite Nat.leb_le in H1. unfold haveNewEntries. destruct (findAtIndex (es ++ removeAfterIndex (log st) pli) (maxIndex es)) eqn:Heq. + unfold findAtIndex in Heq. simpl in Heq. congruence. + simpl in Heq. congruence. ++ unfold haveNewEntries. rewrite null_false_iff in H2. repeat split. * congruence. * auto.", "back_times": 0, "succ": false, "time": 189.45643138885498}]