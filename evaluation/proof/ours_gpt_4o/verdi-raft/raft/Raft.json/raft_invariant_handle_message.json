[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+"], "tactic": "apply H_handle.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params P : network -> Prop xs : list packet p : packet ys : list packet net : network st' : name -> data ps' : list packet d : raft_data l : list (name * msg) H_ae : raft_net_invariant_append_entries P H_aer : raft_net_invariant_append_entries_reply P H_rv : raft_net_invariant_request_vote P H_rvr : raft_net_invariant_request_vote_reply P H_handle : handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) H_P : P net H_reach : raft_intermediate_reachable net H_nwp : nwPackets net = xs ++ p :: ys H_st' : forall h : name, st' h = update name_eq_dec (nwState net) (pDst p) d h H_ps' : forall p' : packet, In p' ps' -> In p' (xs ++ ys) \\\\/ In p' (send_packets (pDst p) l) Unable to unify \"handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l)\" with \"net_handlers (pDst p) (pSrc p) (pBody p) (nwState net (pDst p)) = ([], ?d, ?l)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+"], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params P : network -> Prop xs : list packet p : packet ys : list packet net : network st' : name -> data ps' : list packet d : raft_data l : list (name * msg) H_ae : raft_net_invariant_append_entries P H_aer : raft_net_invariant_append_entries_reply P H_rv : raft_net_invariant_request_vote P H_rvr : raft_net_invariant_request_vote_reply P H_handle : handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) H_P : P net H_reach : raft_intermediate_reachable net H_nwp : nwPackets net = xs ++ p :: ys H_st' : forall h : name, st' h = update name_eq_dec (nwState net) (pDst p) d h H_ps' : forall p' : packet, In p' ps' -> In p' (xs ++ ys) \\\\/ In p' (send_packets (pDst p) l) Unable to unify \"{| nwPackets := send_packets (pDst p) ?l ++ xs ++ ys; nwState := update Net.name_eq_dec (nwState net) (pDst p) ?d |}\" with \"{| nwPackets := ps'; nwState := st' |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+"], "tactic": "apply raft_intermediate_reachable_ind with (P := fun net' => P net' /\\ raft_intermediate_reachable net').", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params P : network -> Prop xs : list packet p : packet ys : list packet net : network st' : name -> data ps' : list packet d : raft_data l : list (name * msg) H_ae : raft_net_invariant_append_entries P H_aer : raft_net_invariant_append_entries_reply P H_rv : raft_net_invariant_request_vote P H_rvr : raft_net_invariant_request_vote_reply P H_handle : handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) H_P : P net H_reach : raft_intermediate_reachable net H_nwp : nwPackets net = xs ++ p :: ys H_st' : forall h : name, st' h = update name_eq_dec (nwState net) (pDst p) d h H_ps' : forall p' : packet, In p' ps' -> In p' (xs ++ ys) \\\\/ In p' (send_packets (pDst p) l) Unable to unify \"P ?M3917 /\\\\ raft_intermediate_reachable ?M3917\" with \"{| nwPackets := ps'; nwState := st' |} = {| nwPackets := send_packets (pDst p) ?l ++ xs ++ ys; nwState := update Net.name_eq_dec (nwState net) (pDst p) ?d |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "shelve.", "-"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "shelve.", "-", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable."], "tactic": "apply H_P.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params H : forall P : network -> Prop, P step_async_init -> (forall (failed : list name) (net : network) (failed' : list name) (net' : network) (out : list (name * (raft_input + list raft_output))), raft_intermediate_reachable net -> P net -> step_failure (failed, net) (failed', net') out -> P net') -> (forall (net : network) (h : name) (inp : raft_input) (out : list raft_output) (d : raft_data) (l : list (name * msg)) (ps' : list packet) (st' : name -> raft_data), raft_intermediate_reachable net -> P net -> handleInput h inp (nwState net h) = (out, d, l) -> (forall h' : name, st' h' = (if name_eq_dec h' h then d else nwState net h')) -> (forall p' : packet, In p' ps' -> In p' (nwPackets net) \\\\/ In p' (map (fun m : name * msg => {| pSrc := h; pDst := fst m; pBody := snd m |}) l)) -> P {| nwPackets := ps'; nwState := st' |}) -> (forall (p : packet) (net : network) (xs ys : list packet) (st' : name -> raft_data) (ps' : list packet) (d : raft_data) (l : list (name * msg)), raft_intermediate_reachable net -> P net -> handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) -> nwPackets net = xs ++ p :: ys -> (forall h : name, st' h = (if name_eq_dec h (pDst p) then d else nwState net h)) -> (forall p' : packet, In p' ps' -> In p' (xs ++ ys) \\\\/ In p' (map (fun m : name * msg => {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)) -> P {| nwPackets := ps'; nwState := st' |}) -> (forall (net : network) (st' : name -> raft_data) (ps' : list packet) (h : name) (os : list raft_output) (d' : raft_data) (ms : list (name * msg)), raft_intermediate_reachable net -> P net -> doLeader (nwState net h) h = (os, d', ms) -> (forall h' : name, st' h' = (if name_eq_dec h' h then d' else nwState net h')) -> (forall p : packet, In p ps' -> In p (nwPackets net) \\\\/ In p (map (fun m : name * msg => {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)) -> P {| nwPackets := ps'; nwState := st' |}) -> (forall (net : network) (st' : name -> raft_data) (ps' : list packet) (os : list raft_output) (d' : raft_data) (ms : list (name * msg)) (h : name), raft_intermediate_reachable net -> P net -> doGenericServer h (nwState net h) = (os, d', ms) -> (forall h' : name, st' h' = (if name_eq_dec h' h then d' else nwState net h')) -> (forall p : packet, In p ps' -> In p (nwPackets net) \\\\/ In p (map (fun m : name * msg => {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)) -> P {| nwPackets := ps'; nwState := st' |}) -> forall n : network, raft_intermediate_reachable n -> P n P : network -> Prop xs : list packet p : packet ys : list packet net : network d : raft_data l : list (name * msg) H_ae : raft_net_invariant_append_entries P H_aer : raft_net_invariant_append_entries_reply P H_rv : raft_net_invariant_request_vote P H_rvr : raft_net_invariant_request_vote_reply P H_handle : handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) H_P : P net H_reach : raft_intermediate_reachable net H_nwp : nwPackets net = xs ++ p :: ys p0 : packet d0 : raft_data H_st' : forall h : name, (if name_eq_dec h (pDst p0) then d0 else nwState net h) = (if name_eq_dec h (pDst p) then d else nwState net h) xs0, ys0 : list packet l0 : list (name * msg) H_ps' : forall p' : packet, In p' (map (fun m : name * msg => {| pSrc := pDst p0; pDst := fst m; pBody := snd m |}) l0 ++ xs0 ++ ys0) -> In p' (xs ++ ys) \\\\/ In p' (map (fun m : name * msg => {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l) H2 : nwPackets net = xs0 ++ p0 :: ys0 H5 : RaftNetHandler (pDst p0) (pSrc p0) (pBody p0) (nwState net (pDst p0)) = ([], d0, l0) H0 : pDst p0 = pDst p Unable to unify \"P net\" with \"P {| nwPackets := map (fun m : name * msg => {| pSrc := pDst p0; pDst := fst m; pBody := snd m |}) l0 ++ xs0 ++ ys0; nwState := fun nm : name => if name_eq_dec nm (pDst p0) then d0 else nwState net nm |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "shelve.", "-", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable."], "tactic": "apply H_reach.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params H1 : forall P : network -> Prop, P step_async_init -> (forall (failed : list name) (net : network) (failed' : list name) (net' : network) (out : list (name * (raft_input + list raft_output))), raft_intermediate_reachable net -> P net -> step_failure (failed, net) (failed', net') out -> P net') -> (forall (net : network) (h : name) (inp : raft_input) (out : list raft_output) (d : raft_data) (l : list (name * msg)) (ps' : list packet) (st' : name -> raft_data), raft_intermediate_reachable net -> P net -> handleInput h inp (nwState net h) = (out, d, l) -> (forall h' : name, st' h' = (if name_eq_dec h' h then d else nwState net h')) -> (forall p' : packet, In p' ps' -> In p' (nwPackets net) \\\\/ In p' (map (fun m : name * msg => {| pSrc := h; pDst := fst m; pBody := snd m |}) l)) -> P {| nwPackets := ps'; nwState := st' |}) -> (forall (p : packet) (net : network) (xs ys : list packet) (st' : name -> raft_data) (ps' : list packet) (d : raft_data) (l : list (name * msg)), raft_intermediate_reachable net -> P net -> handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) -> nwPackets net = xs ++ p :: ys -> (forall h : name, st' h = (if name_eq_dec h (pDst p) then d else nwState net h)) -> (forall p' : packet, In p' ps' -> In p' (xs ++ ys) \\\\/ In p' (map (fun m : name * msg => {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)) -> P {| nwPackets := ps'; nwState := st' |}) -> (forall (net : network) (st' : name -> raft_data) (ps' : list packet) (h : name) (os : list raft_output) (d' : raft_data) (ms : list (name * msg)), raft_intermediate_reachable net -> P net -> doLeader (nwState net h) h = (os, d', ms) -> (forall h' : name, st' h' = (if name_eq_dec h' h then d' else nwState net h')) -> (forall p : packet, In p ps' -> In p (nwPackets net) \\\\/ In p (map (fun m : name * msg => {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)) -> P {| nwPackets := ps'; nwState := st' |}) -> (forall (net : network) (st' : name -> raft_data) (ps' : list packet) (os : list raft_output) (d' : raft_data) (ms : list (name * msg)) (h : name), raft_intermediate_reachable net -> P net -> doGenericServer h (nwState net h) = (os, d', ms) -> (forall h' : name, st' h' = (if name_eq_dec h' h then d' else nwState net h')) -> (forall p : packet, In p ps' -> In p (nwPackets net) \\\\/ In p (map (fun m : name * msg => {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)) -> P {| nwPackets := ps'; nwState := st' |}) -> forall n : network, raft_intermediate_reachable n -> P n P : network -> Prop xs : list packet p : packet ys : list packet net : network d : raft_data l : list (name * msg) H_ae : raft_net_invariant_append_entries P H_aer : raft_net_invariant_append_entries_reply P H_rv : raft_net_invariant_request_vote P H_rvr : raft_net_invariant_request_vote_reply P H_handle : handleMessage (pSrc p) (pDst p) (pBody p) (nwState net (pDst p)) = (d, l) H_P : P net H_reach : raft_intermediate_reachable net H_nwp : nwPackets net = xs ++ p :: ys p0 : packet d0 : raft_data H_st' : forall h : name, (if name_eq_dec h (pDst p0) then d0 else nwState net h) = (if name_eq_dec h (pDst p) then d else nwState net h) xs0, ys0 : list packet l0 : list (name * msg) H_ps' : forall p' : packet, In p' (map (fun m : name * msg => {| pSrc := pDst p0; pDst := fst m; pBody := snd m |}) l0 ++ xs0 ++ ys0) -> In p' (xs ++ ys) \\\\/ In p' (map (fun m : name * msg => {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l) H2 : nwPackets net = xs0 ++ p0 :: ys0 H5 : RaftNetHandler (pDst p0) (pSrc p0) (pBody p0) (nwState net (pDst p0)) = ([], d0, l0) H0 : pDst p0 = pDst p Unable to unify \"raft_intermediate_reachable net\" with \"P {| nwPackets := map (fun m : name * msg => {| pSrc := pDst p0; pDst := fst m; pBody := snd m |}) l0 ++ xs0 ++ ys0; nwState := fun nm : name => if name_eq_dec nm (pDst p0) then d0 else nwState net nm |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "shelve.", "-", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'.", "assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]).", "-", "eapply StepAsync_deliver.", "+", "apply H_nwp.", "+", "qsimpl time: 1.", "shelve.", "+", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "shelve.", "-", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "qsimpl time: 1 use: raft_intermediate_reachable_ind,raft_intermediate_reachable.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros xs p ys net st' ps' d l H_ae H_aer H_rv H_rvr H_handle H_P H_reach H_nwp H_st' H_ps'. assert (H_step: step_async net {| nwPackets := ps'; nwState := st' |} [(pDst p, inr [])]). - eapply StepAsync_deliver. + apply H_nwp. + apply H_handle. + reflexivity. apply raft_intermediate_reachable_ind with (P := fun net' => P net' /\\ raft_intermediate_reachable net'). - split. * apply H_P. * apply H_reach. - intros. destruct H as [H_P' H_reach']. split. * eapply H_ae; eauto. * eapply RIR_step_failure; eauto. - intros. destruct H as [H_P' H_reach']. split. * eapply H_aer; eauto. * eapply RIR_handleMessage; eauto. - intros. destruct H as [H_P' H_reach']. split. * eapply H_rv; eauto. * eapply RIR_handleMessage; eauto. - intros. destruct H as [H_P' H_reach']. split. * eapply H_rvr; eauto. * eapply RIR_handleMessage; eauto. - apply conj; auto. eapply RIR_handleMessage; eauto. rewrite H_handle. reflexivity.", "back_times": 0, "succ": false, "time": 121.26145267486572}]