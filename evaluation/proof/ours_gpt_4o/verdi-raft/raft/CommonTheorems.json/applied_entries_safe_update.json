[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-"], "tactic": "rewrite update_eq with (x := h) (y := n) (v := st) in Hmax.", "exn": "Found no subterm matching \"update ?M1642 ?M1643 h st n\" in Hmax.", "type": "no_subterm", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1."], "tactic": "apply eq_le_incl, Nat.le_refl.", "exn": "The reference eq_le_incl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1."], "tactic": "pose proof applied_entries_update sigma h st H as [Ha1 _].", "exn": "In environment H : forall (A B : Type) (A_eq_dec : forall x y : A, {x = y} + {x = y -> False}) (sigma : A -> B) (x y : A) (v : B), x = y -> update A_eq_dec sigma x v y = v orig_base_params : BaseParams raft_params : RaftParams orig_base_params sigma : name -> RaftState.raft_data term name entry logIndex serverType data clientId output h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output Heq1 : lastApplied st = lastApplied (sigma h) Heq2 : removeAfterIndex (log st) (lastApplied (sigma h)) = removeAfterIndex (log (sigma h)) (lastApplied (sigma h)) n : name Hmax : argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N) = Some n n0 : name Heqo : argmax (fun h : name => lastApplied (sigma h)) (all_fin N) = Some n0 init : data handler : input -> data -> output * data The term \"H\" has type \"forall (A B : Type) (A_eq_dec : forall x y : A, {x = y} + {x = y -> False}) (sigma : A -> B) (x y : A) (v : B), x = y -> update A_eq_dec sigma x v y = v\" while it is expected to have type \"lastApplied st >= lastApplied (sigma h)\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update."], "tactic": "rewrite update_eq with (x := h) (y := n) (v := st) in Ha1.", "exn": "No such hypothesis: Ha1", "type": "no_hypos", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*"], "tactic": "destruct Ha1 as [Happlied _].", "exn": "The reference Ha1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _]."], "tactic": "rewrite Happlied.", "exn": "The reference Happlied was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _]."], "tactic": "rewrite Heq2.", "exn": "Found no subterm matching \"removeAfterIndex (log st) (lastApplied (sigma h))\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "reflexivity.", "exn": "In environment H : forall (A B : Type) (A_eq_dec : forall x y : A, {x = y} + {x = y -> False}) (sigma : A -> B) (x y : A) (v : B), x = y -> update A_eq_dec sigma x v y = v orig_base_params : BaseParams raft_params : RaftParams orig_base_params sigma : name -> RaftState.raft_data term name entry logIndex serverType data clientId output h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output Heq1 : lastApplied st = lastApplied (sigma h) Heq2 : removeAfterIndex (log st) (lastApplied (sigma h)) = removeAfterIndex (log (sigma h)) (lastApplied (sigma h)) n : name Hmax : argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N) = Some n n0 : name Heqo : argmax (fun h : name => lastApplied (sigma h)) (all_fin N) = Some n0 init : data handler : input -> data -> output * data H0 : lastApplied (sigma n) >= lastApplied st Unable to unify \"rev (removeAfterIndex (log (sigma n0)) (lastApplied (sigma n0)))\" with \"rev (removeAfterIndex (log (update name_eq_dec sigma h st n)) (lastApplied (update name_eq_dec sigma h st n)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+"], "tactic": "reflexivity.", "exn": "In environment H : forall (A B : Type) (A_eq_dec : forall x y : A, {x = y} + {x = y -> False}) (sigma : A -> B) (x y : A) (v : B), x = y -> update A_eq_dec sigma x v y = v orig_base_params : BaseParams raft_params : RaftParams orig_base_params sigma : name -> RaftState.raft_data term name entry logIndex serverType data clientId output h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output Heq1 : lastApplied st = lastApplied (sigma h) Heq2 : removeAfterIndex (log st) (lastApplied (sigma h)) = removeAfterIndex (log (sigma h)) (lastApplied (sigma h)) n : name Hmax : argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N) = Some n Heqo : argmax (fun h : name => lastApplied (sigma h)) (all_fin N) = None init : data handler : input -> data -> output * data Unable to unify \"[]\" with \"rev (removeAfterIndex (log (update name_eq_dec sigma h st n)) (lastApplied (update name_eq_dec sigma h st n)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+"], "tactic": "rewrite update_diff with (x := h) (y := n) in Hmax.", "exn": "Found no subterm matching \"update ?M5224 ?M5225 h ?M5227 n\" in Hmax.", "type": "no_subterm", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update."], "tactic": "apply Nat.lt_irrefl in Hmax.", "exn": "Unable to apply lemma of type \"forall x : nat, ~ x < x\" on hypothesis of type \"argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N) = None\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update.", "shelve.", "+"], "tactic": "assert (applied_entries sigma = []) by reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params sigma : name -> RaftState.raft_data term name entry logIndex serverType data clientId output h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output Heq1 : lastApplied st = lastApplied (sigma h) Heq2 : removeAfterIndex (log st) (lastApplied (sigma h)) = removeAfterIndex (log (sigma h)) (lastApplied (sigma h)) Hmax : argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N) = None Hmax' : argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N) = None Unable to unify \"[]\" with \"applied_entries sigma\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: lt_irrefl,applied_entries_update,auto,congruence,eIndex,log,update_diff,update_eq,intro,lastApplied,applied_entries,entry,contradiction,removeAfterIndex.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: lt_irrefl,applied_entries_update,congruence,eIndex,log,update_diff,update_eq,intro,lastApplied,applied_entries,entry,contradiction,removeAfterIndex.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: lt_irrefl,applied_entries_update,eIndex,log,update_diff,update_eq,intro,lastApplied,applied_entries,entry,contradiction,removeAfterIndex.", "exn": "The reference intro was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: lt_irrefl,applied_entries_update,eIndex,log,update_diff,update_eq,lastApplied,applied_entries,entry,contradiction,removeAfterIndex.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros sigma h st Heq1 Heq2.", "unfold applied_entries.", "destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax.", "-", "qsimpl time: 1 use: update_eq.", "+", "assert (lastApplied (sigma n) >= lastApplied st).", "rewrite Heq1.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "qsimpl time: 1 use: update_eq,applied_entries_update.", "*", "destruct handleMessage as [Happlied _].", "qsimpl time: 1 use: update_eq,applied_entries_update.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'.", "+", "qsimpl time: 1 use: update_diff,update_eq,applied_entries_update.", "qsimpl time: 1 use: update_diff,update_eq,lt_irrefl,applied_entries_update.", "shelve.", "+", "qsimpl time: 1 use: lt_irrefl,applied_entries_update,eIndex,log,update_diff,update_eq,lastApplied,applied_entries,entry,removeAfterIndex."], "tactic": "rewrite update_eq in *.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros sigma h st Heq1 Heq2. unfold applied_entries. destruct (argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st h0)) (all_fin N)) eqn:Hmax. - rewrite update_eq with (x := h) (y := n) (v := st) in Hmax. + assert (lastApplied (sigma n) >= lastApplied st). { rewrite Heq1. apply eq_le_incl, Nat.le_refl. } pose proof applied_entries_update sigma h st H as [Ha1 _]. rewrite update_eq with (x := h) (y := n) (v := st) in Ha1. * destruct Ha1 as [Happlied _]. rewrite Happlied. rewrite Heq2. reflexivity. * reflexivity. + reflexivity. - destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin N)) eqn:Hmax'. + rewrite update_diff with (x := h) (y := n) in Hmax. * apply Nat.lt_irrefl in Hmax. contradiction. * intro Hneq. rewrite Hneq in Heq1, Heq2. assert (lastApplied (sigma n) = lastApplied st) by congruence. rewrite Heq2 in *. rewrite update_eq in Heq2. rewrite Heq2 in Heq2. assert (removeAfterIndex (log st) (lastApplied st) = log st) by auto. assert (removeAfterIndex (log st) (lastApplied st) = removeAfterIndex (log st) (lastApplied (sigma n))) by congruence. rewrite update_eq in Heq1. rewrite Heq2. unfold removeAfterIndex. remember (fun e : entry => eIndex e <=? lastApplied st) as f. destruct Hmax'. reflexivity. + assert (applied_entries sigma = []) by reflexivity. rewrite update_eq in *. rewrite Heq1. reflexivity.", "back_times": 0, "succ": false, "time": 205.6172595024109}]