[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''."], "tactic": "apply (prefix_sorted _ (l1 ++ h :: l2)); auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' Hsorted : sorted (h :: t) l1, l2 : list entry Hin : In h (l1 ++ h :: l2) HPerm : Permutation (h :: t) (l1 ++ h :: l2) Hsorted' : sorted (l1 ++ h :: l2) Unable to unify \"sorted (l1 ++ h :: l2)\" with \"sorted (l1 ++ l2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted."], "tactic": "apply Permutation_sym.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry Hin : In h (l1 ++ h :: l2) HPerm : Permutation (h :: t) (l1 ++ h :: l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data Unable to unify \"Permutation ?M3149 ?M3148\" with \"(fix sorted (log : list entry) : Prop := match log with | [] => True | e :: es => (forall e' : entry, In e' es -> eIndex e > eIndex e' /\\\\ eTerm e >= eTerm e') /\\\\ sorted es end) (l1 ++ l2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted."], "tactic": "apply Permutation_cons_append.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H4 : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' H3 : forall (A : Type) (l l' : list A), Permutation l l' -> Permutation l' l h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry Hin : In h (l1 ++ h :: l2) HPerm : Permutation (h :: t) (l1 ++ h :: l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data Unable to unify \"Permutation (?M3817 :: ?M3816) (?M3816 ++ [?M3817])\" with \"(fix sorted (log : list entry) : Prop := match log with | [] => True | e :: es => (forall e' : entry, In e' es -> eIndex e > eIndex e' /\\\\ eTerm e >= eTerm e') /\\\\ sorted es end) (l1 ++ l2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2))."], "tactic": "apply permutation_sorted_eq; auto.", "exn": "The reference permutation_sorted_eq was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-"], "tactic": "destruct (sorted_NoDup _ Hsorted) as [Hnodup].", "exn": "The reference Hsorted was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-"], "tactic": "apply NoDup_cons.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H6 : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' H5 : forall (A : Type) (l l' : list A), Permutation l l' -> Permutation l' l H : forall (A : Type) (l : list A) (x : A), Permutation (x :: l) (l ++ [x]) h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry HPerm : S (length t) = length l1 + S (length l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data Unable to unify \"NoDup (?M4634 :: ?M4635)\" with \"h :: t = h :: l1 ++ l2 \\\\/ h :: t <> h :: l1 ++ l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted."], "tactic": "intro.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted."], "tactic": "apply Hnodup.", "exn": "The reference Hnodup was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted.", "apply Decidable.dec_not_not."], "tactic": "apply Permutation_in with (l := l1 ++ h :: l2); auto.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H8 : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' H7 : forall (A : Type) (l l' : list A), Permutation l l' -> Permutation l' l H4 : forall (A : Type) (x : A) (l : list A), (In x l -> False) -> NoDup l -> NoDup (x :: l) H3 : forall (A : Type) (l : list A) (x : A), Permutation (x :: l) (l ++ [x]) h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry HPerm : S (length t) = length l1 + S (length l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data Unable to unify \"(fix In (a : entry) (l : list entry) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) ?M5465 ?M5464\" with \"Decidable.decidable (h :: t = h :: l1 ++ l2) \\\\/ ~ Decidable.decidable (h :: t = h :: l1 ++ l2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted.", "apply Decidable.dec_not_not.", "qsimpl time: 1 use: Permutation_in,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "right."], "tactic": "apply in_or_app.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H10 : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' H9 : forall (A : Type) (l : list A) (x : A), Permutation (x :: l) (l ++ [x]) H6 : forall (A : Type) (x : A) (l : list A), (In x l -> False) -> NoDup l -> NoDup (x :: l) H5 : forall (A : Type) (l l' : list A), Permutation l l' -> Permutation l' l H : forall (A : Type) (l l' : list A) (x : A), Permutation l l' -> In x l -> In x l' h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry HPerm : S (length t) = length l1 + S (length l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data Unable to unify \"(fix In (a : ?M6721) (l : list ?M6721) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) ?M6724 (?M6722 ++ ?M6723)\" with \"Decidable.decidable (h :: t = h :: l1 ++ l2) -> False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted.", "apply Decidable.dec_not_not.", "qsimpl time: 1 use: Permutation_in,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "right.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted.", "apply Decidable.dec_not_not.", "qsimpl time: 1 use: Permutation_in,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "right.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted."], "tactic": "apply sorted_uniqueIndices.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H15 : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' H14 : forall (A : Type) (l : list A) (x : A), Permutation (x :: l) (l ++ [x]) H10 : forall (A : Type) (x : A) (l : list A), (In x l -> False) -> NoDup l -> NoDup (x :: l) H9 : forall (A : Type) (l l' : list A), Permutation l l' -> Permutation l' l H5 : forall (A : Type) (l l' : list A) (x : A), Permutation l l' -> In x l -> In x l' h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry HPerm : S (length t) = length l1 + S (length l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data H13 : Decidable.decidable (h :: t = h :: l1 ++ l2) H : forall (A : Type) (l m : list A) (a : A), In a m -> In a (l ++ m) H4 : forall (A : Type) (l m : list A) (a : A), In a l -> In a (l ++ m) Unable to unify \"NoDup (map eIndex ?M8465)\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted.", "apply Decidable.dec_not_not.", "qsimpl time: 1 use: Permutation_in,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "right.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,sorted_uniqueIndices,NoDup_cons,Permutation_cons_append,prefix_sorted."], "tactic": "apply sorted_NoDup.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H16 : forall l l' : list entry, sorted l -> Prefix l' l -> sorted l' H12 : forall (A : Type) (l : list A) (x : A), Permutation (x :: l) (l ++ [x]) H11 : forall (A : Type) (x : A) (l : list A), (In x l -> False) -> NoDup l -> NoDup (x :: l) H8 : forall l : list entry, sorted l -> uniqueIndices l H7 : forall (A : Type) (l l' : list A), Permutation l l' -> Permutation l' l H3 : forall (A : Type) (l l' : list A) (x : A), Permutation l l' -> In x l -> In x l' h : entry t : list entry IHt : forall l' : list entry, sorted t -> sorted l' -> Permutation t l' -> t = l' l1, l2 : list entry HPerm : S (length t) = length l1 + S (length l2) Hsorted' : sorted (l1 ++ h :: l2) H1 : sorted t H0 : forall e' : entry, In e' t -> eTerm h >= eTerm e' H2 : forall e' : entry, In e' t -> eIndex h > eIndex e' init : data handler : input -> data -> output * data H13 : Decidable.decidable (h :: t = h :: l1 ++ l2) H : forall (A : Type) (l m : list A) (a : A), In a m -> In a (l ++ m) H4 : forall (A : Type) (l m : list A) (a : A), In a l -> In a (l ++ m) Unable to unify \"NoDup ?M9369\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction l as [| h t IHt].", "--", "intros l' _ Hsorted HPerm.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm].", "--", "intros l' Hsorted Hsorted' HPerm.", "assert (In h l') as Hin.", "apply Permutation_in with (l := h :: t); auto.", "simpl.", "left.", "auto.", "destruct (in_split _ _ Hin) as [l1 [l2 ->]].", "assert (sorted (l1 ++ l2)) as Hsorted''.", "qsimpl time: 1 use: prefix_sorted.", "qsimpl time: 1 use: Permutation_sym,prefix_sorted.", "qsimpl time: 1 use: Permutation_cons_append,Permutation_sym,prefix_sorted.", "apply Permutation_length in HPerm.", "simpl in HPerm.", "rewrite app_length in HPerm.", "simpl in HPerm.", "clear Hin.", "assert (h :: t = h :: (l1 ++ l2)).", "apply Decidable.dec_not_not; auto.", "-", "qsimpl time: 1 use: Permutation_cons_append,NoDup_cons,Permutation_sym,prefix_sorted.", "apply Decidable.dec_not_not.", "qsimpl time: 1 use: Permutation_in,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "right.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,NoDup_cons,Permutation_cons_append,prefix_sorted.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,sorted_uniqueIndices,NoDup_cons,Permutation_cons_append,prefix_sorted.", "qsimpl time: 1 use: Permutation_in,in_or_app,Permutation_sym,sorted_NoDup,sorted_uniqueIndices,NoDup_cons,Permutation_cons_append,prefix_sorted."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "induction l as [| h t IHt]. -- intros l' _ Hsorted HPerm. apply Permutation_length in HPerm. simpl in HPerm. destruct l'; simpl in HPerm; [reflexivity | discriminate HPerm]. -- intros l' Hsorted Hsorted' HPerm. assert (In h l') as Hin. { apply Permutation_in with (l := h :: t); auto. simpl. left. auto. } destruct (in_split _ _ Hin) as [l1 [l2 ->]]. assert (sorted (l1 ++ l2)) as Hsorted''. { apply (prefix_sorted _ (l1 ++ h :: l2)); auto. apply Permutation_sym. apply Permutation_cons_append. } simpl in HPerm. apply Permutation_length in HPerm. simpl in HPerm. rewrite app_length in HPerm. simpl in HPerm. clear Hin. assert (h :: t = h :: (l1 ++ l2)). { apply permutation_sorted_eq; auto. - simpl. destruct (sorted_NoDup _ Hsorted) as [Hnodup]. apply NoDup_cons. intro. apply Hnodup. apply Permutation_in with (l := l1 ++ h :: l2); auto. simpl. right. apply in_or_app. left. auto. apply sorted_uniqueIndices. auto. apply sorted_NoDup. auto. - apply Permutation_trans with (l1 ++ h :: l2). apply Permutation_middle. apply Permutation_sym. auto. } injection Hperm as Heq1. rewrite IHt with (l' := l1 ++ l2); auto. + apply Permutation_cons_inv with (a := h). rewrite <- Heq1. apply Permutation_refl. + apply HPerm.", "back_times": 0, "succ": false, "time": 549.258542060852}]