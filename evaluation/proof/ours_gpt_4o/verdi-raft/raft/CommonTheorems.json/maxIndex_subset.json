[{"history": {"proof": "intros xs ys Hsorted_xs Hsorted_ys Hsubseq. induction xs as [|x xs' IHxs]. -- simpl. sfirstorder depth: 3. -- destruct ys as [|y ys']. ++ simpl. hauto lq: on depth: 3. ++ hfcrush depth: 3.", "repairs": ["", "", "", "", "hammer", "", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros xs ys Hsorted_xs Hsorted_ys Hsubseq.", "induction xs as [|x xs' IHxs].", "--", "simpl."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros xs ys Hsorted_xs Hsorted_ys Hsubseq.", "induction xs as [|x xs' IHxs].", "--", "simpl.", "shelve.", "--", "destruct ys as [|y ys'].", "++", "simpl."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros xs ys Hsorted_xs Hsorted_ys Hsubseq. induction xs as [|x xs' IHxs]. -- simpl. auto. -- destruct ys as [|y ys']. ++ simpl. auto. ++ assert (Hin: In x (y :: ys')) by (apply subseq_In with (A := entry) (xs := x :: xs') (ys := y :: ys'); auto; left; auto). simpl. assert (Hmax: maxIndex xs' <= maxIndex ys') by (apply IHxs; [destruct (sorted_cons xs' x Hsorted_xs) as [_ Hsorted_xs']; auto | intros; apply Hsubseq; auto; right; auto]). generalize Hsorted_ys; intro Hsorted_ys'. destruct Hsorted_xs as [[Hindex _] Hsorted_xs'], Hsorted_ys' as [[Hindex' _] Hsorted_ys'']. destruct Hin. + subst. specialize (Hindex' x H). lia. + apply maxIndex_is_max in H; [| auto]. lia.", "back_times": 3, "succ": true, "time": 9.412782430648804}]