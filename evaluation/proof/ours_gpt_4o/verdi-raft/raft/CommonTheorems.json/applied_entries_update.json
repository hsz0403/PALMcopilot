[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros sigma h st H."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros sigma h st H. split. - unfold applied_entries. unfold update. destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin (N orig_base_params raft_params))) eqn:Ha. + simpl. rewrite Ha. reflexivity. + simpl. rewrite Ha. reflexivity. - left. exists h. split. + unfold argmax. fold (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin (N orig_base_params raft_params))). destruct (argmax (fun h0 : name => lastApplied (sigma h0)) (all_fin (N orig_base_params raft_params))) eqn:Hmax. * destruct (lastApplied (sigma n0) <=? lastApplied st) eqn:Hcomp. -- apply Nat.leb_le in Hcomp. rewrite Ha. simpl. rewrite Hcomp. rewrite Hcomp in H. exfalso. apply (H (Nat.le_refl _)). -- rewrite Ha. simpl. rewrite Hcomp. reflexivity. * simpl. rewrite Ha. reflexivity. + simpl. apply Nat.le_refl.", "back_times": 0, "succ": false, "time": 151.1569607257843}]