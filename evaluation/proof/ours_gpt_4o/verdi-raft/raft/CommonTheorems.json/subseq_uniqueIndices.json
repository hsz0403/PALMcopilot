[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros ys xs Hsubseq Hunique.", "apply subseq_NoDup with (A := entry) in Hsubseq."], "tactic": "apply NoDup_map_elim with (f := fun e => eIndex e) in Hunique.", "exn": "Unable to find an instance for the variables x, y.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros ys xs Hsubseq Hunique.", "apply subseq_NoDup with (A := entry) in Hsubseq.", "qsimpl time: 1 use: NoDup_map_elim,eIndex."], "tactic": "apply subseq_map with (f := fun e => eIndex e).", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params X : entry -> logIndex H : forall (A B : Type) (f : A -> B) (xs : list A) (x y : A), f x = f y -> NoDup (map f xs) -> In x xs -> In y xs -> x = y ys, xs : list entry Hsubseq : NoDup xs Hunique : uniqueIndices ys init : data handler : input -> data -> output * data Unable to unify \"(fix subseq (A : Type) (xs ys : list A) {struct ys} : Prop := match xs with | [] => True | x :: xs' => match ys with | [] => False | y :: ys' => x = y /\\\\ subseq A xs' ys' \\\\/ subseq A xs ys' end end) logIndex (map (fun e : entry => eIndex e) ?M2497) (map (fun e : entry => eIndex e) ?M2496)\" with \"NoDup (map eIndex xs)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros ys xs Hsubseq Hunique. apply subseq_NoDup with (A := entry) in Hsubseq. apply NoDup_map_elim with (f := fun e => eIndex e) in Hunique. auto. apply subseq_map with (f := fun e => eIndex e). auto.", "back_times": 0, "succ": false, "time": 139.84451270103455}]