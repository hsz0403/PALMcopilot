[{"history": {"proof": "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func. qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "repairs": ["cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs."], "tactic": "apply IR_equivalent_acknowledge_all_ops_func with (l := l).", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x <> y} l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> ~ In (O k) l NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"IR_equivalent (acknowledge_all_ops_func l ?M1775) ?M1775\" with \"good_trace ir /\\\\ (exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply Hgood.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"good_trace ir\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply HInO.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H0 : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"(fix In (a : IR) (l : list IR) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) (IRO ?M5293) ir\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply HInIRO.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"(fix In (a : op) (l : list op) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) (O ?M6487) l\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply HInIRU.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H0 : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"(fix In (a : op) (l : list op) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) (I ?M7681) l\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply HnotIn.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"False\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply HbeforeIROIRI.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H0 : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"(fix before (A : Type) (x y : A) (l : list A) {struct l} : Prop := match l with | [] => False | a :: l' => a = x \\\\/ a <> y /\\\\ before A x y l' end) IR (IRO ?M10069) (IRI ?M10070) ir\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply HbIIO.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"(fix before (A : Type) (x y : A) (l : list A) {struct l} : Prop := match l with | [] => False | a :: l' => a = x \\\\/ a <> y /\\\\ before A x y l' end) op (I ?M11263) (O ?M11263) l\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply NoDupInputOps.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H0 : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"NoDup (get_op_input_keys l)\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply NoDupInputIRs.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"NoDup (get_IR_input_keys ir)\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply NoDupOutputOps.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H0 : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"NoDup (get_op_output_keys l)\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func.", "qsimpl time: 1 use: IR_equivalent_acknowledge_all_ops_func."], "tactic": "apply NoDupOutputIRs.", "exn": "In environment K : Type K_eq_dec : forall x y : K, {x = y} + {x = y -> False} H : forall ir : list IR, good_trace ir -> forall l : list op, (forall k : K, In (O k) l -> In (IRO k) ir) -> (forall k : K, In (IRO k) ir -> In (O k) l) -> (forall k : K, In (IRU k) ir -> In (I k) l) -> (forall k : K, In (IRU k) ir -> In (O k) l -> False) -> (forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir) -> (forall k : K, In (O k) l -> before (I k) (O k) l) -> (forall k : K, In (IRI k) ir -> In (I k) l) -> NoDup (get_op_input_keys l) -> NoDup (get_IR_input_keys ir) -> NoDup (get_op_output_keys l) -> NoDup (get_IR_output_keys ir) -> IR_equivalent (acknowledge_all_ops_func l ir) ir l : list op ir : list IR Hgood : good_trace ir HInO : forall k : K, In (O k) l -> In (IRO k) ir HInIRO : forall k : K, In (IRO k) ir -> In (O k) l HInIRU : forall k : K, In (IRU k) ir -> In (I k) l HbeforeIROIRI : forall k k' : K, In (I k') l -> before (O k) (I k') l -> before (IRO k) (IRI k') ir HbIIO : forall k : K, In (O k) l -> before (I k) (O k) l HnotIn : forall k : K, In (IRU k) ir -> In (O k) l -> False NoDupInputOps : NoDup (get_op_input_keys l) NoDupInputIRs : NoDup (get_IR_input_keys ir) NoDupOutputOps : NoDup (get_op_output_keys l) NoDupOutputIRs : NoDup (get_IR_output_keys ir) Unable to unify \"NoDup (get_IR_output_keys ir)\" with \"exists ir' : list IR, acknowledge_all_ops l ir' /\\\\ IR_equivalent ir' ir\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l ir Hgood HInO HInIRO HInIRU HbeforeIROIRI HbIIO HnotIn NoDupInputOps NoDupInputIRs NoDupOutputOps NoDupOutputIRs. apply IR_equivalent_acknowledge_all_ops_func with (l := l). - apply Hgood. - apply HInO. - apply HInIRO. - apply HInIRU. - apply HnotIn. - apply HbeforeIROIRI. - apply HbIIO. - apply NoDupInputOps. - apply NoDupInputIRs. - apply NoDupOutputOps. - apply NoDupOutputIRs.", "back_times": 0, "succ": false, "time": 72.06574368476868}]