[{"history": {"proof": "apply Build_BranchJoinKripkeIntuitionisticModel. intros m1 m2 n le_n_m1 le_n_m2. qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel. qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel. destruct BinNatDef.N.succ_double as [le_m1_m2 | le_m2_m1]. - qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel. - hfcrush inv: NoBranchKripkeIntuitionisticModel. - hfcrush.", "repairs": ["", "", "wrong_type", "wrong_type", "ref_not_found", "", "not_inductive_goal", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2."], "tactic": "pose proof (Build_NoBranchKripkeIntuitionisticModel _ _ nkiM) as H.", "exn": "In environment A : Type R : Relation A po_R : PreOrder Krelation nkiM : NoBranchKripkeIntuitionisticModel A m1, m2, n : A le_n_m1 : n <= m1 le_n_m2 : n <= m2 The term \"nkiM\" has type \"NoBranchKripkeIntuitionisticModel A\" while it is expected to have type \"forall m3 m4 n0 : ?worlds, n0 <= m3 -> n0 <= m4 -> m3 <= m4 \\\\/ m4 <= m3\".", "type": "wrong_type", "handled": true}, {"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel."], "tactic": "specialize (H m1 m2 n le_n_m1 le_n_m2).", "exn": "In environment H : forall (worlds : Type) (R : Relation worlds), (forall m1 m2 n : worlds, n <= m1 -> n <= m2 -> m1 <= m2 \\\\/ m2 <= m1) -> NoBranchKripkeIntuitionisticModel worlds A : Type R : Relation A m1, m2, n : A le_n_m1 : n <= m1 le_n_m2 : n <= m2 Korder_no_branch0 : forall m1 m2 n : A, n <= m1 -> n <= m2 -> m1 <= m2 \\\\/ m2 <= m1 PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation The term \"m1\" has type \"A\" while it is expected to have type \"Type\".", "type": "wrong_type", "handled": true}, {"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel."], "tactic": "destruct H as [le_m1_m2 | le_m2_m1].", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "destruct BinNatDef.N.succ_double as [le_m1_m2 | le_m2_m1].", "-"], "tactic": "exists m2.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "destruct BinNatDef.N.succ_double as [le_m1_m2 | le_m2_m1].", "-", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel."], "tactic": "split.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "destruct BinNatDef.N.succ_double as [le_m1_m2 | le_m2_m1].", "-", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "-", "exists m1.", "split.", "+", "apply PreOrder_Reflexive."], "tactic": "apply po_R.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["apply Build_BranchJoinKripkeIntuitionisticModel.", "intros m1 m2 n le_n_m1 le_n_m2.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "destruct BinNatDef.N.succ_double as [le_m1_m2 | le_m2_m1].", "-", "qsimpl time: 1 use: Build_NoBranchKripkeIntuitionisticModel.", "-", "exists m1.", "split.", "+", "apply PreOrder_Reflexive.", "+"], "tactic": "apply le_m2_m1.", "exn": "The reference le_m2_m1 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "apply Build_BranchJoinKripkeIntuitionisticModel. intros m1 m2 n le_n_m1 le_n_m2. pose proof (Build_NoBranchKripkeIntuitionisticModel _ _ nkiM) as H. specialize (H m1 m2 n le_n_m1 le_n_m2). destruct H as [le_m1_m2 | le_m2_m1]. - exists m2. split. + apply le_m1_m2. + apply PreOrder_Reflexive. apply po_R. - exists m1. split. + apply PreOrder_Reflexive. apply po_R. + apply le_m2_m1.", "back_times": 2, "succ": true, "time": 126.51324248313904}]