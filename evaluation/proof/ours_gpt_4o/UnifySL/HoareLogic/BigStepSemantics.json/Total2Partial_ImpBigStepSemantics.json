[{"history": {"proof": "qsimpl time: 1.", "repairs": ["not_evaluable"], "exceptions": [{"ctx": [], "tactic": "unfold Partial.ImpBigStepSemantics.", "exn": "Cannot coerce Partial.ImpBigStepSemantics to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["qsimpl time: 1."], "tactic": "unfold Total.ImpBigStepSemantics in iBSS.", "exn": "Cannot coerce Total.ImpBigStepSemantics to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["qsimpl time: 1."], "tactic": "destruct iBSS as [eval_bool_total access_total | access_seq access_if access_while].", "exn": "The reference iBSS was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-"], "tactic": "exists (fun s b => ~eval_bool_total s b).", "exn": "The reference eval_bool_total was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-"], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "destruct (access_total s0 c) as [ms access_ms].", "exn": "The reference access_total was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "exists (Terminating s0), Error.", "exn": "The reference s0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [assumption | left; reflexivity].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [| split].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "intros b c1 c2 s ms access_s.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "destruct (access_s c1 c2 s ms access_s) as [ms' [ms'' [access_c1 [forward_c1 lift_c2]]]].", "exn": "The reference access_s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "exists ms', ms''.", "exn": "The reference ms' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [assumption |].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [apply Partial.forward'_ind; eassumption | assumption].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "intros b c1 c2 s ms access_s.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "destruct (access_s b c1 c2 s ms access_s) as [eval_b [ms' [forward_b lift_c]] | eval_n [ms' [forward_n lift_c]]].", "exn": "The reference access_s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [assumption |].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "exists ms'.", "exn": "The reference ms' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [apply Partial.forward'_ind; eassumption | assumption].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [assumption |].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "exists ms'.", "exn": "The reference ms' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "split; [apply Partial.forward'_ind; eassumption | assumption].", "exn": "Unable to find an instance for the variable eval_bool.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 1.", "destruct BinNatDef.N.pred as [eval_bool_total access_total | access_seq access_if access_while].", "-", "qsimpl time: 1.", "-"], "tactic": "intros b c s ms access_s.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "unfold Partial.ImpBigStepSemantics. unfold Total.ImpBigStepSemantics in iBSS. destruct iBSS as [eval_bool_total access_total | access_seq access_if access_while]. - exists (fun s b => ~eval_bool_total s b). split. + intros. destruct (access_total s0 c) as [ms access_ms]. right. exists (Terminating s0), Error. split; [assumption | left; reflexivity]. + split; [| split]. * intros b c1 c2 s ms access_s. destruct (access_s c1 c2 s ms access_s) as [ms' [ms'' [access_c1 [forward_c1 lift_c2]]]]. exists ms', ms''. split; [assumption |]. split; [apply Partial.forward'_ind; eassumption | assumption]. * intros b c1 c2 s ms access_s. destruct (access_s b c1 c2 s ms access_s) as [eval_b [ms' [forward_b lift_c]] | eval_n [ms' [forward_n lift_c]]]. ++ left. split; [assumption |]. exists ms'. split; [apply Partial.forward'_ind; eassumption | assumption]. ++ right. split; [assumption |]. exists ms'. split; [apply Partial.forward'_ind; eassumption | assumption]. * intros b c s ms access_s.", "back_times": 0, "succ": false, "time": 97.22848701477051}]