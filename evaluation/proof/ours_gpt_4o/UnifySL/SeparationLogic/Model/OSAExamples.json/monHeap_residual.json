[{"history": {"proof": "qsimpl time: 1 use: prod_residualSA. qsimpl time: 1 use: prod_residualSA,IndexAlg_residual. qsimpl time: 1 use: prod_residualSA,discHeap_residual,IndexAlg_residual.", "repairs": ["cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": [], "tactic": "apply prod_residualSA.", "exn": "In environment addr : Type val : Type Unable to unify \"ResidualSeparationAlgebra (?M2119 * ?M2120)\" with \"ResidualSeparationAlgebra Heap\".", "type": "cannot_unify", "handled": true}, {"ctx": ["qsimpl time: 1 use: prod_residualSA."], "tactic": "apply IndexAlg_residual.", "exn": "In environment H : forall (A B : Type) (R_A : Relation A) (R_B : Relation B) (Join_A : Join A) (Join_B : Join B), ResidualSeparationAlgebra A -> ResidualSeparationAlgebra B -> ResidualSeparationAlgebra (A * B) addr : Type val : Type Unable to unify \"ResidualSeparationAlgebra nat\" with \"ResidualSeparationAlgebra Heap\".", "type": "cannot_unify", "handled": true}, {"ctx": ["qsimpl time: 1 use: prod_residualSA.", "qsimpl time: 1 use: prod_residualSA,IndexAlg_residual."], "tactic": "apply discHeap_residual.", "exn": "In environment H0 : forall (A B : Type) (R_A : Relation A) (R_B : Relation B) (Join_A : Join A) (Join_B : Join B), ResidualSeparationAlgebra A -> ResidualSeparationAlgebra B -> ResidualSeparationAlgebra (A * B) addr : Type val : Type residue_exists : forall n : nat, exists m : nat, residue n m Unable to unify \"@ResidualSeparationAlgebra Heap discHeap_R Heap_Join\" with \"@ResidualSeparationAlgebra Heap monHeap_R Heap_Join\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "apply prod_residualSA. - apply IndexAlg_residual. - apply discHeap_residual.", "back_times": 0, "succ": false, "time": 36.85644030570984}]