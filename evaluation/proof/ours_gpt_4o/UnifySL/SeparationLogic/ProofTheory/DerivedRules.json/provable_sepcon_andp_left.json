[{"history": {"proof": "qsimpl time: 1 use: provable_iffp_equiv. qsimpl time: 1 use: provable_iffp_equiv. qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2. qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2. qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2. qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2. qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp. qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "repairs": ["cannot_unify", "not_inductive_product", "cannot_unify", "cannot_unify", "cannot_unify", "not_inductive_product", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros x y z."], "tactic": "apply provable_iffp_equiv.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L Gamma : Provable L minAX : MinimumAxiomatization L Gamma ipAX : IntuitionisticPropositionalLogic L Gamma sepconAX : SepconAxiomatization L Gamma x, y, z : expr Unable to unify \"RelationClasses.Equivalence (fun x0 y0 : expr => |-- x0 <--> y0)\" with \"(let (provable) := Gamma in provable) (x && y * z --> x * z && (y * z))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv."], "tactic": "apply sepcon_assoc2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"(let (provable) := ?Gamma in provable) (?M5666 * ?M5667 * ?M5668 --> ?M5666 * (?M5667 * ?M5668))\" with \"(let (provable) := Gamma in provable) (x && y * z --> x * z && (y * z))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2."], "tactic": "apply sepcon_assoc1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H0 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"(let (provable) := Gamma in provable) (?M9741 * (?M9742 * ?M9743) --> ?M9741 * ?M9742 * ?M9743)\" with \"(let (provable) := Gamma in provable) (x && y * z --> x * z && (y * z))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2."], "tactic": "apply provable_iffp_equiv.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H3 : forall x y z : expr, |-- x * y * z --> x * (y * z) H2 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"RelationClasses.Equivalence (fun x0 y0 : expr => |-- x0 <--> y0)\" with \"(let (provable) := Gamma in provable) (x && y * z --> x * z && (y * z))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2."], "tactic": "apply sepcon_proper_iffp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H3 : forall x y z : expr, |-- x * y * z --> x * (y * z) H2 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"forall x0 y0 : expr, (fun x1 y1 : expr => |-- x1 <--> y1) x0 y0 -> Morphisms.respectful (fun x1 y1 : expr => |-- x1 <--> y1) (fun x1 y1 : expr => |-- x1 <--> y1) (sepcon x0) (sepcon y0)\" with \"(let (provable) := Gamma in provable) (x && y * z --> x * z && (y * z))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp."], "tactic": "apply andp_assoc.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H4 : forall x y z : expr, |-- x * y * z --> x * (y * z) H0 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"(let (provable) := ?Gamma in provable) (?M30457 && ?M30458 && ?M30459 <--> ?M30457 && (?M30458 && ?M30459))\" with \"(let (provable) := Gamma in provable) (x && y * z --> x * z && (y * z))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp."], "tactic": "apply (@Build_Adjointness L minL Gamma sepcon sepcon).", "exn": "The reference Build_Adjointness was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon)."], "tactic": "apply wand_sepcon_adjoint.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H7 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H6 : forall x y z : expr, |-- x * y * z --> x * (y * z) H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H2 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"(|-- ?M40379 * ?M40380 --> ?M40381 -> |-- ?M40379 --> ?M40380 -* ?M40381) /\\\\ (|-- ?M40379 --> ?M40380 -* ?M40381 -> |-- ?M40379 * ?M40380 --> ?M40381)\" with \"ProofTheoryPatterns.Adjointness L Gamma sepcon sepcon\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++"], "tactic": "apply sepcon_assoc1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H10 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H9 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H8 : forall x y z : expr, |-- x * y * z --> x * (y * z) H4 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"(let (provable) := Gamma in provable) (?M56180 * (?M56181 * ?M56182) --> ?M56180 * ?M56181 * ?M56182)\" with \"ProofTheoryPatterns.Adjointness L Gamma sepcon sepcon\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--"], "tactic": "apply sepcon_assoc1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> z) /\\\\ (|-- x --> z -> |-- x * y --> z) H12 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H11 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H7 : forall x y z : expr, |-- x * y * z --> x * (y * z) H6 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H2 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"(let (provable) := Gamma in provable) (?M73346 * (?M73347 * ?M73348) --> ?M73346 * ?M73347 * ?M73348)\" with \"ProofTheoryPatterns.Adjointness L Gamma sepcon sepcon\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp."], "tactic": "apply sepcon_assoc2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> z) /\\\\ (|-- x --> z -> |-- x * y --> z) H13 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H10 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H9 : forall x y z : expr, |-- x * y * z --> x * (y * z) H8 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H4 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"(let (provable) := ?Gamma in provable) (?M90998 * ?M90999 * ?M91000 --> ?M90998 * (?M90999 * ?M91000))\" with \"ProofTheoryPatterns.Adjointness L Gamma sepcon sepcon\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp."], "tactic": "apply provable_iffp_equiv.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> z) /\\\\ (|-- x --> z -> |-- x * y --> z) H12 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H11 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H7 : forall x y z : expr, |-- x * y * z --> x * (y * z) H6 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H2 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"RelationClasses.Equivalence (fun x0 y0 : expr => |-- x0 <--> y0)\" with \"ProofTheoryPatterns.Adjointness L Gamma sepcon sepcon\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting --.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "--"], "tactic": "apply sepcon_proper_iffp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H10 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H9 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H8 : forall x y z : expr, |-- x * y * z --> x * (y * z) H4 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"forall x0 y0 : expr, (fun x1 y1 : expr => |-- x1 <--> y1) x0 y0 -> Morphisms.respectful (fun x1 y1 : expr => |-- x1 <--> y1) (fun x1 y1 : expr => |-- x1 <--> y1) (sepcon x0) (sepcon y0)\" with \"WandAxiomatization L Gamma\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "--"], "tactic": "apply andp_assoc.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H10 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H9 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H8 : forall x y z : expr, |-- x * y * z --> x * (y * z) H4 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"(let (provable) := ?Gamma in provable) (?M126308 && ?M126309 && ?M126310 <--> ?M126308 && (?M126309 && ?M126310))\" with \"WandAxiomatization L Gamma\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "--"], "tactic": "apply (@Build_Adjointness L minL Gamma sepcon sepcon).", "exn": "The reference Build_Adjointness was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "--"], "tactic": "apply wand_sepcon_adjoint.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H10 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H9 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H8 : forall x y z : expr, |-- x * y * z --> x * (y * z) H4 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H0 : forall x y z : expr, (|-- x * y --> z -> |-- x --> y -* z) /\\\\ (|-- x --> y -* z -> |-- x * y --> z) Unable to unify \"(|-- ?M126308 * ?M126309 --> ?M126310 -> |-- ?M126308 --> ?M126309 -* ?M126310) /\\\\ (|-- ?M126308 --> ?M126309 -* ?M126310 -> |-- ?M126308 * ?M126309 --> ?M126310)\" with \"WandAxiomatization L Gamma\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "--"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros x y z.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2.", "qsimpl time: 1 use: provable_iffp_equiv,sepcon_assoc2,sepcon_proper_iffp.", "qsimpl time: 1 use: provable_iffp_equiv,andp_assoc,sepcon_assoc2,sepcon_proper_iffp.", "apply (@ProofTheoryPatterns.adjoint L minL Gamma sepcon sepcon).", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "++", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "--", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "qsimpl time: 1 use: wand_sepcon_adjoint,andp_assoc,sepcon_assoc2,provable_iffp_equiv,sepcon_proper_iffp.", "split.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "--", "shelve.", "++"], "tactic": "apply sepcon_assoc2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L sepconL : SepconLanguage L x, y, z : expr sepcon_comm_impp : forall x y : expr, |-- x * y --> y * x sepcon_assoc1 : forall x y z : expr, |-- x * (y * z) --> x * y * z sepcon_mono : forall x1 x2 y1 y2 : expr, |-- x1 --> x2 -> |-- y1 --> y2 -> |-- x1 * y1 --> x2 * y2 andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z Equivalence_Reflexive : RelationClasses.Reflexive (fun x y : expr => |-- x <--> y) Equivalence_Symmetric : RelationClasses.Symmetric (fun x y : expr => |-- x <--> y) Equivalence_Transitive : RelationClasses.Transitive (fun x y : expr => |-- x <--> y) H : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) H1 : forall x y z : expr, |-- x * y * z --> x * (y * z) H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H7 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun x y : expr => |-- x <--> y))) sepcon H6 : forall x y z : expr, |-- x * y * z --> x * (y * z) H3 : forall x y z : expr, |-- x && y && z <--> x && (y && z) H2 : RelationClasses.Equivalence (fun x y : expr => |-- x <--> y) Unable to unify \"(let (provable) := ?Gamma in provable) (?M126308 * ?M126309 * ?M126310 --> ?M126308 * (?M126309 * ?M126310))\" with \"WandAxiomatization L Gamma\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros x y z. apply provable_iffp_equiv. split. -- apply sepcon_assoc2. apply sepcon_assoc1. apply provable_iffp_equiv. split. ++ apply sepcon_proper_iffp. * apply andp_assoc. * apply (@Build_Adjointness L minL Gamma sepcon sepcon). intros. apply wand_sepcon_adjoint. ++ apply sepcon_assoc1. -- apply sepcon_assoc1. apply sepcon_assoc2. apply provable_iffp_equiv. split. ++ apply sepcon_proper_iffp. * apply andp_assoc. * apply (@Build_Adjointness L minL Gamma sepcon sepcon). intros. apply wand_sepcon_adjoint. ++ apply sepcon_assoc2.", "back_times": 0, "succ": false, "time": 193.28355288505554}]