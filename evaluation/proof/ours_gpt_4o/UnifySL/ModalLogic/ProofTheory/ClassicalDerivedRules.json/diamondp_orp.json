[{"history": {"proof": "qsimpl time: 1 use: provable_proper_iffp. qsimpl time: 1 use: provable_proper_iffp.", "repairs": ["cannot_unify", "not_inductive_product"], "exceptions": [{"ctx": ["intros x y."], "tactic": "apply provable_proper_iffp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L Gamma : Provable L minAX : MinimumAxiomatization L Gamma ipAX : IntuitionisticPropositionalLogic L Gamma cpAX : ClassicalPropositionalLogic L Gamma KmAX : SystemK L Gamma x, y : expr Unable to unify \"forall x0 y0 : expr, (fun x1 y1 : expr => |-- x1 <--> y1) x0 y0 -> |-- x0 <-> |-- y0\" with \"(let (provable) := Gamma in provable) (\u25c7 (x || y) <--> \u25c7 x || \u25c7 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp."], "tactic": "apply deduction_orp_elim'.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H0 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable Unable to unify \"(let (derivable) := ?Gamma in derivable) ?M4812 (?M4813 || ?M4814 --> ?M4815)\" with \"(let (provable) := Gamma in provable) (\u25c7 (x || y) <--> \u25c7 x || \u25c7 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+"], "tactic": "apply deduction_orp_intros1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H2 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H1 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z Unable to unify \"(let (derivable) := ?Gamma in derivable) ?M12561 (?M12562 || ?M12563)\" with \"(let (provable) := Gamma in provable) (\u25c7 (x || y) <--> \u25c7 x || \u25c7 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1."], "tactic": "apply deduction_orp_intros1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H3 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H0 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z Unable to unify \"(let (derivable) := ?Gamma in derivable) ?M25364 (?M25365 || ?M25366)\" with \"(let (provable) := Gamma in provable) (\u25c7 (x || y) <--> \u25c7 x || \u25c7 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1."], "tactic": "apply provable_proper_iffp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H6 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H5 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H2 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z Unable to unify \"forall x0 y0 : expr, (fun x1 y1 : expr => |-- x1 <--> y1) x0 y0 -> |-- x0 <-> |-- y0\" with \"(let (provable) := Gamma in provable) (\u25c7 (x || y) <--> \u25c7 x || \u25c7 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1."], "tactic": "apply axiom_D.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H7 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H3 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H0 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z Unable to unify \"(let (provable) := ?Gamma in provable) (\u25a1 ?M55162 --> \u25c7 ?M55162)\" with \"(let (provable) := Gamma in provable) (\u25c7 (x || y) <--> \u25c7 x || \u25c7 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply deduction_orp_intros1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H0 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable Unable to unify \"(let (derivable) := ?Gamma in derivable) ?M73750 (?M73751 || ?M73752)\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1."], "tactic": "apply deduction_orp_intros2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H3 : forall x : expr, |-- \u25a1 x --> \u25c7 x H2 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H1 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z Unable to unify \"(let (derivable) := ?Gamma in derivable) ?M88753 (?M88754 || ?M88755)\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp."], "tactic": "apply provable_proper_iffp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H3 : forall x : expr, |-- \u25a1 x --> \u25c7 x H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H8 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H7 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H6 : forall x : expr, |-- \u25a1 x --> \u25c7 x H5 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z H0 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y Unable to unify \"forall x0 y0 : expr, (fun x1 y1 : expr => |-- x1 <--> y1) x0 y0 -> |-- x0 <-> |-- y0\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp."], "tactic": "apply axiom_D.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H3 : forall x : expr, |-- \u25a1 x --> \u25c7 x H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H0 : forall (Phi : context) (x y : expr), Phi y -> Phi (x || y) H12 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H11 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H10 : forall x : expr, |-- \u25a1 x --> \u25c7 x H9 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y Unable to unify \"(let (provable) := ?Gamma in provable) (\u25a1 ?M139843 --> \u25c7 ?M139843)\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "-"], "tactic": "apply deduction_orp_intros1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H3 : forall x : expr, |-- \u25a1 x --> \u25c7 x H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H0 : forall (Phi : context) (x y : expr), Phi y -> Phi (x || y) H13 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H8 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H7 : forall x : expr, |-- \u25a1 x --> \u25c7 x H6 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z H5 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y Unable to unify \"(let (derivable) := ?Gamma in derivable) ?M168066 (?M168067 || ?M168068)\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "-", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp."], "tactic": "apply provable_proper_iffp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H3 : forall x : expr, |-- \u25a1 x --> \u25c7 x H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H0 : forall (Phi : context) (x y : expr), Phi y -> Phi (x || y) H12 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H11 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H10 : forall x : expr, |-- \u25a1 x --> \u25c7 x H9 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y Unable to unify \"forall x0 y0 : expr, (fun x1 y1 : expr => |-- x1 <--> y1) x0 y0 -> |-- x0 <-> |-- y0\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: deduction_orp_elim',provable_proper_iffp,axiom_D,deduction_orp_intros1.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "-", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp.", "qsimpl time: 1 use: deduction_orp_intros2,deduction_orp_elim',axiom_D,deduction_orp_intros1,provable_proper_iffp."], "tactic": "apply orp_diamondp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Provable L H : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable mL : ModalLanguage L x, y : expr axiom_K : forall x y : expr, |-- \u25a1 (x --> y) --> \u25a1 x --> \u25a1 y rule_N : forall x : expr, |-- x -> |-- \u25a1 x excluded_middle : forall x : expr, |-- x || ~~ x andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z H4 : forall (Phi : context) (x y : expr), Phi x -> Phi (x || y) H3 : forall x : expr, |-- \u25a1 x --> \u25c7 x H1 : forall (Phi : context) (x y z : expr), Phi (x --> z) -> Phi (y --> z) -> Phi (x || y --> z) H0 : forall (Phi : context) (x y : expr), Phi y -> Phi (x || y) H13 : Morphisms.Proper (Morphisms.respectful (fun x y : expr => |-- x <--> y) (fun A B : Prop => (A -> B) /\\\\ (B -> A))) provable H8 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y H7 : forall x : expr, |-- \u25a1 x --> \u25c7 x H6 : forall (Phi : context) (x y z : expr), Phi |-- x --> z -> Phi |-- y --> z -> Phi |-- x || y --> z H5 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y Unable to unify \"(let (provable) := ?Gamma in provable) (\u25c7 ?M224512 || \u25c7 ?M224513 --> \u25c7 (?M224512 || ?M224513))\" with \"BasicSequentCalculus L {| derivable := fun X : context => X |}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros x y. apply provable_proper_iffp. split. - apply deduction_orp_elim'. + apply deduction_orp_intros1. apply deduction_orp_intros1. apply provable_proper_iffp. apply axiom_D. + apply deduction_orp_intros1. apply deduction_orp_intros2. apply provable_proper_iffp. apply axiom_D. - apply deduction_orp_intros1. apply provable_proper_iffp. apply orp_diamondp.", "back_times": 0, "succ": false, "time": 516.3094789981842}]