[{"history": {"proof": "intros A P Q R. split. - intros H. split. + qsimpl time: 1 use: Disjoint_spec,Union. apply Decidable.dec_not_not. * qsimpl time: 1 use: Disjoint_spec,Union,Union_spec. sauto lq: on. * sauto. + qsimpl time: 1 use: Disjoint_spec,Union,Union_spec. hauto l: on depth: 3. - intros. qsimpl time: 1 use: Disjoint_spec,Union,Union_spec. sauto lq: on.", "repairs": ["", "", "", "", "", "", "cannot_apply_in", "ref_not_found", "", "cannot_unify", "hammer", "", "hammer", "", "cannot_apply_in", "hammer", "", "no_product", "cannot_unify", "hammer"], "exceptions": [{"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+"], "tactic": "intros x Px Rx.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+"], "tactic": "apply (Disjoint_spec A (Union A P Q) R) in H.", "exn": "Unable to apply lemma of type \"Disjoint A (Union A P Q) R <-> (forall x : A, Union A P Q x -> R x -> False)\" on hypothesis of type \"Disjoint A (Union A P Q) R\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*"], "tactic": "now apply Union_spec.", "exn": "In environment A : Type P, Q, R : Ensemble A H0 : forall (A : Type) (P Q : Ensemble A), (forall x : A, P x -> Q x -> False) -> Disjoint A P Q H1 : forall (A : Type) (P Q : Ensemble A), Disjoint A P Q -> forall x : A, P x -> Q x -> False H2 : forall x : A, In A (Intersection A (Union A P Q) R) x -> False Unable to unify \"(Union ?M2855 ?M2857 ?M2858 ?M2856 -> ?M2857 ?M2856 \\\\/ ?M2858 ?M2856) /\\\\ (?M2857 ?M2856 \\\\/ ?M2858 ?M2856 -> Union ?M2855 ?M2857 ?M2858 ?M2856)\" with \"Disjoint A P R \\\\/ ~ Disjoint A P R\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+"], "tactic": "intros x Qx Rx.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+"], "tactic": "apply (Disjoint_spec A (Union A P Q) R) in H.", "exn": "Unable to apply lemma of type \"Disjoint A (Union A P Q) R <-> (forall x : A, Union A P Q x -> R x -> False)\" on hypothesis of type \"Disjoint A (Union A P Q) R\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "apply Decidable.dec_not_not.", "*"], "tactic": "now apply Union_spec.", "exn": "In environment A : Type P, Q, R : Ensemble A H0 : forall (A : Type) (P Q : Ensemble A), (forall x : A, P x -> Q x -> False) -> Disjoint A P Q H2 : forall (A : Type) (P Q : Ensemble A), Disjoint A P Q -> forall x : A, P x -> Q x -> False H1 : forall (A : Type) (v : A) (P Q : Ensemble A), P v \\\\/ Q v -> Union A P Q v H3 : forall (A : Type) (v : A) (P Q : Ensemble A), Union A P Q v -> P v \\\\/ Q v H4 : forall x : A, In A (Intersection A (Union A P Q) R) x -> False Unable to unify \"(Union ?M5184 ?M5186 ?M5187 ?M5185 -> ?M5186 ?M5185 \\\\/ ?M5187 ?M5185) /\\\\ (?M5186 ?M5185 \\\\/ ?M5187 ?M5185 -> Union ?M5184 ?M5186 ?M5187 ?M5185)\" with \"Disjoint A Q R \\\\/ ~ Disjoint A Q R\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "apply Decidable.dec_not_not.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "apply Decidable.dec_not_not.", "*", "shelve.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "apply Decidable.dec_not_not.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "intros [HP HQ] x [Px | Qx] Rx.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "apply Decidable.dec_not_not.", "*", "shelve.", "*", "shelve.", "-", "intros."], "tactic": "now apply (Disjoint_spec A P R).", "exn": "In environment A : Type P, Q, R : Ensemble A H : Disjoint A P R /\\\\ Disjoint A Q R Unable to unify \"Disjoint A P R <-> (forall x : A, P x -> R x -> False)\" with \"Disjoint A (Union A P Q) R\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A P Q R.", "split.", "-", "intros H.", "split.", "+", "qsimpl time: 1 use: Disjoint_spec,Union.", "apply Decidable.dec_not_not.", "*", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "shelve.", "*", "shelve.", "+", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec.", "apply Decidable.dec_not_not.", "*", "shelve.", "*", "shelve.", "-", "intros.", "qsimpl time: 1 use: Disjoint_spec,Union,Union_spec."], "tactic": "now apply (Disjoint_spec A Q R).", "exn": "In environment A : Type P, Q, R : Ensemble A H0 : forall (A : Type) (P Q : Ensemble A), (forall x : A, P x -> Q x -> False) -> Disjoint A P Q H3 : forall (A : Type) (P Q : Ensemble A), Disjoint A P Q -> forall x : A, P x -> Q x -> False H1 : forall (A : Type) (v : A) (P Q : Ensemble A), P v \\\\/ Q v -> Union A P Q v H4 : forall (A : Type) (v : A) (P Q : Ensemble A), Union A P Q v -> P v \\\\/ Q v H5 : forall x : A, In A (Intersection A Q R) x -> False H2 : forall x : A, In A (Intersection A P R) x -> False Unable to unify \"Disjoint A Q R <-> (forall x : A, Q x -> R x -> False)\" with \"Disjoint A (Union A P Q) R\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros A P Q R. split. - intros H. split. + intros x Px Rx. apply (Disjoint_spec A (Union A P Q) R) in H. apply H. * now apply Union_spec. * auto. + intros x Qx Rx. apply (Disjoint_spec A (Union A P Q) R) in H. apply H. * now apply Union_spec. * auto. - intros [HP HQ] x [Px | Qx] Rx. + now apply (Disjoint_spec A P R). + now apply (Disjoint_spec A Q R).", "back_times": 4, "succ": true, "time": 35.695732831954956}]