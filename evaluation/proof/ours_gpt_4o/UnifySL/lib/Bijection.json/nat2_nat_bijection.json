[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto.", "shelve.", "-", "unfold surjective.", "intros m.", "destruct m.", "+", "exists (inl 0).", "reflexivity.", "+", "destruct (Nat.div_mod m 2) as [Eq _].", "destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case].", "++"], "tactic": "exists (inl (m / 2)).", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto.", "shelve.", "-", "unfold surjective.", "intros m.", "destruct m.", "+", "exists (inl 0).", "reflexivity.", "+", "destruct (Nat.div_mod m 2) as [Eq _].", "destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case].", "++"], "tactic": "qsimpl time: 1 use: inl,auto.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto.", "shelve.", "-", "unfold surjective.", "intros m.", "destruct m.", "+", "exists (inl 0).", "reflexivity.", "+", "destruct (Nat.div_mod m 2) as [Eq _].", "destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case].", "++", "qsimpl time: 1 use: inl."], "tactic": "subst.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto.", "shelve.", "-", "unfold surjective.", "intros m.", "destruct m.", "+", "exists (inl 0).", "reflexivity.", "+", "destruct (Nat.div_mod m 2) as [Eq _].", "destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case].", "++", "qsimpl time: 1 use: inl.", "++"], "tactic": "exists (inr (m / 2)).", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto.", "shelve.", "-", "unfold surjective.", "intros m.", "destruct m.", "+", "exists (inl 0).", "reflexivity.", "+", "destruct (Nat.div_mod m 2) as [Eq _].", "destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case].", "++", "qsimpl time: 1 use: inl.", "++"], "tactic": "qsimpl time: 1 use: inl,auto,inr.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end).", "-", "unfold image_defined.", "intros [n | n].", "+", "exists (2 * n).", "reflexivity.", "+", "exists (S (2 * n)).", "reflexivity.", "-", "unfold partial_functional.", "shelve.", "-", "unfold injective.", "intros [n1 | n1] [n2 | n2]; intros m H1 H2.", "+", "inversion H1; inversion H2; auto.", "shelve.", "+", "inversion H2.", "shelve.", "+", "inversion H1.", "shelve.", "+", "inversion H1; inversion H2; auto.", "shelve.", "-", "unfold surjective.", "intros m.", "destruct m.", "+", "exists (inl 0).", "reflexivity.", "+", "destruct (Nat.div_mod m 2) as [Eq _].", "destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case].", "++", "qsimpl time: 1 use: inl.", "++", "qsimpl time: 1 use: inl,inr."], "tactic": "subst.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}]}, "chat": [], "original": "apply Build_bijection with (bij_R := fun x y => match x, y with | inl n, m => m = 2 * n | inr n, m => m = S (2 * n) end). - unfold image_defined. intros [n | n]. + exists (2 * n). reflexivity. + exists (S (2 * n)). reflexivity. - unfold partial_functional. intros [n1 | n1] [n2 | n2]; intros m H1 H2. + inversion H1; inversion H2; auto. + inversion H1. + inversion H2. + inversion H1; inversion H2; auto. - unfold injective. intros [n1 | n1] [n2 | n2]; intros m H1 H2. + inversion H1; inversion H2; auto. + inversion H2. + inversion H1. + inversion H1; inversion H2; auto. - unfold surjective. intros m. destruct m. + exists (inl 0). reflexivity. + destruct (Nat.div_mod m 2) as [Eq _]. destruct (Nat.eq_dec (m mod 2) 0) as [Case | Case]. ++ exists (inl (m / 2)). subst. rewrite Nat.mul_comm. apply Nat.div_apply in Eq. apply Eq. apply Case. ++ exists (inr (m / 2)). subst. rewrite Nat.mul_comm. rewrite S_pred by auto. apply plus_n_Sm.", "back_times": 0, "succ": false, "time": 180.5301489830017}]