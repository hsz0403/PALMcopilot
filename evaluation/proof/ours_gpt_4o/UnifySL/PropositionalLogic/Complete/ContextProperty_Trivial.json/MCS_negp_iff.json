[{"history": {"proof": "hauto lq: on use: @derivable_closed_element_derivable, @maximal_consistent_derivable_closed, @deduction_left_impp_intros, MCS_nonelement_inconsistent, MCS_impp_iff unfold: negp, falsep.", "repairs": [], "exceptions": [{"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec."], "tactic": "exists x.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1.", "shelve.", "-", "intros H1.", "apply maximal_consistent_spec in maxC as [_ HmaxC]."], "tactic": "apply ClassicalPropositionalSequentCalculus_double_negp_elim in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1.", "shelve.", "-", "intros H1.", "apply maximal_consistent_spec in maxC as [_ HmaxC]."], "tactic": "qsimpl time: 1 use: auto,MCS_nonelement_inconsistent.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1.", "shelve.", "-", "intros H1.", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "qsimpl time: 1 use: MCS_nonelement_inconsistent."], "tactic": "apply MCS_element_derivable in H as Hd.", "exn": "Unable to apply lemma of type \"forall Phi0 : context, maximal consistent Phi0 -> forall x0 : expr, Phi0 x0 <-> Phi0 |-- x0\" on hypothesis of type \"forall Phi : context, maximal consistent Phi -> forall x : expr, Phi |-- x --> FF -> Phi x -> False\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros Phi maxC x.", "split.", "-", "intros H1 H2.", "apply MCS_nonelement_inconsistent with Phi x.", "+", "apply maxC.", "+", "qsimpl time: 1.", "+", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "apply HmaxC.", "apply consistent_spec.", "qsimpl time: 1.", "shelve.", "-", "intros H1.", "apply maximal_consistent_spec in maxC as [_ HmaxC].", "qsimpl time: 1 use: MCS_nonelement_inconsistent."], "tactic": "qsimpl time: 1 use: MCS_element_derivable,auto,MCS_nonelement_inconsistent.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros Phi maxC x. split. - intros H1 H2. apply MCS_nonelement_inconsistent with Phi x. + apply maxC. + split. * apply maximal_consistent_spec in maxC as [_ HmaxC]. apply HmaxC. -- apply consistent_spec. exists x. auto. -- intros H. apply MCS_nonelement_inconsistent with Phi. ++ apply maxC. ++ right. auto. * apply H2. - intros H1. apply maximal_consistent_spec in maxC as [_ HmaxC]. apply ClassicalPropositionalSequentCalculus_double_negp_elim in H. apply MCS_element_derivable in H as Hd. + apply doubl_negation_classical_equiv in H1. destruct H1 as [H2 | H2]. * contradiction. * firstorder. + apply maxC.", "back_times": 0, "succ": true, "time": 162.5413646697998}]