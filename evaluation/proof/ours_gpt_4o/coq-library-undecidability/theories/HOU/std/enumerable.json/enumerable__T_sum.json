[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "intros H1 H2. apply enumerable_enumerable_T. apply enumerable_enum. exists (fun n => match n with | 0 => [] | S n' => match n' mod 2 with | 0 => map inl (proj1_sig (enum_enumT _ H1) n') | _ => map inr (proj1_sig (enum_enumT _ H2) (n' / 2)) end end). split. - intros n. destruct n. * exists []. auto. * destruct (n mod 2). ++ exists (proj1_sig (enum_enumT _ H1) n). reflexivity. ++ exists (proj1_sig (enum_enumT _ H2) (n / 2)). reflexivity. - intros [x|y]. + destruct (proj2_sig (enum_enumT _ H1) x) as [m Hm]. exists (S (2 * m)). simpl. rewrite Nat.mod_add. rewrite Hm. left. apply in_map. apply in_eq. discriminate. apply eq_refl. + destruct (proj2_sig (enum_enumT _ H2) y) as [m Hm]. exists (S (2 * m + 1)). simpl. rewrite <- Nat.add_mod_idemp_r. rewrite Nat.mod_small. rewrite Hm. left. apply in_map. apply in_eq. apply eq_refl. apply Nat.lt_lt_add. apply Nat.lt_lt_add. apply PeanoNat.Nat.lt_0_1.", "back_times": 0, "succ": false, "time": 240.30908966064453}]