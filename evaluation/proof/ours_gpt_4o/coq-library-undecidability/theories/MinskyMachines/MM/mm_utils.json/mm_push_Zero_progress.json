[{"history": {"proof": "qsimpl time: 1 use: mm_transfert_progress. qsimpl time: 1 use: mm_transfert_progress. qsimpl time: 1 use: mm_transfert_progress. qsimpl time: 1 use: mm_transfert_progress,stack_enc. qsimpl time: 1 use: mm_mul2_progress,mm_transfert_progress,stack_enc. qsimpl time: 1 use: vec_one_spec_neq,mm_mul2_progress,mm_transfert_progress,stack_enc. qsimpl time: 1 use: vec_one_spec_neq,mm_mul2_progress,mm_transfert_progress,stack_enc.", "repairs": ["cannot_unify", "no_subterm", "no_subterm", "cannot_unify", "cannot_unify", "cannot_unify", "no_subterm"], "exceptions": [{"ctx": ["intros H1 H2 H3."], "tactic": "apply mm_transfert_progress with (src := src) (dst := tmp) (zero := zero).", "exn": "In environment n : nat src, tmp, zero : pos n Hst : src <> tmp Hsz : src <> zero Htz : tmp <> zero i : nat s : list bool v : vec nat n H1 : v#>tmp = 0 H2 : v#>zero = 0 H3 : v#>src = stack_enc s Unable to unify \"exists k : nat, 0 < k /\\\\ (?M1467, mm_transfert src tmp zero ?M1467) // (?M1467, ?M1468) -[k]-> ?M1469\" with \"exists k : nat, 0 < k /\\\\ (i, mm_push_Zero) // (i, v) -[k]-> (7 + i, v[(stack_enc (Zero :: s))/src])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H1 H2 H3.", "qsimpl time: 1 use: mm_transfert_progress."], "tactic": "rewrite H1.", "exn": "Found no subterm matching \"v#>tmp\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H1 H2 H3.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress."], "tactic": "rewrite H2.", "exn": "Found no subterm matching \"v#>zero\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H1 H2 H3.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress."], "tactic": "apply stack_enc.", "exn": "In environment n : nat H : forall src dst zero : pos n, (src = dst -> False) -> (src = zero -> False) -> (dst = zero -> False) -> forall (i : nat) (v : vec nat n) (st : nat * vec nat n), v#>dst = 0 -> v#>zero = 0 -> st = (S (S (S i)), v[0/src][(v#>src)/dst]) -> (i, mm_transfert src dst zero i) // (i, v) -+> st src, tmp, zero : pos n Hst : src = tmp -> False Hsz : src = zero -> False Htz : tmp = zero -> False i : nat s : list bool v : vec nat n H1 : v#>tmp = 0 H2 : v#>zero = 0 H3 : v#>src = stack_enc s Unable to unify \"nat\" with \"(i, mm_push_Zero) // (i, v) -+> (S (S (S (S (S (S (S i)))))), v[(stack_enc s + (stack_enc s + 0))/src])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H1 H2 H3.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress,stack_enc."], "tactic": "apply mm_mul2_progress with (src := tmp) (dst := src) (zero := zero).", "exn": "In environment n0 : list bool -> nat n : nat H0 : forall src dst zero : pos n, (src = dst -> False) -> (src = zero -> False) -> (dst = zero -> False) -> forall (i : nat) (v : vec nat n) (st : nat * vec nat n), v#>dst = 0 -> v#>zero = 0 -> st = (S (S (S i)), v[0/src][(v#>src)/dst]) -> (i, mm_transfert src dst zero i) // (i, v) -+> st src, tmp, zero : pos n Hst : src = tmp -> False Hsz : src = zero -> False Htz : tmp = zero -> False i : nat s : list bool v : vec nat n H1 : v#>tmp = 0 H2 : v#>zero = 0 H3 : v#>src = stack_enc s Unable to unify \"exists k : nat, 0 < k /\\\\ (?M4805, mm_mul2 tmp src zero ?M4805) // (?M4805, ?M4806) -[k]-> ?M4807\" with \"exists k : nat, 0 < k /\\\\ (i, mm_push_Zero) // (i, v) -[k]-> (S (S (S (S (S (S (S i)))))), v[(n0 s + (n0 s + 0))/src])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H1 H2 H3.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress,stack_enc.", "qsimpl time: 1 use: mm_mul2_progress,mm_transfert_progress,stack_enc."], "tactic": "apply vec_one_spec_neq.", "exn": "In environment n : nat H4 : forall src dst zero : pos n, (src = dst -> False) -> (src = zero -> False) -> (dst = zero -> False) -> forall (i : nat) (v : vec nat n) (st : nat * vec nat n), v#>dst = 0 -> v#>zero = 0 -> st = (S (S (S i)), v[0/src][(v#>src)/dst]) -> (i, mm_transfert src dst zero i) // (i, v) -+> st H : forall src dst zero : pos n, (src = dst -> False) -> (src = zero -> False) -> (dst = zero -> False) -> forall (i : nat) (v : vec nat n) (st : nat * vec nat n), v#>dst = 0 -> v#>zero = 0 -> st = (S (S (S (S i))), v[0/src][((v#>src) + ((v#>src) + 0))/dst]) -> (i, mm_mul2 src dst zero i) // (i, v) -+> st n0 : list bool -> nat src, tmp, zero : pos n Hst : src = tmp -> False Hsz : src = zero -> False Htz : tmp = zero -> False i : nat s : list bool v : vec nat n H1 : v#>tmp = 0 H2 : v#>zero = 0 H3 : v#>src = stack_enc s H6 : nat Unable to unify \"vec_one ?M6014#>?M6015 = 0\" with \"exists k : nat, 0 < k /\\\\ (i, mm_push_Zero) // (i, v) -[k]-> (S (S (S (S (S (S (S i)))))), v[(n0 s + (n0 s + 0))/src])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H1 H2 H3.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress,stack_enc.", "qsimpl time: 1 use: mm_mul2_progress,mm_transfert_progress,stack_enc.", "qsimpl time: 1 use: vec_one_spec_neq,mm_mul2_progress,mm_transfert_progress,stack_enc."], "tactic": "rewrite H3.", "exn": "Found no subterm matching \"v#>src\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [], "original": "intros H1 H2 H3. apply mm_transfert_progress with (src := src) (dst := tmp) (zero := zero). -- auto. -- auto. -- auto. -- rewrite H1. rewrite H2. replace (0 + 0) with 0 by auto. simpl. apply stack_enc. apply mm_mul2_progress with (src := tmp) (dst := src) (zero := zero). -- auto. -- auto. -- apply vec_one_spec_neq. auto. -- rewrite H3. simpl. replace (2 * stack_enc s) with (stack_enc s + stack_enc s) by auto. reflexivity.", "back_times": 0, "succ": false, "time": 64.4070737361908}]