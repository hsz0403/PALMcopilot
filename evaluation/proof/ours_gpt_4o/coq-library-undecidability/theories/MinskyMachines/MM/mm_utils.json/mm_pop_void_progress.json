[{"history": {"proof": "qsimpl time: 1 use: mm_transfert_progress. qsimpl time: 1 use: mm_transfert_progress. qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress. qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress. qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress. qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress.", "repairs": ["cannot_unify", "no_subterm", "cannot_unify", "no_subterm", "no_subterm", "no_subterm"], "exceptions": [{"ctx": ["intros Htmp1 Htmp2 Hsrc."], "tactic": "apply mm_transfert_progress with (st := (3 + i, v[0/src][(v#>src)/tmp1])).", "exn": "In environment n : nat src, tmp1, tmp2, zero : pos n Hs1 : src <> tmp1 Hs2 : src <> tmp2 Hsz : src <> zero H12 : tmp1 <> tmp2 H1z : tmp1 <> zero H2z : tmp2 <> zero i, j, k, e : nat src' := src : pos n v : vec nat n Htmp1 : v#>tmp1 = 0 Htmp2 : v#>tmp2 = 0 Hsrc : v#>src = stack_enc nil Unable to unify \"exists k : nat, 0 < k /\\\\ (?M1475, mm_transfert ?M1469 ?M1470 ?M1471 ?M1475) // (?M1475, ?M1476) -[k]-> (3 + i, v[0/src][(v#>src)/tmp1])\" with \"exists k : nat, 0 < k /\\\\ (i, mm_pop) // (i, v) -[k]-> (e, v)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Htmp1 Htmp2 Hsrc.", "qsimpl time: 1 use: mm_transfert_progress."], "tactic": "rewrite Htmp1.", "exn": "Found no subterm matching \"v#>tmp1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros Htmp1 Htmp2 Hsrc.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress."], "tactic": "apply mm_div2_progress_0 with (st := (6 + i, v[0/src][0/tmp2][0/tmp1])).", "exn": "In environment n : nat H0 : forall src dst zero : pos n, (src = dst -> False) -> (src = zero -> False) -> (dst = zero -> False) -> forall (i : nat) (v : vec nat n) (st : nat * vec nat n), v#>dst = 0 -> v#>zero = 0 -> st = (S (S (S i)), v[0/src][(v#>src)/dst]) -> (i, mm_transfert src dst zero i) // (i, v) -+> st src, tmp1, tmp2, zero : pos n Hs1 : src = tmp1 -> False Hs2 : src = tmp2 -> False Hsz : src = zero -> False H12 : tmp1 = tmp2 -> False H1z : tmp1 = zero -> False H2z : tmp2 = zero -> False i, j, k, e : nat src' := src : pos n v : vec nat n Htmp1 : v#>tmp1 = 0 Htmp2 : v#>tmp2 = 0 Hsrc : v#>src = 1 Unable to unify \"exists k : nat, 0 < k /\\\\ (?M3443, mm_div2 ?M3437 ?M3438 ?M3439 ?M3443) // (?M3443, ?M3444) -[k]-> (6 + i, v[0/src][0/tmp2][0/tmp1])\" with \"exists k : nat, 0 < k /\\\\ (i, mm_pop) // (i, v) -[k]-> (e, v)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Htmp1 Htmp2 Hsrc.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress."], "tactic": "rewrite Htmp2.", "exn": "Found no subterm matching \"v#>tmp2\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros Htmp1 Htmp2 Hsrc.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress.", "qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress."], "tactic": "rewrite Htmp1.", "exn": "Found no subterm matching \"v#>tmp1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros Htmp1 Htmp2 Hsrc.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_transfert_progress.", "qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress.", "qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress.", "qsimpl time: 1 use: mm_div2_progress_0,mm_transfert_progress."], "tactic": "rewrite Hsrc.", "exn": "Found no subterm matching \"v#>src\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [], "original": "intros Htmp1 Htmp2 Hsrc. apply mm_transfert_progress with (st := (3 + i, v[0/src][(v#>src)/tmp1])). -- auto. -- auto. -- auto. -- auto. -- auto. -- simpl. rewrite Htmp1. auto. apply mm_div2_progress_0 with (st := (6 + i, v[0/src][0/tmp2][0/tmp1])). -- auto. -- auto. -- auto. -- simpl. rewrite Htmp2. auto. -- simpl. rewrite Htmp1. auto. -- simpl. rewrite Hsrc. reflexivity. simpl. rewrite Htmp1. auto. apply mm_steps_DEC_0_inv with (st := (13 + i, v[0/src][1/src])). --", "back_times": 0, "succ": false, "time": 64.73320031166077}]