[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold Q."], "tactic": "unfold sc.", "exn": "The reference sc was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold Q.", "unfold bsm_mm.", "unfold lnk_Q_pair."], "tactic": "exists (fst (projT2 lnk_Q_pair)).", "exn": "In environment m : nat n := 2 + m : nat Hreg : forall p q : pos m, reg p = reg q -> p = q iP : nat cP : list (bsm_instr m) v : vec (list bool) m w_prop : v \u22c8 w The term \"projT2 lnk_Q_pair\" has type \"{Q : nat * list (mm_instr (pos n)) | fst Q = 1 /\\\\ projT1 lnk_Q_pair (fst (iP, cP)) = 1 /\\\\ (forall i : nat, out_code i (iP, cP) -> projT1 lnk_Q_pair i = code_end Q) /\\\\ (forall (i1 : nat) (v1 : vec (list bool) m) (w1 : vec nat n) (i2 : nat) (v2 : vec (list bool) m), v1 \u22c8 w1 /\\\\ (iP, cP) /BSM/ (i1, v1) ~~> (i2, v2) -> exists w2 : vec nat n, v2 \u22c8 w2 /\\\\ Q /MM/ (projT1 lnk_Q_pair i1, w1) ~~> (projT1 lnk_Q_pair i2, w2)) /\\\\ (forall (i1 : nat) (v1 : vec (list bool) m) (w1 : vec nat n) (j2 : nat) (w2 : vec nat n), v1 \u22c8 w1 /\\\\ Q /MM/ (projT1 lnk_Q_pair i1, w1) ~~> (j2, w2) -> exists (i2 : nat) (v2 : vec (list bool) m), v2 \u22c8 w2 /\\\\ (iP, cP) /BSM/ (i1, v1) ~~> (i2, v2) /\\\\ j2 = projT1 lnk_Q_pair i2)}\" while it is expected to have type \"(?A * ?B)%type\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "unfold Q. unfold sc. unfold bsm_mm. unfold lnk_Q_pair. exists (fst (projT2 lnk_Q_pair)). exists (snd (projT2 lnk_Q_pair) ++ cE). split. - apply subcode_refl. - simpl. apply bsm_compute_POP_0. ++ unfold reg. apply Hreg with (p:=proj1_sig (1, bsm_mm)). auto. ++ split. unfold cE. simpl. apply Hreg with (p:=proj1_sig (1, bsm_mm)). auto. ++ apply w_prop.", "back_times": 0, "succ": false, "time": 130.54701900482178}]