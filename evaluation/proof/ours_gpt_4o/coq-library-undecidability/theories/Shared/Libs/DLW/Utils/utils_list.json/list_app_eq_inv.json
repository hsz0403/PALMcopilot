[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl."], "tactic": "rewrite <- Heqlr1.", "exn": "Found no subterm matching \"nil ++ r1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1."], "tactic": "reflexivity.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1."], "tactic": "reflexivity.", "exn": "In environment X : Type lr2 : list X H : nil = lr2 x : X l2, r1, r2 : list X Heqlr1 : nil = nil ++ r1 Heqlr2 : lr2 = (x :: l2) ++ r2 Unable to unify \"nil ++ r1\" with \"x :: l2 ++ x :: l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1."], "tactic": "**", "exn": "[Focus] Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl."], "tactic": "rewrite <- Heqlr2.", "exn": "Found no subterm matching \"(x :: l2) ++ r2\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1."], "tactic": "rewrite <- Heqlr1.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl."], "tactic": "rewrite Heqlr2.", "exn": "Found no subterm matching \"lr2\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1."], "tactic": "reflexivity.", "exn": "No such goal. Focus next goal with bullet **.", "type": "next_goal", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl."], "tactic": "rewrite <- Heqlr1.", "exn": "Found no subterm matching \"(x :: l1) ++ r1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1."], "tactic": "rewrite <- Heqlr2.", "exn": "No such goal. Focus next goal with bullet ++.", "type": "next_goal", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil)."], "tactic": "**", "exn": "[Focus] Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**"], "tactic": "rewrite <- Heqlr2.", "exn": "Found no subterm matching \"(x0 :: l2) ++ r2\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**"], "tactic": "qsimpl time: 1 use: congruence.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1."], "tactic": "simpl.", "exn": "No such goal. Focus next goal with bullet --.", "type": "next_goal", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst."], "tactic": "++", "exn": "[Focus] Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl."], "tactic": "reflexivity.", "exn": "In environment X : Type x : X lr : list X IH : lr = x :: lr -> forall l1 l2 r1 r2 : list X, lr = l1 ++ r1 -> x :: lr = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} b : X l2', r2 : list X Heqlr2 : x :: lr = (b :: l2') ++ r2 Unable to unify \"nil\" with \"b :: l2' ++ b :: l2'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl."], "tactic": "**", "exn": "[Focus] Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**"], "tactic": "rewrite <- Heqlr2.", "exn": "Found no subterm matching \"(b :: l2') ++ r2\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**"], "tactic": "qsimpl time: 1 use: congruence,contradiction.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**"], "tactic": "qsimpl time: 1 use: contradiction.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1."], "tactic": "apply app_inv_tail with (l := lr2).", "exn": "The reference lr2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2')."], "tactic": "++", "exn": "[Focus] Wrong bullet ++: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl."], "tactic": "reflexivity.", "exn": "In environment X : Type x : X lr : list X IH : lr = x :: lr -> forall l1 l2 r1 r2 : list X, lr = l1 ++ r1 -> x :: lr = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} a : X l1', r1 : list X Heqlr1 : x :: lr = (a :: l1') ++ r1 Unable to unify \"nil\" with \"a :: l1' ++ a :: l1'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl."], "tactic": "**", "exn": "[Focus] Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**"], "tactic": "rewrite <- Heqlr1.", "exn": "Found no subterm matching \"(a :: l1') ++ r1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**"], "tactic": "qsimpl time: 1 use: congruence,contradiction.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**"], "tactic": "qsimpl time: 1 use: contradiction.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1."], "tactic": "apply app_inv_tail with (l := lr2).", "exn": "The reference lr2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1)."], "tactic": "++", "exn": "[Focus] Wrong bullet ++: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst."], "tactic": "destruct (IH l1' l2' r1 r2 eq_refl eq_refl) as [H | H].", "exn": "In environment X : Type l1', r1 : list X b : X IH : l1' ++ r1 = b :: l1' ++ r1 -> forall l1 l2 r2 r3 : list X, l1' ++ r1 = l1 ++ r2 -> b :: l1' ++ r1 = l2 ++ r3 -> {m : list X | l1 ++ m = l2 /\\\\ r2 = m ++ r3} + {m : list X | l2 ++ m = l1 /\\\\ r3 = m ++ r2} l2', r2 : list X H4 : l1' ++ r1 = l2' ++ r2 The term \"l1'\" has type \"list X\" while it is expected to have type \"l1' ++ r1 = b :: l1' ++ r1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst."], "tactic": "qsimpl time: 1 use: congruence,eq_refl,contradiction.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst."], "tactic": "qsimpl time: 1 use: eq_refl,contradiction.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left."], "tactic": "destruct H as [m [H5 H6]].", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left."], "tactic": "exists m.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal."], "tactic": "---", "exn": "[Focus] Wrong bullet ---: Current bullet --- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "qsimpl time: 1 use: congruence,eq_refl,contradiction.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "qsimpl time: 1 use: eq_refl,contradiction.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "destruct H as [m [H5 H6]].", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "exists m.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "split.", "exn": "In environment X : Type l1', r1 : list X b : X IH : l1' ++ r1 = b :: l1' ++ r1 -> forall l1 l2 r2 r3 : list X, l1' ++ r1 = l1 ++ r2 -> b :: l1' ++ r1 = l2 ++ r3 -> {m : list X | l1 ++ m = l2 /\\\\ r2 = m ++ r3} + {m : list X | l2 ++ m = l1 /\\\\ r3 = m ++ r2} l2', r2 : list X H4 : l1' ++ r1 = l2' ++ r2 Unable to unify \"r1 ++ r2\" with \"r1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "qsimpl time: 1 use: congruence,eq_refl,contradiction.", "exn": "The reference congruence was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "qsimpl time: 1 use: eq_refl,contradiction.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---"], "tactic": "---", "exn": "[Focus] Wrong bullet ---: Current bullet --- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "remember (l1 ++ r1) as lr1.", "remember (l2 ++ r2) as lr2.", "revert l1 l2 r1 r2 Heqlr1 Heqlr2.", "induction lr1 as [|x lr IH].", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1, l2.", "++", "left.", "exists nil.", "split.", "**", "reflexivity.", "**", "apply app_inv_head with (l := nil).", "rewrite <- Heqlr2.", "simpl.", "qsimpl time: 1.", "++", "right.", "exists (x :: l2).", "split.", "**", "simpl.", "rewrite Heqlr1.", "shelve.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists (x :: l1).", "split.", "**", "simpl.", "qsimpl time: 1.", "**", "simpl.", "qsimpl time: 1.", "++", "left.", "exists nil.", "split.", "**", "simpl.", "apply app_inv_tail with (l := nil).", "shelve.", "**", "qsimpl time: 1.", "--", "intros l1 l2 r1 r2 Heqlr1 Heqlr2.", "destruct l1 as [|a l1'], l2 as [|b l2'].", "++", "simpl in Heqlr1, Heqlr2.", "subst.", "shelve.", "++", "simpl in Heqlr1.", "subst.", "right.", "exists (b :: l2').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := l2').", "shelve.", "++", "simpl in Heqlr2.", "subst.", "left.", "exists (a :: l1').", "split.", "**", "simpl.", "shelve.", "**", "qsimpl time: 1.", "apply app_inv_tail with (l := r1).", "shelve.", "++", "simpl in Heqlr1, Heqlr2.", "injection Heqlr1 as H1 H2.", "subst.", "injection Heqlr2 as H3 H4.", "subst.", "qsimpl time: 1 use: eq_refl.", "left.", "exists r1.", "split.", "---", "f_equal.", "shelve.", "---", "shelve."], "tactic": "---", "exn": "[Focus] Wrong bullet ---: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros H. remember (l1 ++ r1) as lr1. remember (l2 ++ r2) as lr2. revert l1 l2 r1 r2 Heqlr1 Heqlr2. induction lr1 as [|x lr IH]. -- intros l1 l2 r1 r2 Heqlr1 Heqlr2. destruct l1, l2. ++ left. exists nil. split. ** reflexivity. ** apply app_inv_head with (l := nil). rewrite <- Heqlr2. simpl. rewrite <- Heqlr1. reflexivity. ++ right. exists (x :: l2). split. ** simpl. rewrite Heqlr1. reflexivity. ** simpl. rewrite <- Heqlr2. rewrite <- Heqlr1. simpl. reflexivity. ++ left. exists (x :: l1). split. ** simpl. rewrite Heqlr2. reflexivity. ** simpl. rewrite <- Heqlr1. rewrite <- Heqlr2. simpl. reflexivity. ++ left. exists nil. split. ** simpl. apply app_inv_tail with (l := nil). congruence. ** rewrite <- Heqlr2. simpl. repeat rewrite <- app_nil_end. auto. -- intros l1 l2 r1 r2 Heqlr1 Heqlr2. destruct l1 as [|a l1'], l2 as [|b l2']. ++ simpl in Heqlr1, Heqlr2. subst. contradiction. ++ simpl in Heqlr1. subst. right. exists (b :: l2'). split. ** simpl. reflexivity. ** rewrite <- Heqlr2. simpl. f_equal. apply app_inv_tail with (l := lr2). auto. ++ simpl in Heqlr2. subst. left. exists (a :: l1'). split. ** simpl. reflexivity. ** rewrite <- Heqlr1. simpl. f_equal. apply app_inv_tail with (l := lr2). auto. ++ simpl in Heqlr1, Heqlr2. injection Heqlr1 as H1 H2. subst. injection Heqlr2 as H3 H4. subst. destruct (IH l1' l2' r1 r2 eq_refl eq_refl) as [H | H]. ** left. destruct H as [m [H5 H6]]. exists m. split. --- simpl. f_equal. auto. --- auto. ** right. destruct H as [m [H5 H6]]. exists m. split. --- simpl. f_equal. auto. --- auto.", "back_times": 0, "succ": false, "time": 504.77969431877136}]