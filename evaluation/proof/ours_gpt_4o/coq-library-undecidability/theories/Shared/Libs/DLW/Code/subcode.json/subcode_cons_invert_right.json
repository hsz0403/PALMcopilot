[{"history": {"proof": "intros H. qsimpl time: 1 use: subcode_app_invert_right. qsimpl time: 1 use: subcode_app_invert_right,subcode_cons_inj. sauto depth: 3.", "repairs": ["", "cannot_apply_in", "no_hypos", "hammer"], "exceptions": [{"ctx": ["intros H."], "tactic": "apply subcode_app_invert_right in H as [H1 | H2].", "exn": "Unable to apply lemma of type \"forall (j : nat) (Q1 Q2 : list X) (i : nat) (I : X), (i, I :: nil) <sc (j, Q1 ++ Q2) -> (i, I :: nil) <sc (j, Q1) \\\\/ (i, I :: nil) <sc (length Q1 + j, Q2)\" on hypothesis of type \"(i, I :: nil) <sc (j, J :: Q)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros H.", "qsimpl time: 1 use: subcode_app_invert_right."], "tactic": "apply subcode_cons_inj with (\u03c1 := I) (\u03b4 := J) in H1.", "exn": "No such hypothesis: H1", "type": "no_hypos", "handled": true}, {"ctx": ["intros H.", "qsimpl time: 1 use: subcode_app_invert_right.", "qsimpl time: 1 use: subcode_app_invert_right,subcode_cons_inj.", "left.", "split.", "++"], "tactic": "apply in_code_subcode.", "exn": "In environment X : Type H2 : forall (i : nat) (\u03c1 \u03b4 : X) P, (let (n, code) := P in exists l r : list X, code = l ++ \u03c1 :: r /\\\\ i = n + length l) -> (let (n, code) := P in exists l r : list X, code = l ++ \u03b4 :: r /\\\\ i = n + length l) -> \u03c1 = \u03b4 H1 : forall (j : nat) (Q1 Q2 : list X) (i : nat) (I : X), (exists l r : list X, Q1 ++ Q2 = l ++ I :: r /\\\\ i = j + length l) -> (exists l r : list X, Q1 = l ++ I :: r /\\\\ i = j + length l) \\\\/ (exists l r : list X, Q2 = l ++ I :: r /\\\\ i = length Q1 + j + length l) j : nat J : X Q : list X I : X l, r : list X H : J :: Q = l ++ I :: r Unable to unify \"exists a : X, (?M3685, a :: nil) <sc ?M3686\" with \"j + length l = j\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "qsimpl time: 1 use: subcode_app_invert_right.", "qsimpl time: 1 use: subcode_app_invert_right,subcode_cons_inj.", "left.", "split.", "++", "qsimpl time: 1 use: subcode_app_invert_right,subcode_cons_inj,in_code_subcode."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros H. apply subcode_app_invert_right in H as [H1 | H2]. - apply subcode_cons_inj with (\u03c1 := I) (\u03b4 := J) in H1. ++ subst. left. split. auto. ++ apply in_code_subcode. eauto. - right. auto.", "back_times": 0, "succ": true, "time": 125.99942827224731}]