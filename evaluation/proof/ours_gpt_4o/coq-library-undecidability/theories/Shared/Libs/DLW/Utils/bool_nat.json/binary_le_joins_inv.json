[{"history": {"proof": "qsimpl time: 1 use: nat_joins_binary_le_right.", "repairs": ["cannot_apply_in"], "exceptions": [{"ctx": ["intros H."], "tactic": "apply nat_joins_binary_le_right in H.", "exn": "Unable to apply lemma of type \"forall (m n : nat) (f : nat -> nat), (exists i : nat, i < n /\\\\ m \u2272 f i) -> m \u2272 msum nat_join 0 n f\" on hypothesis of type \"m \u2272 msum nat_join 0 n f\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros H. apply nat_joins_binary_le_right in H. destruct H as [i [Hi Hfi]]. exists (S i). exists (fun j => if EqNat.beq_nat j i then f j else 0). exists (fun j => j). split. - apply msum_only_one with (n:=S i). + apply monoid_nat_join. + apply Hi. + intros j Hj Hij. apply EqNat.beq_nat_false in Hij. simpl. destruct (EqNat.beq_nat j i); auto. contradiction. - split. + apply le_n_S, le_S, le_0_n. + split. * intros k Hk. split. -- simpl. destruct (EqNat.beq_nat k i). ++ intros H0. discriminate. ++ intros _. auto. -- simpl. destruct (EqNat.beq_nat k i). ++ auto. ++ intros _ _. apply le_n. * split. -- intros k Hk. simpl. destruct (EqNat.beq_nat k i); auto with arith. -- intros j k Hj Hjk. simpl in *. apply lt_trans with (m := j); auto.", "back_times": 0, "succ": false, "time": 101.67248272895813}]