[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil)."], "tactic": "apply in_lbs_1.", "exn": "Unable to unify \"list_bool_succ (list_repeat One ?M1455) (list_repeat Zero (S ?M1455))\" with \"list_bool_succ nil (One :: nil)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+"], "tactic": "destruct (exists_last bool (true :: l')) as [ll [a Hl]].", "exn": "In environment l' : list bool The term \"bool\" has type \"Set\" while it is expected to have type \"?l <> nil\".", "type": "wrong_type", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true."], "tactic": "intros C.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true."], "tactic": "inversion C.", "exn": "No such hypothesis: C", "type": "no_hypos", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true."], "tactic": "rewrite Hl.", "exn": "The reference Hl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true."], "tactic": "destruct a.", "exn": "The reference a was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*"], "tactic": "exists (list_repeat Zero (S (length ll)) ++ One :: nil).", "exn": "The reference ll was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*"], "tactic": "rewrite <- Hl.", "exn": "The reference Hl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*"], "tactic": "apply in_lbs_0.", "exn": "In environment H1 : bool X0 : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} H0 : forall k : nat, list_bool_succ (list_repeat One k) (Zero :: list_repeat Zero k) b : bool X : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} l' : list bool Unable to unify \"list_bool_succ (list_repeat One ?M1882 ++ Zero :: ?M1883) (list_repeat Zero ?M1882 ++ One :: ?M1883)\" with \"{m : list bool | list_bool_succ (b :: l') m}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last."], "tactic": "*", "exn": "[Focus] Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exists (One :: nil)."], "tactic": "apply in_lbs_1.", "exn": "In environment H1 : bool X0 : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} H0 : forall k : nat, list_bool_succ (list_repeat One k) (Zero :: list_repeat Zero k) b : bool X : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} l' : list bool z : ZMicromega.ZWitness z0 : ZMicromega.ZArithProof Unable to unify \"list_bool_succ (list_repeat One ?M2234) (list_repeat Zero (S ?M2234))\" with \"list_bool_succ (b :: l') (One :: nil)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exfalso."], "tactic": "apply (list_bool_succ_neq_nil (Zero :: l')).", "exn": "In environment H1 : bool X0 : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} H0 : forall k : nat, list_bool_succ (list_repeat One k) (Zero :: list_repeat Zero k) b : bool X : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} l' : list bool z : ZMicromega.ZWitness z0 : ZMicromega.ZArithProof The term \"Zero :: l'\" has type \"list bool\" while it is expected to have type \"list_bool_succ ?l nil\".", "type": "wrong_type", "handled": true}, {"ctx": ["destruct l as [| b l'].", "-", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1.", "shelve.", "-", "destruct b.", "+", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "qsimpl time: 1 use: in_lbs_1,bool,exists_last,true.", "destruct ZMicromega.DoneProof.", "*", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exists (One :: nil).", "qsimpl time: 1 use: in_lbs_1,bool,true,in_lbs_0,exists_last.", "shelve.", "*", "exfalso.", "qsimpl time: 1 use: in_lbs_1,bool,true,Zero,in_lbs_0,exists_last,list_bool_succ_neq_nil."], "tactic": "apply in_lbs_0.", "exn": "In environment H3 : forall l : list bool, list_bool_succ l nil -> False X1 : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} b1, b0 : bool H2 : forall (k : nat) (l : list bool), list_bool_succ (list_repeat b0 k ++ b1 :: l) (list_repeat b1 k ++ b0 :: l) H : forall k : nat, list_bool_succ (list_repeat One k) (Zero :: list_repeat Zero k) H1 : bool X0 : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} b : bool X : forall (A : Type) (l : list A), (l = nil -> False) -> {l' : list A & {a : A | l = l' ++ a :: nil}} l' : list bool z : ZMicromega.ZWitness z0 : ZMicromega.ZArithProof Unable to unify \"list_bool_succ (list_repeat One ?M2954 ++ Zero :: ?M2955) (list_repeat Zero ?M2954 ++ One :: ?M2955)\" with \"False\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "destruct l as [| b l']. - exists (One :: nil). apply in_lbs_1. - destruct b. + destruct (exists_last bool (true :: l')) as [ll [a Hl]]. { intros C. inversion C. } rewrite Hl. destruct a. * exists (list_repeat Zero (S (length ll)) ++ One :: nil). rewrite <- Hl. apply in_lbs_0. * exists (One :: nil). apply in_lbs_1. + exfalso. apply (list_bool_succ_neq_nil (Zero :: l')). apply in_lbs_0.", "back_times": 0, "succ": false, "time": 127.29297852516174}]