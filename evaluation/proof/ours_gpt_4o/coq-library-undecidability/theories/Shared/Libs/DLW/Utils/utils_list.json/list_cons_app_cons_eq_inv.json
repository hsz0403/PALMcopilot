[{"history": {"proof": "intro H. qsimpl time: 1 use: list_app_cons_eq_inv. sauto depth: 3.", "repairs": ["", "cannot_apply_in", "hammer"], "exceptions": [{"ctx": ["intro H."], "tactic": "apply list_app_cons_eq_inv in H.", "exn": "Unable to apply lemma of type \"forall (X : Type) (l1 l2 r1 r2 : list X) (x : X), l1 ++ r1 = l2 ++ x :: r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ x :: r2} + {m : list X | l2 ++ x :: m = l1 /\\\\ r2 = m ++ r1}\" on hypothesis of type \"x :: r1 = l2 ++ y :: r2\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intro H.", "qsimpl time: 1 use: list_app_cons_eq_inv."], "tactic": ["destruct H as [[m [H1 H2]] | [m [H1 H2]]].", ""], "exn": "Expects a disjunctive pattern with 1 branch or a conjunctive pattern made of 0 patterns.", "type": "num_branch_both", "handled": false}]}, "chat": [], "original": "intro H. apply list_app_cons_eq_inv in H. destruct H as [[m [H1 H2]] | [m [H1 H2]]]. - destruct l2. + simpl in H1. subst. left. auto. + right. exists l2. split. auto. subst. auto. - right. exists (m ++ y :: nil). split; subst; auto.", "back_times": 0, "succ": true, "time": 3.1186087131500244}]