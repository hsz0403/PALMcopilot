[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": ["destruct (list_bool_choose lb) as [[k' [tl [Heq |]]] | [k' Heq]].", ""], "exn": "Expects a disjunctive pattern with 1 branch or a conjunctive pattern made of 0 patterns.", "type": "num_branch_both", "handled": false}]}, "chat": [], "original": "destruct (list_bool_choose lb) as [[k' [tl [Heq |]]] | [k' Heq]]. - left. exists (k' :: nil). exists tl. split. + rewrite Heq. simpl. reflexivity. + constructor. * simpl. apply le_n. * constructor. - destruct (Exists_Forall_neg nat (fun x => k' < x) (k' :: nil)) as [Hex | Hfa]. + intros x. destruct (le_lt_dec k' x); auto. + left. exists nil. exists (list_repeat Zero (S k')). split. * rewrite Heq. simpl. reflexivity. * simpl. constructor. apply le_n. + right. exists nil. exists k'. split. * rewrite Heq. simpl. reflexivity. * constructor.", "back_times": 0, "succ": false, "time": 26.285325527191162}]