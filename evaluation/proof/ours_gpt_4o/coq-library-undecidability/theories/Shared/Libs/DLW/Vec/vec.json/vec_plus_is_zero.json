[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["revert u v."], "tactic": ["induction n; intros.", ""], "exn": "Abstracting over the term \"n0\" leads to a term fun n1 : nat => forall u v : vec nat n1, vec_zero = vec_plus u v -> u = vec_zero /\\\\ v = vec_zero which is ill-typed. Reason is: Illegal application: The term \"vec_plus\" of type \"vec nat n -> vec nat n -> vec nat n\" cannot be applied to the terms \"u\" : \"vec nat n1\" \"v\" : \"vec nat n1\" The 1st term has type \"vec nat n1\" which should be coercible to \"vec nat n\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "revert u v. induction n; intros. -- repeat rewrite VectorSpec.eta. split; apply Vector.t_ind; auto. -- replace (S n) with (n + 1) in H by lia. rewrite (VectorSpec.splitat_append v u) in H. apply pair_equal_spec in H as [H1 H2]. repeat rewrite VectorSpec.eta in H1, H2. destruct (vec_cons_inv _ _ _ _ _ _ H1) as [H3 H4]. destruct (vec_cons_inv _ _ _ _ _ _ H2) as [H5 H6]. split; apply IHn; auto.", "back_times": 0, "succ": false, "time": 47.2559540271759}]