[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intros H."], "tactic": "apply Zp_invertible_prime in H as Hinv.", "exn": "Unable to apply lemma of type \"forall x, prime p -> Zp_invertible x <-> x <> Zp\" on hypothesis of type \"inv x = x\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left."], "tactic": "apply Zp_invert_eq_not_zero.", "exn": "In environment p : nat Hp : p = 0%nat -> False Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp = Op -> False H : inv Zp = Zp H0 : forall x, prime p -> (x = Zp -> False) -> Zp_invertible x H1 : forall x, prime p -> Zp_invertible x -> x = Zp -> False H2 : forall x y, x <> Zp -> inv x = y -> y \u2297 x = Op Unable to unify \"?M2222 \u2297 ?M2221 = Op\" with \"Zp = Zp\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime."], "tactic": "auto.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left."], "tactic": "apply Zp_invert_eq_not_zero.", "exn": "In environment p : nat Hp : p = 0%nat -> False Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp = Op -> False H : inv Op = Op H0 : forall x, prime p -> (x = Zp -> False) -> Zp_invertible x H1 : forall x, prime p -> Zp_invertible x -> x = Zp -> False H2 : forall x y, x <> Zp -> inv x = y -> y \u2297 x = Op Unable to unify \"?M2255 \u2297 ?M2254 = Op\" with \"Op = Op\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime."], "tactic": "auto.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry."], "tactic": "apply Zp_invert_eq_not_zero.", "exn": "In environment p : nat Hp : p = 0%nat -> False Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp = Op -> False H : inv (\u2238 Op) = \u2238 Op H0 : forall x, prime p -> (x = Zp -> False) -> Zp_invertible x H1 : forall x, prime p -> Zp_invertible x -> x = Zp -> False H2 : forall x y, x <> Zp -> inv x = y -> y \u2297 x = Op Unable to unify \"?M2292 \u2297 ?M2291 = Op\" with \"exist (fun x : nat => (x < p)%nat) (rem (p - rem 1 p) p) (div_rem_spec2 (p - rem 1 p) Hp) = \u2238 Op\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime."], "tactic": "auto.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm]."], "tactic": "pose proof (Zp_prime_invert Hp' Hinv) as [i Hi].", "exn": "The reference Hinv was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm]."], "tactic": "pose proof (Zp_invertible_eq_zero i x Hinv Hi) as Hy.", "exn": "The reference Hi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm]."], "tactic": "apply Zp_prime_integral in Hy as [Hy | Hy].", "exn": "No such hypothesis: Hy", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one."], "tactic": "reflexivity.", "exn": "In environment p : nat Hp : p = 0%nat -> False H4 : forall x y, prime p -> x \u2297 y = Zp -> x = Zp \\\\/ y = Zp Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp = Op -> False m : nat H : inv (exist (fun x : nat => (x < p)%nat) (rem m p) (div_rem_spec2 m Hp)) = exist (fun x : nat => (x < p)%nat) (rem m p) (div_rem_spec2 m Hp) H0 : forall x, prime p -> (x = Zp -> False) -> Zp_invertible x H1 : forall x, prime p -> Zp_invertible x -> x = Zp -> False H2 : forall x y, (x = Zp -> False) -> y \u2297 x = Op -> inv x = y H5 : forall x y, (x = Zp -> False) -> inv x = y -> y \u2297 x = Op Unable to unify \"Op\" with \"Zp\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso."], "tactic": "apply Hy.", "exn": "The reference Hy was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp."], "tactic": "apply Hm.", "exn": "The reference Hm was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero."], "tactic": "reflexivity.", "exn": "In environment p : nat Hp : p <> 0%nat Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp <> Op Unable to unify \"Op\" with \"Zp \u2297 Zp\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero."], "tactic": "apply Zp_neq_opposite_not_zero.", "exn": "The reference Zp_neq_opposite_not_zero was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero.", "apply Zp_invert_eq_not_zero."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero.", "apply Zp_invert_eq_not_zero.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "subst.", "symmetry."], "tactic": "apply Zp_invert_eq_not_zero.", "exn": "In environment p : nat Hp : p <> 0%nat Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp <> Op H : forall x y, x <> Zp -> inv x = y -> y \u2297 x = Op Unable to unify \"?M3691 \u2297 ?M3690 = Op\" with \"Op = inv Op\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero.", "apply Zp_invert_eq_not_zero.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "subst.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral."], "tactic": "apply Zp_neq_opposite_not_zero.", "exn": "The reference Zp_neq_opposite_not_zero was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero.", "apply Zp_invert_eq_not_zero.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "subst.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "apply Zp_inj."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero.", "apply Zp_invert_eq_not_zero.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "subst.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "apply Zp_inj.", "shelve.", "+", "subst.", "symmetry."], "tactic": "apply Zp_invert_eq_not_zero.", "exn": "In environment p : nat Hp : p <> 0%nat Hp' : prime p Hp'' : (2 <= p)%nat Hzero_one : Zp <> Op H : forall x y, x <> Zp -> inv x = y -> y \u2297 x = Op Unable to unify \"?M4377 \u2297 ?M4376 = Op\" with \"\u2238 Op = inv (\u2238 Op)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "qsimpl time: 1 use: Zp_invertible_prime.", "destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]].", "+", "subst.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "left.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "subst.", "right.", "right.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime.", "+", "destruct Hm as [_ Hm].", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "exfalso.", "apply Hzero_one.", "exfalso.", "apply Hp.", "apply prime_rect.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "intros [Hx | [Hx | Hx]].", "+", "subst.", "rewrite Zp_invert_eq_not_zero.", "apply Zp_invert_eq_not_zero.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "subst.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral.", "apply Zp_inj.", "shelve.", "+", "subst.", "symmetry.", "qsimpl time: 1 use: Zp_invert_eq_not_zero,Zp_invertible_prime,Zp_prime_integral."], "tactic": "apply Zp_neq_opposite_not_zero.", "exn": "The reference Zp_neq_opposite_not_zero was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "split. - intros H. apply Zp_invertible_prime in H as Hinv. destruct (nat2Zp_choose x) as [Hx | [Hx | [Hx | [m Hm]]]]. + subst. left. symmetry. apply Zp_invert_eq_not_zero. auto. apply Hinv. + subst. right. left. symmetry. apply Zp_invert_eq_not_zero. auto. apply Hinv. + subst. right. right. symmetry. apply Zp_invert_eq_not_zero. auto. apply Hinv. + destruct Hm as [_ Hm]. pose proof (Zp_prime_invert Hp' Hinv) as [i Hi]. pose proof (Zp_invertible_eq_zero i x Hinv Hi) as Hy. apply Zp_prime_integral in Hy as [Hy | Hy]. * exfalso. apply Hzero_one. subst. reflexivity. * exfalso. apply Hy. apply Hm. - intros [Hx | [Hx | Hx]]. + subst. rewrite Zp_invert_eq_not_zero. reflexivity. apply Zp_neq_opposite_not_zero. + subst. symmetry. apply Zp_invert_eq_not_zero. apply Zp_neq_opposite_not_zero. + subst. symmetry. apply Zp_invert_eq_not_zero. apply Zp_neq_opposite_not_zero.", "back_times": 3, "succ": false, "time": 1414.011299610138}]