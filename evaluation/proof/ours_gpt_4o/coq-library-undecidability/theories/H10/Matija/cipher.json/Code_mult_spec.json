[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso."], "tactic": ["apply Nat.nlt_0_r with (l := l).", ""], "exn": "No such bound variable l (possible name is: n).", "type": "no_such_bound", "handled": false}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+"], "tactic": "assert (Hmatch: cb * cc \u21e3 (r' * v1) = ca * v \u21e3 (r' * v1)) by (rewrite Hp1; assumption).", "exn": "Found no subterm matching \"p\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: auto,Nat,nlt_0_r.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: Nat,nlt_0_r.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+"], "tactic": "qsimpl time: 1 use: nlt_0_r.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "clear Hp1.", "exn": "No such hypothesis: Hp1", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "qsimpl time: 1 use: auto,Nat,nlt_0_r.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "qsimpl time: 1 use: Nat,nlt_0_r.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "qsimpl time: 1 use: nlt_0_r.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "assert (Hl_pos : 0 < l) by (contradict Hl; intro Hl0; apply Nat.neq_succ_0; symmetry; assumption).", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "apply is_cipher_of_equiv in Ha as HA; try auto.", "exn": "No such hypothesis: Ha", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "qsimpl time: 1 use: auto,Nat,nlt_0_r,is_cipher_of_equiv.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "qsimpl time: 1 use: Nat,nlt_0_r,is_cipher_of_equiv.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1."], "tactic": "qsimpl time: 1 use: nlt_0_r,is_cipher_of_equiv.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "apply is_cipher_of_equiv in Hb as HB; try auto.", "exn": "No such hypothesis: Hb", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: auto,Nat,nlt_0_r,is_cipher_of_equiv.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: Nat,nlt_0_r,is_cipher_of_equiv.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: nlt_0_r,is_cipher_of_equiv.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "apply is_cipher_of_equiv in Hc as HC; try auto.", "exn": "No such hypothesis: Hc", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: auto,Nat,nlt_0_r,is_cipher_of_equiv.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: Nat,nlt_0_r,is_cipher_of_equiv.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: nlt_0_r,is_cipher_of_equiv.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "apply cipher_mult_eq in Hp2 as Hmult; eauto.", "exn": "Unable to apply lemma of type \"forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((r - 1) * u1) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) r)\" on hypothesis of type \"\u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,Nat,nlt_0_r,is_cipher_of_equiv,auto.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,nlt_0_r,is_cipher_of_equiv,auto.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv,auto.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv."], "tactic": "intros i Hi.", "exn": "i is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv."], "tactic": "intros i' Hi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv."], "tactic": "apply power_decomp_unique with (p := power q 2) (f := fun i => power (S (S i)) r).", "exn": "In environment l, q : nat H4 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hl : l = 0 -> False r' : nat Hr'_eq : power (q + (q + (q + (q + 0)))) 2 = r' + 1 Hp2 : \u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) i : nat H : i < l H0 : l + 1 < q H3 : forall i : nat, i < l -> c i < power q 2 H5 : forall i : nat, i < l -> b i < power q 2 H7 : forall i : nat, i < l -> a i < power q 2 H1 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i Unable to unify \"c i\" with \"i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,auto.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique."], "tactic": "intros i j Hij.", "exn": "i is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique."], "tactic": "intros i' j Hij.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique."], "tactic": "apply Nat.lt_trans with (power i (power (S (S 0)) r)); try apply power_lt_base.", "exn": "In environment n : nat -> nat H11 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i l, q, H9 : nat H6 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hl : l = 0 -> False r' : nat Hr'_eq : power (q + (q + (q + (q + 0)))) 2 = r' + 1 Hp2 : \u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) i : nat H : i < l H0 : l + 1 < q H3 : forall i : nat, i < l -> c i < power q 2 H5 : forall i : nat, i < l -> b i < power q 2 H7 : forall i : nat, i < l -> a i < power q 2 H1 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H8 : nat Unable to unify \"S ?M7525 <= ?M7527\" with \"a i = b i * c i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "apply power_lt; try lia.", "exn": "The reference power_lt was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "intros i Hi.", "exn": "i is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "intros i' Hi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "apply Hc in Hi.", "exn": "No such hypothesis: Hi", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "rewrite <- Nat.add_1_r.", "exn": "Found no subterm matching \"S ?M12420\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "rewrite Nat.add_1_r.", "exn": "Found no subterm matching \"?M15609 + 1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "apply Nat.lt_le_trans with (power q 2).", "exn": "In environment H25 : forall n m p : nat, n < m -> m < p -> n < p n3 : nat -> nat H24 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q, H20 : nat H6 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n2 : nat -> nat H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H17 : nat n1 : nat -> nat H18 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H16 : nat n0 : nat -> nat H14 : forall p : nat, n0 (n0 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n0 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n0 0) (f i) p) -> forall i : nat, i < n -> a i = b i H12 : nat n : nat -> nat H11 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i H9 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hl : l = 0 -> False r' : nat Hr'_eq : power (q + (q + (q + (q + 0)))) 2 = r' + 1 Hp2 : \u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) i : nat H : i < l H0 : l + 1 < q H3 : forall i : nat, i < l -> c i < power q 2 H5 : forall i : nat, i < l -> b i < power q 2 H7 : forall i : nat, i < l -> a i < power q 2 H1 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H8, H10, H13, H15, H19 : nat Unable to unify \"S ?M19311 <= ?M19313\" with \"a i = b i * c i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "apply le_n_S, power_le_base; lia.", "exn": "In environment H29 : forall n m p : nat, n < m -> m < p -> n < p n4 : nat -> nat H28 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q, H26 : nat H23 : forall n m p : nat, n < m -> m <= p -> n < p H4 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n3 : nat -> nat H24 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H20 : nat n2 : nat -> nat H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H17 : nat n1 : nat -> nat H18 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H16 : nat n0 : nat -> nat H14 : forall p : nat, n0 (n0 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n0 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n0 0) (f i) p) -> forall i : nat, i < n -> a i = b i H12 : nat n : nat -> nat H11 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i H9 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hl : l = 0 -> False r' : nat Hr'_eq : power (q + (q + (q + (q + 0)))) 2 = r' + 1 Hp2 : \u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) i : nat H : i < l H0 : l + 1 < q H3 : forall i : nat, i < l -> c i < power q 2 H5 : forall i : nat, i < l -> b i < power q 2 H7 : forall i : nat, i < l -> a i < power q 2 H1 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H8, H10, H13, H15, H19, H22 : nat Unable to unify \"S ?M23670 <= S ?M23671\" with \"a i = b i * c i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "intros i Hi.", "exn": "i is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "intros i' Hi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Hb in Hi.", "exn": "No such hypothesis: Hi", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Nat.lt_le_trans with (power q 2); try auto.", "exn": "In environment H38 : forall n m p : nat, n < m -> m < p -> n < p n6 : nat -> nat H37 : forall n m : nat, n <= m -> n6 n <= n6 m H36 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q, H31 : nat H29 : forall n m p : nat, n < m -> m <= p -> n < p H4 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n5 : nat -> nat H33 : forall n m : nat, n <= m -> n5 n <= n5 m H32 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H30 : nat n4 : nat -> nat H28 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H26 : nat n3 : nat -> nat H24 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H20 : nat n2 : nat -> nat H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H17 : nat n1 : nat -> nat H18 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H16 : nat n0 : nat -> nat H14 : forall p : nat, n0 (n0 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n0 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n0 0) (f i) p) -> forall i : nat, i < n -> a i = b i H12 : nat n : nat -> nat H11 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i H9 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hl : l = 0 -> False r' : nat Hr'_eq : power (q + (q + (q + (q + 0)))) 2 = r' + 1 Hp2 : \u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) i : nat H : i < l H0 : l + 1 < q H3 : forall i : nat, i < l -> c i < power q 2 H5 : forall i : nat, i < l -> b i < power q 2 H7 : forall i : nat, i < l -> a i < power q 2 H1 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H8, H10, H13, H15, H19, H22, H25, H23 : nat Unable to unify \"S ?M34711 <= ?M34713\" with \"a i = b i * c i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply le_n_S, power_le_base.", "exn": "In environment H42 : forall n m p : nat, n < m -> m < p -> n < p n7 : nat -> nat H41 : forall n m : nat, n <= m -> n7 n <= n7 m H40 : forall p : nat, n7 (n7 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n7 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n7 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q, H35 : nat H34 : forall n m p : nat, n < m -> m <= p -> n < p H6 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n6 : nat -> nat H37 : forall n m : nat, n <= m -> n6 n <= n6 m H36 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i H31 : nat n5 : nat -> nat H33 : forall n m : nat, n <= m -> n5 n <= n5 m H32 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H30 : nat n4 : nat -> nat H28 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H26 : nat n3 : nat -> nat H24 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H20 : nat n2 : nat -> nat H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H17 : nat n1 : nat -> nat H18 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H16 : nat n0 : nat -> nat H14 : forall p : nat, n0 (n0 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n0 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n0 0) (f i) p) -> forall i : nat, i < n -> a i = b i H12 : nat n : nat -> nat H11 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i H9 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hl : l = 0 -> False r' : nat Hr'_eq : power (q + (q + (q + (q + 0)))) 2 = r' + 1 Hp2 : \u2211 l (fun i : nat => a i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) * \u2211 l (fun i : nat => c i * power (power (S i) 2) (power (q + (q + (q + (q + 0)))) 2)) \u21e3 (r' * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) i : nat H : i < l H0 : l + 1 < q H3 : forall i : nat, i < l -> c i < power q 2 H5 : forall i : nat, i < l -> b i < power q 2 H7 : forall i : nat, i < l -> a i < power q 2 H1 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H8, H10, H13, H15, H19, H22, H25, H23, H27 : nat Unable to unify \"S ?M41305 <= S ?M41306\" with \"a i = b i * c i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l)."], "tactic": "split; [reflexivity | split].", "exn": "In environment l, q : nat Hr : 1 < q -> 4 <= r a, b, c : nat -> nat ca, cb, cc : nat Ha : is_cipher_of a ca Hb : is_cipher_of b cb Hc : is_cipher_of c cc Hall : forall i : nat, i < l -> a i = b i * c i Hl : l <> 0 Unable to unify \"r\" with \"1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l)."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l)."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l)."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l)."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*"], "tactic": "apply Nat.add_1_r.", "exn": "In environment H5 : forall n m p : nat, n < m -> m < p -> n < p n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i l, q, n0 : nat H1 : forall n m p : nat, n < m -> m <= p -> n < p H : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 Unable to unify \"?M69210 + 1 = S ?M69210\" with \"n 0 = n0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "*", "exn": "[Focus] Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*"], "tactic": "split.", "exn": "In environment H5 : forall n m p : nat, n < m -> m < p -> n < p n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i l, q, n0 : nat H1 : forall n m p : nat, n < m -> m <= p -> n < p H : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 Unable to unify \"l * l + n 0\" with \"n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*"], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply const_u1_meet with (f := power (S (S l))) (w := \u2211 S l (fun i => power i (power (4 * q) 2))); try auto.", "exn": "In environment H18 : forall n m p : nat, n < m -> m < p -> n < p n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q, H14 : nat H12 : forall n m p : nat, n < m -> m <= p -> n < p H8 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10 : nat The term \"S\" has type \"nat -> nat\" while it is expected to have type \"nat\".", "type": "wrong_type", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Hr.", "exn": "In environment H23 : forall n m p : nat, n < m -> m < p -> n < p n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat H5 : forall n m p : nat, n < m -> m <= p -> n < p H : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1 : nat Unable to unify \"4 <= power (q + (q + (q + (q + 0)))) 2\" with \"n 0 = l * l + n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "intros i.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "specialize (Hall i).", "exn": "The reference i was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "rewrite Hall.", "exn": "Found no subterm matching \"a ?M81327\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "intros j.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "specialize (Hall j).", "exn": "The reference j was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "cbn; intros _ _; apply power_lt; lia.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "destruct (Nat.lt_dec l j).", "exn": "The reference Nat.lt_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Hall.", "exn": "In environment H33 : forall n m p : nat, n < m -> m < p -> n < p n4 : nat -> nat H32 : forall n m : nat, n <= m -> n4 n <= n4 m H31 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H29 : forall l q : nat, 0 < l -> l + n4 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n4 (n4 0) * m < mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n4 0) i (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> n4 (n4 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> p = u * u \u21e3 w) H25 : nat H23 : forall n m p : nat, n < m -> m <= p -> n < p H : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n3 : nat -> nat H27 : forall n m : nat, n <= m -> n3 n <= n3 m H26 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H24 : forall l q : nat, 0 < l -> l + n3 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n3 (n3 0) * m < mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n3 0) i (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> n3 (n3 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> p = u * u \u21e3 w) H20 : nat n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1, H12, H5 : nat Unable to unify \"a ?M86573 = b ?M86573 * c ?M86573\" with \"n 0 = l * l + n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Nat.lt_lt_succ_r in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Hall.", "exn": "In environment H43 : forall n m p : nat, n < m -> m < p -> n < p n6 : nat -> nat H42 : forall n m : nat, n <= m -> n6 n <= n6 m H41 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H39 : forall l q : nat, 0 < l -> l + n6 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n6 (n6 0) * m < mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n6 0) i (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> n6 (n6 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> p = u * u \u21e3 w) H35 : nat H33 : forall n m p : nat, n < m -> m <= p -> n < p H : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n5 : nat -> nat H37 : forall n m : nat, n <= m -> n5 n <= n5 m H36 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H34 : forall l q : nat, 0 < l -> l + n5 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n5 (n5 0) * m < mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n5 0) i (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> n5 (n5 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> p = u * u \u21e3 w) H30 : nat n4 : nat -> nat H32 : forall n m : nat, n <= m -> n4 n <= n4 m H31 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H29 : forall l q : nat, 0 < l -> l + n4 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n4 (n4 0) * m < mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n4 0) i (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> n4 (n4 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> p = u * u \u21e3 w) H25 : nat n3 : nat -> nat H27 : forall n m : nat, n <= m -> n3 n <= n3 m H26 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H24 : forall l q : nat, 0 < l -> l + n3 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n3 (n3 0) * m < mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n3 0) i (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> n3 (n3 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> p = u * u \u21e3 w) H20 : nat n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1, H12, H5, H18, H23 : nat Unable to unify \"a ?M100198 = b ?M100198 * c ?M100198\" with \"n 0 = l * l + n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Hr, Hp2; lia.", "exn": "In environment H48 : forall n m p : nat, n < m -> m < p -> n < p n7 : nat -> nat H47 : forall n m : nat, n <= m -> n7 n <= n7 m H46 : forall p : nat, n7 (n7 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n7 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n7 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H44 : forall l q : nat, 0 < l -> l + n7 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n7 (n7 0) * m < mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n7 0) i (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> n7 (n7 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> p = u * u \u21e3 w) H40 : nat H38 : forall n m p : nat, n < m -> m <= p -> n < p H8 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n6 : nat -> nat H42 : forall n m : nat, n <= m -> n6 n <= n6 m H41 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i H39 : forall l q : nat, 0 < l -> l + n6 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n6 (n6 0) * m < mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n6 0) i (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> n6 (n6 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> p = u * u \u21e3 w) H35 : nat n5 : nat -> nat H37 : forall n m : nat, n <= m -> n5 n <= n5 m H36 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H34 : forall l q : nat, 0 < l -> l + n5 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n5 (n5 0) * m < mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n5 0) i (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> n5 (n5 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> p = u * u \u21e3 w) H30 : nat n4 : nat -> nat H32 : forall n m : nat, n <= m -> n4 n <= n4 m H31 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H29 : forall l q : nat, 0 < l -> l + n4 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n4 (n4 0) * m < mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n4 0) i (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> n4 (n4 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> p = u * u \u21e3 w) H25 : nat n3 : nat -> nat H27 : forall n m : nat, n <= m -> n3 n <= n3 m H26 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H24 : forall l q : nat, 0 < l -> l + n3 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n3 (n3 0) * m < mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n3 0) i (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> n3 (n3 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> p = u * u \u21e3 w) H20 : nat n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1, H12, H5, H18, H23, H28 : nat Unable to unify \"4 <= power (q + (q + (q + (q + 0)))) 2\" with \"n 0 = l * l + n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "apply Ha.", "exn": "The reference Ha was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "specialize (Hall i Hi).", "exn": "The reference Hi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "rewrite Hall.", "exn": "Found no subterm matching \"a ?M118187\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "rewrite Ha; rewrite Hb; rewrite Hc.", "exn": "The reference Ha was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "reflexivity.", "exn": "In environment H58 : forall n m p : nat, n < m -> m < p -> n < p n9 : nat -> nat H57 : forall n m : nat, n <= m -> n9 n <= n9 m H56 : forall p : nat, n9 (n9 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n9 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n9 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H54 : forall l q : nat, 0 < l -> l + n9 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n9 (n9 0) * m < mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n9 0) i (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> n9 (n9 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (n9 (n9 0) * f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (n9 (n9 0) * f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> p = u * u \u21e3 w) H50 : nat H48 : forall n m p : nat, n < m -> m <= p -> n < p H8 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n8 : nat -> nat H52 : forall n m : nat, n <= m -> n8 n <= n8 m H51 : forall p : nat, n8 (n8 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n8 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n8 0) (f i) p) -> forall i : nat, i < n -> a i = b i H49 : forall l q : nat, 0 < l -> l + n8 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n8 (n8 0) * m < mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n8 0) i (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> n8 (n8 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (n8 (n8 0) * f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (n8 (n8 0) * f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> p = u * u \u21e3 w) H45 : nat n7 : nat -> nat H47 : forall n m : nat, n <= m -> n7 n <= n7 m H46 : forall p : nat, n7 (n7 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n7 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n7 0) (f i) p) -> forall i : nat, i < n -> a i = b i H44 : forall l q : nat, 0 < l -> l + n7 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n7 (n7 0) * m < mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n7 0) i (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> n7 (n7 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> p = u * u \u21e3 w) H40 : nat n6 : nat -> nat H42 : forall n m : nat, n <= m -> n6 n <= n6 m H41 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i H39 : forall l q : nat, 0 < l -> l + n6 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n6 (n6 0) * m < mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n6 0) i (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> n6 (n6 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> p = u * u \u21e3 w) H35 : nat n5 : nat -> nat H37 : forall n m : nat, n <= m -> n5 n <= n5 m H36 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H34 : forall l q : nat, 0 < l -> l + n5 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n5 (n5 0) * m < mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n5 0) i (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> n5 (n5 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> p = u * u \u21e3 w) H30 : nat n4 : nat -> nat H32 : forall n m : nat, n <= m -> n4 n <= n4 m H31 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H29 : forall l q : nat, 0 < l -> l + n4 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n4 (n4 0) * m < mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n4 0) i (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> n4 (n4 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> p = u * u \u21e3 w) H25 : nat n3 : nat -> nat H27 : forall n m : nat, n <= m -> n3 n <= n3 m H26 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H24 : forall l q : nat, 0 < l -> l + n3 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n3 (n3 0) * m < mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n3 0) i (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> n3 (n3 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> p = u * u \u21e3 w) H20 : nat n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1, H12, H5, H18, H23, H28, H33, H38 : nat Unable to unify \"l * l + n 0\" with \"n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "exists ca.", "exn": "The reference ca was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "split.", "exn": "In environment H58 : forall n m p : nat, n < m -> m < p -> n < p n9 : nat -> nat H57 : forall n m : nat, n <= m -> n9 n <= n9 m H56 : forall p : nat, n9 (n9 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n9 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n9 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H54 : forall l q : nat, 0 < l -> l + n9 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n9 (n9 0) * m < mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n9 0) i (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> n9 (n9 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (n9 (n9 0) * f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (n9 (n9 0) * f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> p = u * u \u21e3 w) H50 : nat H48 : forall n m p : nat, n < m -> m <= p -> n < p H8 : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n8 : nat -> nat H52 : forall n m : nat, n <= m -> n8 n <= n8 m H51 : forall p : nat, n8 (n8 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n8 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n8 0) (f i) p) -> forall i : nat, i < n -> a i = b i H49 : forall l q : nat, 0 < l -> l + n8 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n8 (n8 0) * m < mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n8 0) i (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> n8 (n8 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (n8 (n8 0) * f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (n8 (n8 0) * f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> p = u * u \u21e3 w) H45 : nat n7 : nat -> nat H47 : forall n m : nat, n <= m -> n7 n <= n7 m H46 : forall p : nat, n7 (n7 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n7 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n7 0) (f i) p) -> forall i : nat, i < n -> a i = b i H44 : forall l q : nat, 0 < l -> l + n7 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n7 (n7 0) * m < mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n7 0) i (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> n7 (n7 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> p = u * u \u21e3 w) H40 : nat n6 : nat -> nat H42 : forall n m : nat, n <= m -> n6 n <= n6 m H41 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i H39 : forall l q : nat, 0 < l -> l + n6 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n6 (n6 0) * m < mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n6 0) i (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> n6 (n6 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> p = u * u \u21e3 w) H35 : nat n5 : nat -> nat H37 : forall n m : nat, n <= m -> n5 n <= n5 m H36 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H34 : forall l q : nat, 0 < l -> l + n5 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n5 (n5 0) * m < mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n5 0) i (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> n5 (n5 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> p = u * u \u21e3 w) H30 : nat n4 : nat -> nat H32 : forall n m : nat, n <= m -> n4 n <= n4 m H31 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H29 : forall l q : nat, 0 < l -> l + n4 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n4 (n4 0) * m < mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n4 0) i (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> n4 (n4 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> p = u * u \u21e3 w) H25 : nat n3 : nat -> nat H27 : forall n m : nat, n <= m -> n3 n <= n3 m H26 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H24 : forall l q : nat, 0 < l -> l + n3 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n3 (n3 0) * m < mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n3 0) i (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> n3 (n3 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> p = u * u \u21e3 w) H20 : nat n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1, H12, H5, H18, H23, H28, H33, H38 : nat Unable to unify \"l * l + n 0\" with \"n 0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,lia,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,Nat,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,nlt_0_r,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference nlt_0_r was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,auto,le_n_S,lt_trans.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "intros H.", "destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]].", "+", "intros i Hi.", "exfalso.", "shelve.", "+", "qsimpl time: 1.", "qsimpl time: 1 use: is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,is_cipher_of_equiv.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "-", "intros Hall.", "destruct (Nat.eq_dec l 0) as [H0 | Hl].", "+", "left.", "auto.", "+", "right.", "split.", "auto.", "exists (S l), (S l), (l * l), 1, (ca * S l).", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "shelve.", "*", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans.", "qsimpl time: 1 use: cipher_mult_eq,power,lt_le_trans,S,r,const_u1_meet,is_cipher_of_equiv,power_decomp_unique,le_n_S,lt_trans."], "tactic": "reflexivity.", "exn": "In environment H63 : forall n m p : nat, n < m -> m < p -> n < p n10 : nat -> nat H62 : forall n m : nat, n <= m -> n10 n <= n10 m H61 : forall p : nat, n10 (n10 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n10 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n10 0) (f i) p) -> forall i : nat, i < n -> a i = b i l, q : nat H59 : forall l q : nat, 0 < l -> l + n10 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n10 (n10 0) * m < mscal Init.Nat.mul (n10 0) (n10 (n10 (n10 (n10 0))) * q) (n10 (n10 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n10 0) i (mscal Init.Nat.mul (n10 0) (n10 (n10 (n10 (n10 0))) * q) (n10 (n10 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n10 0) (f i) (mscal Init.Nat.mul (n10 0) (n10 (n10 (n10 (n10 0))) * q) (n10 (n10 0)))) -> n10 (n10 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n10 0) (n10 (n10 0) * f i) (mscal Init.Nat.mul (n10 0) (n10 (n10 (n10 (n10 0))) * q) (n10 (n10 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n10 0) (n10 (n10 0) * f i) (mscal Init.Nat.mul (n10 0) (n10 (n10 (n10 (n10 0))) * q) (n10 (n10 0)))) -> p = u * u \u21e3 w) H55 : nat H53 : forall n m p : nat, n < m -> m <= p -> n < p H : forall (b c : nat -> nat) (cb cc : nat), is_cipher_of b cb -> is_cipher_of c cc -> cb * cc \u21e3 ((power (q + (q + (q + (q + 0)))) 2 - 1) * \u2211 l (fun i : nat => power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2))) = \u2211 l (fun i : nat => b i * c i * power (power (S (S i)) 2) (power (q + (q + (q + (q + 0)))) 2)) n9 : nat -> nat H57 : forall n m : nat, n <= m -> n9 n <= n9 m H56 : forall p : nat, n9 (n9 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n9 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n9 0) (f i) p) -> forall i : nat, i < n -> a i = b i H54 : forall l q : nat, 0 < l -> l + n9 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n9 (n9 0) * m < mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n9 0) i (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> n9 (n9 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (n9 (n9 0) * f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n9 0) (n9 (n9 0) * f i) (mscal Init.Nat.mul (n9 0) (n9 (n9 (n9 (n9 0))) * q) (n9 (n9 0)))) -> p = u * u \u21e3 w) H50 : nat n8 : nat -> nat H52 : forall n m : nat, n <= m -> n8 n <= n8 m H51 : forall p : nat, n8 (n8 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n8 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n8 0) (f i) p) -> forall i : nat, i < n -> a i = b i H49 : forall l q : nat, 0 < l -> l + n8 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n8 (n8 0) * m < mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n8 0) i (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> n8 (n8 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (n8 (n8 0) * f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n8 0) (n8 (n8 0) * f i) (mscal Init.Nat.mul (n8 0) (n8 (n8 (n8 (n8 0))) * q) (n8 (n8 0)))) -> p = u * u \u21e3 w) H45 : nat n7 : nat -> nat H47 : forall n m : nat, n <= m -> n7 n <= n7 m H46 : forall p : nat, n7 (n7 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n7 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n7 0) (f i) p) -> forall i : nat, i < n -> a i = b i H44 : forall l q : nat, 0 < l -> l + n7 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n7 (n7 0) * m < mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n7 0) i (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> n7 (n7 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n7 0) (n7 (n7 0) * f i) (mscal Init.Nat.mul (n7 0) (n7 (n7 (n7 (n7 0))) * q) (n7 (n7 0)))) -> p = u * u \u21e3 w) H40 : nat n6 : nat -> nat H42 : forall n m : nat, n <= m -> n6 n <= n6 m H41 : forall p : nat, n6 (n6 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n6 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n6 0) (f i) p) -> forall i : nat, i < n -> a i = b i H39 : forall l q : nat, 0 < l -> l + n6 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n6 (n6 0) * m < mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n6 0) i (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> n6 (n6 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n6 0) (n6 (n6 0) * f i) (mscal Init.Nat.mul (n6 0) (n6 (n6 (n6 (n6 0))) * q) (n6 (n6 0)))) -> p = u * u \u21e3 w) H35 : nat n5 : nat -> nat H37 : forall n m : nat, n <= m -> n5 n <= n5 m H36 : forall p : nat, n5 (n5 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n5 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n5 0) (f i) p) -> forall i : nat, i < n -> a i = b i H34 : forall l q : nat, 0 < l -> l + n5 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n5 (n5 0) * m < mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n5 0) i (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> n5 (n5 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n5 0) (n5 (n5 0) * f i) (mscal Init.Nat.mul (n5 0) (n5 (n5 (n5 (n5 0))) * q) (n5 (n5 0)))) -> p = u * u \u21e3 w) H30 : nat n4 : nat -> nat H32 : forall n m : nat, n <= m -> n4 n <= n4 m H31 : forall p : nat, n4 (n4 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n4 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n4 0) (f i) p) -> forall i : nat, i < n -> a i = b i H29 : forall l q : nat, 0 < l -> l + n4 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n4 (n4 0) * m < mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n4 0) i (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> n4 (n4 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n4 0) (n4 (n4 0) * f i) (mscal Init.Nat.mul (n4 0) (n4 (n4 (n4 (n4 0))) * q) (n4 (n4 0)))) -> p = u * u \u21e3 w) H25 : nat n3 : nat -> nat H27 : forall n m : nat, n <= m -> n3 n <= n3 m H26 : forall p : nat, n3 (n3 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n3 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n3 0) (f i) p) -> forall i : nat, i < n -> a i = b i H24 : forall l q : nat, 0 < l -> l + n3 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n3 (n3 0) * m < mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n3 0) i (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> n3 (n3 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n3 0) (n3 (n3 0) * f i) (mscal Init.Nat.mul (n3 0) (n3 (n3 (n3 (n3 0))) * q) (n3 (n3 0)))) -> p = u * u \u21e3 w) H20 : nat n2 : nat -> nat H22 : forall n m : nat, n <= m -> n2 n <= n2 m H21 : forall p : nat, n2 (n2 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n2 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n2 0) (f i) p) -> forall i : nat, i < n -> a i = b i H19 : forall l q : nat, 0 < l -> l + n2 0 < q -> forall (m k k' u w : nat) (f : nat -> nat), n2 (n2 0) * m < mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)) -> (forall i : nat, i < m -> f i <= k) -> (forall i j : nat, i < j < m -> f i < f j) -> w = \u2211 k' (fun i : nat => mscal Init.Nat.mul (n2 0) i (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> u = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> n2 (n2 0) * k < k' -> forall p : nat, (p = u * u \u21e3 w -> p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0))))) /\\\\ (p = \u2211 m (fun i : nat => mscal Init.Nat.mul (n2 0) (n2 (n2 0) * f i) (mscal Init.Nat.mul (n2 0) (n2 (n2 (n2 (n2 0))) * q) (n2 (n2 0)))) -> p = u * u \u21e3 w) H15 : nat n1 : nat -> nat H17 : forall n m : nat, n <= m -> n1 n <= n1 m H16 : forall p : nat, n1 (n1 0) <= p -> forall (n : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n -> f i < f j) -> (forall i : nat, i < n -> a i < p) -> (forall i : nat, i < n -> b i < p) -> \u2211 n (fun i : nat => a i * mscal Init.Nat.mul (n1 0) (f i) p) = \u2211 n (fun i : nat => b i * mscal Init.Nat.mul (n1 0) (f i) p) -> forall i : nat, i < n -> a i = b i H14 : nat n : nat -> nat H4 : forall n0 m : nat, n0 <= m -> n n0 <= n m H3 : forall p : nat, n (n 0) <= p -> forall (n0 : nat) (f a b : nat -> nat), (forall i j : nat, i < j < n0 -> f i < f j) -> (forall i : nat, i < n0 -> a i < p) -> (forall i : nat, i < n0 -> b i < p) -> \u2211 n0 (fun i : nat => a i * mscal Init.Nat.mul (n 0) (f i) p) = \u2211 n0 (fun i : nat => b i * mscal Init.Nat.mul (n 0) (f i) p) -> forall i : nat, i < n0 -> a i = b i n0 : nat Hr : 1 < q -> 4 <= power (q + (q + (q + (q + 0)))) 2 a, b, c : nat -> nat Hall : forall i : nat, i < l -> a i = b i * c i Hl : l = 0 -> False H0 : nat H2 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> (forall i : nat, i < l -> f1 i = f2 i) -> a = b H6 : forall (f1 f2 : nat -> nat) (a b : nat), is_cipher_of f1 a -> is_cipher_of f2 b -> a = b -> forall i : nat, i < l -> f1 i = f2 i H7 : l + 1 < q H9 : forall i : nat, i < l -> c i < power q 2 H11 : forall i : nat, i < l -> b i < power q 2 H13 : forall i : nat, i < l -> a i < power q 2 H10, H1, H12, H5, H18, H23, H28, H33, H38, H43 : nat Unable to unify \"l * l + n 0\" with \"n 0\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "split. - intros H. destruct H as [H0 | [Hl [v [v1 [r' [r'' [p [Hr_eq [Hr'_eq [Hseq [Hp1 Hp2]]]]]]]]]]]. + intros i Hi. exfalso. apply Nat.nlt_0_r with (l := l). auto. + assert (Hmatch: cb * cc \u21e3 (r' * v1) = ca * v \u21e3 (r' * v1)) by (rewrite Hp1; assumption). clear Hp1. assert (Hl_pos : 0 < l) by (contradict Hl; intro Hl0; apply Nat.neq_succ_0; symmetry; assumption). apply is_cipher_of_equiv in Ha as HA; try auto. apply is_cipher_of_equiv in Hb as HB; try auto. apply is_cipher_of_equiv in Hc as HC; try auto. apply cipher_mult_eq in Hp2 as Hmult; eauto. intros i Hi. apply power_decomp_unique with (p := power q 2) (f := fun i => power (S (S i)) r). * intros i j Hij. apply Nat.lt_trans with (power i (power (S (S 0)) r)); try apply power_lt_base. apply power_lt; try lia. * intros i Hi. apply Hc in Hi. rewrite <- Nat.add_1_r. rewrite Nat.add_1_r. apply Nat.lt_le_trans with (power q 2). auto. apply le_n_S, power_le_base; lia. * intros i Hi. apply Hb in Hi. apply Nat.lt_le_trans with (power q 2); try auto. apply le_n_S, power_le_base. lia. - intros Hall. destruct (Nat.eq_dec l 0) as [H0 | Hl]. + left. auto. + right. split. auto. exists (S l), (S l), (l * l), 1, (ca * S l). split; [reflexivity | split]. * apply Nat.add_1_r. * split. -- apply const_u1_meet with (f := power (S (S l))) (w := \u2211 S l (fun i => power i (power (4 * q) 2))); try auto. ++ apply Hr. intros i. specialize (Hall i). rewrite Hall. intros j. specialize (Hall j). cbn; intros _ _; apply power_lt; lia. ++ cbn; intros. destruct (Nat.lt_dec l j). ** apply Hall. apply Nat.lt_lt_succ_r in H. auto. ** apply Hall. auto. ++ cbn. apply Hr, Hp2; lia. ++ intros. apply Ha. ++ intros. specialize (Hall i Hi). rewrite Hall. rewrite Ha; rewrite Hb; rewrite Hc. reflexivity. -- exists ca. split. reflexivity. auto.", "back_times": 0, "succ": false, "time": 499.3582911491394}]