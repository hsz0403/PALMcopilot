[{"history": {"proof": "qsimpl time: 1 use: joinA.", "repairs": ["no_match_term"], "exceptions": [{"ctx": ["unfold W.", "rewrite /=."], "tactic": "rewrite !joinA.", "exn": "The LHS of joinA (_ \\\\+ (_ \\\\+ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold W.", "rewrite /=.", "qsimpl time: 1 use: joinA.", "rewrite [plab pc \\\\-> pc \\+ _]joinC."], "tactic": "rewrite [plab pq \\\\-> pq \\+ (Unit, query_hookz)]joinC.", "exn": "In environment H : forall (U : pcm) (x y z : U), x \\\\+ (y \\\\+ z) = x \\\\+ y \\\\+ z lq : nat pc : protocol Data : Type qnodes : seq nat serialize : Data -> seq nat deserialize : seq nat -> Data ds_inverse : left_inverse serialize deserialize core_state_to_data : nid -> heap -> Data -> Prop core_state_to_data_inj : forall (n : nid) (h : heap) (d d' : Data), core_state_to_data n h d -> core_state_to_data n h d' -> d = d' Lab_neq : lq != plab pc The term \"(Unit, query_hookz)\" has type \"(?cT * union_mapUMC (prod_ordType (prod_ordType nat_ordType Label) (prod_ordType Label nat_ordType)) hook_type)%type\" while it is expected to have type \"PCM.sort (union_map_classPCM (union_mapUMC Label protocol))\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "unfold W. rewrite /=. rewrite !joinA. rewrite [plab pc \\\\-> pc \\+ _]joinC. rewrite [plab pq \\\\-> pq \\+ (Unit, query_hookz)]joinC. by rewrite /plab /pq.", "back_times": 0, "succ": false, "time": 209.39431428909302}]