[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-"], "tactic": "apply soupCoh.", "exn": "Unable to unify \"Pred soup\" with \"calcoh prec cs1 cls1 init_dstatelet1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh."], "tactic": "apply CalculatorProtocol.l2.", "exn": "In environment X : (input -> bool) -> seq nid -> seq nid -> Pred soup Unable to unify \"valid (dsoup ?M2069) = true\" with \"[/\\\\ soupCoh prec cs1 cls1 (dsoup init_dstatelet1), dom (cT:=union_mapUMC [ordType of nid] heap) (dstate init_dstatelet1) =i nodes1, valid (dstate init_dstatelet1) & forall n : nat_eqType, n \\\\in nodes1 -> localCoh prec n (getLocal n init_dstatelet1)]\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2."], "tactic": "apply calcoh_soup.", "exn": "The reference calcoh_soup was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2.", "apply mark_msg."], "tactic": "apply l3.", "exn": "In environment H : nat X1 : (input -> bool) -> seq nid -> seq nid -> Pred soup X0 : (input -> option nat) -> (input -> bool) -> seq nid -> seq nid -> nat -> protocol X : (input -> bool) -> seq nid -> seq nid -> Pred soup Unable to unify \"forall x : [ordType of nid], (x \\\\in dom (cT:=union_mapUMC [ordType of nid] heap) (dstate ?M9245)) = (x \\\\in ?M9243 ++ ?M9244)\" with \"msg (calcoh prec cs1 cls1 init_dstatelet1)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2.", "apply mark_msg."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2.", "apply mark_msg.", "shelve.", "-"], "tactic": "apply ii.", "exn": "Unable to unify \"ProtocolWithInvariant.InductiveInv (Exports.CalculatorProtocol ?M9243 ?M9244 ?M9245 ?M9246 ?M9242) (fun d : dstatelet => fun=> CalcInv ?M9242 ?M9243 ?M9244 ?M9245 ?M9246 d)\" with \"coh (Exports.CalculatorProtocol f prec cs1 cls1 l1) init_dstatelet1 -> forall (n to : nat_eqType) (v : nat) (args : Exports.input) (i : mid) (s' : union_map_classPCM (union_mapUMC mid (msg TaggedMessage))), n \\\\in cls1 -> to \\\\in cs1 -> dsoup init_dstatelet1 = i \\\\\\\\-> {| content := {| tag := Exports.resp; tms_cont := v :: args |}; from := to; to := n; active := true |} \\\\+ s' -> f args = Some v\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2.", "apply mark_msg.", "shelve.", "-"], "tactic": "qsimpl time: 1 use: soupCoh,auto,qsimpl,CalculatorProtocol,um_eta,ii,l1,l3,l2.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2.", "apply mark_msg.", "shelve.", "-", "qsimpl time: 1 use: soupCoh,CalculatorProtocol,um_eta,ii,l1,l3,l2."], "tactic": "apply prec_valid in H.", "exn": "Unable to apply lemma of type \"forall i : input, prec i -> exists v : nat, f i = Some v\" on hypothesis of type \"forall (K : ordType) (V : Type) (U : union_map_class K V) (k : K) (f : U), k \\\\in dom (cT:=U) f -> exists v : V, find (cT:=U) k f = Some v /\\\\ f = pts k v \\\\+ free (cT:=U) k f\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "qsimpl time: 1 use: soupCoh.", "qsimpl time: 1 use: CalculatorProtocol,soupCoh,l2.", "apply mark_msg.", "shelve.", "-", "qsimpl time: 1 use: soupCoh,CalculatorProtocol,um_eta,ii,l1,l3,l2."], "tactic": "qsimpl time: 1 use: soupCoh,auto,prec_valid,qsimpl,CalculatorProtocol,um_eta,ii,l1,l3,l2.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "split. - apply soupCoh. + apply CalculatorProtocol.l2. apply calcoh_soup. + apply l3. auto. + apply um_eta. + apply um_eta. apply CalculatorProtocol.l1. apply calcoh_soup. - apply ii. intros. apply prec_valid in H. destruct H as [v Hv]. split. + apply cohMsg. * apply soupCoh. ++ apply CalculatorProtocol.l2. apply calcoh_soup. ++ apply l3. auto. ++ apply um_eta. ++ apply um_eta. apply CalculatorProtocol.l1. apply calcoh_soup. * exists v, args. rewrite Hv. easy. + intros. destruct H as [v [args Hv]]. unfold f in Hv. destruct args as [|a [|b]]; simpl in Hv; discriminate.", "back_times": 0, "succ": false, "time": 75.51924681663513}]