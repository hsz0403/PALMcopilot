[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP."], "tactic": "destruct (rely_ext i j s) as [i' [j' [Heq [Hi' Hrel]]]]; auto using alw_coh, Hafter.", "exn": "In environment V, W : world K : hooks A : Type w : injects V W K this : nid p : proc this V A P : A -> state -> Prop i, j : union_mapPCM Label dstatelet HCoh : i \\\\+ j \\\\In Coh W Hafter : after i p P v : A s : state HCoh' : s \\\\In Coh W HP : ?P1 v s The term \"i\" has type \"PCM.sort (union_mapPCM Label dstatelet)\" while it is expected to have type \"?i \\\\In Coh V\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh."], "tactic": "exists i', j'.", "exn": "The reference i' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh."], "tactic": "split; [assumption| split; [assumption|]].", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh."], "tactic": "eapply network_rely; eauto.", "exn": "In environment H8 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W V, W : world this : nid H6 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> network_rely W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V K : hooks A : Type w : injects V W K p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P v : A s : state HP : P v s H1 : valid W H2 : valid s H3 : hook_complete W H4 : dom W.1 =i dom s H5 : forall l : nat, coh (getProtocol W l) (getStatelet s l) H7 : valid (i \\\\+ j) H9 : dom W.1 =i dom (i \\\\+ j) H10 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) Unable to unify \"Prop\" with \"exists i' j' : union_map Label dstatelet, [/\\\\ s = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this j j' & P v i']\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-"], "tactic": "eapply aftA.", "exn": "In environment V, W : world K : hooks A : Type w : injects V W K this : nid p : proc this V A P : A -> state -> Prop i, j : union_mapPCM Label dstatelet HCoh : i \\\\+ j \\\\In Coh W Hafter : after i p P Unable to unify \"(after ?M5255 ?M5256 (fun (v : ?M5253) (s' : state) => forall x : ?M5254, ?M5257 x v s') -> forall x : ?M5254, after ?M5255 ?M5256 (fun v : ?M5253 => [eta ?M5257 x v])) /\\\\ ((forall x : ?M5254, after ?M5255 ?M5256 (fun v : ?M5253 => [eta ?M5257 x v])) -> after ?M5255 ?M5256 (fun (v : ?M5253) (s' : state) => forall x : ?M5254, ?M5257 x v s'))\" with \"forall scs : seq schedule, always_sc (i \\\\+ j) (Inject w p) scs (fun (s2 : state) (p2 : proc this W A) => forall v : A, p2 = Ret v -> P v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh."], "tactic": "eapply alw_inject.", "exn": "In environment H1 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W P0 : world -> nid -> state -> state -> Prop V, W : world this : nid H0 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> P0 W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V K : hooks A : Type w : injects V W K p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P H : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> (forall x : B, after s p (fun v : A => [eta P x v])) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') H2 : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') -> forall x : B, after s p (fun v : A => [eta P x v]) H3 : valid W H4 : valid (i \\\\+ j) H5 : hook_complete W H6 : dom W.1 =i dom (i \\\\+ j) H7 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) scs : seq schedule Unable to unify \"(fix always_sc (A : Type) (s1 : state) (p : proc this W A) (scs : seq schedule) (P : state -> proc this W A -> Prop) {struct scs} : Prop := s1 \\\\In Coh W /\\\\ match scs with | [::] => forall s2 : state, network_rely W this s1 s2 -> P s2 p | sc :: scs' => forall s2 : state, network_rely W this s1 s2 -> [/\\\\ safe p sc s2, P s2 p & forall (s3 : state) (q : proc this W A), pstep s2 p sc s3 q -> always_sc A s3 q scs' P] end) A (?M6861 \\\\+ ?M6862) (Inject w ?M6859) scs (fun (m : state) (q : proc this W A) => exists i' j' : union_mapPCM Label dstatelet, [/\\\\ m = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this ?M6862 j' & (exists q' : proc this V A, q = Inject w q' /\\\\ ?M6860 i' q') \\\\/ (exists v' : A, q = Ret v' /\\\\ ?M6860 i' (Ret v'))])\" with \"(fix always_sc (A : Type) (s1 : state) (p : proc this W A) (scs : seq schedule) (P : state -> proc this W A -> Prop) {struct scs} : Prop := s1 \\\\In Coh W /\\\\ match scs with | [::] => forall s2 : state, network_rely W this s1 s2 -> P s2 p | sc :: scs' => forall s2 : state, network_rely W this s1 s2 -> [/\\\\ safe p sc s2, P s2 p & forall (s3 : state) (q : proc this W A), pstep s2 p sc s3 q -> always_sc A s3 q scs' P] end) A (i \\\\+ j) (Inject w p) scs (fun (s2 : state) (p2 : proc this W A) => forall v : A, p2 = Ret v -> P v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "eapply alw_coh.", "exn": "In environment H11 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W V, W : world this : nid K : hooks A : Type w : injects V W K H10 : forall (p : proc this V A) (P : state -> proc this V A -> Prop) (i j : union_map Label dstatelet), i \\\\+ j \\\\In Coh W -> always i p P -> always (i \\\\+ j) (Inject w p) (fun (m : state) (q : proc this W A) => exists i' j' : union_map Label dstatelet, [/\\\\ m = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this j j' & (exists q' : proc this V A, q = Inject w q' /\\\\ P i' q') \\\\/ (exists v' : A, q = Ret v' /\\\\ P i' (Ret v'))]) H8 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> network_rely W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V P0 : world -> nid -> state -> state -> Prop H0 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> P0 W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P H : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> (forall x : B, after s p (fun v : A => [eta P x v])) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') H2 : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') -> forall x : B, after s p (fun v : A => [eta P x v]) H3 : valid W H4 : valid (i \\\\+ j) H5 : hook_complete W H6 : dom W.1 =i dom (i \\\\+ j) H7 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) X : Prop Unable to unify \"(let 'MemProp p := Mem (Coh ?M8147) in [eta p]) ?M8149\" with \"forall scs : seq schedule, always_sc (i \\\\+ j) (Inject w p) scs (fun (s2 : state) (p2 : proc this W A) => forall v : A, p2 = Ret v -> P v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "eapply alw_coh.", "exn": "In environment H13 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W V, W : world this : nid K : hooks A : Type w : injects V W K H12 : forall (p : proc this V A) (P : state -> proc this V A -> Prop) (i j : union_map Label dstatelet), i \\\\+ j \\\\In Coh W -> always i p P -> always (i \\\\+ j) (Inject w p) (fun (m : state) (q : proc this W A) => exists i' j' : union_map Label dstatelet, [/\\\\ m = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this j j' & (exists q' : proc this V A, q = Inject w q' /\\\\ P i' q') \\\\/ (exists v' : A, q = Ret v' /\\\\ P i' (Ret v'))]) H1 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> network_rely W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V P0 : world -> nid -> state -> state -> Prop H0 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> P0 W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P H : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> (forall x : B, after s p (fun v : A => [eta P x v])) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') H2 : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') -> forall x : B, after s p (fun v : A => [eta P x v]) H3 : valid W H4 : valid (i \\\\+ j) H5 : hook_complete W H6 : dom W.1 =i dom (i \\\\+ j) H7 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) X, X0 : Prop Unable to unify \"(let 'MemProp p := Mem (Coh ?M9438) in [eta p]) ?M9440\" with \"forall scs : seq schedule, always_sc (i \\\\+ j) (Inject w p) scs (fun (s2 : state) (p2 : proc this W A) => forall v : A, p2 = Ret v -> P v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "eapply aftA.", "exn": "In environment H11 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W V, W : world this : nid K : hooks A : Type w : injects V W K H10 : forall (p : proc this V A) (P : state -> proc this V A -> Prop) (i j : union_map Label dstatelet), i \\\\+ j \\\\In Coh W -> always i p P -> always (i \\\\+ j) (Inject w p) (fun (m : state) (q : proc this W A) => exists i' j' : union_map Label dstatelet, [/\\\\ m = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this j j' & (exists q' : proc this V A, q = Inject w q' /\\\\ P i' q') \\\\/ (exists v' : A, q = Ret v' /\\\\ P i' (Ret v'))]) H8 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> network_rely W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V P0 : world -> nid -> state -> state -> Prop H0 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> P0 W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P H : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> (forall x : B, after s p (fun v : A => [eta P x v])) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') H2 : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') -> forall x : B, after s p (fun v : A => [eta P x v]) H3 : valid W H4 : valid (i \\\\+ j) H5 : hook_complete W H6 : dom W.1 =i dom (i \\\\+ j) H7 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) X, X0, X1 : Prop Unable to unify \"(after ?M10732 ?M10733 (fun (v : ?M10730) (s' : state) => forall x : ?M10731, ?M10734 x v s') -> forall x : ?M10731, after ?M10732 ?M10733 (fun v : ?M10730 => [eta ?M10734 x v])) /\\\\ ((forall x : ?M10731, after ?M10732 ?M10733 (fun v : ?M10730 => [eta ?M10734 x v])) -> after ?M10732 ?M10733 (fun (v : ?M10730) (s' : state) => forall x : ?M10731, ?M10734 x v s'))\" with \"forall scs : seq schedule, always_sc (i \\\\+ j) (Inject w p) scs (fun (s2 : state) (p2 : proc this W A) => forall v : A, p2 = Ret v -> P v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI."], "tactic": "eapply alw_coh.", "exn": "In environment H13 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W V, W : world this : nid K : hooks A : Type w : injects V W K H12 : forall (p : proc this V A) (P : state -> proc this V A -> Prop) (i j : union_map Label dstatelet), i \\\\+ j \\\\In Coh W -> always i p P -> always (i \\\\+ j) (Inject w p) (fun (m : state) (q : proc this W A) => exists i' j' : union_map Label dstatelet, [/\\\\ m = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this j j' & (exists q' : proc this V A, q = Inject w q' /\\\\ P i' q') \\\\/ (exists v' : A, q = Ret v' /\\\\ P i' (Ret v'))]) H1 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> network_rely W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V P0 : world -> nid -> state -> state -> Prop H0 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> P0 W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P H : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> (forall x : B, after s p (fun v : A => [eta P x v])) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') H2 : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') -> forall x : B, after s p (fun v : A => [eta P x v]) H3 : valid W H4 : valid (i \\\\+ j) H5 : hook_complete W H6 : dom W.1 =i dom (i \\\\+ j) H7 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) X, X0, X1, X2 : Prop Unable to unify \"(let 'MemProp p := Mem (Coh ?M12084) in [eta p]) ?M12086\" with \"forall scs : seq schedule, always_sc (i \\\\+ j) (Inject w p) scs (fun=> xPredT)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*"], "tactic": "intros v s0 IH.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*"], "tactic": "eexists.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "eexists.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "split; [eauto|].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "split; [eauto|].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "split; [|now apply IH].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros HCoh Hafter.", "eapply aft_imp.", "-", "intros v s HCoh' HP.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,alw_coh.", "qsimpl time: 1 use: network_rely,rely_ext,alw_coh.", "shelve.", "-", "qsimpl time: 1 use: network_rely,aftA,rely_ext,alw_coh.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "eapply aftI.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "*", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely.", "qsimpl time: 1 use: rely_ext,aftA,alw_inject,alw_coh,network_rely."], "tactic": "eapply rely_split; eauto.", "exn": "In environment H13 : forall (this : nid) (W : world) (A : Type) (s : state) (p : proc this W A) (P : state -> proc this W A -> Prop), always s p P -> s \\\\In Coh W V, W : world this : nid K : hooks A : Type w : injects V W K H12 : forall (p : proc this V A) (P : state -> proc this V A -> Prop) (i j : union_map Label dstatelet), i \\\\+ j \\\\In Coh W -> always i p P -> always (i \\\\+ j) (Inject w p) (fun (m : state) (q : proc this W A) => exists i' j' : union_map Label dstatelet, [/\\\\ m = i' \\\\+ j', i' \\\\In Coh V, network_rely W2 this j j' & (exists q' : proc this V A, q = Inject w q' /\\\\ P i' q') \\\\/ (exists v' : A, q = Ret v' /\\\\ P i' (Ret v'))]) H1 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> network_rely W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V P0 : world -> nid -> state -> state -> Prop H0 : forall (i : state) (j : union_map Label dstatelet) (s : state), i \\\\In Coh V -> P0 W this (i \\\\+ j) s -> exists i' j' : union_map Label dstatelet, s = i' \\\\+ j' /\\\\ i' \\\\In Coh V p : proc this V A P : A -> state -> Prop i, j : union_map Label dstatelet Hafter : after i p P H : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> (forall x : B, after s p (fun v : A => [eta P x v])) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') H2 : forall (this : nid) (W : world) (A B : Type) (s : state) (p : proc this W A) (P : B -> A -> state -> Prop), always s p (fun=> xPredT) -> after s p (fun (v : A) (s' : state) => forall x : B, P x v s') -> forall x : B, after s p (fun v : A => [eta P x v]) H3 : valid W H4 : valid (i \\\\+ j) H5 : hook_complete W H6 : dom W.1 =i dom (i \\\\+ j) H7 : forall l : nat, coh (getProtocol W l) (getStatelet (i \\\\+ j) l) X, X0, X1, X2, X3, X4, X5, X6, X7, X8 : Prop Unable to unify \"network_rely V this ?M19829 ?M19831 /\\\\ network_rely W2 this ?M19830 ?M19832\" with \"forall scs : seq schedule, always_sc (i \\\\+ j) (Inject w p) scs (fun=> xPredT)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros HCoh Hafter. eapply aft_imp. - intros v s HCoh' HP. destruct (rely_ext i j s) as [i' [j' [Heq [Hi' Hrel]]]]; auto using alw_coh, Hafter. exists i', j'. split; [assumption| split; [assumption|]]. eapply network_rely; eauto. - eapply aftA. + eapply alw_inject. * eapply alw_coh. eauto. * eapply alw_coh. eauto. + intros. eapply aftA. * eapply aftI. eapply alw_coh. eauto. * intros v s0 IH. eexists. eexists. split; [eauto|]. split; [eauto|]. split; [|now apply IH]. eapply rely_split; eauto.", "back_times": 1, "succ": false, "time": 171.16288948059082}]