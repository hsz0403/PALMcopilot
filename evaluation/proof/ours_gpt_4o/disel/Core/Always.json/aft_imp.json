[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros H after_s_p_P1."], "tactic": ["induction p.", ""], "exn": "Abstracting over the terms \"W\", \"A\" and \"p\" leads to a term fun (W0 : world) (A0 : Type) (p0 : proc A0) => forall P0 P3 : A0 -> state -> Prop, (forall (v : A0) (s0 : state), s0 \\\\In Coh W0 -> P0 v s0 -> P3 v s0) -> after s p0 P0 -> after s p0 P3 which is ill-typed. Reason is: Illegal application: The term \"after\" of type \"forall A : Type, state -> proc A -> (A -> state -> Prop) -> Prop\" cannot be applied to the terms \"A0\" : \"Type\" \"s\" : \"state\" \"p0\" : \"proc A0\" \"P0\" : \"A0 -> state -> Prop\" The 3rd term has type \"@proc this W0 A0\" which should be coercible to \"@proc this W A0\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "intros H after_s_p_P1. induction p. - intros v s' Hin_coh H_P1_v_s'. apply H; auto. - intros v s' Hin_coh H_P1_v_s'. inversion after_s_p_P1. - intros v s' Hin_coh H_P1_v_s'. inversion after_s_p_P1. - intros v s' Hin_coh H_P1_v_s'. apply aft_bnd with (p1 := p1) (pp2 := fun v => [eta p2 v]). + apply after_s_p_P1. + intros a s0 after_s_p1_a. apply IHp with (P1 := fun v => P1 v). * intros v0 s1 after_s0_p1_v0. apply H; auto. * apply after_s_p1_a. - intros v s' Hin_coh H_P1_v_s'. inversion after_s_p_P1. - intros v s' Hin_coh H_P1_v_s'. destruct after_s_p_P1 as [A B C]. apply aft_bnd with (p1 := p1) (pp2 := fun _ => [eta fun p0 => after s p0 P2]). + apply B. + intros a s0 after_s0_p1_a. apply IHp2; auto. apply aftI. apply aftI in after_s0_p1_a as D. apply D.", "back_times": 0, "succ": false, "time": 69.4181706905365}]