[{"history": {"proof": "intros H_in. apply leq_trans with (e2 := sup es). - unfold leq. simpl. qsimpl time: 1 use: leq_refl. sfirstorder depth: 3. - unfold leq. simpl. qsimpl time: 1 use: leq_refl.", "repairs": ["", "", "", "", "", "cannot_unify", "hammer", "", "", "", "not_inductive_goal"], "exceptions": [{"ctx": ["intros H_in.", "apply leq_trans with (e2 := sup es).", "-", "unfold leq.", "simpl."], "tactic": "apply leq_refl.", "exn": "In environment this : nid W : world A : Type s : spec A es : Pred_Class e : DTbin s H_in : e \\\\In es Unable to unify \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class (funPoset (proc this W A) propPoset)) in mx_leq) ?M1563 ?M1563\" with \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class (funPoset (proc this W A) propPoset)) in mx_leq) e (sup_set es)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H_in.", "apply leq_trans with (e2 := sup es).", "-", "unfold leq.", "simpl.", "qsimpl time: 1 use: leq_refl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H_in.", "apply leq_trans with (e2 := sup es).", "-", "unfold leq.", "simpl.", "qsimpl time: 1 use: leq_refl.", "shelve.", "-", "unfold leq.", "simpl."], "tactic": "exists e.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros H_in.", "apply leq_trans with (e2 := sup es).", "-", "unfold leq.", "simpl.", "qsimpl time: 1 use: leq_refl.", "shelve.", "-", "unfold leq.", "simpl.", "qsimpl time: 1 use: leq_refl."], "tactic": "split.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros H_in. apply leq_trans with (e2 := sup es). - unfold leq. simpl. apply leq_refl. - unfold leq. simpl. exists e. split. ++ auto. ++ right. exists e. split; auto.", "back_times": 1, "succ": true, "time": 2.835228681564331}]