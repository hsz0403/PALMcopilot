[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->."], "tactic": "eapply Coh_dom; eauto.", "exn": "In environment w : world this : nid l : Label s, s' : state m : mid tm : TaggedMessage to : nat b : bool z : nat_eqType Nz : this != z l' : Label st' : send_trans (Protocols.coh (getProtocol w l')) InSt : st' \\\\In get_st w l' to' : nid msg : seq nat b' : heap InNodes : z \\\\in nodes (getProtocol w l') (gets s l') InDom : l' \\\\in dom s Coh : Worlds.Core.Coh w s S : send_safe st' z to' (gets s l') msg F : all_hooks_fire w l' (t_snd st') s z msg to' Fire' : Some b' = send_step S Send : s' = upd l' {| dstate := upd z b' (dstate (gets s l')); dsoup := (post_msg (dsoup (gets s l')) {| content := {| tag := t_snd st'; tms_cont := msg |}; from := z; to := to'; active := true |}).1 |} s Fnd : find m (dsoup (gets s' l)) = Some {| content := tm; from := this; to := to; active := b |} Unable to unify \"forall x : [ordType of nid], (x \\\\in dom (dstate (gets ?M1571 ?M1570))) = (x \\\\in nodes (getProtocol ?M1569 ?M1570) (gets ?M1571 ?M1570))\" with \"l = l'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->."], "tactic": "qsimpl time: 1 use: auto,Coh_dom.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->.", "+", "shelve.", "+", "shelve.", "-", "assert (l = l') as ->."], "tactic": "eapply Coh_dom; eauto.", "exn": "In environment w : world this : nid l : Label s, s' : state m : mid tm : TaggedMessage to : nat b : bool z : nat_eqType Nz : this != z l' : Label rt' : receive_trans (Protocols.coh (getProtocol w l')) InRt : rt' \\\\In get_rt w l' i : mid from : nat pf : z \\\\in nodes (getProtocol w l') (gets s l') InDom : l' \\\\in dom s Coh : Worlds.Core.Coh w s msg0 : TaggedMessage Eq : tag msg0 = t_rcv rt' Receive : [/\\\\ find i (dsoup (gets s l')) = Some {| content := msg0; from := from; to := z; active := true |}, msg_wf rt' (coh_s l' Coh) z from msg0 & let loc' := receive_step rt' from msg0 (coh_s l' Coh) pf in s' = upd l' {| dstate := upd z loc' (dstate (gets s l')); dsoup := consume_msg (dsoup (gets s l')) i |} s] Fnd : find m (dsoup (gets s' l)) = Some {| content := tm; from := this; to := to; active := b |} Unable to unify \"forall x : [ordType of nid], (x \\\\in dom (dstate (gets ?M1577 ?M1576))) = (x \\\\in nodes (getProtocol ?M1575 ?M1576) (gets ?M1577 ?M1576))\" with \"l = l'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->.", "+", "shelve.", "+", "shelve.", "-", "assert (l = l') as ->."], "tactic": "qsimpl time: 1 use: step_preserves_node_ids,auto,eqType,eq_dec,proof,step_consume_other,discriminate,from,qsimpl,true,Coh_dom.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->.", "+", "shelve.", "+", "shelve.", "-", "assert (l = l') as ->."], "tactic": "qsimpl time: 1 use: step_preserves_node_ids,eqType,eq_dec,proof,step_consume_other,discriminate,from,true,Coh_dom.", "exn": "The reference eq_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->.", "+", "shelve.", "+", "shelve.", "-", "assert (l = l') as ->."], "tactic": "qsimpl time: 1 use: step_preserves_node_ids,eqType,proof,step_consume_other,discriminate,from,true,Coh_dom.", "exn": "The reference proof was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Nz Step Fnd.", "induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive].", "-", "exists b.", "shelve.", "-", "assert (l = l') as ->.", "+", "shelve.", "+", "shelve.", "-", "assert (l = l') as ->."], "tactic": "qsimpl time: 1 use: step_preserves_node_ids,eqType,step_consume_other,discriminate,from,true,Coh_dom.", "exn": "The reference discriminate was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros Nz Step Fnd. induction Step as [Eq Co | l' st' InSt to' msg b' InNodes InDom Coh S F Fire' Send | l' rt' InRt i from pf InDom Coh msg0 Eq Receive]. - exists b. rewrite Eq in Fnd. split. auto. auto. - assert (l = l') as ->. eapply Coh_dom; eauto. pose proof (step_preserves_node_ids w z s s' l' InDom Step). rewrite <- H in InNodes. rewrite <- Send in Fnd. destruct (eqType.eq_dec this to'). + subst. apply step_consume_other with (from := from) in Step; auto. rewrite H0 in Fnd. discriminate. + exists true. split. * apply step_consume_other with (from := from) in Step; auto. rewrite H0. eauto. * auto. - assert (l = l') as ->. eapply Coh_dom; eauto. assert (msg0 = tm) by congruence; subst. exists b; split; eauto using rely_consume_other. auto.", "back_times": 0, "succ": false, "time": 171.98736906051636}]