[{"history": {"proof": "intros H. unfold dfun_sup. qsimpl time: 1 use: fun_supP. red. intros x. apply supP. qsimpl time: 1 use: fun_supP.", "repairs": ["", "", "cannot_unify", "", "", "", "not_inductive_product"], "exceptions": [{"ctx": ["intros H.", "unfold dfun_sup."], "tactic": "apply fun_supP.", "exn": "In environment A : Type B : A -> lattice s : Pred (dfunPoset (fun x : A => B x)) p : dfunPoset (fun x : A => B x) H : p \\\\In s Unable to unify \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class (funPoset ?M1464 ?M1465)) in mx_leq) ?M1467 (fun_sup ?M1466)\" with \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class (dfunPoset (fun x : A => B x))) in mx_leq) p (fun x : A => sup [Pred p | exists f : dfunPoset (fun x0 : A => B x0), f \\\\In s /\\\\ p = f x])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold dfun_sup.", "qsimpl time: 1 use: fun_supP.", "red.", "intros x.", "apply supP."], "tactic": "destruct H as [f [Hf Heq]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros H.", "unfold dfun_sup.", "qsimpl time: 1 use: fun_supP.", "red.", "intros x.", "apply supP.", "qsimpl time: 1 use: fun_supP."], "tactic": "exists f.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros H. unfold dfun_sup. apply fun_supP. red. intros x. apply supP. destruct H as [f [Hf Heq]]. exists f. split. - apply Hf. - apply Heq.", "back_times": 0, "succ": true, "time": 0.882030725479126}]