[{"history": {"proof": "qsimpl time: 1.", "repairs": ["not_inductive_product"], "exceptions": [{"ctx": [], "tactic": "case: um1 um2 => [f1 Pf1] [f2 Pf2].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["qsimpl time: 1."], "tactic": "rewrite -/(Union f1 f2).", "exn": "The reference Union was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "apply/allP => l Hl; move: (Hl)."], "tactic": "case: (boolP (_ \\in dom (Union f1 f2))) => [D | ND].", "exn": "The reference Union was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "apply/allP => l Hl; move: (Hl)."], "tactic": "move: (domUn D) => [D1 | D2].", "exn": "The reference D was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "apply/allP => l Hl; move: (Hl)."], "tactic": "move/(_ isT): (allP Pf1 D1) => /=.", "exn": "The reference D1 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "case: um1 um2 => [f1 Pf1] [f2 Pf2]. rewrite -/(Union f1 f2). apply/allP => l Hl; move: (Hl). case: (boolP (_ \\in dom (Union f1 f2))) => [D | ND]. - move: (domUn D) => [D1 | D2]. ++ move/(_ isT): (allP Pf1 D1) => /=. by case: find => //= p /eqP ->. ++ move/(_ isT): (allP Pf2 D2) => /=. by case: find => //= p /eqP ->. - by move=> /(_ isT); rewrite (dom0 (Union _ _)) // dom0 in ND.", "back_times": 0, "succ": false, "time": 65.12374520301819}]