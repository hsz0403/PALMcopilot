[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros H H0 H1.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "apply (is_RInt_ext (fun x => if Rlt_dec x b then f x else zero)).", "exn": "In environment V : CompleteNormedModule R_AbsRing f : R -> V a, b : R l : V H : is_RInt f a b l Unable to unify \"forall P : V -> Prop, locally ?M2368 P -> filtermap (fun ptd : SF_seq => scal (sign (?M2367 - ?M2366)) (Riemann_sum ?M2365 ptd)) (Riemann_fine ?M2366 ?M2367) P\" with \"RInt f a b = l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Rlt_dec,is_RInt_ext,zero.", "-"], "tactic": "intros x Hx.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Rlt_dec,is_RInt_ext,zero.", "-"], "tactic": "destruct (Rlt_dec x b) as [H2|H2]; auto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Rlt_dec,is_RInt_ext,zero.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Rlt_dec,is_RInt_ext,zero.", "-", "shelve.", "-"], "tactic": "apply (is_RInt_comp_lin (fun x => if Rlt_dec x b then f x else zero) 1 0 a c (plus l1 l2)).", "exn": "The reference l2 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros H H0 H1. apply (is_RInt_ext (fun x => if Rlt_dec x b then f x else zero)). - intros x Hx. destruct (Rlt_dec x b) as [H2|H2]; auto. exfalso; lra. - apply (is_RInt_comp_lin (fun x => if Rlt_dec x b then f x else zero) 1 0 a c (plus l1 l2)). apply is_RInt_ext with (g := fun x => if Rlt_dec x b then f x else f x). ++ intros x Hx. destruct (Rlt_dec x b); auto. ++ apply (is_RInt_ext f a b); auto. ++ apply is_RInt_ext with (g := fun x => if Rlt_dec x b then f x else zero); auto. intros x Hx. exfalso; lra. ++ apply is_RInt_point. ++ apply (is_RInt_swap (fun x => if Rlt_dec x b then f x else f x) c b l2); auto. ++ eapply is_RInt_ext. intros x Hx. destruct (Rlt_dec x b); auto. ++ apply is_RInt_point.", "back_times": 2, "succ": false, "time": 81.34885668754578}]