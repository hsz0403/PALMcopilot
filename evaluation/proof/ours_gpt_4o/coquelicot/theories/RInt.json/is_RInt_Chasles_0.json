[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros [H0 H1] H2 H3."], "tactic": "destruct (classic (a = b)).", "exn": "The reference classic was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-"], "tactic": "rewrite H in H2.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-"], "tactic": "apply ex_RInt_point.", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a, b, c : R l1, l2 : V H0 : a < b H1 : b < c H2 : is_RInt f a b l1 H3 : is_RInt f b c l2 P : Prop Unable to unify \"exists If : V, is_RInt ?M2376 ?M2377 ?M2377 If\" with \"forall P : V -> Prop, locally (plus l1 l2) P -> filtermap (fun ptd : SF_seq => scal (sign (c - a)) (Riemann_sum f ptd)) (Riemann_fine a c) P\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "-"], "tactic": "destruct (classic (b = c)).", "exn": "The reference classic was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "-", "destruct (Ring_polynom.Pc (b = c)).", "++"], "tactic": "rewrite H4 in H3.", "exn": "The reference H4 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "-", "destruct (Ring_polynom.Pc (b = c)).", "++"], "tactic": "apply ex_RInt_point.", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a, b, c : R l1, l2 : V H0 : a < b H1 : b < c H2 : is_RInt f a b l1 H3 : is_RInt f b c l2 p : positive p0 : Ring_polynom.Pol Prop P : Prop Unable to unify \"exists If : V, is_RInt ?M2691 ?M2692 ?M2692 If\" with \"forall P : V -> Prop, locally (plus l1 l2) P -> filtermap (fun ptd : SF_seq => scal (sign (c - a)) (Riemann_sum f ptd)) (Riemann_fine a c) P\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "-", "destruct (Ring_polynom.Pc (b = c)).", "++", "qsimpl time: 1 use: ex_RInt_point."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "-", "destruct (Ring_polynom.Pc (b = c)).", "++", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "++"], "tactic": "assert (a < b) by (split; assumption).", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros [H0 H1] H2 H3.", "destruct (Ring_polynom.Pc (a = b)).", "-", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "-", "destruct (Ring_polynom.Pc (b = c)).", "++", "qsimpl time: 1 use: ex_RInt_point.", "shelve.", "++", "qsimpl time: 1 use: ex_RInt_point."], "tactic": "assert (b < c) by (split; assumption).", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}]}, "chat": [], "original": "intros [H0 H1] H2 H3. destruct (classic (a = b)). - rewrite H in H2. apply ex_RInt_point. - destruct (classic (b = c)). ++ rewrite H4 in H3. apply ex_RInt_point. ++ assert (a < b) by (split; assumption). assert (b < c) by (split; assumption). apply (ex_RInt_ext _ _ a b). -- intros x [H5 H6]. reflexivity. -- apply H2. -- apply (ex_RInt_ext _ _ b c). ** intros x [H7 H8]. reflexivity. ** apply H3. apply (ex_RInt_ext _ _ a c). -- intros x [H9 H10]. reflexivity. -- apply (ex_RInt_comp_lin (f)). simpl. apply H.", "back_times": 0, "succ": false, "time": 89.82327055931091}]