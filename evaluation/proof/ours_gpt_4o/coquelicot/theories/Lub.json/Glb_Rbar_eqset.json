[{"history": {"proof": "qsimpl time: 1. pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x)). apply Rbar_opp_eq. qsimpl time: 1. hauto use: Glb_Rbar_correct, Rbar_le_antisym unfold: is_lb_Rbar, is_glb_Rbar.", "repairs": ["not_inductive_goal", "ref_not_found", "ref_not_found", "cannot_unify", "hammer"], "exceptions": [{"ctx": [], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["qsimpl time: 1."], "tactic": "intro M.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 1."], "tactic": "intro H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 1."], "tactic": "pose (E' := fun x : Rbar => E (Rbar_opp x)).", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x))."], "tactic": "assert (Haux: Rbar_is_upper_bound E' (Rbar_opp M)).", "exn": "The reference Rbar_is_upper_bound was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x))."], "tactic": "unfold E' in *.", "exn": "The reference E' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x))."], "tactic": "intros x Ex.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x))."], "tactic": "apply Rbar_ub_lb.", "exn": "The reference Rbar_ub_lb was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x)).", "apply Rbar_opp_eq."], "tactic": "apply H.", "exn": "In environment E1, E2 : R -> Prop H : forall x : R, E2 x -> E1 x H0 : forall x : R, E1 x -> E2 x Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x) : Rbar -> R -> nat -> R Unable to unify \"E1 ?M2459\" with \"Rbar_opp (Glb_Rbar E1) = Rbar_opp (Glb_Rbar E2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x)).", "apply Rbar_opp_eq.", "qsimpl time: 1."], "tactic": "assert (Rbar_is_lower_bound E m_infty).", "exn": "The reference Rbar_is_lower_bound was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x)).", "apply Rbar_opp_eq.", "qsimpl time: 1."], "tactic": "apply Rbar_ub_lb.", "exn": "The reference Rbar_ub_lb was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x)).", "apply Rbar_opp_eq.", "qsimpl time: 1.", "apply Rbar_rec."], "tactic": "apply Haux.", "exn": "The reference Haux was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 1.", "pose (Reste_E' := fun x : Rbar => Reste_E (Rbar_opp x)).", "apply Rbar_opp_eq.", "qsimpl time: 1.", "apply Rbar_rec."], "tactic": "apply Rbar_ub_m_infty with E x; auto.", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "right. intro M. intro H. pose (E' := fun x : Rbar => E (Rbar_opp x)). assert (Haux: Rbar_is_upper_bound E' (Rbar_opp M)). { unfold E' in *. intros x Ex. apply Rbar_ub_lb. apply H. } assert (Rbar_is_lower_bound E m_infty). { apply Rbar_ub_lb. apply Haux. } apply Rbar_ub_m_infty with E x; auto.", "back_times": 0, "succ": true, "time": 61.99611258506775}]