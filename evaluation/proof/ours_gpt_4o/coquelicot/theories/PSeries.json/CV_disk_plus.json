[{"history": {"proof": "qsimpl time: 1 use: not_ex_series_DAlembert. qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl. qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0. qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0,is_lim_seq_scal_l. qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0,is_lim_seq_scal_l.", "repairs": ["cannot_unify", "cannot_unify", "wrong_type", "cannot_unify", "cannot_apply_in"], "exceptions": [{"ctx": ["intros H.", "intro."], "tactic": "apply not_ex_series_DAlembert with (l := 1).", "exn": "In environment a, b : nat -> R x : R H : CV_disk a x H0 : CV_disk b x Unable to unify \"is_lim_seq ?M2363 0 -> False\" with \"exists l : R_NormedModule, is_series (fun n : nat => Rabs (PS_plus a b n * x ^ n)) l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert."], "tactic": "apply Rlt_irrefl.", "exn": "In environment H1 : forall (a : nat -> R) (l : R), l > 1 -> (forall n : nat, a n = 0 -> False) -> is_lim_seq (fun n : nat => Rabs (a (S n) / a n)) l -> is_lim_seq a 0 -> False a, b : nat -> R x, x0 : R H2 : is_series (fun n : nat => Rabs (b n * x ^ n)) x0 x1 : R H0 : is_series (fun n : nat => Rabs (a n * x ^ n)) x1 Unable to unify \"?M2917 < ?M2917 -> False\" with \"exists l : R_NormedModule, is_series (fun n : nat => Rabs (PS_plus a b n * x ^ n)) l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl."], "tactic": "intros n Hn.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl."], "tactic": "apply (ex_series_lim_0 _ H) in H0 as Hlim.", "exn": "In environment H3 : forall r : R, r < r -> False H : forall (a : nat -> R) (l : R), l > 1 -> (forall n : nat, a n = 0 -> False) -> is_lim_seq (fun n : nat => Rabs (a (S n) / a n)) l -> is_lim_seq a 0 -> False a, b : nat -> R x, x0 : R H2 : is_series (fun n : nat => Rabs (b n * x ^ n)) x0 x1 : R H0 : is_series (fun n : nat => Rabs (a n * x ^ n)) x1 The term \"H\" has type \"forall (a : nat -> R) (l : R), l > 1 -> (forall n : nat, a n = 0 -> False) -> is_lim_seq (fun n : nat => Rabs (a (S n) / a n)) l -> is_lim_seq a 0 -> False\" while it is expected to have type \"ex_series ?a\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0."], "tactic": "apply is_lim_seq_scal_l with (a := x).", "exn": "In environment H5 : forall a : nat -> R, ex_series a -> is_lim_seq a 0 H4 : forall r : R, r < r -> False H1 : forall (a : nat -> R) (l : R), l > 1 -> (forall n : nat, a n = 0 -> False) -> is_lim_seq (fun n : nat => Rabs (a (S n) / a n)) l -> is_lim_seq a 0 -> False a, b : nat -> R x, x0 : R H2 : is_series (fun n : nat => Rabs (b n * x ^ n)) x0 x1 : R H0 : is_series (fun n : nat => Rabs (a n * x ^ n)) x1 Unable to unify \"forall P : R -> Prop, Rbar_locally (Rbar_mult x ?M3743) P -> filtermap (fun n : nat => x * ?M3741 n) eventually P\" with \"exists l : R_NormedModule, is_series (fun n : nat => Rabs (PS_plus a b n * x ^ n)) l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0,is_lim_seq_scal_l."], "tactic": "now apply is_lim_seq_pow_0; auto with real.", "exn": "The reference is_lim_seq_pow_0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0,is_lim_seq_scal_l."], "tactic": "apply ex_series_lim_0 in H as [M HM].", "exn": "Unable to apply lemma of type \"forall a : nat -> R, ex_series a -> is_lim_seq a 0\" on hypothesis of type \"forall (a : nat -> R) (l : R), l > 1 -> (forall n : nat, a n = 0 -> False) -> is_lim_seq (fun n : nat => Rabs (a (S n) / a n)) l -> is_lim_seq a 0 -> False\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros H.", "intro.", "qsimpl time: 1 use: not_ex_series_DAlembert.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0,is_lim_seq_scal_l.", "qsimpl time: 1 use: not_ex_series_DAlembert,Rlt_irrefl,ex_series_lim_0,is_lim_seq_scal_l."], "tactic": ["eapply ex_series_ext with (b := fun n => Rabs (a n * x ^ n)).", ""], "exn": "No such bound variable b (possible names are: a0 and b0).", "type": "no_such_bound", "handled": false}]}, "chat": [], "original": "intros H. unfold not in *. intro. apply not_ex_series_DAlembert with (l := 1). - apply Rlt_irrefl. - intros n Hn. apply (ex_series_lim_0 _ H) in H0 as Hlim. apply is_lim_seq_scal_l with (a := x). now apply is_lim_seq_pow_0; auto with real. - apply ex_series_lim_0 in H as [M HM]. eapply ex_series_ext with (b := fun n => Rabs (a n * x ^ n)). + intros n; rewrite Rabs_mult; apply Rmult_le_compat_r. now apply Rabs_pos. specialize (HM n). now rewrite Rabs_Rab. + now apply CV_disk_inside.", "back_times": 0, "succ": false, "time": 97.01569771766663}]