[{"history": {"proof": "sfirstorder use: Cinv_r, Cmult_comm unfold: RtoC.", "repairs": ["cannot_unify"], "exceptions": [{"ctx": ["intros x."], "tactic": "split.", "exn": "In environment r : C x : r <> 0 Unable to unify \"RtoC 1\" with \"/ r * r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x.", "qsimpl time: 1."], "tactic": "intros H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros x.", "qsimpl time: 1."], "tactic": ["destruct x as [a b].", ""], "exn": "Expects a disjunctive pattern with 0 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros x. split. - intros H. unfold Cmod. unfold C in x. destruct x as [a b]. simpl in *. assert (a <> 0 \\/ b <> 0) as H0. { intros H1. apply H. subst. reflexivity. } destruct H0 as [H0|H0]. + apply Rabs_pos_lt in H0. apply Rlt_le_trans with (r2 := Rabs a). * unfold Rabs. destruct (Rcase_abs a); lra. * apply Rle_trans with (r2 := Rmax (Rabs a) (Rabs b)). -- apply Rmax_l. -- apply Cmod_2Rmax. + apply Rabs_pos_lt in H0. apply Rlt_le_trans with (r2 := Rabs b). * unfold Rabs. destruct (Rcase_abs b); lra. * apply Rle_trans with (r2 := Rmax (Rabs a) (Rabs b)). -- apply Rmax_r. -- apply Cmod_2Rmax. - intros H. intros H1. assert (Cmod x = 0). { rewrite <- H1. unfold Cmod. simpl. rewrite Rplus_0_l. rewrite sqrt_0. reflexivity. } apply Cmod_eq_0 in H2. apply H. auto.", "back_times": 0, "succ": true, "time": 54.53248190879822}]