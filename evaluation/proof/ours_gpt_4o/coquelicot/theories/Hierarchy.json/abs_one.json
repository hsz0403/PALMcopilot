[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "apply abs_opp_one.", "exn": "In environment K : AbsRing Unable to unify \"abs (opp one) = 1\" with \"abs one = 1\".", "type": "cannot_unify", "handled": true}]}, "chat": [{"role": "user", "content": "Help me to prove a theorem in Coq, based on provided proof states including hypotheses and goals. Give a complete proof in only one single code block without explanations, extra definitions. Give a complete proof in one response, only give the proof body, without repeating the definition and \"Proof.\". Avoid existing names when using intros. Write the commands separately, without \";\" and \"[cmd|cmd]\". Use bullets for structure, NEVER use \"{\" and \"}\". When -, + and * are used out, proceed to double versions like --, ++, etc. For example, given proof state:\nn, m: nat\nIHn: m + n = n + m\n============================\nm + S n = S n + m\nThe hypotheses n, m: nat and IHn: m + n = n + m are given first, then the goal, m + S n = S n + m, separated by =. Expect a response like: \n```coq\nsimpl. rewrite <- IHn. auto.``` \nYou do not intros any terms because all terms have already been introduced.\n\nWhen I give:\nforall n m : nat, m + n = n + m\n============================\nn, m: nat\nyour answer should be like:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\nDefinitions and lemmas related to the proof will be provided, use them accordingly.\n\n\nSolve This Proof State:\n\nHypotheses:\nK: AbsRing\n\nGoal:\nabs one = 1\n\nPremises:\none = fun K : Ring => Ring.one (AbelianGroup.Pack K (Ring.class K) K) (Ring.class K) : forall K : Ring, K Argument K is implicit and maximally inserted\nabs = AbsRing.abs (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : K -> R\nAbsRing.Mixin : forall (K : Ring) (abs : K -> R), abs zero = 0 -> abs (opp one) = 1 -> (forall x y : K, abs (plus x y) <= abs x + abs y) -> (forall x y : K, abs (mult x y) <= abs x * abs y) -> (forall x : K, abs x = 0 -> x = zero) -> AbsRing.mixin_of K\nabs_opp_one = AbsRing.ax2 K (AbsRing.class K) : abs (opp one) = 1\nRecord mixin_of (K : Ring) : Type := Mixin { abs : K -> R; ax1 : abs zero = 0; ax2 : abs (opp one) = 1; ax3 : forall x y : K, abs (plus x y) <= abs x + abs y; ax4 : forall x y : K, abs (mult x y) <= abs x * abs y; ax5 : forall x : K, abs x = 0 -> x = zero } For Mixin: Argument scopes are [_ function_scope _ _ function_scope function_scope function_scope]\nabs_opp : forall x : K, abs (opp x) = abs x\nabs_minus : forall x y : K, abs (minus x y) = abs (minus y x)\nmult_one_l : forall x : ?K, mult one x = x where ?K : [K : AbsRing |- Ring]\nmult_one_r : forall x : ?K, mult x one = x where ?K : [K : AbsRing |- Ring]\nabs_eq_zero : forall x : K, abs x = 0 -> x = zero\nabs_zero = AbsRing.ax1 (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : abs zero = 0\nabs_triangle : forall x y : K, abs (plus x y) <= abs x + abs y\nabs_mult : forall x y : K, abs (mult x y) <= abs x * abs y\nRabs_R1 = match Rcase_abs 1 as s return ((if s then - (1) else 1) = 1) with | left H => False_ind (- (1) = 1) ((fun H0 : 1 < 0 => R1_neq_R0 (Rle_antisym 1 0 (Rlt_le 1 0 H0) (IZR_le 0 1 (Zle_bool_imp_le 0 1 eq_refl)))) H) | right _ => eq_refl end : Rabs 1 = 1\npow_R1 : forall (r : R) (n : nat), r ^ n = 1 -> Rabs r = 1 \\/ n = 0%nat\npowerRZ_R1 : forall n : Z, powerRZ 1 n = 1\nln_1 = eq_ind (exp 0) (fun r : R => ln r = 0) (eq_ind_r (fun r : R => r = 0) eq_refl (ln_exp 0)) 1 exp_0 : ln 1 = 0\npow_n = fun K : Ring => fix pow_n (x : K) (N : nat) {struct N} : K := match N with | 0%nat => one | S i => mult x (pow_n x i) end : forall K : Ring, K -> nat -> K Argument K is implicit and maximally inserted Argument scopes are [_ _ nat_scope]\nRmult_1_l : forall r : R, 1 * r = r\nRmult_1_r : forall r : R, r * 1 = r\nC_n_n : forall n : nat, C n n = 1\npow_1_abs : forall n : nat, Rabs ((-1) ^ n) = 1\npow_1_even : forall n : nat, (-1) ^ (2 * n) = 1\nsin2 : forall x : R, (sin x)\u00b2 = 1 - (cos x)\u00b2\nderive_pt_id : forall x : R, derive_pt id x (derivable_pt_id x) = 1\nsign_eq_1 : forall x : R, 0 < x -> sign x = 1\nR1_sqrt2_neq_0 = (fun H : / sqrt 2 <> 0 => (fun H0 : 1 * / sqrt 2 <> 0 => H0) (Rmult_integral_contrapositive_currified 1 (/ sqrt 2) R1_neq_R0 H)) (Rinv_neq_0_compat (sqrt 2) sqrt2_neq_0) : 1 / sqrt 2 <> 0\nRinv_l : forall r : R, r <> 0 -> / r * r = 1\nRinv_l_sym : forall r : R, r <> 0 -> 1 = / r * r\nRinv_r_sym : forall r : R, r <> 0 -> 1 = r * / r\nRinv_r : forall r : R, r <> 0 -> r * / r = 1\nAbsRing.ax2 : forall (K : Ring) (m : AbsRing.mixin_of K), AbsRing.abs K m (opp one) = 1"}, {"role": "assistant", "content": "```coq\nexact abs_opp_one.\nQed.\n```"}], "original": "apply abs_opp_one.", "back_times": 0, "succ": false, "time": 44.44553089141846}]