[{"history": {"proof": "hauto lq: on use: Rlt_irrefl, Rlt_le_trans, Rle_div_r, Rle_lt_trans, Rlt_le, Rle_div_l unfold: Rle.", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros f g a b pr_f pr_g pr.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "assert (pr_f_g : Riemann_integrable (fun x : R => f x + (-1) * g x) a b).", "exn": "The reference g was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros."], "tactic": "apply RiemannInt_P10; auto.", "exn": "In environment a, b, c : R H : c > 0 Unable to unify \"forall eps : posreal, {phi : StepFun ?M2285 ?M2286 & {psi : StepFun ?M2285 ?M2286 | (forall t : R, Rmin ?M2285 ?M2286 <= t <= Rmax ?M2285 ?M2286 -> Rabs ((fun x : R => ?M2283 x + ?M2287 * ?M2284 x) t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}}\" with \"(a / c < b -> a < b * c) /\\\\ (a < b * c -> a / c < b)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: RiemannInt_P10."], "tactic": "assert (H := RiemannInt_P13 f g a b (-1) pr_f pr_g pr_f_g).", "exn": "The reference pr_f_g was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros f g a b pr_f pr_g pr. assert (pr_f_g : Riemann_integrable (fun x : R => f x + (-1) * g x) a b). { apply RiemannInt_P10; auto. } assert (H := RiemannInt_P13 f g a b (-1) pr_f pr_g pr_f_g). simpl in H. rewrite H. simpl. assert (H0 : RiemannInt pr_f_g = RiemannInt pr). { apply RiemannInt_ext. intros x Hx. unfold Rminus, Rplus, Ropp. reflexivity. } rewrite <- H0. rewrite Rplus_assoc. rewrite Rplus_opp_r. rewrite Rplus_0_r. reflexivity.", "back_times": 0, "succ": true, "time": 90.08272504806519}]