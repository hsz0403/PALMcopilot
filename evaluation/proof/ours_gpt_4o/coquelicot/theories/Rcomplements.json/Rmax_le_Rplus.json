[{"history": {"proof": "intros. qsimpl time: 1 use: Riemann_integrable,f. apply Ropp_le_cancel. apply Ropp_le_cancel. hcrush use: Rplus_0_r, Rplus_le_compat_l, Rplus_opp_r, Ropp_involutive, Rplus_comm unfold: Rmax, Rminus. qsimpl time: 1 use: Riemann_integrable,f. qsimpl time: 1 use: Riemann_integrable,f,Rplus_opp_r.", "repairs": ["no_product", "wrong_type", "ref_not_found", "ref_not_found", "hammer", "wrong_type", "no_match_term"], "exceptions": [{"ctx": [], "tactic": "intros f a b pr_f pr.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "pose (pr_opp := Riemann_integrable_Ropp f a b pr_f).", "exn": "The reference pr_f was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros."], "tactic": "assert (H: Riemann_integrable (fun x => f x + (- f x)) a b).", "exn": "In environment a, b : R H : 0 <= a H0 : 0 <= b x : R The term \"x\" has type \"R\" while it is expected to have type \"family\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Riemann_integrable,f."], "tactic": "apply Riemann_integrable_plus.", "exn": "The reference Riemann_integrable_plus was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Riemann_integrable,f.", "apply Ropp_le_cancel."], "tactic": "apply pr_f.", "exn": "The reference pr_f was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Riemann_integrable,f.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel."], "tactic": "apply pr_opp.", "exn": "The reference pr_opp was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Riemann_integrable,f.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel."], "tactic": "assert (Heq: forall x, (fun x => f x + (- f x)) x = 0).", "exn": "In environment X0 : family -> R -> R -> Prop a, b : R H : 0 <= a H0 : 0 <= b X1 : Type x : ?T x0 : family The term \"f x0\" has type \"R -> R -> Prop\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Riemann_integrable,f.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel.", "qsimpl time: 1 use: Riemann_integrable,f."], "tactic": "intro x.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: Riemann_integrable,f.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel.", "apply Ropp_le_cancel.", "qsimpl time: 1 use: Riemann_integrable,f."], "tactic": "rewrite Rplus_opp_r.", "exn": "The LHS of Rplus_opp_r (_ + - _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}]}, "chat": [], "original": "intros f a b pr_f pr. pose (pr_opp := Riemann_integrable_Ropp f a b pr_f). assert (H: Riemann_integrable (fun x => f x + (- f x)) a b). apply Riemann_integrable_plus. - apply pr_f. - apply pr_opp. assert (Heq: forall x, (fun x => f x + (- f x)) x = 0). intro x. rewrite Rplus_opp_r. reflexivity. assert (H0: RiemannInt H = RiemannInt pr_f + RiemannInt pr). apply RiemannInt_plus with (pr1:=pr_f) (pr2:=pr) (pr3:=H). assert (H1: RiemannInt H = RiemannInt (Riemann_integrable_ext _ _ _ _ _ H _ Heq)). apply RiemannInt_ext. auto. rewrite H0 in H1. rewrite Rplus_0_r in H1. symmetry in H1.", "back_times": 0, "succ": true, "time": 71.69655132293701}]