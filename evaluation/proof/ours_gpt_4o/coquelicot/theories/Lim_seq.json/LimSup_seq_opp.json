[{"history": {"proof": "qsimpl time: 1 use: is_LimInf_supInf_seq. qsimpl time: 1 use: is_sup_seq_ext,nat,is_LimInf_supInf_seq,Inf_seq. qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_opp_sup,Inf_seq. qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_seq_ext,Inf_opp_sup,Inf_seq.", "repairs": ["no_subterm", "cannot_unify", "no_match_term", "cannot_unify"], "exceptions": [{"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq."], "tactic": "rewrite <- is_LimInf_supInf_seq.", "exn": "Found no subterm matching \"is_sup_seq (fun m : nat => Inf_seq (fun n : nat => ?r (n + m)%nat)) ?r0\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq.", "qsimpl time: 1 use: is_LimInf_supInf_seq."], "tactic": "apply is_sup_seq_ext with (u := fun m : nat => Inf_seq (fun n : nat => - u (n + m)%nat)).", "exn": "In environment u : nat -> R H : forall (u : nat -> R) (l : Rbar), is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l -> is_LimInf_seq u l H0 : forall (u : nat -> R) (l : Rbar), is_LimInf_seq u l -> is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l Unable to unify \"match ?M2494 with | Finite l => forall eps : posreal, (forall n : nat, Rbar_lt (?M2493 n) (l + eps)) /\\\\ (exists n : nat, Rbar_lt (l - eps) (?M2493 n)) | p_infty => forall M : R, exists n : nat, Rbar_lt M (?M2493 n) | m_infty => forall (M : R) (n : nat), Rbar_lt (?M2493 n) M end\" with \"match LimInf_seq u with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ u n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < u n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < u n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ u n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq.", "qsimpl time: 1 use: is_LimInf_supInf_seq.", "qsimpl time: 1 use: is_sup_seq_ext,nat,is_LimInf_supInf_seq,Inf_seq."], "tactic": "intros n.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq.", "qsimpl time: 1 use: is_LimInf_supInf_seq.", "qsimpl time: 1 use: is_sup_seq_ext,nat,is_LimInf_supInf_seq,Inf_seq."], "tactic": "rewrite Inf_opp_sup.", "exn": "The LHS of Inf_opp_sup (Inf_seq _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq.", "qsimpl time: 1 use: is_LimInf_supInf_seq.", "qsimpl time: 1 use: is_sup_seq_ext,nat,is_LimInf_supInf_seq,Inf_seq.", "qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_opp_sup,Inf_seq."], "tactic": "apply Inf_seq_ext.", "exn": "In environment H6 : (nat -> Rbar) -> Rbar H5 : forall u : nat -> Rbar, Inf_seq u = Rbar_opp (Sup_seq (fun n : nat => Rbar_opp (u n))) H4 : forall (u v : nat -> Rbar) (l : Rbar), (forall n : nat, u n = v n) -> is_sup_seq u l -> is_sup_seq v l H3 : (nat -> Rbar) -> Rbar u : nat -> R H : forall (u : nat -> R) (l : Rbar), is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l -> is_LimInf_seq u l H0 : forall (u : nat -> R) (l : Rbar), is_LimInf_seq u l -> is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l Unable to unify \"Inf_seq ?M3388 = Inf_seq ?M3389\" with \"match LimInf_seq u with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ u n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < u n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < u n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ u n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq.", "qsimpl time: 1 use: is_LimInf_supInf_seq.", "qsimpl time: 1 use: is_sup_seq_ext,nat,is_LimInf_supInf_seq,Inf_seq.", "qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_opp_sup,Inf_seq.", "qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_seq_ext,Inf_opp_sup,Inf_seq."], "tactic": "intros m.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["apply is_LimSup_seq_unique.", "apply is_LimSup_opp_LimInf_seq.", "qsimpl time: 1 use: is_LimInf_supInf_seq.", "qsimpl time: 1 use: is_sup_seq_ext,nat,is_LimInf_supInf_seq,Inf_seq.", "qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_opp_sup,Inf_seq.", "qsimpl time: 1 use: nat,is_LimInf_supInf_seq,is_sup_seq_ext,Inf_seq_ext,Inf_opp_sup,Inf_seq."], "tactic": "apply Rbar_opp_involutive.", "exn": "In environment H9 : (nat -> Rbar) -> Rbar H8 : forall u : nat -> Rbar, Inf_seq u = Rbar_opp (Sup_seq (fun n : nat => Rbar_opp (u n))) H7 : forall u v : nat -> Rbar, (forall n : nat, u n = v n) -> Inf_seq u = Inf_seq v H2 : forall (u v : nat -> Rbar) (l : Rbar), (forall n : nat, u n = v n) -> is_sup_seq u l -> is_sup_seq v l H6, H3 : (nat -> Rbar) -> Rbar u : nat -> R H : forall (u : nat -> R) (l : Rbar), is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l -> is_LimInf_seq u l H0 : forall (u : nat -> R) (l : Rbar), is_LimInf_seq u l -> is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l Unable to unify \"Rbar_opp (Rbar_opp ?M4976) = ?M4976\" with \"match LimInf_seq u with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ u n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < u n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < u n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ u n < M end\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "apply is_LimSup_seq_unique. apply is_LimSup_opp_LimInf_seq. rewrite <- is_LimInf_supInf_seq. apply is_sup_seq_ext with (u := fun m : nat => Inf_seq (fun n : nat => - u (n + m)%nat)). - intros n. rewrite Inf_opp_sup. apply Inf_seq_ext. intros m. apply Rbar_opp_involutive. - apply is_sup_seq_ext with (u := fun m : nat => Rbar_opp (Sup_seq (fun n : nat => u (n + m)%nat))). ++ intros n. apply Rbar_opp_involutive. ++ apply is_sup_opp_inf_seq. apply is_LimSup_infSup_seq. apply is_LimSup_seq_unique. reflexivity.", "back_times": 0, "succ": false, "time": 140.0503067970276}]