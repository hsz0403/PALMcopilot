[{"history": {"proof": "qsimpl time: 1 use: is_inf_seq_glb. qsimpl time: 1 use: is_sup_seq_lub,is_inf_seq_glb. qsimpl time: 1 use: is_sup_seq_lub,Rbar_is_glb,is_inf_seq_glb.", "repairs": ["cannot_unify", "cannot_apply_in", "cannot_unify"], "exceptions": [{"ctx": ["pose (v := fun n => Inf_seq (fun m => u (m + n)%nat))."], "tactic": "assert (H: is_sup_seq v l) by apply is_LimInf_supInf_seq.", "exn": "The reference l was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["pose (v := fun n => Inf_seq (fun m => u (m + n)%nat)).", "destruct (ex_sup_seq v) as [l' Hl'].", "exists l'."], "tactic": "apply is_inf_seq_glb.", "exn": "In environment u : nat -> R v := fun n : nat => Inf_seq (fun m : nat => u (m + n)%nat) : nat -> Rbar l' : Rbar Hl' : is_sup_seq v l' Unable to unify \"Rbar_is_lower_bound (fun x : Rbar => exists n : nat, x = ?M2372 n) ?M2373 /\\\\ (forall b : Rbar, Rbar_is_lower_bound (fun x : Rbar => exists n : nat, x = ?M2372 n) b -> Rbar_le b ?M2373)\" with \"match l' with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ u n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < u n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < u n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ u n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["pose (v := fun n => Inf_seq (fun m => u (m + n)%nat)).", "destruct (ex_sup_seq v) as [l' Hl'].", "exists l'.", "qsimpl time: 1 use: is_inf_seq_glb."], "tactic": "apply is_sup_seq_lub in H.", "exn": "Unable to apply lemma of type \"forall (u : nat -> Rbar) (l : Rbar), is_sup_seq u l -> Rbar_is_lub (fun x : Rbar => exists n : nat, x = u n) l\" on hypothesis of type \"forall (u : nat -> Rbar) (l : Rbar), is_inf_seq u l -> Rbar_is_glb (fun x : Rbar => exists n : nat, x = u n) l\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["pose (v := fun n => Inf_seq (fun m => u (m + n)%nat)).", "destruct (ex_sup_seq v) as [l' Hl'].", "exists l'.", "qsimpl time: 1 use: is_inf_seq_glb.", "qsimpl time: 1 use: is_sup_seq_lub,is_inf_seq_glb."], "tactic": "rewrite <- (is_sup_seq_unique _ _ H).", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["pose (v := fun n => Inf_seq (fun m => u (m + n)%nat)).", "destruct (ex_sup_seq v) as [l' Hl'].", "exists l'.", "qsimpl time: 1 use: is_inf_seq_glb.", "qsimpl time: 1 use: is_sup_seq_lub,is_inf_seq_glb.", "rewrite <- (is_sup_seq_unique _ _ Hl')."], "tactic": "apply Rbar_is_glb.", "exn": "In environment H1 : forall (u : nat -> Rbar) (l : Rbar), is_inf_seq u l -> Rbar_is_glb (fun x : Rbar => exists n : nat, x = u n) l H0 : forall (u : nat -> Rbar) (l : Rbar), is_sup_seq u l -> Rbar_is_lub (fun x : Rbar => exists n : nat, x = u n) l u : nat -> R l' : Rbar Hl' : is_sup_seq (fun n : nat => Inf_seq (fun m : nat => u (m + n)%nat)) l' Unable to unify \"Prop\" with \"is_LimInf_seq u (Sup_seq (fun n : nat => Inf_seq (fun m : nat => u (m + n)%nat)))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "pose (v := fun n => Inf_seq (fun m => u (m + n)%nat)). assert (H: is_sup_seq v l) by apply is_LimInf_supInf_seq. destruct (ex_sup_seq v) as [l' Hl']. exists l'. apply is_inf_seq_glb. apply is_sup_seq_lub in H. rewrite <- (is_sup_seq_unique _ _ H). apply Rbar_is_glb. auto.", "back_times": 0, "succ": false, "time": 209.586040019989}]