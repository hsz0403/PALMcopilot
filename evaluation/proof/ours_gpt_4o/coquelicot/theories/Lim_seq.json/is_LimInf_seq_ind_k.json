[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H."], "tactic": "apply is_sup_opp_inf_seq in H.", "exn": "Unable to apply lemma of type \"forall (u : nat -> Rbar) (l : Rbar), is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) <-> is_inf_seq u l\" on hypothesis of type \"is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq."], "tactic": "apply is_sup_opp_inf_seq.", "exn": "In environment u : nat -> R k : nat l : Rbar H : is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l H0 : forall (u : nat -> Rbar) (l : Rbar), is_inf_seq u l -> is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) H1 : forall (u : nat -> Rbar) (l : Rbar), is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) -> is_inf_seq u l Unable to unify \"(is_sup_seq (fun n : nat => Rbar_opp (?M2534 n)) (Rbar_opp ?M2535) -> is_inf_seq ?M2534 ?M2535) /\\\\ (is_inf_seq ?M2534 ?M2535 -> is_sup_seq (fun n : nat => Rbar_opp (?M2534 n)) (Rbar_opp ?M2535))\" with \"match l with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < (fun n0 : nat => u (n0 + k)%nat) n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < (fun n0 : nat => u (n0 + k)%nat) n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq."], "tactic": "apply is_LimInf_opp_LimSup_seq.", "exn": "In environment u : nat -> R k : nat l : Rbar H : is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l H0 : forall (u : nat -> Rbar) (l : Rbar), is_inf_seq u l -> is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) H1 : forall (u : nat -> Rbar) (l : Rbar), is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) -> is_inf_seq u l Unable to unify \"(is_LimInf_seq (fun n : nat => - ?M2534 n) (Rbar_opp ?M2535) -> is_LimSup_seq ?M2534 ?M2535) /\\\\ (is_LimSup_seq ?M2534 ?M2535 -> is_LimInf_seq (fun n : nat => - ?M2534 n) (Rbar_opp ?M2535))\" with \"match l with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < (fun n0 : nat => u (n0 + k)%nat) n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < (fun n0 : nat => u (n0 + k)%nat) n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq."], "tactic": "apply is_LimSup_seq_ext with (u := fun m => - Inf_seq (fun n => u (n + m + k)%nat)).", "exn": "In environment u : nat -> R k : nat l : Rbar H : is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat)) l H0 : forall (u : nat -> Rbar) (l : Rbar), is_inf_seq u l -> is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) H1 : forall (u : nat -> Rbar) (l : Rbar), is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) -> is_inf_seq u l H2 : forall (u : nat -> R) (l : Rbar), is_LimSup_seq u l -> is_LimInf_seq (fun n : nat => - u n) (Rbar_opp l) H3 : forall (u : nat -> R) (l : Rbar), is_LimInf_seq (fun n : nat => - u n) (Rbar_opp l) -> is_LimSup_seq u l Unable to unify \"match ?M2799 with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ l - eps < ?M2798 n) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> ?M2798 n < l + eps) | p_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ M < ?M2798 n | m_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> ?M2798 n < M end\" with \"match l with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < (fun n0 : nat => u (n0 + k)%nat) n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < (fun n0 : nat => u (n0 + k)%nat) n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq."], "tactic": "intros m.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq."], "tactic": "rewrite Inf_opp_sup.", "exn": "The LHS of Inf_opp_sup (Inf_seq _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq.", "shelve.", "-", "intros H.", "apply is_LimInf_seq_ext_loc with (u := fun n => u (n + k)%nat).", "+", "exists O.", "intros n."], "tactic": "reflexivity.", "exn": "In environment u : nat -> R k : nat l : Rbar H : is_LimInf_seq (fun n : nat => u (n + k)%nat) l n : nat H0 : (0 <= n)%nat Unable to unify \"u n\" with \"u (n + k)%nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq.", "shelve.", "-", "intros H.", "apply is_LimInf_seq_ext_loc with (u := fun n => u (n + k)%nat).", "+", "exists O.", "intros n."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq.", "shelve.", "-", "intros H.", "apply is_LimInf_seq_ext_loc with (u := fun n => u (n + k)%nat).", "+", "exists O.", "intros n.", "shelve.", "+", "apply is_LimInf_supInf_seq in H."], "tactic": "apply is_LimSup_infSup_seq.", "exn": "In environment u : nat -> R k : nat l : Rbar H : is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m + k)%nat)) l Unable to unify \"(is_LimSup_seq ?M3577 ?M3578 -> is_inf_seq (fun m : nat => Sup_seq (fun n : nat => ?M3577 (n + m)%nat)) ?M3578) /\\\\ (is_inf_seq (fun m : nat => Sup_seq (fun n : nat => ?M3577 (n + m)%nat)) ?M3578 -> is_LimSup_seq ?M3577 ?M3578)\" with \"match l with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < (fun n0 : nat => u (n0 + k)%nat) n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < (fun n0 : nat => u (n0 + k)%nat) n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq.", "shelve.", "-", "intros H.", "apply is_LimInf_seq_ext_loc with (u := fun n => u (n + k)%nat).", "+", "exists O.", "intros n.", "shelve.", "+", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,Sup_seq,is_sup_seq_ext,is_LimInf_opp_LimSup_seq,is_LimSup_opp_LimInf_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq,is_LimSup_seq_ind_k,is_LimSup_infSup_seq."], "tactic": "apply is_LimSup_seq_ext with (u := fun m => Inf_seq (fun n => u (n + m + k)%nat)).", "exn": "In environment r : (nat -> Rbar) -> Rbar H5 : forall (u v : nat -> R) (l : Rbar), (forall n : nat, u n = v n) -> is_LimSup_seq u l -> is_LimSup_seq v l H4 : forall u : nat -> Rbar, Inf_seq u = Rbar_opp (r (fun n : nat => Rbar_opp (u n))) H1 : forall (u v : nat -> Rbar) (l : Rbar), (forall n : nat, u n = v n) -> is_sup_seq u l -> is_sup_seq v l u : nat -> R k : nat l : Rbar H : is_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m + k)%nat)) l H0 : forall (u : nat -> Rbar) (l : Rbar), is_inf_seq u l -> is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) H9 : forall (u : nat -> Rbar) (l : Rbar), is_sup_seq (fun n : nat => Rbar_opp (u n)) (Rbar_opp l) -> is_inf_seq u l H2 : forall (u : nat -> R) (l : Rbar), is_LimSup_seq u l -> is_LimInf_seq (fun n : nat => - u n) (Rbar_opp l) H10 : forall (u : nat -> R) (l : Rbar), is_LimInf_seq (fun n : nat => - u n) (Rbar_opp l) -> is_LimSup_seq u l H3 : forall (u : nat -> R) (l : Rbar), is_LimInf_seq u l -> is_LimSup_seq (fun n : nat => - u n) (Rbar_opp l) H11 : forall (u : nat -> R) (l : Rbar), is_LimSup_seq (fun n : nat => - u n) (Rbar_opp l) -> is_LimInf_seq u l H7 : forall (u : nat -> R) (k : nat) (l : Rbar), is_LimSup_seq (fun n : nat => u (n + k)%nat) l -> is_LimSup_seq u l H12 : forall (u : nat -> R) (k : nat) (l : Rbar), is_LimSup_seq u l -> is_LimSup_seq (fun n : nat => u (n + k)%nat) l H8 : forall (u : nat -> R) (l : Rbar), is_inf_seq (fun m : nat => r (fun n : nat => u (n + m)%nat)) l -> is_LimSup_seq u l H13 : forall (u : nat -> R) (l : Rbar), is_LimSup_seq u l -> is_inf_seq (fun m : nat => r (fun n : nat => u (n + m)%nat)) l H14 : Rbar Unable to unify \"match ?M4410 with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ l - eps < ?M4409 n) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> ?M4409 n < l + eps) | p_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ M < ?M4409 n | m_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> ?M4409 n < M end\" with \"match l with | Finite l => forall eps : posreal, (forall N : nat, exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < l + eps) /\\\\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < (fun n0 : nat => u (n0 + k)%nat) n) | p_infty => forall M : R, exists N : nat, forall n : nat, (N <= n)%nat -> M < (fun n0 : nat => u (n0 + k)%nat) n | m_infty => forall (M : R) (N : nat), exists n : nat, (N <= n)%nat /\\\\ (fun n0 : nat => u (n0 + k)%nat) n < M end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: is_sup_opp_inf_seq.", "qsimpl time: 1 use: is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,is_LimSup_seq_ext,Inf_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,is_LimInf_opp_LimSup_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq.", "shelve.", "-", "intros H.", "apply is_LimInf_seq_ext_loc with (u := fun n => u (n + k)%nat).", "+", "exists O.", "intros n.", "shelve.", "+", "apply is_LimInf_supInf_seq in H.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,Sup_seq,is_sup_seq_ext,is_LimInf_opp_LimSup_seq,is_LimSup_opp_LimInf_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq,is_LimSup_seq_ind_k,is_LimSup_infSup_seq.", "qsimpl time: 1 use: nat,is_sup_opp_inf_seq,Sup_seq,is_sup_seq_ext,is_LimInf_opp_LimSup_seq,is_LimSup_opp_LimInf_seq,Inf_opp_sup,is_LimSup_seq_ext,Inf_seq,is_LimSup_seq_ind_k,is_LimSup_infSup_seq."], "tactic": "intros m.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "split. - intros H. apply is_LimInf_supInf_seq in H. apply is_sup_opp_inf_seq in H. apply is_sup_opp_inf_seq. apply is_LimInf_opp_LimSup_seq. apply is_LimSup_seq_ext with (u := fun m => - Inf_seq (fun n => u (n + m + k)%nat)). + intros m. rewrite Inf_opp_sup. reflexivity. + apply is_LimSup_seq_ind_k. apply is_LimSup_infSup_seq. apply is_sup_seq_ext with (u := fun m => Sup_seq (fun n => - u (n + m)%nat)). * intros m. apply Rbar_opp_eq_compat, Inf_opp_sup. * apply is_LimSup_seq_ind_k, is_LimSup_opp_LimInf_seq in H. apply H. - intros H. apply is_LimInf_seq_ext_loc with (u := fun n => u (n + k)%nat). + exists O. intros n. reflexivity. + apply is_LimInf_supInf_seq in H. apply is_LimSup_infSup_seq. apply is_LimSup_seq_ext with (u := fun m => Inf_seq (fun n => u (n + m + k)%nat)). * intros m. reflexivity. * apply is_LimSup_seq_ind_k in H. apply H.", "back_times": 1, "succ": false, "time": 382.3358380794525}]