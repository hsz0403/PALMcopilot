[{"history": {"proof": "intros [Hintern [Hassoc [Hneutral Hopposite]]] x y Hopp. unfold is_opposite in Hopp. hauto depth: 2 lq: on exh: on use: regular_l unfold: is_group, opposite, is_opposite. qsimpl time: 1.", "repairs": ["", "", "hammer", "cannot_apply_in"], "exceptions": [{"ctx": ["intros [Hintern [Hassoc [Hneutral Hopposite]]] x y Hopp.", "unfold is_opposite in Hopp.", "destruct Hopp as [Hx [Hy Hxy]]."], "tactic": "apply Hopposite in Hxy.", "exn": "Unable to apply lemma of type \"opposite S G Add O Opp\" on hypothesis of type \"Add x y = O /\\\\ Add y x = O\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros [Hintern [Hassoc [Hneutral Hopposite]]] x y Hopp.", "unfold is_opposite in Hopp.", "destruct Hopp as [Hx [Hy Hxy]].", "qsimpl time: 1."], "tactic": "destruct Hxy as [H1 H2].", "exn": "The reference Hxy was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros [Hintern [Hassoc [Hneutral Hopposite]]] x y Hopp. unfold is_opposite in Hopp. destruct Hopp as [Hx [Hy Hxy]]. apply Hopposite in Hxy. - destruct Hxy as [H1 H2]. apply regular_l with (x:=Add x y) (y:=y) (z:=Opp x). -- apply (Hneutral x). -- apply H1. -- auto. -- apply (Hneutral x). -- rewrite H1. rewrite <- Hassoc. rewrite (Hneutral x x Hx). rewrite H2. reflexivity. - auto.", "back_times": 0, "succ": true, "time": 50.34198880195618}]