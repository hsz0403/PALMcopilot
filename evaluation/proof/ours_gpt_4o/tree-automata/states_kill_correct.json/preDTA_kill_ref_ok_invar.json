[{"history": {"proof": "hauto use: preDTA_ref_ok_def, preDTA_kill_ref_ok_distinct_invar unfold: preDTA_ref_ok_distinct.", "repairs": ["cannot_apply_in", "cannot_apply_in"], "exceptions": [{"ctx": ["intros d sigma Href_ok Hcorrect."], "tactic": "apply preDTA_ref_ok_def in Href_ok.", "exn": "Unable to apply lemma of type \"forall d : preDTA, preDTA_ref_ok d <-> (forall (a : ad) (s : state), MapGet state d a = Some s -> state_ref_ok s d)\" on hypothesis of type \"preDTA_ref_ok d\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy."], "tactic": "apply Href_ok in Hmap_copy.", "exn": "Unable to apply lemma of type \"preDTA_ref_ok d\" on hypothesis of type \"ad\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill."], "tactic": "apply Hcorrect in Hmap.", "exn": "Unable to apply lemma of type \"predta_correct_wrt_sign d sigma\" on hypothesis of type \"ad\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect)."], "tactic": "destruct (states_kill (dta_non_empty_states d) s0) eqn:Ekill.", "exn": "The reference s0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+"], "tactic": "apply states_kill_ref_ok_invar with (s := s0) (s' := s1) in H; auto.", "exn": "The reference s1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+"], "tactic": "exists s1.", "exn": "The reference s1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s."], "tactic": "rewrite Ekill.", "exn": "Found no subterm matching \"states_kill (dta_non_empty_states d) s\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def."], "tactic": "simpl.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "+"], "tactic": "rewrite Ekill in Hmap.", "exn": "Found no subterm matching \"states_kill (dta_non_empty_states d) s\" in Hmap.", "type": "no_subterm", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "+", "qsimpl time: 1 use: preDTA_ref_ok_def."], "tactic": "simpl in Hmap.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "+", "qsimpl time: 1 use: preDTA_ref_ok_def.", "-", "pose proof dt_kill_empty_d as Hd.", "pose proof dt_kill_empty_r as Hr."], "tactic": "specialize (Hd d a t).", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "+", "qsimpl time: 1 use: preDTA_ref_ok_def.", "-", "pose proof dt_kill_empty_d as Hd.", "pose proof dt_kill_empty_r as Hr."], "tactic": "specialize (Hr (preDTA_kill (dta_non_empty_states d) d) a t).", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "+", "qsimpl time: 1 use: preDTA_ref_ok_def.", "-", "pose proof dt_kill_empty_d as Hd.", "pose proof dt_kill_empty_r as Hr.", "remember (preDTA_kill (dta_non_empty_states d) d) as dk."], "tactic": "destruct (dt_kill_empty_d_1 n d p tl H t) as [p' [Hp' Hlist]].", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma Href_ok Hcorrect.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "intros a s Hmap.", "pose proof Hmap as Hmap_copy.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "pose proof states_kill_ref_ok_invar as Hstates_kill.", "destruct s eqn:Es.", "-", "pose proof preDTA_kill_correct_wrt_sign_invar as Hkill.", "specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect).", "destruct (states_kill (dta_non_empty_states d) s) eqn:Ekill.", "+", "exists s.", "qsimpl time: 1 use: preDTA_ref_ok_def.", "+", "qsimpl time: 1 use: preDTA_ref_ok_def.", "-", "pose proof dt_kill_empty_d as Hd.", "pose proof dt_kill_empty_r as Hr.", "remember (preDTA_kill (dta_non_empty_states d) d) as dk.", "remember (prec_list_kill (dta_non_empty_states d) p) as plk.", "exists s.", "unfold preDTA_kill in *."], "tactic": "destruct (MapGet state (M2 state (M0 state) dk0) x) eqn:Ex; auto.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros d sigma Href_ok Hcorrect. apply preDTA_ref_ok_def in Href_ok. intros a s Hmap. pose proof Hmap as Hmap_copy. apply Href_ok in Hmap_copy. pose proof states_kill_ref_ok_invar as Hstates_kill. apply Hcorrect in Hmap. destruct s eqn:Es. - simpl in Hmap. pose proof preDTA_kill_correct_wrt_sign_invar as Hkill. specialize (Hkill d (dta_non_empty_states d) sigma Hcorrect). simpl in Hkill. destruct (states_kill (dta_non_empty_states d) s0) eqn:Ekill. + apply states_kill_ref_ok_invar with (s := s0) (s' := s1) in H; auto. exists s1. rewrite Ekill. simpl. reflexivity. + rewrite Ekill in Hmap. simpl in Hmap. contradiction. - simpl in Hmap. pose proof dt_kill_empty_d as Hd. pose proof dt_kill_empty_r as Hr. specialize (Hd d a t). specialize (Hr (preDTA_kill (dta_non_empty_states d) d) a t). remember (preDTA_kill (dta_non_empty_states d) d) as dk. destruct (dt_kill_empty_d_1 n d p tl H t) as [p' [Hp' Hlist]]. remember (prec_list_kill (dta_non_empty_states d) p) as plk. exists s. unfold preDTA_kill in *. destruct (MapGet state (M2 state (M0 state) dk0) x) eqn:Ex; auto.", "back_times": 0, "succ": true, "time": 223.6991560459137}]