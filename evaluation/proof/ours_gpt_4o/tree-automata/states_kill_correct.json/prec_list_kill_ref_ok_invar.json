[{"history": {"proof": "hauto use: dt_non_empty_fix, prec_list_kill_occur, dt_kill_empty_kill_empty unfold: prec_list_ref_ok.", "repairs": [], "exceptions": [{"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2]."], "tactic": "destruct (IHp1 Hp1 Href_p1) as [s' Hs'].", "exn": "In environment d : preDTA a0 : ad p1, p2, p' : prec_list sigma : signature Href_p1 : prec_list_ref_ok p1 d Href_p2 : prec_list_ref_ok p2 d Hd_correct : predta_correct_wrt_sign d sigma Ha0 : MapGet bool (dta_non_empty_states d) a0 = Some true Hkill : match p2 with | prec_cons _ _ _ => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la'0 ls') | None => Some (prec_cons a la'0 prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => Some (prec_cons a la'0 prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some (prec_cons a0 la' ls') | None => Some (prec_cons a0 la' prec_empty) end | None => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some ls' | None => None end end | prec_empty => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => Some (prec_cons a0 la' prec_empty) | None => None end end = Some p' a : ad Hoc : prec_occur p' a IHp1 : prec_list_ref_ok p1 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s IHp2 : prec_list_ref_ok p2 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s p : prec_list Hp1 : prec_list_kill (dta_non_empty_states d) p1 = Some p p0 : prec_list Hp2 : prec_list_kill (dta_non_empty_states d) p2 = Some p0 H0 : match p2 with | prec_cons _ _ _ => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la'0 ls') | None => Some (prec_cons a la'0 prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => Some (prec_cons a la'0 prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some (prec_cons a0 la' ls') | None => Some (prec_cons a0 la' prec_empty) end | None => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some ls' | None => None end end | prec_empty => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => Some (prec_cons a0 la' prec_empty) | None => None end end = Some p' The term \"Hp1\" has type \"prec_list_kill (dta_non_empty_states d) p1 = Some p\" while it is expected to have type \"prec_list_ref_ok p1 d\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2]."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _]."], "tactic": "destruct (IHp1 Hp1 Href_p1) as [s' Hs'].", "exn": "In environment d : preDTA a0 : ad p1, p2, p' : prec_list sigma : signature Href_p1 : prec_list_ref_ok p1 d Hd_correct : predta_correct_wrt_sign d sigma Ha0 : MapGet bool (dta_non_empty_states d) a0 = Some true Hkill : match p2 with | prec_cons _ _ _ => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la'0 ls') | None => Some (prec_cons a la'0 prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => Some (prec_cons a la'0 prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some (prec_cons a0 la' ls') | None => Some (prec_cons a0 la' prec_empty) end | None => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some ls' | None => None end end | prec_empty => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => Some (prec_cons a0 la' prec_empty) | None => None end end = Some p' a : ad Hoc : prec_occur p' a IHp1 : prec_list_ref_ok p1 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s IHp2 : prec_list_ref_ok p2 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s p : prec_list Hp1 : prec_list_kill (dta_non_empty_states d) p1 = Some p Hp2 : prec_list_kill (dta_non_empty_states d) p2 = None The term \"Hp1\" has type \"prec_list_kill (dta_non_empty_states d) p1 = Some p\" while it is expected to have type \"prec_list_ref_ok p1 d\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _]."], "tactic": "qsimpl time: 1 use: qsimpl,st_kill_0.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _]."], "tactic": "--", "exn": "Wrong bullet --: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct."], "tactic": "destruct (IHp2 Hkill (proj2 Href_correct)) as [s' Hs'].", "exn": "In environment d : preDTA a0 : ad p1, p2, p' : prec_list sigma : signature Href_correct : prec_list_ref_ok p1 d /\\\\ prec_list_ref_ok p2 d Hd_correct : predta_correct_wrt_sign d sigma Ha0 : MapGet bool (dta_non_empty_states d) a0 = Some true Hkill : match p2 with | prec_cons _ _ _ => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la'0 ls') | None => Some (prec_cons a la'0 prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => Some (prec_cons a la'0 prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some (prec_cons a0 la' ls') | None => Some (prec_cons a0 la' prec_empty) end | None => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some ls' | None => None end end | prec_empty => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => Some (prec_cons a0 la' prec_empty) | None => None end end = Some p' a : ad Hoc : prec_occur p' a IHp1 : prec_list_ref_ok p1 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s IHp2 : prec_list_ref_ok p2 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s Hp1 : prec_list_kill (dta_non_empty_states d) p1 = None The term \"Hkill\" has type \"match p2 with | prec_cons _ _ _ => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la'0 ls') | None => Some (prec_cons a la'0 prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => Some (prec_cons a la'0 prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some (prec_cons a0 la' ls') | None => Some (prec_cons a0 la' prec_empty) end | None => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 with | Some ls' => Some ls' | None => None end end | prec_empty => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 with | Some la' => Some (prec_cons a0 la' prec_empty) | None => None end end = Some p'\" while it is expected to have type \"prec_list_ref_ok p2 d\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct."], "tactic": "qsimpl time: 1 use: qsimpl,proj2,st_kill_0.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct."], "tactic": "*", "exn": "Wrong bullet *: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst."], "tactic": "destruct (IHp2 Hp2 (proj2 Href_correct)) as [s' Hs'].", "exn": "In environment d : preDTA a0 : ad p1, p2, p' : prec_list sigma : signature Href_correct : prec_list_ref_ok (prec_cons a0 p1 p2) d Hd_correct : predta_correct_wrt_sign d sigma Ha0 : MapGet bool (dta_non_empty_states d) a0 = Some false Hkill : match p2 with | prec_cons _ _ _ => (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 | prec_empty => None end = Some p' a : ad Hoc : prec_occur p' a IHp1 : prec_list_ref_ok p1 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s IHp2 : prec_list_ref_ok p2 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s p : prec_list Hp2 : prec_list_kill (dta_non_empty_states d) p2 = Some p H0 : match p2 with | prec_cons _ _ _ => (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 | prec_empty => None end = Some p' The term \"Hp2\" has type \"prec_list_kill (dta_non_empty_states d) p2 = Some p\" while it is expected to have type \"prec_list_ref_ok p2 d\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst."], "tactic": "qsimpl time: 1 use: qsimpl,proj2,st_kill_0.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst.", "shelve.", "--", "inversion Hkill."], "tactic": "+", "exn": "Wrong bullet +: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst.", "shelve.", "--", "inversion Hkill.", "shelve.", "+", "apply prec_list_ref_ok_destr in Href_correct."], "tactic": "destruct (IHp2 Hkill (proj2 Href_correct)) as [s' Hs'].", "exn": "In environment d : preDTA a0 : ad p1, p2, p' : prec_list sigma : signature Href_correct : prec_list_ref_ok p1 d /\\\\ prec_list_ref_ok p2 d Hd_correct : predta_correct_wrt_sign d sigma Ha0 : MapGet bool (dta_non_empty_states d) a0 = None Hkill : match p2 with | prec_cons _ _ _ => (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 | prec_empty => None end = Some p' a : ad Hoc : prec_occur p' a IHp1 : prec_list_ref_ok p1 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p1 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s IHp2 : prec_list_ref_ok p2 d -> (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 = Some p' -> exists s : state, MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some s The term \"Hkill\" has type \"match p2 with | prec_cons _ _ _ => (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) (dta_non_empty_states d) p2 | prec_empty => None end = Some p'\" while it is expected to have type \"prec_list_ref_ok p2 d\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst.", "shelve.", "--", "inversion Hkill.", "shelve.", "+", "apply prec_list_ref_ok_destr in Href_correct."], "tactic": "qsimpl time: 1 use: qsimpl,proj2,st_kill_0.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p p' sigma Href_correct Hd_correct Hkill.", "unfold prec_list_ref_ok.", "intros a Hoc.", "unfold prec_list_kill, preDTA_kill in Hkill.", "induction p.", "-", "destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0.", "+", "destruct b.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1.", "--", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "++", "inversion Hkill; subst.", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 Href_p2].", "shelve.", "++", "apply prec_list_ref_ok_destr in Href_correct.", "destruct Href_correct as [Href_p1 _].", "shelve.", "--", "apply prec_list_ref_ok_destr in Href_correct.", "shelve.", "*", "destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2.", "--", "inversion Hkill; subst.", "shelve.", "--", "inversion Hkill.", "shelve.", "+", "apply prec_list_ref_ok_destr in Href_correct."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros d p p' sigma Href_correct Hd_correct Hkill. unfold prec_list_ref_ok. intros a Hoc. unfold prec_list_kill, preDTA_kill in Hkill. induction p. - destruct (MapGet bool (dta_non_empty_states d) a0) eqn:Ha0. + destruct b. * simpl in Hkill. destruct (prec_list_kill (dta_non_empty_states d) p1) eqn:Hp1. -- destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2. ++ inversion Hkill; subst. apply prec_list_ref_ok_destr in Href_correct. destruct Href_correct as [Href_p1 Href_p2]. destruct (IHp1 Hp1 Href_p1) as [s' Hs']. destruct (IHp2 Hp2 Href_p2) as [s'' Hs'']. exists s'. eapply st_kill_0; eauto. ++ simpl in Hkill. apply prec_list_ref_ok_destr in Href_correct. destruct Href_correct as [Href_p1 _]. destruct (IHp1 Hp1 Href_p1) as [s' Hs']. exists s'. eapply st_kill_0; eauto. -- simpl in Hkill. apply prec_list_ref_ok_destr in Href_correct. destruct (IHp2 Hkill (proj2 Href_correct)) as [s' Hs']. exists s'. eapply st_kill_0; eauto. * simpl in Hkill. destruct (prec_list_kill (dta_non_empty_states d) p2) eqn:Hp2. -- inversion Hkill; subst. destruct (IHp2 Hp2 (proj2 Href_correct)) as [s' Hs']. exists s'. eapply st_kill_0; eauto. -- inversion Hkill. + simpl in Hkill. apply prec_list_ref_ok_destr in Href_correct. destruct (IHp2 Hkill (proj2 Href_correct)) as [s' Hs']. exists s'. eapply st_kill_0; eauto. - inversion Hkill.", "back_times": 2, "succ": true, "time": 377.61980843544006}]