[{"history": {"proof": "qsimpl time: 1. qsimpl time: 1 use: semantic_equiv_0_2.", "repairs": ["no_subterm", "cannot_unify"], "exceptions": [{"ctx": ["induction 1 using reconnaissance_ind.", "unfold essence, rec_term."], "tactic": "rewrite H.", "exn": "Found no subterm matching \"MapGet state d a\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["induction 1 using reconnaissance_ind.", "unfold essence, rec_term.", "qsimpl time: 1."], "tactic": "apply semantic_equiv_0_2 with (s := ladj) (p := l).", "exn": "In environment d : preDTA a, a0 : ad t : term_list ladj : state Heqo : MapGet state d a = Some ladj p : prec_list Heqo0 : MapGet prec_list ladj a0 = Some p l : prec_list H4 : MapGet prec_list ladj a0 = Some l H5 : liste_reconnait d l t Unable to unify \"rec_list_terms ?M4018 l ?M4021 ?M4022 = true\" with \"(fix rec_term (d : preDTA) (a : ad) (t : term) (n : nat) {struct n} : bool := match n with | 0 => false | S k => match t with | app c l => match MapGet state d a with | Some lts => match MapGet prec_list lts c with | Some pre => rec_list_terms d pre l k | None => false end | None => false end end end with rec_list_terms (d : preDTA) (pre : prec_list) (l : term_list) (n : nat) {struct n} : bool := match n with | 0 => false | S k => match pre with | prec_cons st stp pre' => match l with | tnil => false | tcons hd tl => rec_list_terms d pre' l k || rec_term d st hd k && rec_list_terms d stp tl k end | prec_empty => match l with | tnil => true | tcons _ _ => false end end end for rec_list_terms) d p t (DTA_taille d + S (DTA_taille d + term_high_0 t * S (DTA_taille d))) = true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["induction 1 using reconnaissance_ind.", "unfold essence, rec_term.", "qsimpl time: 1.", "qsimpl time: 1 use: semantic_equiv_0_2."], "tactic": ["apply invar_1_1 with (p:=l).", ""], "exn": "No such bound variable p (possible names are: d, a, c, t and n).", "type": "no_such_bound", "handled": false}]}, "chat": [], "original": "induction 1 using reconnaissance_ind. - unfold essence, rec_term. rewrite H. simpl. apply semantic_equiv_0_2 with (s := ladj) (p := l). + apply invar_1_1 with (p:=l). apply semantic_equiv_0_3. now exists ladj. + apply semantic_equiv_1_0. now exists ladj. - apply invar_1_0 with (s := s) (p := l) (n := 0). + auto. + auto. + apply semantic_equiv_0_3. now exists s.", "back_times": 0, "succ": false, "time": 96.93198704719543}]