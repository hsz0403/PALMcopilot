[{"history": {"proof": "intros d m. unfold def_ok_app. unfold dta_app_ne_aux. induction d. - sauto lq: on depth: 3. - destruct m. + sauto lq: on depth: 3. + destruct (N.lxor_eq a a). * qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0. srun best use: N.lxor_nilpotent unfold: ad. * sauto lq: on depth: 3. + sauto lq: on depth: 3. - sauto depth: 3.", "repairs": ["", "", "", "", "", "hammer", "", "", "", "hammer", "", "ref_not_found", "", "cannot_unify", "hammer", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-"], "tactic": ["apply lattice_bounded_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+"], "tactic": ["apply lattice_bounded_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+"], "tactic": "destruct (ad_eq_dec a a).", "exn": "The reference ad_eq_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*"], "tactic": "apply lattice_bounded_1.", "exn": "In environment a : ad a0 : state a1 : ad b : bool Unable to unify \"lattice_bounded_def_0 (single bool ?M1871) -> forall m : Map bool, lattice_bounded_def_0 (concat bool (single bool ?M1871) m)\" with \"N.lxor a a = 0%N\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*"], "tactic": ["apply lattice_bounded_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+"], "tactic": ["apply lattice_bounded_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+"], "tactic": ["apply lattice_bounded_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+", "shelve.", "+"], "tactic": ["apply lattice_bounded_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "shelve.", "+"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0."], "tactic": "apply IHd1.", "exn": "In environment H0 : forall m : Map bool, lattice_bounded_def_0 (single bool m) H : forall m : Map bool, lattice_bounded_def_1 (single bool m) d1, d2 : Map state m1, m2 : Map bool IHd1 : forall x : Map bool, ensemble_base state d1 x -> ensemble_base state d1 ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) d1 (M2 bool m1 m2) x) IHd2 : forall x : Map bool, ensemble_base state d2 x -> ensemble_base state d2 ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) d2 (M2 bool m1 m2) x) x : Map bool H1 : ensemble_base state (M2 state d1 d2) x Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d1 ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) d1 (M2 bool m1 m2) ?M2255)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool (M2 state d1 d2) ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) (M2 state d1 d2) (M2 bool m1 m2) x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m.", "unfold def_ok_app.", "unfold dta_app_ne_aux.", "induction d.", "-", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "destruct (N.lxor_eq a a).", "*", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "shelve.", "*", "shelve.", "+", "shelve.", "-", "destruct m.", "+", "shelve.", "+", "shelve.", "+", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0.", "qsimpl time: 1 use: lattice_bounded_1,lattice_bounded_0."], "tactic": "apply IHd2.", "exn": "In environment H3 : forall m : Map bool, lattice_bounded_def_0 (single bool m) H2 : forall m : Map bool, lattice_bounded_def_1 (single bool m) d1, d2 : Map state m1, m2 : Map bool IHd1 : forall x : Map bool, ensemble_base state d1 x -> ensemble_base state d1 ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) d1 (M2 bool m1 m2) x) IHd2 : forall x : Map bool, ensemble_base state d2 x -> ensemble_base state d2 ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) d2 (M2 bool m1 m2) x) x : Map bool H1 : ensemble_base state (M2 state d1 d2) x Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d2 ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) d2 (M2 bool m1 m2) ?M2471)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool (M2 state d1 d2) ((fix dta_app_ne_aux (d : preDTA) (m r : Map bool) {struct r} : Map bool := match d with | @M0 _ => M0 bool | @M1 _ a s => match r with | @M1 _ a' b => if (a =? a')%N then M1 bool a (b || st_non_empty m s) else M0 bool | _ => M0 bool end | @M2 _ d0 d1 => match r with | @M2 _ r0 r1 => M2 bool (dta_app_ne_aux d0 m r0) (dta_app_ne_aux d1 m r1) | _ => M0 bool end end) (M2 state d1 d2) (M2 bool m1 m2) x)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros d m. unfold def_ok_app. unfold dta_app_ne. unfold dta_app_ne_aux. induction d. - simpl. apply lattice_bounded_0. - destruct m. + simpl. apply lattice_bounded_0. + simpl. destruct (ad_eq_dec a a). * apply lattice_bounded_1. * apply lattice_bounded_0. + simpl. apply lattice_bounded_0. - destruct m. + simpl. apply lattice_bounded_0. + simpl. apply lattice_bounded_0. + simpl. split. * apply IHd1. * apply IHd2.", "back_times": 6, "succ": true, "time": 61.227055072784424}]