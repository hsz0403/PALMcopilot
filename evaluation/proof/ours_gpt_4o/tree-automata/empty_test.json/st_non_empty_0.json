[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m s p a H1 H2.", "revert s a H1.", "induction p.", "-", "intros.", "destruct a0.", "--"], "tactic": "destruct (MapGet bool m a0) eqn:G1.", "exn": "The reference a0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m s p a H1 H2.", "revert s a H1.", "induction p.", "-", "intros.", "destruct a0.", "--", "destruct (MapGet bool m a) eqn:G1.", "++"], "tactic": "apply Bool.orb_true_iff in H2.", "exn": "Unable to apply lemma of type \"forall b1 b2 : bool, b1 || b2 = true <-> b1 = true \\\\/ b2 = true\" on hypothesis of type \"pl_non_empty m (prec_cons a p1 p2) = true\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros m s p a H1 H2. revert s a H1. induction p. - simpl. intros. destruct a0. -- destruct (MapGet bool m a0) eqn:G1. ++ apply Bool.orb_true_iff in H2. destruct H2. ** simpl in H1. rewrite G1, (surjective_pairing (MapGet prec_list s a0)) in H1. destruct H1. apply (IHp1 s x); auto. ** simpl. rewrite G1 in H2. simpl. rewrite H2.", "back_times": 0, "succ": false, "time": 127.91093802452087}]