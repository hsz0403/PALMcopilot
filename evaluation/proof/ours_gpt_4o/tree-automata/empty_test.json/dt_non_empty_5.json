[{"history": {"proof": "qsimpl time: 1 use: reconnaissance_ind. qsimpl time: 1 use: reconnaissance_ind.", "repairs": ["no_subterm", "no_hypos"], "exceptions": [{"ctx": ["intros d a t H n Ht."], "tactic": "apply reconnaissance_ind with (a:=a) (t:=t).", "exn": "Found no subterm matching \"t\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "intros p a0 t0 ladj Hladj Hsreconnait n0 Htermhigh.", "exn": "ladj is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "intros p a0 t0 ladj' Hladj Hsreconnait n0 Htermhigh.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "destruct (eq_nat_dec (term_high t0) 0).", "exn": "The reference t0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "assert (term_high t0 <= 0) by lia.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "rewrite e in H0.", "exn": "The reference e was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "simpl in Htermhigh.", "exn": "No such hypothesis: Htermhigh", "type": "no_hypos", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind.", "qsimpl time: 1 use: reconnaissance_ind."], "tactic": "rewrite H0.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H n Ht.", "qsimpl time: 1 use: reconnaissance_ind.", "qsimpl time: 1 use: reconnaissance_ind.", "rewrite dt_non_empty_0."], "tactic": "apply map_mini_mapget_true with (A:=state) (x:=d) in Hladj.", "exn": "No such hypothesis: Hladj", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros d a t H n Ht. apply reconnaissance_ind with (a:=a) (t:=t). - intros p a0 t0 ladj Hladj Hsreconnait n0 Htermhigh. destruct (eq_nat_dec (term_high t0) 0). + assert (term_high t0 <= 0) by lia. rewrite e in H0. simpl in Htermhigh. rewrite H0. apply map_mini_mapget_true with (A:=state) (x:=d) in Hladj. contradiction. + assert (term_high t0 > 0) by lia. destruct (dta_non_empty_states_lazy p) as [m Hm]. { apply dta_non_empty_states. } specialize (st_non_empty_1 p m (power (Map bool) (dta_app_ne p) m (term_high t0)) a0 ladj Hladj Hm). intros Hmaptrue. apply semantic_equiv_1_0 in Hsreconnait. -- apply semantic_equiv_0 with (n:=term_high t0) in Hsreconnait. apply semantic_equiv_0_3 in Hsreconnait. destruct Hsreconnait as [s Hs]. exists a0, ladj. split. ++ rewrite <- Hladj. apply Hs. ++ apply st_non_empty_1. auto. apply state_reconnait_ind with (H:=st_non_empty_1) in Hsreconnait. reflexivity.", "back_times": 0, "succ": false, "time": 91.84751510620117}]