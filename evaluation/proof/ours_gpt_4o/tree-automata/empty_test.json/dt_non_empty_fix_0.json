[{"history": {"proof": "qsimpl time: 1 use: lattice_bounded. qsimpl time: 1 use: map_mini_mini,lattice_bounded. qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded. qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded. qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok. qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok. qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok. qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok. qsimpl time: 1 use: lattice_bounded_10,lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "repairs": ["cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros d."], "tactic": "apply lattice_bounded.", "exn": "In environment d : preDTA Unable to unify \"forall p : prechain bool, sas_chain bool (ensemble_base ?M1851 ?M1852) lem p -> chain_length bool p <= S (MapCard ?M1851 ?M1852)\" with \"fix_point bool (ensemble_base state d) (dta_app_ne d) (dta_non_empty_states d) /\\\\ inf_fix_points bool (ensemble_base state d) lem (dta_app_ne d) (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded."], "tactic": "apply map_mini_mini.", "exn": "In environment H : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) d : preDTA Unable to unify \"ensemble_base ?M2246 ?M2247 (map_mini ?M2246 ?M2247) /\\\\ (forall x : Map bool, ensemble_base ?M2246 ?M2247 x -> lem (map_mini ?M2246 ?M2247) x)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded."], "tactic": "apply lem_reflexive.", "exn": "In environment H1 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H0 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) d : preDTA Unable to unify \"r_reflexive bool lem\" with \"ensemble_base state d (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded."], "tactic": "apply lem_antisymmetric.", "exn": "In environment H3 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H2 : r_reflexive bool lem H : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) d : preDTA Unable to unify \"r_antisymmetric bool lem\" with \"ensemble_base state d (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded."], "tactic": "apply lem_transitive.", "exn": "In environment H5 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H4 : r_reflexive bool lem H1 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H0 : r_antisymmetric bool lem d : preDTA Unable to unify \"r_transitive bool lem\" with \"ensemble_base state d (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive."], "tactic": "apply lem_domain_equal.", "exn": "In environment H7 : r_reflexive bool lem H6 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H3 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H2 : r_transitive bool lem H : r_antisymmetric bool lem d : preDTA Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) bool bool ?M2854 ?M2855\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive."], "tactic": "apply lem_reflexive.", "exn": "In environment H9 : r_reflexive bool lem H8 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H5 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H4 : r_transitive bool lem H1 : r_antisymmetric bool lem H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"r_reflexive bool lem\" with \"ensemble_base state d (dta_non_empty_states d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok."], "tactic": "apply dta_app_ne_inc.", "exn": "In environment H10 : r_reflexive bool lem H7 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H6 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H3 : r_transitive bool lem H2 : r_antisymmetric bool lem H : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"forall x y : Map bool, lem x y -> lem (dta_app_ne ?M3450 x) (dta_app_ne ?M3450 y)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive."], "tactic": "apply dt_non_empty_d.", "exn": "In environment H11 : r_reflexive bool lem H9 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H8 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H5 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H4 : r_transitive bool lem H1 : r_antisymmetric bool lem H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"exists n : nat, MapGet bool (power (Map bool) (dta_app_ne ?M3762) (map_mini state ?M3762) n) ?M3763 = Some true\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d."], "tactic": "apply dt_non_empty_r.", "exn": "In environment H13 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H12 : r_reflexive bool lem H10 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H7 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H6 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H3 : r_transitive bool lem H2 : r_antisymmetric bool lem H : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"exists t : term, reconnaissance ?M4139 ?M4140 t\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d."], "tactic": "apply dt_non_empty_5.", "exn": "In environment H15 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H14 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H11 : r_reflexive bool lem H9 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H8 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H5 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H4 : r_transitive bool lem H1 : r_antisymmetric bool lem H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"MapGet bool (power (Map bool) (dta_app_ne ?M4578) (map_mini state ?M4578) ?M4582) ?M4579 = Some true\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d."], "tactic": "apply dt_non_empty_7.", "exn": "In environment H17 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H16 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H13 : r_reflexive bool lem H12 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H10 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H7 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H6 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H3 : r_transitive bool lem H2 : r_antisymmetric bool lem H : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"pl_non_empty (power (Map bool) (dta_app_ne ?M5114) (map_mini state ?M5114) (term_high_0 ?M5116)) ?M5115 = true\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d."], "tactic": "apply dt_non_empty_r_4.", "exn": "In environment H19 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H18 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H15 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H14 : r_reflexive bool lem H11 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H9 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H8 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H5 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H4 : r_transitive bool lem H1 : r_antisymmetric bool lem H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"exists tl : term_list, liste_reconnait ?M5716 ?M5714 tl\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d."], "tactic": "apply dt_non_empty_r_3.", "exn": "In environment H21 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H20 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H17 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H16 : r_reflexive bool lem H13 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H12 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H10 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H7 : forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path), dt_non_empty_r_def_0 n -> pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) -> pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl H6 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H3 : r_transitive bool lem H2 : r_antisymmetric bool lem H : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"dt_non_empty_r_def_0 0\" with \"ensemble_base state d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d."], "tactic": "apply dta_app_ne_aux_def_ok.", "exn": "In environment H23 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H22 : dt_non_empty_r_def_0 0 H19 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H18 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H15 : r_reflexive bool lem H14 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H11 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H9 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H8 : forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path), dt_non_empty_r_def_0 n -> pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) -> pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl H5 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H4 : r_transitive bool lem H1 : r_antisymmetric bool lem H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"forall x : Map bool, ensemble_base state ?M7186 x -> ensemble_base state ?M7186 (dta_app_ne_aux ?M7186 ?M7187 x)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok."], "tactic": "apply dt_non_empty_2.", "exn": "In environment H25 : forall (d : preDTA) (m : Map bool), def_ok_app bool (ensemble_base state d) (dta_app_ne_aux d m) H24 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H21 : dt_non_empty_r_def_0 0 H20 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H17 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H16 : r_reflexive bool lem H13 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H12 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H10 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H7 : forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path), dt_non_empty_r_def_0 n -> pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) -> pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl H6 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H3 : r_transitive bool lem H2 : r_antisymmetric bool lem H : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"forall n : nat, term_high_0 tnil <= n -> pl_non_empty (power (Map bool) (dta_app_ne ?M7978) (map_mini state ?M7978) n) prec_empty = true\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok."], "tactic": "apply semantic_equiv_1_2.", "exn": "In environment H27 : forall (d : preDTA) (m : Map bool), def_ok_app bool (ensemble_base state d) (dta_app_ne_aux d m) H26 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H23 : dt_non_empty_r_def_0 0 H22 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H19 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H18 : r_reflexive bool lem H15 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H14 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H11 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H9 : forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path), dt_non_empty_r_def_0 n -> pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) -> pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl H8 : forall d : preDTA, dt_non_empty_def_2 d prec_empty tnil (rec_empty d) H5 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H4 : r_transitive bool lem H1 : r_antisymmetric bool lem H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"rec_list_terms ?M8786 prec_empty tnil (essence_list tnil ?M8786 prec_empty) = true\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok."], "tactic": "apply lattice_bounded_5.", "exn": "In environment H29 : forall (d : preDTA) (m : Map bool), def_ok_app bool (ensemble_base state d) (dta_app_ne_aux d m) H28 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H25 : dt_non_empty_r_def_0 0 H24 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H21 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H20 : r_reflexive bool lem H17 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H16 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H13 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H12 : forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path), dt_non_empty_r_def_0 n -> pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) -> pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl H10 : forall d : preDTA, dt_non_empty_def_2 d prec_empty tnil (rec_empty d) H7 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H6 : r_transitive bool lem H3 : r_antisymmetric bool lem H2 : forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d) H : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base ?M9611 ?M9612) lem p0 /\\\\ sas_chain bool (ensemble_base ?M9611 ?M9613) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool ?M9610) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool ?M9610)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok."], "tactic": "apply lattice_bounded_10.", "exn": "In environment H31 : forall (d : preDTA) (m : Map bool), def_ok_app bool (ensemble_base state d) (dta_app_ne_aux d m) H30 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H27 : dt_non_empty_r_def_0 0 H26 : forall (p : prechain bool) (A : Set) (m0 m1 : Map A), sas_chain bool (ensemble_base A (M2 A m0 m1)) lem p -> exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p) H23 : forall (n : nat) (d : preDTA) (a : ad), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> exists t : term, reconnaissance d a t H22 : forall (d : preDTA) (p : prec_list) (t : term_list), liste_reconnait d p t -> pl_non_empty (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 t)) p = true H19 : r_reflexive bool lem H18 : forall d : preDTA, increasing_app bool lem (dta_app_ne d) H15 : forall (A : Set) (x : Map A), bounded_sas_chain bool (ensemble_base A x) lem (S (MapCard A x)) H14 : forall (A : Set) (x : Map A), mini bool lem (ensemble_base A x) (map_mini A x) H11 : forall (p : prec_list) (n : nat) (d : preDTA) (pl : pl_path), dt_non_empty_r_def_0 n -> pl_path_true pl (power (Map bool) (dta_app_ne d) (map_mini state d) n) -> pl_path_incl pl p -> exists tl : term_list, liste_reconnait d p tl H9 : forall d : preDTA, dt_non_empty_def_2 d prec_empty tnil (rec_empty d) H8 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> forall n : nat, term_high t <= n -> MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H5 : r_transitive bool lem H4 : r_antisymmetric bool lem H1 : forall d : preDTA, pre_reconnait d prec_empty tnil (rec_empty d) H0 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 d : preDTA Unable to unify \"chain_length bool ?M10516 <= S (MapCard ?M10514 ?M10515)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d ((fix power (A : Set) (f : A -> A) (x : A) (n : nat) {struct n} : A := match n with | 0 => x | S n0 => f (power A f x n0) end) (Map bool) (dta_app_ne d) (map_mini state d) (MapCard state d))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lattice_bounded_10,lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok."], "tactic": "apply essense.", "exn": "The reference essense was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d.", "qsimpl time: 1 use: lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lattice_bounded.", "qsimpl time: 1 use: map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,map_mini_mini,lem_reflexive,lattice_bounded.", "qsimpl time: 1 use: lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,lem_reflexive.", "apply dta_app_ne_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "qsimpl time: 1 use: lattice_bounded_10,lem_domain_equal,semantic_equiv_1_2,lem_antisymmetric,lem_transitive,dt_non_empty_5,dt_non_empty_2,dt_non_empty_r_4,map_mini_mini,lattice_bounded,dta_app_ne_inc,lem_reflexive,dt_non_empty_7,dt_non_empty_r,lattice_bounded_5,dt_non_empty_r_3,dt_non_empty_d,dta_app_ne_aux_def_ok.", "apply prec_list_ind."], "tactic": ["apply semantic_equiv_1.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "intros d. apply lattice_bounded. apply map_mini_mini. apply lem_reflexive. apply lem_antisymmetric. apply lem_transitive. apply lem_domain_equal. apply lem_reflexive. apply dta_app_ne_def_ok. apply dta_app_ne_inc. apply dt_non_empty_d. apply dt_non_empty_r. apply dt_non_empty_5. apply dt_non_empty_7. apply dt_non_empty_r_4. apply dt_non_empty_r_3. apply dta_app_ne_aux_def_ok. apply dt_non_empty_2. apply semantic_equiv_1_2. apply lattice_bounded_5. apply lattice_bounded_10. apply essense. apply semantic_equiv_1. apply semantic_equiv_0_1. apply dta_non_empty_states_lazy.", "back_times": 0, "succ": false, "time": 121.46479773521423}]