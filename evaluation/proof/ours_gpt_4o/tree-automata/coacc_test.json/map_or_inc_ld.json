[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros d m m0 m1 H1 H2.", "destruct H2 as [H2 [H3 H4]].", "split.", "-", "apply map_or_def_ok_d.", "--"], "tactic": "apply H1.", "exn": "In environment d : preDTA m, m0, m1 : Map bool H1 : ensemble_base state d m H2 : ensemble_base state d m0 H3 : ensemble_base state d m1 H4 : lem m0 m1 Unable to unify \"ensemble_base state d m\" with \"ensemble_base state d m0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m m0 m1 H1 H2.", "destruct H2 as [H2 [H3 H4]].", "split.", "-", "apply map_or_def_ok_d.", "--", "qsimpl time: 1.", "--"], "tactic": "apply H2.", "exn": "In environment d : preDTA m, m0, m1 : Map bool H1 : ensemble_base state d m H2 : ensemble_base state d m0 H3 : ensemble_base state d m1 H4 : lem m0 m1 Unable to unify \"ensemble_base state d m0\" with \"ensemble_base state d m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m m0 m1 H1 H2.", "destruct H2 as [H2 [H3 H4]].", "split.", "-", "apply map_or_def_ok_d.", "--", "qsimpl time: 1.", "--", "qsimpl time: 1.", "-", "split.", "--", "apply map_or_def_ok_d.", "++"], "tactic": "apply H1.", "exn": "In environment d : preDTA m, m0, m1 : Map bool H1 : ensemble_base state d m H2 : ensemble_base state d m0 H3 : ensemble_base state d m1 H4 : lem m0 m1 Unable to unify \"ensemble_base state d m\" with \"ensemble_base state d m1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m m0 m1 H1 H2.", "destruct H2 as [H2 [H3 H4]].", "split.", "-", "apply map_or_def_ok_d.", "--", "qsimpl time: 1.", "--", "qsimpl time: 1.", "-", "split.", "--", "apply map_or_def_ok_d.", "++", "qsimpl time: 1.", "++"], "tactic": "apply H3.", "exn": "In environment d : preDTA m, m0, m1 : Map bool H1 : ensemble_base state d m H2 : ensemble_base state d m0 H3 : ensemble_base state d m1 H4 : lem m0 m1 Unable to unify \"ensemble_base state d m1\" with \"ensemble_base state d m\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros d m m0 m1 H1 H2. destruct H2 as [H2 [H3 H4]]. split. - apply map_or_def_ok_d. -- apply H1. -- apply H2. - split. -- apply map_or_def_ok_d. ++ apply H1. ++ apply H3. -- unfold lem in *. revert m1 H4. induction m0 as [|a0 b0|m0 IHm0 m0']. ++ intros [|a1 b1|m1 m1'] H4; simpl in H4; try contradiction. destruct (a0 =? a1)%N. ** simpl. split; apply lemd_reflexive; apply H1. ** simpl. contradiction. ++ intros [|a1 b1|m1 m1'] H4; simpl in H4; try contradiction. destruct (a0 =? a1)%N eqn:Ha. ** simpl in *. subst. destruct b0, b1; simpl in *; try easy. inversion H4; subst; auto. ** contradiction. ++ intros [|a1 b1|m1 m1'] H4; try contradiction. simpl in *. destruct H4 as [H4 H5]. split. ** apply IHm0; auto. ** apply IHm0'; auto.", "back_times": 0, "succ": false, "time": 215.23638272285461}]