[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl."], "tactic": "intro Hok.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl."], "tactic": "apply map_replace_mapget_true.", "exn": "The reference map_replace_mapget_true was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl."], "tactic": "intro Hok.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl."], "tactic": "apply prec_list_ref_ok_destr in Hok as [Hok0 Hok1].", "exn": "No such hypothesis: Hok", "type": "no_hypos", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr."], "tactic": "apply map_or_mapget_true_ld.", "exn": "In environment d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl0 a H0 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"MapGet bool (map_or ?M3059 ?M3060) ?M3061 = Some true\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr."], "tactic": "apply pl_coacc_def_ok.", "exn": "In environment H2 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl0 a H0 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool ?M4331 (pl_coacc ?M4331 ?M4332)\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok."], "tactic": "apply pl_coacc_def_ok.", "exn": "In environment H5 : forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl) H3 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl0 a H0 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool ?M5652 (pl_coacc ?M5652 ?M5653)\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok."], "tactic": "apply IH0; auto.", "exn": "In environment H6 : forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl) H2 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl0 a H0 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"MapGet bool (pl_coacc d pl0) ?M6974 = Some true\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl."], "tactic": "intro Hok.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl."], "tactic": "apply prec_list_ref_ok_destr in Hok as [Hok0 Hok1].", "exn": "No such hypothesis: Hok", "type": "no_hypos", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok."], "tactic": "apply map_or_mapget_true_rd.", "exn": "In environment H2 : forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl) H0 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl1 a H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H3 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"MapGet bool (map_or ?M9616 ?M9617) ?M9618 = Some true\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd."], "tactic": "apply pl_coacc_def_ok.", "exn": "In environment H7 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m1 a = Some true -> MapGet bool (map_or m0 m1) a = Some true H6 : forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl) H4 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl1 a H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H3 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool ?M11104 (pl_coacc ?M11104 ?M11105)\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd."], "tactic": "apply pl_coacc_def_ok.", "exn": "In environment H8 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m1 a = Some true -> MapGet bool (map_or m0 m1) a = Some true H5 : forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl) H0 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl1 a H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H3 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool ?M12593 (pl_coacc ?M12593 ?M12594)\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd."], "tactic": "apply IH1; auto.", "exn": "In environment H7 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m1 a = Some true -> MapGet bool (map_or m0 m1) a = Some true H6 : forall (d : preDTA) (pl : prec_list), ensemble_base state d (pl_coacc d pl) H2 : forall (d : preDTA) (m0 m1 : Map bool) (a : ad), ensemble_base state d m0 -> ensemble_base state d m1 -> MapGet bool m0 a = Some true -> MapGet bool (map_or m0 m1) a = Some true d : preDTA a' : ad pl0, pl1 : prec_list Hoc : prec_list_ref_ok (prec_cons a' pl0 pl1) d IH0 : prec_list_ref_ok pl0 d -> forall a : ad, prec_occur pl0 a -> MapGet bool (pl_coacc d pl0) a = Some true IH1 : prec_list_ref_ok pl1 d -> forall a : ad, prec_occur pl1 a -> MapGet bool (pl_coacc d pl1) a = Some true a : ad Hp : prec_occur (prec_cons a' pl0 pl1) a H : prec_occur pl1 a H1 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok ls d H3 : forall (a : ad) (la ls : prec_list) (d : preDTA), prec_list_ref_ok (prec_cons a la ls) d -> prec_list_ref_ok la d Unable to unify \"MapGet bool (pl_coacc d pl1) ?M14083 = Some true\" with \"MapGet bool (map_replace bool (map_or (pl_coacc d pl0) (pl_coacc d pl1)) a' true) a = Some true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p a Hp Hoc.", "revert a Hp.", "induction p as [a' pl0 IH0 pl1 IH1 |].", "-", "intros a Hp.", "inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst.", "+", "simpl.", "apply map_replace_mapget_ins_true_1.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "shelve.", "+", "simpl.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd.", "qsimpl time: 1 use: map_or_mapget_true_ld,prec_list_ref_ok_destr,pl_coacc_def_ok,map_or_mapget_true_rd."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros d p a Hp Hoc. revert a Hp. induction p as [a' pl0 IH0 pl1 IH1 |]. - intros a Hp. inversion Hp as [Hhd | ? ? ? Hrec0 | ? ? ? Hrec1]; subst. + simpl. intro Hok. apply map_replace_mapget_true. + simpl. intro Hok. apply prec_list_ref_ok_destr in Hok as [Hok0 Hok1]. apply map_or_mapget_true_ld. * apply pl_coacc_def_ok. * apply pl_coacc_def_ok. * apply IH0; auto. + simpl. intro Hok. apply prec_list_ref_ok_destr in Hok as [Hok0 Hok1]. apply map_or_mapget_true_rd. * apply pl_coacc_def_ok. * apply pl_coacc_def_ok. * apply IH1; auto. - intros a H. inversion H.", "back_times": 0, "succ": false, "time": 246.55664706230164}]