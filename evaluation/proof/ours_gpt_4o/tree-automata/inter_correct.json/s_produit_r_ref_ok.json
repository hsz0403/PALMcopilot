[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-"], "tactic": "destruct (sproductr_1 s a p a' p0 H3) as [r0 [r1 [H4 H5]]].", "exn": "In environment s : state a : ad p : prec_list d0, d1 : preDTA H1 : forall (a : ad) (p : prec_list), MapGet prec_list s a = Some p -> prec_list_ref_ok p d1 H2 : forall (a0 : ad) (p0 : prec_list), MapGet prec_list (M1 prec_list a p) a0 = Some p0 -> prec_list_ref_ok p0 d0 a' : ad p' : prec_list H3 : MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p' p0 : prec_list Hs : MapGet prec_list s a' = Some p0 The term \"H3\" has type \"MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p'\" while it is expected to have type \"MapGet prec_list (s_produit_r a p s) a' = Some p0\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1."], "tactic": "apply pl_produit_ref_ok.", "exn": "In environment H : forall (s : state) (a : ad) (p : prec_list) (c : ad) (r : prec_list), MapGet prec_list (s_produit_r a p s) c = Some r -> exists r0 r1 : prec_list, (if (a =? c)%N then Some p else None) = Some r0 /\\\\ MapGet prec_list s c = Some r1 s : state a : ad p : prec_list d0, d1 : preDTA H1 : forall (a : ad) (p : prec_list), MapGet prec_list s a = Some p -> prec_list_ref_ok p d1 H2 : forall (a0 : ad) (p0 : prec_list), (if (a =? a0)%N then Some p else None) = Some p0 -> prec_list_ref_ok p0 d0 a' : ad p' : prec_list H3 : MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p' p0 : prec_list Hs : MapGet prec_list s a' = Some p0 a0 : ad Unable to unify \"prec_occur (pl_produit ?M2582 ?M2583) a0\" with \"prec_occur p' a0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1."], "tactic": "apply H1.", "exn": "In environment H4 : forall (s : state) (a : ad) (p : prec_list) (c : ad) (r : prec_list), MapGet prec_list (s_produit_r a p s) c = Some r -> exists r0 r1 : prec_list, (if (a =? c)%N then Some p else None) = Some r0 /\\\\ MapGet prec_list s c = Some r1 H0 : forall (p0 p1 : prec_list) (d0 d1 : preDTA), prec_list_ref_ok p0 d0 -> prec_list_ref_ok p1 d1 -> prec_list_ref_ok (pl_produit p0 p1) (preDTA_produit d0 d1) s : state a : ad p : prec_list d0, d1 : preDTA H1 : forall (a : ad) (p : prec_list), MapGet prec_list s a = Some p -> prec_list_ref_ok p d1 H2 : forall (a0 : ad) (p0 : prec_list), (if (a =? a0)%N then Some p else None) = Some p0 -> prec_list_ref_ok p0 d0 a' : ad p' : prec_list H3 : MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p' p0 : prec_list Hs : MapGet prec_list s a' = Some p0 a0 : ad p1 : prec_occur ?M3477 a0 Unable to unify \"exists s : state, MapGet state d1 a0 = Some s\" with \"exists s : state, MapGet state (preDTA_produit d1 d0) a0 = Some s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1."], "tactic": "eapply H2.", "exn": "In environment H5 : forall (s : state) (a : ad) (p : prec_list) (c : ad) (r : prec_list), MapGet prec_list (s_produit_r a p s) c = Some r -> exists r0 r1 : prec_list, (if (a =? c)%N then Some p else None) = Some r0 /\\\\ MapGet prec_list s c = Some r1 H : forall (p0 p1 : prec_list) (d0 d1 : preDTA), prec_list_ref_ok p0 d0 -> prec_list_ref_ok p1 d1 -> prec_list_ref_ok (pl_produit p0 p1) (preDTA_produit d0 d1) s : state a : ad p : prec_list d0, d1 : preDTA H1 : forall (a : ad) (p : prec_list), MapGet prec_list s a = Some p -> prec_list_ref_ok p d1 H2 : forall (a0 : ad) (p0 : prec_list), (if (a =? a0)%N then Some p else None) = Some p0 -> prec_list_ref_ok p0 d0 a' : ad p' : prec_list H3 : MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p' p0 : prec_list Hs : MapGet prec_list s a' = Some p0 a0 : ad p1 : prec_occur ?M4371 a0 Unable to unify \"exists s : state, MapGet state d0 a0 = Some s\" with \"exists s : state, MapGet state (preDTA_produit d1 d0) a0 = Some s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1."], "tactic": ["rewrite H4.", ""], "exn": "Cannot find an homogeneous relation to rewrite.", "type": "no_rewrite_homo", "handled": false}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "shelve.", "-", "exfalso."], "tactic": "eapply H2.", "exn": "In environment s : state a : ad p : prec_list d0, d1 : preDTA H1 : forall (a : ad) (p : prec_list), MapGet prec_list s a = Some p -> prec_list_ref_ok p d1 H2 : forall (a0 : ad) (p0 : prec_list), MapGet prec_list (M1 prec_list a p) a0 = Some p0 -> prec_list_ref_ok p0 d0 a' : ad p' : prec_list H3 : MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p' Hs : MapGet prec_list s a' = None Unable to unify \"forall a : ad, prec_occur ?M5267 a -> exists s : state, MapGet state d0 a = Some s\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p d0 d1 H1 H2.", "unfold state_ref_ok in *.", "intros a' p' H3.", "unfold s_produit_r in H3.", "destruct (MapGet prec_list s a') eqn:Hs.", "-", "qsimpl time: 1 use: sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1.", "shelve.", "-", "exfalso.", "qsimpl time: 1 use: pl_produit_ref_ok,sproductr_1."], "tactic": "apply H3.", "exn": "In environment H0 : forall (s : state) (a : ad) (p : prec_list) (c : ad) (r : prec_list), MapGet prec_list (s_produit_r a p s) c = Some r -> exists r0 r1 : prec_list, (if (a =? c)%N then Some p else None) = Some r0 /\\\\ MapGet prec_list s c = Some r1 H : forall (p0 p1 : prec_list) (d0 d1 : preDTA), prec_list_ref_ok p0 d0 -> prec_list_ref_ok p1 d1 -> prec_list_ref_ok (pl_produit p0 p1) (preDTA_produit d0 d1) s : state a : ad p : prec_list d0, d1 : preDTA H1 : forall (a : ad) (p : prec_list), MapGet prec_list s a = Some p -> prec_list_ref_ok p d1 H2 : forall (a0 : ad) (p0 : prec_list), (if (a =? a0)%N then Some p else None) = Some p0 -> prec_list_ref_ok p0 d0 a' : ad p' : prec_list H3 : MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p' Hs : MapGet prec_list s a' = None Unable to unify \"MapGet prec_list ((fix s_produit_r (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p' p) else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_r 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_r (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_r 0%N p s1) end end) a p s) a' = Some p'\" with \"False\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s a p d0 d1 H1 H2. unfold state_ref_ok in *. intros a' p' H3. unfold s_produit_r in H3. destruct (MapGet prec_list s a') eqn:Hs. - destruct (sproductr_1 s a p a' p0 H3) as [r0 [r1 [H4 H5]]]. apply pl_produit_ref_ok. + apply H1. auto. + eapply H2. rewrite H4. reflexivity. - exfalso. eapply H2. apply H3.", "back_times": 1, "succ": false, "time": 201.19076228141785}]