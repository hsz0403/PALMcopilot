[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *."], "tactic": "destruct (a0 =? a)%N eqn:Haa; rewrite Hget0 in Hget1.", "exn": "Found no subterm matching \"Some b0'\" in Hget1.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst."], "tactic": "apply leb_reflexive.", "exn": "In environment a0 : ad b0' : bool a1 : ad b1' : bool a : ad b0, b1 : bool Hlem : if (a0 =? a1)%N then leb b0' b1' else False Hget0 : MapGet bool (M1 bool a0 b0') a = Some b0 Hget1 : MapGet bool (M1 bool a1 b1') a = Some b1 H0 : (if (a1 =? a)%N then Some b1' else None) = Some b1 Unable to unify \"b1\" with \"b0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2]."], "tactic": "destruct (in_M2_disj _ _ _ _ _ Hget0) as [Hget0'|Hget0'].", "exn": "Illegal application (Non-functional construction): The expression \"in_M2_disj ?A ?a ?m0 ?m1 ?e\" of type \"(exists c : ad, MapGet ?A ?m0 c = Some ?a) \\\\/ (exists c : ad, MapGet ?A ?m1 c = Some ?a)\" cannot be applied to the term \"Hget0\" : \"match a with | 0%N => MapGet bool m0_1 0%N | N.pos (p~1)%positive => MapGet bool m0_2 (N.pos p) | N.pos (p~0)%positive => MapGet bool m0_1 (N.pos p) | 1%N => MapGet bool m0_2 0%N end = Some b0\"", "type": "exp_cannot_apply", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2]."], "tactic": "qsimpl time: 1 use: in_M2_disj,discriminate,leb_reflexive,N.", "exn": "The reference discriminate was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+"], "tactic": "destruct (in_M2_disj _ _ _ _ _ Hget1) as [Hget1'|Hget1'].", "exn": "Illegal application (Non-functional construction): The expression \"in_M2_disj ?A ?a ?m0 ?m1 ?e\" of type \"(exists c : ad, MapGet ?A ?m0 c = Some ?a) \\\\/ (exists c : ad, MapGet ?A ?m1 c = Some ?a)\" cannot be applied to the term \"Hget1\" : \"MapGet bool m1_2 (N.pos p) = Some b1\"", "type": "exp_cannot_apply", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+"], "tactic": "qsimpl time: 1 use: lem_transitive,discriminate,N,auto,in_M2_disj,leb_reflexive.", "exn": "The reference discriminate was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+"], "tactic": "qsimpl time: 1 use: lem_transitive,N,auto,in_M2_disj,leb_reflexive.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive."], "tactic": "eapply lem_transitive; eauto.", "exn": "In environment H3 : forall b : bool, leb b b H2 : forall (A : Set) (a : A) (m0 m1 : Map A), (exists c : ad, match c with | 0%N => MapGet A m0 0%N | N.pos (p~1)%positive => MapGet A m1 (N.pos p) | N.pos (p~0)%positive => MapGet A m0 (N.pos p) | 1%N => MapGet A m1 0%N end = Some a) -> (exists c : ad, MapGet A m0 c = Some a) \\\\/ (exists c : ad, MapGet A m1 c = Some a) H1 : r_transitive bool lem m0_1, m0_2, m1_1, m1_2 : Map bool p : positive b0, b1 : bool Hlem1 : (fix lem (m0 m1 : Map bool) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a b => match m1 with | @M1 _ a' b' => if (a =? a')%N then leb b b' else False | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => lem a c /\\\\ lem b d | _ => False end end) m0_1 m1_1 Hlem2 : (fix lem (m0 m1 : Map bool) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a b => match m1 with | @M1 _ a' b' => if (a =? a')%N then leb b b' else False | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => lem a c /\\\\ lem b d | _ => False end end) m0_2 m1_2 Hget0 : MapGet bool m0_2 (N.pos p) = Some b0 Hget1 : MapGet bool m1_2 (N.pos p) = Some b1 Unable to unify \"r_transitive bool lem\" with \"leb b0 b1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive."], "tactic": "qsimpl time: 1 use: lem_transitive,discriminate,N,auto,in_M2_disj,leb_reflexive.", "exn": "The reference discriminate was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive."], "tactic": "qsimpl time: 1 use: lem_transitive,N,auto,in_M2_disj,leb_reflexive.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive.", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive."], "tactic": "apply IHm0_2; auto.", "exn": "The reference IHm0_2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive.", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m0 m1 a b0 b1 Hlem Hget0 Hget1.", "unfold lem in Hlem.", "destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2].", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "discriminate.", "-", "simpl in *.", "qsimpl time: 1 use: N.", "-", "inversion Hget1; subst.", "qsimpl time: 1 use: leb_reflexive,N.", "-", "shelve.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "contradiction.", "-", "simpl in *.", "destruct Hlem as [Hlem1 Hlem2].", "qsimpl time: 1 use: in_M2_disj,leb_reflexive,N.", "+", "shelve.", "+", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive.", "qsimpl time: 1 use: lem_transitive,N,in_M2_disj,leb_reflexive.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros m0 m1 a b0 b1 Hlem Hget0 Hget1. unfold lem in Hlem. destruct m0 as [|a0 b0'|m0_1 m0_2], m1 as [|a1 b1'|m1_1 m1_2]. - simpl in *. discriminate. - simpl in *. discriminate. - simpl in *. discriminate. - simpl in *. destruct (a0 =? a)%N eqn:Haa; rewrite Hget0 in Hget1. + inversion Hget1; subst. apply leb_reflexive. + discriminate. - simpl in *. contradiction. - simpl in *. contradiction. - simpl in *. destruct Hlem as [Hlem1 Hlem2]. destruct (in_M2_disj _ _ _ _ _ Hget0) as [Hget0'|Hget0']. + destruct (in_M2_disj _ _ _ _ _ Hget1) as [Hget1'|Hget1']. * apply IHm0_1; auto. * eapply lem_transitive; eauto. + destruct (in_M2_disj _ _ _ _ _ Hget1) as [Hget1'|Hget1']. * eapply lem_transitive; eauto. * apply IHm0_2; auto. - simpl in *. contradiction.", "back_times": 0, "succ": false, "time": 280.4372589588165}]