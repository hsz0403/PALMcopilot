[{"history": {"proof": "intros p A m0 m1 H. srun best use: lattice_bounded_4 unfold: lattice_bounded_def_0. qsimpl time: 1 use: single,bool. qsimpl time: 1 use: single,bool. qsimpl time: 1 use: single,bool,lattice_bounded_0. qsimpl time: 1 use: single,bool,lattice_bounded_0. qsimpl time: 1 use: single,bool,lattice_bounded_0. qsimpl time: 1 use: single,bool,lattice_bounded_0. qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0. qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0. qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0. qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0. qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0. qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0. qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "repairs": ["", "hammer", "wrong_type", "no_instance_var", "cannot_unify", "no_instance_var", "cannot_unify", "no_instance_var", "cannot_unify", "no_instance_var", "cannot_unify", "cannot_unify", "cannot_unify", "no_instance_var", "cannot_unify"], "exceptions": [{"ctx": ["intros p A m0 m1 H.", "induction H."], "tactic": "exists (single bool m0), (single bool m1).", "exn": "In environment p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p The term \"m0\" has type \"Map A\" while it is expected to have type \"Map bool\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool."], "tactic": "apply lattice_bounded_0.", "exn": "In environment X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"forall (A : Set) (m0 m1 : Map A), sas_chain bool (ensemble_base A (M2 A m0 m1)) lem (single bool ?M3184) -> exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool (single bool ?M3184)) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool (single bool ?M3184))\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0."], "tactic": "apply lattice_bounded_0.", "exn": "In environment p1 : forall A : Set, Map A -> prechain A H2 : forall m : Map bool, lattice_bounded_def_0 (p1 bool m) p0 : forall A : Set, Map A -> prechain A H1 : forall m : Map bool, lattice_bounded_def_0 (p0 bool m) X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"forall (A : Set) (m0 m1 : Map A), sas_chain bool (ensemble_base A (M2 A m0 m1)) lem (single bool ?M4864) -> exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool (single bool ?M4864)) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool (single bool ?M4864))\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0."], "tactic": "apply lem_reflexive.", "exn": "In environment p3 : forall A : Set, Map A -> prechain A H4 : forall m : Map bool, lattice_bounded_def_0 (p3 bool m) p2 : forall A : Set, Map A -> prechain A H3 : forall m : Map bool, lattice_bounded_def_0 (p2 bool m) p1 : forall A : Set, Map A -> prechain A H2 : forall m : Map bool, lattice_bounded_def_0 (p1 bool m) p0 : forall A : Set, Map A -> prechain A H1 : forall m : Map bool, lattice_bounded_def_0 (p0 bool m) X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"r_reflexive bool lem\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0."], "tactic": "destruct IHsas_chain1 as [p0 [p1 [H0 [H1 [H2 H3]]]]].", "exn": "The reference IHsas_chain1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0."], "tactic": "destruct IHsas_chain2 as [p0' [p1' [H0' [H1' [H2' H3']]]]].", "exn": "The reference IHsas_chain2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0."], "tactic": "exists (concat bool p0 p0'), (concat bool p1 p1').", "exn": "The reference p0' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0."], "tactic": "apply incr_concat.", "exn": "In environment p5 : forall A : Set, Map A -> prechain A H8 : forall m : Map bool, lattice_bounded_def_0 (p5 bool m) H7 : r_reflexive bool lem p4 : forall A : Set, Map A -> prechain A H6 : forall m : Map bool, lattice_bounded_def_0 (p4 bool m) p3 : forall A : Set, Map A -> prechain A H4 : forall m : Map bool, lattice_bounded_def_0 (p3 bool m) p2 : forall A : Set, Map A -> prechain A H3 : forall m : Map bool, lattice_bounded_def_0 (p2 bool m) p1 : forall A : Set, Map A -> prechain A H2 : forall m : Map bool, lattice_bounded_def_0 (p1 bool m) p0 : forall A : Set, Map A -> prechain A H1 : forall m : Map bool, lattice_bounded_def_0 (p0 bool m) X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"prechain_incr ?M9440 ?M9442 (concat ?M9440 ?M9443 ?M9441)\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0."], "tactic": "apply H.", "exn": "In environment p6 : forall A : Set, Map A -> prechain A H10 : forall m : Map bool, lattice_bounded_def_0 (p6 bool m) H9 : r_reflexive bool lem H5 : forall (A : Set) (x : Map A) (r : mRelation A) (p : prechain A), r (prechain_last A p) x -> prechain_incr A r p -> prechain_incr A r (concat A p x) p5 : forall A : Set, Map A -> prechain A H8 : forall m : Map bool, lattice_bounded_def_0 (p5 bool m) p4 : forall A : Set, Map A -> prechain A H6 : forall m : Map bool, lattice_bounded_def_0 (p4 bool m) p3 : forall A : Set, Map A -> prechain A H4 : forall m : Map bool, lattice_bounded_def_0 (p3 bool m) p2 : forall A : Set, Map A -> prechain A H3 : forall m : Map bool, lattice_bounded_def_0 (p2 bool m) p1 : forall A : Set, Map A -> prechain A H2 : forall m : Map bool, lattice_bounded_def_0 (p1 bool m) p0 : forall A : Set, Map A -> prechain A H1 : forall m : Map bool, lattice_bounded_def_0 (p0 bool m) X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"chain bool (ensemble_base A (M2 A m0 m1)) lem p\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0."], "tactic": "apply H0.", "exn": "In environment p7 : forall A : Set, Map A -> prechain A H12 : forall m : Map bool, lattice_bounded_def_0 (p7 bool m) H11 : r_reflexive bool lem H7 : forall (A : Set) (x : Map A) (r : mRelation A) (p : prechain A), r (prechain_last A p) x -> prechain_incr A r p -> prechain_incr A r (concat A p x) p6 : forall A : Set, Map A -> prechain A H10 : forall m : Map bool, lattice_bounded_def_0 (p6 bool m) p5 : forall A : Set, Map A -> prechain A H8 : forall m : Map bool, lattice_bounded_def_0 (p5 bool m) p4 : forall A : Set, Map A -> prechain A H6 : forall m : Map bool, lattice_bounded_def_0 (p4 bool m) p3 : forall A : Set, Map A -> prechain A H4 : forall m : Map bool, lattice_bounded_def_0 (p3 bool m) p2 : forall A : Set, Map A -> prechain A H3 : forall m : Map bool, lattice_bounded_def_0 (p2 bool m) p1 : forall A : Set, Map A -> prechain A H2 : forall m : Map bool, lattice_bounded_def_0 (p1 bool m) p0 : forall A : Set, Map A -> prechain A H1 : forall m : Map bool, lattice_bounded_def_0 (p0 bool m) X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"dist_chain bool p\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0."], "tactic": "apply incr_concat.", "exn": "In environment p9 : forall A : Set, Map A -> prechain A H14 : forall m : Map bool, lattice_bounded_def_0 (p9 bool m) H11 : r_reflexive bool lem H7 : forall (A : Set) (x : Map A) (r : mRelation A) (p : prechain A), r (prechain_last A p) x -> prechain_incr A r p -> prechain_incr A r (concat A p x) p8 : forall A : Set, Map A -> prechain A H13 : forall m : Map bool, lattice_bounded_def_0 (p8 bool m) p7 : forall A : Set, Map A -> prechain A H12 : forall m : Map bool, lattice_bounded_def_0 (p7 bool m) p6 : forall A : Set, Map A -> prechain A H10 : forall m : Map bool, lattice_bounded_def_0 (p6 bool m) p5 : forall A : Set, Map A -> prechain A H8 : forall m : Map bool, lattice_bounded_def_0 (p5 bool m) p4 : forall A : Set, Map A -> prechain A H6 : forall m : Map bool, lattice_bounded_def_0 (p4 bool m) p3 : forall A : Set, Map A -> prechain A H4 : forall m : Map bool, lattice_bounded_def_0 (p3 bool m) p2 : forall A : Set, Map A -> prechain A H3 : forall m : Map bool, lattice_bounded_def_0 (p2 bool m) p1 : forall A : Set, Map A -> prechain A H2 : forall m : Map bool, lattice_bounded_def_0 (p1 bool m) p0 : forall A : Set, Map A -> prechain A H1 : forall m : Map bool, lattice_bounded_def_0 (p0 bool m) X0, X : forall A : Set, Map A -> prechain A p : prechain bool A : Set m0, m1 : Map A H : chain bool (ensemble_base A (M2 A m0 m1)) lem p H0 : dist_chain bool p Unable to unify \"prechain_incr ?M16384 ?M16386 (concat ?M16384 ?M16387 ?M16385)\" with \"exists p0 p1 : prechain bool, sas_chain bool (ensemble_base A m0) lem p0 /\\\\ sas_chain bool (ensemble_base A m1) lem p1 /\\\\ lem (M2 bool (prechain_last bool p0) (prechain_last bool p1)) (prechain_last bool p) /\\\\ chain_length bool p0 + chain_length bool p1 = S (chain_length bool p)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0."], "tactic": "apply H0'.", "exn": "The reference H0' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p A m0 m1 H.", "induction H.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: lem_reflexive,single,bool,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "qsimpl time: 1 use: bool,incr_concat,single,lem_reflexive,lattice_bounded_0.", "apply positive_ind.", "--"], "tactic": ["apply H1.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "intros p A m0 m1 H. induction H. - exists (single bool m0), (single bool m1). split. * apply lattice_bounded_0. * split. + apply lattice_bounded_0. + split. ++ simpl. apply lem_reflexive. ++ simpl. auto. - destruct IHsas_chain1 as [p0 [p1 [H0 [H1 [H2 H3]]]]]. destruct IHsas_chain2 as [p0' [p1' [H0' [H1' [H2' H3']]]]]. exists (concat bool p0 p0'), (concat bool p1 p1'). split. * apply incr_concat. -- apply H. -- apply H0. * split. + apply incr_concat. -- apply H0'. -- apply H1. + split. ++ simpl. apply lem_transitive with (M2 bool (prechain_last bool p0') (prechain_last bool p1')). ** apply lem_transitive with (M2 bool (prechain_last bool p0) (prechain_last bool p1)). --- apply lem_reflexive. --- apply H2. ** apply H2'. ++ simpl. rewrite <- plus_n_Sm. rewrite <- H3. f_equal. apply plus_comm.", "back_times": 1, "succ": true, "time": 105.32339096069336}]