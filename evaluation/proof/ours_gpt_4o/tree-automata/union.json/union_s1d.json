[{"history": {"proof": "intros s d a pl c tl Hcompat Hreconn. revert d c tl Hreconn. srun best use: union_s1d_3 unfold: union_s_prd1.", "repairs": ["", "", "hammer"], "exceptions": [{"ctx": ["intros s d a pl c tl Hcompat Hreconn.", "revert d c tl Hreconn."], "tactic": ["induction s as [|s1 IH1 s2 IH2].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros s d a pl c tl Hcompat Hreconn. revert d c tl Hreconn. induction s as [|s1 IH1 s2 IH2]. - intros d c tl Hreconn. apply union_s0d. + simpl. apply mpl_compat_7. + auto. - intros d c tl Hreconn. destruct (N.eq_dec a c) as [Heq|Hneq]. + rewrite Heq. apply union_s0d_1_0. * apply mpl_compat_7. * auto. + apply mpl_compat_8 in Hcompat; auto. apply state_reconnait_ind with (P0:=fun d s t => state_reconnait d (union_mpl_0 a pl (M1 prec_list c pl0)) (app c tl)); try auto. intros d' s' c' tl' l Hmap Hlreconn. apply rec_st with (l:=l). * simpl. erewrite mpl_compat_8; eauto. * auto.", "back_times": 0, "succ": true, "time": 14.044722080230713}]