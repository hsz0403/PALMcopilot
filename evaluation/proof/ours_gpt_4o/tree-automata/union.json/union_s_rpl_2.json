[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-"], "tactic": "intros m0 H0.", "exn": "m0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-"], "tactic": "intros m0' H0.", "exn": "H0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'."], "tactic": ["apply union_s_rpl_0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-"], "tactic": "intros a pl Hrec m0 H0.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-"], "tactic": "intros a' pl Hrec m0 H0.", "exn": "m0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-"], "tactic": "intros a' pl Hrec m0' H0.", "exn": "H0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'."], "tactic": "apply union_s_rpl_1.", "exn": "In environment a : ad a0 : prec_list H : union_s_rpl_def (M1 prec_list a a0) m0 : state H0 : union_s_rpl_def m0 a' : preDTA pl : ad Hrec : prec_list m0' : ad H0' : term_list Unable to unify \"forall (a : ad) (a0 : prec_list), union_s_rpl_def (M1 prec_list a a0)\" with \"mpl_compat (M1 prec_list pl Hrec) (M2 prec_list (M1 prec_list a a0) m0) -> state_reconnait a' (union_mpl_0 pl Hrec (M2 prec_list (M1 prec_list a a0) m0)) (app m0' H0') -> state_reconnait a' (M1 prec_list pl Hrec) (app m0' H0') \\\\/ state_reconnait a' (M2 prec_list (M1 prec_list a a0) m0) (app m0' H0')\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-"], "tactic": "intros m1 IHm1 m2 IHm2 m0 H0.", "exn": "m1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-"], "tactic": "intros m1' IHm1 m2 IHm2 m0 H0.", "exn": "IHm1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-"], "tactic": "intros m1' IHm1' m2 IHm2 m0 H0.", "exn": "m2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-"], "tactic": "intros m1' IHm1' m2' IHm2 m0 H0.", "exn": "IHm2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-"], "tactic": "intros m1' IHm1' m2' IHm2' m0 H0.", "exn": "m0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-"], "tactic": "intros m1' IHm1' m2' IHm2' m0' H0.", "exn": "H0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-", "intros m1' IHm1' m2' IHm2' m0' H0'."], "tactic": "apply union_s_rpl_def.", "exn": "In environment m1, m2 : Map prec_list H : union_s_rpl_def (M2 prec_list m1 m2) m0 : state H0 : union_s_rpl_def m0 IHm1 : union_s_rpl_def m1 -> union_s_rpl_def (M2 prec_list m1 m0) IHm2 : union_s_rpl_def m2 -> union_s_rpl_def (M2 prec_list m2 m0) m1' : preDTA IHm1' : ad m2' : prec_list IHm2' : ad m0' : term_list H0' : mpl_compat (M1 prec_list IHm1' m2') (M2 prec_list (M2 prec_list m1 m2) m0) Unable to unify \"state -> Prop\" with \"state_reconnait m1' (union_mpl_0 IHm1' m2' (M2 prec_list (M2 prec_list m1 m2) m0)) (app IHm2' m0') -> state_reconnait m1' (M1 prec_list IHm1' m2') (app IHm2' m0') \\\\/ state_reconnait m1' (M2 prec_list (M2 prec_list m1 m2) m0) (app IHm2' m0')\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m H m0 H0.", "induction m using Map_ind.", "-", "intros m0' H0'.", "shelve.", "-", "intros a' pl Hrec m0' H0'.", "shelve.", "-", "intros m1' IHm1' m2' IHm2' m0' H0'."], "tactic": "qsimpl time: 1 use: union_s_rpl_def,qsimpl,union_s_rpl_0,union_s_rpl_1.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros m H m0 H0. induction m using Map_ind. - intros m0 H0. apply union_s_rpl_0. - intros a pl Hrec m0 H0. apply union_s_rpl_1. - intros m1 IHm1 m2 IHm2 m0 H0. apply union_s_rpl_def. intros d a pl c tl H1 H2. destruct (union_std_2 m1) as [H3 _]. apply mpl_compat_2 in H1. destruct (IHm1 H3 m0 H0 d a pl c tl H1 H2) as [H4 | H4]. + left. apply H4. + destruct (union_std_2 m2) as [_ H3]. apply mpl_compat_1 in H1. destruct (IHm2 H3 m0 H0 d a pl c tl H1 H2) as [H5 | H5]. * left. apply H5. * right. apply H5.", "back_times": 0, "succ": false, "time": 125.42821836471558}]