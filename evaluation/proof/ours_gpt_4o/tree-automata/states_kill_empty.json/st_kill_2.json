[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s m a p H.", "revert s a p H."], "tactic": "induction m; intros s a p H.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+"], "tactic": "apply H.", "exn": "In environment s : state a' : ad p : prec_list H : MapGet prec_list (states_kill_aux (M0 bool) s) a' = Some p Unable to unify \"MapGet prec_list (states_kill_aux (M0 bool) s) a' = Some p\" with \"MapGet prec_list s a' = Some p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+"], "tactic": "destruct (prec_list_kill m p) eqn:Hkill.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H."], "tactic": "apply pl_kill_prec_empty in Hkill.", "exn": "No such hypothesis: Hkill", "type": "no_hypos", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty."], "tactic": "rewrite Hkill.", "exn": "The reference Hkill was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty."], "tactic": "discriminate.", "exn": "Unable to find an instance for the variables p, m.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate."], "tactic": "destruct (prec_list_kill m p0) eqn:Hkill; try discriminate.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "destruct (states_kill_aux m s1) eqn:Haux1.", "exn": "The reference s1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "destruct (states_kill_aux m s2) eqn:Haux2.", "exn": "The reference s2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "destruct (MapGet prec_list (M1 prec_list a p) a) eqn:Hget; try discriminate.", "exn": "The reference a was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "exists p.", "split; auto.", "*"], "tactic": "destruct (MapGet prec_list s1 a) eqn:Hget1.", "exn": "The reference a was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "exists p.", "split; auto.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "exists p.", "split; auto.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s m a p H.", "revert s a p H.", "induction m; intros s a' p H.", "-", "exists p.", "split.", "+", "shelve.", "+", "inversion H.", "qsimpl time: 1 use: pl_kill_prec_empty.", "qsimpl time: 1 use: pl_kill_prec_empty.", "shelve.", "-", "destruct (MapGet prec_list s a) eqn:Hget; try discriminate.", "inversion H.", "exists p0.", "split; auto.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "exists p.", "split; auto.", "*", "shelve.", "*"], "tactic": "destruct (states_kill_aux m1 s1) eqn:Haux1; destruct (states_kill_aux m1 s2) eqn:Haux2; exist p; split; eauto.", "exn": "The reference exist was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros s m a p H. revert s a p H. induction m; intros s a p H. - exists p. split. + apply H. + simpl in H. destruct (prec_list_kill m p) eqn:Hkill. * inversion H. apply pl_kill_prec_empty in Hkill. rewrite Hkill. simpl. auto. * discriminate. - simpl in H. destruct (MapGet prec_list s a) eqn:Hget; try discriminate. destruct (prec_list_kill m p0) eqn:Hkill; try discriminate. inversion H. subst. exists p0. split; auto. - simpl in H. destruct (states_kill_aux m s1) eqn:Haux1. + destruct (states_kill_aux m s2) eqn:Haux2. * destruct (MapGet prec_list (M1 prec_list a p) a) eqn:Hget; try discriminate. exists p. split; auto. * destruct (MapGet prec_list s1 a) eqn:Hget1. { exists p. split; auto. apply st_kill_0 with (p' := p); auto. } destruct (MapGet prec_list s2 a) eqn:Hget2. { exists p. split; auto. apply st_kill_0 with (p' := p); auto. } discriminate. + destruct (MapGet prec_list (M1 prec_list a p) a) eqn:Hget; try discriminate. inversion H; subst. exists p. split; auto. - destruct (states_kill_aux m1 s1) eqn:Haux1; destruct (states_kill_aux m1 s2) eqn:Haux2; exist p; split; eauto.", "back_times": 0, "succ": false, "time": 216.492094039917}]