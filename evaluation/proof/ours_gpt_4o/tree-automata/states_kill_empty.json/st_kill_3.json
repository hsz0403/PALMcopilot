[{"history": {"proof": "qsimpl time: 1 use: dt_non_empty_r_1.", "repairs": ["cannot_apply_in"], "exceptions": [{"ctx": ["intros s' s m H H0."], "tactic": "apply dt_non_empty_r_1 in H0.", "exn": "Unable to apply lemma of type \"forall (s : state) (m : Map bool), st_non_empty m s = true -> exists (c : ad) (p : prec_list), MapGet prec_list s c = Some p /\\\\ pl_non_empty m p = true\" on hypothesis of type \"s' <> M0 prec_list\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s' s m H H0.", "qsimpl time: 1 use: dt_non_empty_r_1."], "tactic": ["destruct H0 as [p [a H0]].", ""], "exn": "Expects a disjunctive pattern with 0 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros s' s m H H0. apply dt_non_empty_r_1 in H0. destruct H0 as [p [a H0]]. exists p, a. pose proof (st_kill_2 s m a p). destruct (MapGet prec_list (states_kill_aux m s) a) eqn:Heq; try contradiction. - destruct (H1 _ Heq) as [p' [H2 H3]]. assert (H4: MapGet prec_list s a = Some p'). { apply st_kill_0 with (m:=m) (p:=p') (p':=p); auto. } congruence.", "back_times": 0, "succ": false, "time": 65.60116410255432}]