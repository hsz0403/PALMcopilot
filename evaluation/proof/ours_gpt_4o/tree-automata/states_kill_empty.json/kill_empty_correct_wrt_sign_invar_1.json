[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl."], "tactic": "destruct (prec_list_kill m p) eqn:Hk.", "exn": "The reference p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl."], "tactic": "intros a0 p0 Hget.", "exn": "a0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget."], "tactic": "destruct (MapGet prec_list (M1 prec_list a p0) a0) eqn:Hget'.", "exn": "In environment a : ad a0 : prec_list sigma : signature m : Map bool H : state_correct_wrt_sign (M1 prec_list a a0) sigma a0' : ad p0 : prec_list Hget : MapGet prec_list match prec_list_kill m a0 with | Some p' => M1 prec_list a p' | None => M0 prec_list end a0' = Some p0 The term \"a0\" has type \"prec_list\" while it is expected to have type \"ad\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1."], "tactic": "inversion Hget.", "exn": "No such hypothesis: Hget", "type": "no_hypos", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1."], "tactic": "eapply st_kill_2 in Hget.", "exn": "No such hypothesis: Hget", "type": "no_hypos", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1."], "tactic": "destruct Hget as [p' [Hget' Hkill]].", "exn": "The reference Hget was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]]."], "tactic": "eapply H.", "exn": "In environment X3 : forall A : Type, ad -> A -> Map A X2 : forall A : Type, Map A -> ad -> option A H0 : forall (s : state) (m : Map bool) (a : ad) (p : prec_list), MapGet prec_list (states_kill_aux m s) a = Some p -> exists p' : prec_list, MapGet prec_list s a = Some p' /\\\\ prec_list_kill m p' = Some p X1 : forall A : Type, ad -> A -> Map A X0 : forall A : Type, Map A -> ad -> option A X : forall A : Type, ad -> A -> Map A o : forall A : Type, Map A -> ad -> option A a0 : prec_list sigma : signature m : Map bool a0' : ad H : state_correct_wrt_sign (M1 prec_list a0' a0) sigma p0 : prec_list Unable to unify \"state_correct_wrt_sign (M1 prec_list a0' a0) sigma\" with \"exists n : nat, o nat sigma a0' = Some n /\\\\ pl_tl_length p0 n\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1."], "tactic": "apply Hget'.", "exn": "The reference Hget' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence."], "tactic": "--", "exn": "Wrong bullet --: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++"], "tactic": "intros a0 p0 Hget.", "exn": "a0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++"], "tactic": "intros a0' p0 Hget.", "exn": "a0' is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++"], "tactic": "intros a0'' p0 Hget.", "exn": "p0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++"], "tactic": "intros a0'' p0' Hget.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++"], "tactic": "simpl in Hget.", "exn": "No such hypothesis: Hget", "type": "no_hypos", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1."], "tactic": "destruct (MapGet prec_list M0 a0) eqn:Hget'.", "exn": "In environment X7 : forall A : Type, ad -> A -> Map A X6 : forall A : Type, Map A -> ad -> option A H0 : forall (s : state) (m : Map bool) (a : ad) (p : prec_list), MapGet prec_list (states_kill_aux m s) a = Some p -> exists p' : prec_list, MapGet prec_list s a = Some p' /\\\\ prec_list_kill m p' = Some p X5 : forall A : Type, ad -> A -> Map A X4 : forall A : Type, Map A -> ad -> option A X3 : forall A : Type, ad -> A -> Map A X2 : forall A : Type, Map A -> ad -> option A X1 : forall A : Type, ad -> A -> Map A X0 : forall A : Type, Map A -> ad -> option A X : forall A : Type, ad -> A -> Map A o : forall A : Type, Map A -> ad -> option A a0 : prec_list sigma : signature m : Map bool a0' : ad H : state_correct_wrt_sign (M1 prec_list a0' a0) sigma p0 : prec_list The term \"M0\" has type \"forall A : Type, Map A\" while it is expected to have type \"Map prec_list\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "qsimpl time: 1 use: M1,prec_list,st_kill_2,MapGet,M0."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "qsimpl time: 1 use: M1,prec_list,st_kill_2,MapGet,M0.", "shelve.", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "qsimpl time: 1 use: M1,prec_list,st_kill_2,MapGet,M0.", "shelve.", "++", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "qsimpl time: 1 use: M1,prec_list,st_kill_2,MapGet,M0.", "shelve.", "++", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "induction s.", "-", "simpl.", "intros a p Hget.", "inversion Hget.", "-", "simpl.", "intros a0' p0 Hget.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: MapGet,prec_list,M1.", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "destruct Heqo0 as [p' [Heqo0' Hkill]].", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "apply power.", "++", "congruence.", "++", "qsimpl time: 1 use: st_kill_2,MapGet,prec_list,M1.", "qsimpl time: 1 use: M1,prec_list,st_kill_2,MapGet,M0.", "shelve.", "++", "shelve.", "-", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros s sigma m H. induction s. - simpl. intros a p Hget. inversion Hget. - simpl. destruct (prec_list_kill m p) eqn:Hk. -- intros a0 p0 Hget. simpl in Hget. destruct (MapGet prec_list (M1 prec_list a p0) a0) eqn:Hget'. ++ inversion Hget. subst. eapply st_kill_2 in Hget. destruct Hget as [p' [Hget' Hkill]]. eapply H. apply Hget'. ++ congruence. -- intros a0 p0 Hget. simpl in Hget. destruct (MapGet prec_list M0 a0) eqn:Hget'. ++ congruence. ++ congruence. - simpl. intros a p Hget. destruct (states_kill_aux m s1) eqn:Hk1. -- destruct (states_kill_aux m s0) eqn:Hk0. ++ simpl in Hget. destruct (MapGet prec_list M0 a) eqn:Hget'. ** congruence. ** congruence. ++ simpl in Hget. destruct (MapGet prec_list (M1 prec_list a p) a) eqn:Hget'. ** inversion Hget. subst. eapply st_kill_2 in Hget. destruct Hget as [p' [Hget' Hkill]]. eapply H in Hget'. auto. ** congruence. -- simpl in Hget. destruct (MapGet prec_list (M2 prec_list (M0 prec_list) (M2 prec_list s2 s3)) a) eqn:Hget'. ++ congruence. ++ congruence.", "back_times": 0, "succ": false, "time": 120.06956696510315}]