[{"history": {"proof": "qsimpl time: 1 use: dt_non_empty_d. qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "repairs": ["wrong_type", "no_hypos"], "exceptions": [{"ctx": ["intros d a t H.", "induction H using reconnaissance_ind."], "tactic": "destruct (dt_non_empty_d _ _ _ H0) as [n Hn].", "exn": "In environment d : preDTA a : ad t : term ladj : state H : MapGet state d a = Some ladj H0 : state_reconnait d ladj t The term \"H0\" has type \"state_reconnait d ladj t\" while it is expected to have type \"reconnaissance ?d ?a ?t\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d."], "tactic": "apply dt_kill_0 with (s := ladj) in Hn as [s' [Hget Hkill]].", "exn": "No such hypothesis: Hn", "type": "no_hypos", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d."], "tactic": "apply rec_dta with (ladj := s').", "exn": "The reference s' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-"], "tactic": "apply dt_kill_1 with (s := ladj).", "exn": "In environment H4 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H0 : forall (d : preDTA) (m : Map bool) (a : ad) (s s' : state), states_kill m s = Some s' -> MapGet state d a = Some s -> MapGet state (preDTA_kill m d) a = Some s' d : preDTA a : ad ladj : state H : MapGet state d a = Some ladj c : ad tl : term_list l : prec_list H2 : MapGet prec_list ladj c = Some l H3 : liste_reconnait d l tl Unable to unify \"exists s' : state, MapGet state ?M3649 ?M3651 = Some s' /\\\\ states_kill ?M3650 s' = Some ladj\" with \"MapGet state (preDTA_kill (dta_non_empty_states d) d) a = Some ladj\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d."], "tactic": "exists s'.", "exn": "The reference s' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d."], "tactic": "split; auto.", "exn": "In environment H6 : forall (d : preDTA) (a : ad) (t : term), reconnaissance d a t -> exists n : nat, MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true H5 : forall (d : preDTA) (m : Map bool) (a : ad) (s : state), MapGet state (preDTA_kill m d) a = Some s -> exists s' : state, MapGet state d a = Some s' /\\\\ states_kill m s' = Some s H1 : forall (d : preDTA) (m : Map bool) (a : ad) (s s' : state), states_kill m s = Some s' -> MapGet state d a = Some s -> MapGet state (preDTA_kill m d) a = Some s' d : preDTA a : ad ladj : state H : MapGet state d a = Some ladj c : ad tl : term_list l : prec_list H2 : MapGet prec_list ladj c = Some l H3 : liste_reconnait d l tl Unable to unify \"Some ladj\" with \"MapGet state (preDTA_kill (dta_non_empty_states d) d) a\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "shelve.", "-"], "tactic": "induction s using state_reconnait_ind.", "exn": "The reference s was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "shelve.", "-", "apply rec_st with (l := l).", "+"], "tactic": "apply dt_kill_0 with (s := s0).", "exn": "The reference s0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "shelve.", "-", "apply rec_st with (l := l).", "+"], "tactic": "apply dt_non_empty_fix_1 in H0.", "exn": "Unable to apply lemma of type \"forall (d : preDTA) (a : ad) (n : nat), MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) n) a = Some true -> MapGet bool (dta_non_empty_states d) a = Some true\" on hypothesis of type \"forall (d : preDTA) (m : Map bool) (a : ad) (s s' : state), states_kill m s = Some s' -> MapGet state d a = Some s -> MapGet state (preDTA_kill m d) a = Some s'\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "shelve.", "-", "apply rec_st with (l := l).", "+", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_fix_1,dt_non_empty_d."], "tactic": "apply Hget.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "shelve.", "-", "apply rec_st with (l := l).", "+", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_fix_1,dt_non_empty_d.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d a t H.", "induction H using reconnaissance_ind.", "qsimpl time: 1 use: dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_non_empty_d.", "apply rec_dta with (ladj := ladj).", "-", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_d.", "shelve.", "-", "apply rec_st with (l := l).", "+", "qsimpl time: 1 use: dt_kill_0,dt_kill_1,dt_non_empty_fix_1,dt_non_empty_d.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros d a t H. induction H using reconnaissance_ind. destruct (dt_non_empty_d _ _ _ H0) as [n Hn]. apply dt_kill_0 with (s := ladj) in Hn as [s' [Hget Hkill]]. apply rec_dta with (ladj := s'). - apply dt_kill_1 with (s := ladj). exists s'. split; auto. - induction s using state_reconnait_ind. apply rec_st with (l := l). + apply dt_kill_0 with (s := s0). apply dt_non_empty_fix_1 in H0. apply Hget. + induction l using liste_reconnait_ind. * apply rec_empty. * simpl. destruct (dt_kill_empty_d_1 n _ _ _ H0 H1 H2) as [p' [Hpkill Hr]]. apply rec_cons with (p := p'). -- auto. -- apply IHl0. apply Hr. auto. + auto.", "back_times": 0, "succ": false, "time": 190.0094175338745}]