[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p m plp H_incl H_true.", "induction H_incl as [| plp a la ls H_incl IH | plp a la ls H_incl IH H_neq].", "-", "exists prec_empty.", "split.", "+", "simpl.", "auto.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m plp H_incl H_true.", "induction H_incl as [| plp a la ls H_incl IH | plp a la ls H_incl IH H_neq].", "-", "exists prec_empty.", "split.", "+", "simpl.", "auto.", "+", "shelve.", "-"], "tactic": ["destruct H_true as [H_true_head H_true_tail].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros p m plp H_incl H_true.", "induction H_incl as [| plp a la ls H_incl IH | plp a la ls H_incl IH H_neq].", "-", "exists prec_empty.", "split.", "+", "simpl.", "auto.", "+", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m plp H_incl H_true.", "induction H_incl as [| plp a la ls H_incl IH | plp a la ls H_incl IH H_neq].", "-", "exists prec_empty.", "split.", "+", "simpl.", "auto.", "+", "shelve.", "-", "shelve.", "-", "destruct plp; try contradiction."], "tactic": ["destruct H_true as [H_true_head H_true_tail].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros p m plp H_incl H_true. induction H_incl as [| plp a la ls H_incl IH | plp a la ls H_incl IH H_neq]. - exists prec_empty. split. + simpl. auto. + simpl. auto. - destruct H_true as [H_true_head H_true_tail]. simpl. destruct (MapGet bool m a) eqn:Ha. + destruct b. * apply IH in H_true_tail as [pl [H_kill H_incl']]. rewrite Ha. simpl. exists (prec_cons a pl (prec_empty la ls)). split; [| apply pl_path_incl_cons; assumption]. rewrite H_kill. auto. * apply IH in H_true_tail as [pl [H_kill H_incl']]. rewrite Ha. simpl. exists pl. split; auto. + apply IH in H_true_tail as [pl [H_kill H_incl']]. rewrite Ha. exists pl. split; auto. - destruct plp; try contradiction. destruct H_true as [H_true_head H_true_tail]. simpl. apply IH in H_true as [pl [H_kill H_incl']]. rewrite Ha. exists (prec_cons a pl ls). split; [auto | apply pl_path_incl_cons; assumption].", "back_times": 0, "succ": false, "time": 141.59492421150208}]