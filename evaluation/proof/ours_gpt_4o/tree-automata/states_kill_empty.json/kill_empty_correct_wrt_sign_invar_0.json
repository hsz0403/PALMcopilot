[{"history": {"proof": "intros p p' m n Hlength Heq. revert dependent p'. induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls]. - intros p' Heq. simpl in Heq. inversion Heq. constructor. - intros p' Heq. simpl in Heq. destruct (MapGet bool m a) eqn:Hget. + destruct b. * destruct (prec_list_kill m pl) eqn:Hkill. -- inversion Heq. subst. constructor. apply IH. auto. -- inversion Heq. * qsimpl time: 1. + qsimpl time: 1. - intros p' Heq. simpl in Heq. destruct (MapGet bool m a) eqn:Hget. + destruct b. * destruct (prec_list_kill m la) eqn:Hkilla. -- destruct (prec_list_kill m ls) eqn:Hkillls. ++ inversion Heq. sauto lq: on depth: 3. ++ inversion Heq; subst. sauto lq: on depth: 3. -- destruct (prec_list_kill m ls) eqn:Hkillls. ++ inversion Heq. apply IHls. hauto lq: on depth: 3. ++ inversion Heq. hauto lq: on depth: 3. * apply IHls. hauto lq: on depth: 3. + apply IHls. hauto lq: on depth: 3.", "repairs": ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "cannot_unify", "", "cannot_unify", "", "", "", "", "", "", "", "", "", "", "", "", "hammer", "", "", "hammer", "", "", "", "", "", "hammer", "", "", "hammer", "", "", "hammer", "", "", "hammer"], "exceptions": [{"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*"], "tactic": "apply IH.", "exn": "In environment m : Map bool a : ad pl : prec_list n : nat Hlength : pl_tl_length pl n IH : forall p' : prec_list, prec_list_kill m pl = Some p' -> pl_tl_length p' n p' : prec_list Hget : MapGet bool m a = Some false Heq : None = Some p' Unable to unify \"pl_tl_length ?M1923 n\" with \"pl_tl_length p' (S n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1."], "tactic": "auto.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+"], "tactic": "apply IH.", "exn": "In environment m : Map bool a : ad pl : prec_list n : nat Hlength : pl_tl_length pl n IH : forall p' : prec_list, prec_list_kill m pl = Some p' -> pl_tl_length p' n p' : prec_list Hget : MapGet bool m a = None Heq : None = Some p' Unable to unify \"pl_tl_length ?M1948 n\" with \"pl_tl_length p' (S n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1."], "tactic": "auto.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq."], "tactic": "apply pl_tl_propag.", "exn": "In environment m : Map bool a : ad la, ls : prec_list n : nat Hla : pl_tl_length la n Hls : pl_tl_length ls (S n) p : prec_list Hkilla : prec_list_kill m la = Some p IHla : forall p' : prec_list, Some p = Some p' -> pl_tl_length p' n p0 : prec_list Hkillls : prec_list_kill m ls = Some p0 IHls : forall p' : prec_list, Some p0 = Some p' -> pl_tl_length p' (S n) p' : prec_list Hget : MapGet bool m a = Some true Heq, H0 : match ls with | prec_cons _ _ _ => Some (prec_cons a p p0) | prec_empty => Some (prec_cons a p prec_empty) end = Some p' Unable to unify \"pl_tl_length (prec_cons ?M2005 ?M2006 ?M2007) (S ?M2008)\" with \"pl_tl_length p' (S n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst."], "tactic": "apply pl_tl_S.", "exn": "In environment m : Map bool a : ad la, ls : prec_list n : nat Hla : pl_tl_length la n Hls : pl_tl_length ls (S n) p : prec_list Hkilla : prec_list_kill m la = Some p IHla : forall p' : prec_list, Some p = Some p' -> pl_tl_length p' n Hkillls : prec_list_kill m ls = None IHls : forall p' : prec_list, None = Some p' -> pl_tl_length p' (S n) p' : prec_list Hget : MapGet bool m a = Some true Heq, H0 : match ls with | prec_cons _ _ _ | _ => Some (prec_cons a p prec_empty) end = Some p' Unable to unify \"pl_tl_length (prec_cons ?M2018 ?M2019 prec_empty) (S ?M2020)\" with \"pl_tl_length p' (S n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst."], "tactic": "qsimpl time: 1 use: qsimpl,pl_tl_propag,pl_tl_S,auto.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst."], "tactic": "qsimpl time: 1 use: pl_tl_propag,pl_tl_S,auto.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst."], "tactic": "--", "exn": "Wrong bullet --: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst.", "shelve.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "apply IHls."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst.", "shelve.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "apply IHls.", "shelve.", "++", "inversion Heq."], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p p' m n Hlength Heq.", "revert dependent p'.", "induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls].", "-", "intros p' Heq.", "simpl in Heq.", "inversion Heq.", "constructor.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m pl) eqn:Hkill.", "--", "inversion Heq.", "subst.", "constructor.", "apply IH.", "auto.", "--", "inversion Heq.", "*", "qsimpl time: 1.", "+", "qsimpl time: 1.", "-", "intros p' Heq.", "simpl in Heq.", "destruct (MapGet bool m a) eqn:Hget.", "+", "destruct b.", "*", "destruct (prec_list_kill m la) eqn:Hkilla.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "shelve.", "++", "inversion Heq; subst.", "shelve.", "--", "destruct (prec_list_kill m ls) eqn:Hkillls.", "++", "inversion Heq.", "apply IHls.", "shelve.", "++", "inversion Heq.", "shelve.", "*", "apply IHls."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros p p' m n Hlength Heq. revert dependent p'. induction Hlength as [| a pl n Hlength IH | a la ls n Hla IHla Hls IHls]. - intros p' Heq. simpl in Heq. inversion Heq. constructor. - intros p' Heq. simpl in Heq. destruct (MapGet bool m a) eqn:Hget. + destruct b. * destruct (prec_list_kill m pl) eqn:Hkill. -- inversion Heq. subst. constructor. apply IH. auto. -- inversion Heq. * apply IH. auto. + apply IH. auto. - intros p' Heq. simpl in Heq. destruct (MapGet bool m a) eqn:Hget. + destruct b. * destruct (prec_list_kill m la) eqn:Hkilla. -- destruct (prec_list_kill m ls) eqn:Hkillls. ++ inversion Heq. subst. apply pl_tl_propag. ** apply IHla. auto. ** apply IHls. auto. ++ inversion Heq; subst. apply pl_tl_S. apply IHla. auto. -- destruct (prec_list_kill m ls) eqn:Hkillls. ++ inversion Heq. apply IHls. auto. ++ inversion Heq. * apply IHls. auto. + apply IHls. auto.", "back_times": 6, "succ": true, "time": 13.369681119918823}]