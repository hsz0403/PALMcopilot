[{"history": {"proof": "qsimpl time: 1 use: Union_IN. qsimpl time: 1 use: Union_IN. qsimpl time: 1 use: Union_IN. qsimpl time: 1 use: Union_IN,IN_EXType. qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "repairs": ["cannot_apply_in", "not_inductive_product", "no_hypos", "no_hypos", "wrong_type"], "exceptions": [{"ctx": ["intros E X HOrdE HIN."], "tactic": "apply Union_IN in HIN.", "exn": "Unable to apply lemma of type \"forall E E' : Ens, IN E' (Union E) -> EXType Ens (fun E1 : Ens => IN E1 E /\\\\ IN E' E1)\" on hypothesis of type \"IN X (Vee (Succ E))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN."], "tactic": "destruct HIN as [E' [HIN E' HE']].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE."], "tactic": "apply Union_IN in HE'.", "exn": "No such hypothesis: HE'", "type": "no_hypos", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN."], "tactic": "destruct HE' as [F [HEF HF]].", "exn": "The reference HE' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]]."], "tactic": "apply IN_EXType in HEF.", "exn": "No such hypothesis: HEF", "type": "no_hypos", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType."], "tactic": "destruct HEF as [b Hb].", "exn": "The reference HEF was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb]."], "tactic": "exists (sup bool (fun b : bool => bool_rect (fun _ : bool => Ens) (pi2 F b) (pi2 E a) b)).", "exn": "In environment H : forall E E' : Ens, IN E' (Union E) -> EXType Ens (fun E1 : Ens => IN E1 E /\\\\ IN E' E1) E, X : Ens HOrdE : IN E (Succ E) a : pi1 (Vee (Succ E)) Ha : EQ X (pi2 (Vee (Succ E)) a) F : Type b : bool The term \"F\" has type \"Type\" while it is expected to have type \"Ens\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "-"], "tactic": "intros Y HY.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "-"], "tactic": "apply Union_IN in HY.", "exn": "No such hypothesis: HY", "type": "no_hypos", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "-", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool."], "tactic": "destruct HY as [G [HGIN HGG]].", "exn": "The reference HY was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "-", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "destruct Inter' as [G [HGIN HGG]]."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "-", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "destruct Inter' as [G [HGIN HGG]].", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "eapply Ord_Succ.", "exn": "In environment H : forall E E' : Ens, IN E' (Union E) -> EXType Ens (fun E1 : Ens => IN E1 E /\\\\ IN E' E1) E, X : Ens HOrdE : IN E (Succ E) a : pi1 (Vee (Succ E)) Ha : EQ X (pi2 (Vee (Succ E)) a) F, HEF : Type HF : HEF -> Ens Unable to unify \"(fix F (e : Ens) : (fun E : Ens => forall E' : Ens, INC E' E -> Prop) e := match e as e0 return ((fun E : Ens => forall E' : Ens, INC E' E -> Prop) e0) with | sup A e0 => (fun (A0 : Type) (f : A0 -> Ens) (HR : forall (a : A0) (E' : Ens), INC E' (f a) -> Prop) (E' : Ens) (_ : INC E' (sup A0 f)) => (forall a : A0, IN (f a) E' -> HR a (f a) (INC_refl (f a))) /\\\\ (forall (a : A0) (e1 : Ens), IN (f a) E' -> forall p : INC e1 (f a), HR a e1 p -> IN e1 E')) A e0 (fun a : A => F (e0 a)) end) (Succ ?M2473) (Succ ?M2473) (INC_refl (Succ ?M2473))\" with \"EXType Ens (fun Y : Ens => INC Y E /\\\\ Ord Y /\\\\ INC X (Vee Y))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros E X HOrdE HIN.", "qsimpl time: 1 use: Union_IN.", "qsimpl time: 1 use: Union_IN.", "apply IN_EXType in HIN.", "destruct HIN as [a Ha].", "apply Succ_incr in HOrdE.", "qsimpl time: 1 use: Union_IN.", "destruct Inter' as [F [HEF HF]].", "qsimpl time: 1 use: Union_IN,IN_EXType.", "destruct Inter' as [b Hb].", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "-", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,bool_rect,pi2,Ens,bool.", "destruct Inter' as [G [HGIN HGG]].", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl time: 1 use: IN_EXType,sup,Union_IN,EQ,Ord_Succ,bool_rect,pi2,Ens,bool."], "tactic": "eapply Ord_trans; eauto.", "exn": "In environment X3 : forall E : Ens, pi1 E -> Ens X2 : forall P : bool -> Type, P true -> P false -> forall b : bool, P b H2 : forall E : Ens, Ord E -> Ord (Succ E) H1 : forall E E' : Ens, IN E' (Union E) -> EXType Ens (fun E1 : Ens => IN E1 E /\\\\ IN E' E1) X0 : forall A : Type, (A -> Ens) -> Ens H0 : forall E E' : Ens, IN E' E -> EXType (pi1 E) (fun a : pi1 E => EQ E' (pi2 E a)) E, X : Ens HOrdE : IN E (Succ E) a : pi1 (Vee (Succ E)) Ha : EQ X (pi2 (Vee (Succ E)) a) F, HEF : Type HF : HEF -> Ens X1 : Prop Unable to unify \"forall E : Ens, IN E ?M2917 -> IN E ?M2915\" with \"EXType Ens (fun Y : Ens => INC Y E /\\\\ Ord Y /\\\\ INC X (Vee Y))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros E X HOrdE HIN. apply Union_IN in HIN. destruct HIN as [E' [HIN E' HE']]. apply IN_EXType in HIN. destruct HIN as [a Ha]. apply Succ_incr in HOrdE. apply Union_IN in HE'. destruct HE' as [F [HEF HF]]. apply IN_EXType in HEF. destruct HEF as [b Hb]. exists (sup bool (fun b : bool => bool_rect (fun _ : bool => Ens) (pi2 F b) (pi2 E a) b)). split. - intros Y HY. apply Union_IN in HY. destruct HY as [G [HGIN HGG]]. apply Union_IN. exists G. split. + apply IN_EXType. exists b. apply EQ. + apply HGG. - eapply Ord_Succ. eapply Ord_trans; eauto.", "back_times": 0, "succ": false, "time": 273.4262845516205}]