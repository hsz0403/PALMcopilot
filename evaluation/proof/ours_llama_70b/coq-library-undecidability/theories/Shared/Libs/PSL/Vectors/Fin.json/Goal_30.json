[{"history": {"proof": "trivial.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nTrue\n\nPremises:\nrdone = fun (T : Type) (_ : T) => True : forall T : Type, T -> Prop Arguments rdone {T}%type_scope\nnat_ind : forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n\nInductive Op1 : Set := Equal : RingMicromega.Op1 | NonEqual : RingMicromega.Op1 | Strict : RingMicromega.Op1 | NonStrict : RingMicromega.Op1\nInductive PExpr (C : Type) : Type := PEO : Ring_polynom.PExpr C | PEI : Ring_polynom.PExpr C | PEc : C -> Ring_polynom.PExpr C | PEX : positive -> Ring_polynom.PExpr C | PEadd : Ring_polynom.PExpr C -> Ring_polynom.PExpr C -> Ring_polynom.PExpr C | PEsub : Ring_polynom.PExpr C -> Ring_polynom.PExpr C ->...-> Ring_polynom.PExpr C Arguments Ring_polynom.PExpr _%type_scope Arguments Ring_polynom.PEO {C}%type_scope Arguments Ring_polynom.PEI {C}%type_scope Arguments Ring_polynom.PEc [C]%type_scope Arguments Ring_polynom.PEX _%type_scope _%positive_scope Arguments Ring_polynom.PEadd [C]%type_scope Arguments Ring_polynom.PEsub [C]%type_scope Arguments Ring_polynom.PEmul [C]%type_scope Arguments Ring_polynom.PEopp [C]%type_scope Arguments Ring_polynom.PEpow [C]%type_scope _ _%N_scope\nBinIntDef.Z.even = fun z : Z => match z with | 0%Z | Z.pos _~0 | Z.neg _~0 => true | _ => false end : Z -> bool Arguments BinIntDef.Z.even _%Z_scope\nBinPosDef.Pos.testbit = fix testbit (p : positive) (n : N) {struct p} : bool := match p with | (p0~1)%positive => match n with | 0%N => true | N.pos n0 => testbit p0 (BinPosDef.Pos.pred_N n0) end | (p0~0)%positive => match n with | 0%N => false | N.pos n0 => testbit p0 (BinPosDef.Pos.pred_N n0) end | 1%positive => match n with | 0%N => true | N.pos _ => false end end : positive -> N -> bool Arguments BinPosDef.Pos.testbit _%positive_scope _%N_scope\nssreflect.ssr_have_let : forall (Pgoal Plemma : Type) (step : Plemma), (let x := step in Pgoal) -> Pgoal\nBinIntDef.Z.max = fun n m : Z => match (n ?= m)%Z with | Lt => m | _ => n end : Z -> Z -> Z Arguments BinIntDef.Z.max (_ _)%Z_scope\nZ.Even_Odd_False : forall x : Z, Z.Even x -> Z.Odd x -> False\nRecord PropUOp (Op : Prop -> Prop) : Prop := mkuprop { uop_iff : forall p1 q1 : Prop, p1 < -> q1 -> Op p1 < -> Op q1 } PropUOp has primitive projections with eta conversion. Arguments ZifyClasses.PropUOp _%function_scope Arguments ZifyClasses.mkuprop (_ _)%function_scope\nZ.sub_cancel_r : forall n m p : Z, (n - p)%Z = (m - p)%Z < -> n = m\nnat_rect : forall P : nat -> Type, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n\nInductive bool : Set := true : bool | false : bool\nVariant decimal : Set := Decimal : Decimal.int -> Decimal.uint -> Decimal.decimal | DecimalExp : Decimal.int -> Decimal.uint -> Decimal.int -> Decimal.decimal\nVariant mem_pred (T : Type) : Type := Mem : ssrbool.pred T -> ssrbool.mem_pred T Arguments ssrbool.mem_pred _%type_scope Arguments ssrbool.Mem [T]%type_scope\nZ.add_move_l : forall n m p : Z, (n + m)%Z = p < -> m = (p - n)%Z\nssreflect.returnType : forall aT rT : Type, (aT -> rT) -> Type\nssreflect.ssr_have : forall Plemma Pgoal : Type, Plemma -> (Plemma -> Pgoal) -> Pgoal\nInductive or3 (P1 P2 P3 : Prop) : Prop := Or31 : P1 -> ssrbool.or3 P1 P2 P3 | Or32 : P2 -> ssrbool.or3 P1 P2 P3 | Or33 : P3 -> ssrbool.or3 P1 P2 P3 Arguments ssrbool.or3 (_ _ _)%type_scope Arguments ssrbool.Or31 [P1]%type_scope (_ _)%type_scope Arguments ssrbool.Or32 _%type_scope [P2]%type_scope _%type_scope Arguments ssrbool.Or33 (_ _)%type_scope [P3]%type_scope\nRecord injterm (S T : Type) (I : S -> T) : Type := mkinjterm { source : S; target : T; inj_ok : I source = target } injterm has primitive projections with eta conversion. Arguments ZifyClasses.injterm {S T}%type_scope _%function_scope Arguments ZifyClasses.mkinjterm (_ _)%type_scope _%function_scope\nRing_theory.IDphi : forall R : Type, R -> R\nRing_theory.ARmul_assoc : forall (R : Type) (rO rI : R) (radd rmul rsub : R -> R -> R) (ropp : R -> R) (req : R -> R -> Prop), Ring_theory.almost_ring_theory rO rI radd rmul rsub ropp req -> forall x y z : R, req (rmul x (rmul y z)) (rmul (rmul x y) z)\nEnvRing.Pol_ind : forall (C : Type) (P : EnvRing.Pol C -> Prop), (forall c : C, P (EnvRing.Pc c)) -> (forall (p : positive) (p0 : EnvRing.Pol C), P p0 -> P (EnvRing.Pinj p p0)) -> (forall p : EnvRing.Pol C, P p -> forall (p0 : positive) (p1 : EnvRing.Pol C), P p1 -> P (EnvRing.PX p p0 p1)) -> forall p : EnvRing.Pol C, P p\nZdiv.Zodd_mod : forall a : Z, Z.odd a = Zeq_bool (a mod 2) 1\nEnvRing.Padd : forall C : Type, C -> (C -> C -> C) -> (C -> C -> bool) -> EnvRing.Pol C -> EnvRing.Pol C -> EnvRing.Pol C"}, {"role": "assistant", "content": "```coq\ntrivial.\nQed.```"}], "original": "trivial.", "succ": true}]