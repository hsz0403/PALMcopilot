[{"history": {"proof": "rewrite <- bin_add_eq_00x. auto.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nx: bool\n\nGoal:\nbin_add \u27d8 x \u27d8 = (\u27d8, x)\n\nPremises:\nNotation bin_add := bool_add_with_rem\nbin_add_eq_00x : forall x : bool, bin_add \u27d8 \u27d8 x = (\u27d8, x)\npartition_cons2 : forall (A : Type) (f : A -> bool) (a : A) (l l1 l2 : list A), partition f l = (l1, l2) -> f a = \u27d8 -> partition f (a :: l) = (l1, a :: l2)\nByte.to_bits = fun b : Byte.byte => match b with | Byte.x00 => (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, \u27d8))))))) | Byte.x01 => (\u27d9, (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, \u27d8))))))) | Byte.x02 => (\u27d8, (\u27d9, (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, \u27d8))))))) | Byte.x03 => (\u27d9, (\u27d9, (\u27d8, (\u27d8, (\u27d8, (\u27d8, (\u27d8, \u27d8))))))) | Byte.x04 => (\u27d8, (\u27d8, (\u27d9, (\u27d8, (\u27d8, (\u27d8, (\u27d8, \u27d8))))))) | Byte.x05 => (\u27d9, (\u27d8, (\u27d9, (\u27d8, (\u27d8, (\u27d8, (\u27d8...\nAcc_ind : forall (A : Type) (R : A -> A -> Prop) (P : A -> Prop), (forall x : A, (forall y : A, R y x -> Acc R y) -> (forall y : A, R y x -> P y) -> P x) -> forall x : A, Acc R x -> P x\nbool_add_with_rem = fun a b c : bool => if a then if b then if c then (\u27d9, \u27d9) else (\u27d9, \u27d8) else if c then (\u27d9, \u27d8) else (\u27d8, \u27d9) else if b then if c then (\u27d9, \u27d8) else (\u27d8, \u27d9) else if c then (\u27d8, \u27d9) else (\u27d8, \u27d8) : bool -> bool -> bool -> bool * bool Arguments bool_add_with_rem (_ _ _)%bool_scope\nLexicographic_Product.swap_Acc : forall (A : Type) (R : A -> A -> Prop) (x y : A), Acc (Relation_Operators.swapprod A R) (x, y) -> Acc (Relation_Operators.swapprod A R) (y, x)\nRelation_Operators.sp_swap : forall (A : Type) (R : A -> A -> Prop) (x y : A) (p : A * A), Relation_Operators.symprod A A R R (x, y) p -> Relation_Operators.swapprod A R (y, x) p\nBinIntDef.Z.add = fun x y : BinNums.Z => match x with | BinNums.Z0 => y | BinNums.Zpos x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.add x' y') | BinNums.Zneg y' => BinIntDef.Z.pos_sub x' y' end | BinNums.Zneg x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinIntDef.Z.pos_sub y' x' | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.add x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.add (_ _)%Z_scope\nBinInt.Z.le = fun x y : BinNums.Z => BinInt.Z.compare x y <> Gt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.le (_ _)%Z_scope\nInductive swapprod (A : Type) (R : A -> A -> Prop) : A * A -> A * A -> Prop := sp_noswap : forall (x y : A) (p : A * A), Relation_Operators.symprod A A R R (x, y) p -> Relation_Operators.swapprod A R (x, y) p | sp_swap : forall (x y : A) (p : A * A), Relation_Operators.symprod A A R R (x, y) p -> Relation_Operators.swapprod A R (y, x) p Arguments Relation_Operators.swapprod _%type_scope _%function_scope Arguments Relation_Operators.sp_noswap _%type_scope _%function_scope Arguments Relation_Operators.sp_swap _%type_scope _%function_scope\nAcc_inv : forall (A : Type) (R : A -> A -> Prop) (x : A), Acc R x -> forall y : A, R y x -> Acc R y\nAcc_intro : forall (A : Type) (R : A -> A -> Prop) (x : A), (forall y : A, R y x -> Acc R y) -> Acc R x\nInductive Acc (A : Type) (R : A -> A -> Prop) (x : A) : Prop := Acc_intro : (forall y : A, R y x -> Acc R y) -> Acc R x Arguments Acc [A]%type_scope _%function_scope Arguments Acc_intro [A]%type_scope [R]%function_scope _ _%function_scope\nInductive symprod (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) : A * B -> A * B -> Prop := left_sym : forall x x' : A, leA x x' -> forall y : B, Relation_Operators.symprod A B leA leB (x, y) (x', y) | right_sym : forall y y' : B, leB y y' -> forall x : A, Relation_Operators.symprod A B leA leB (x, y) (x, y') Arguments Relation_Operators.symprod (_ _)%type_scope (_ _)%function_scope Arguments Relation_Operators.left_sym (_ _)%type_scope (_ _)%function_scope Arguments Relation_Operators.right_sym (_ _)%type_scope (_ _)%function_scope\nrew_pair : forall (A : Type) (P Q : A -> Type) (x1 x2 : A) (y1 : P x1) (y2 : Q x1) (H : x1 = x2), (eq_rect x1 P y1 x2 H, eq_rect x1 Q y2 x2 H) = eq_rect x1 (fun x : A => (P x * Q x)%type) (y1, y2) x2 H\nBinIntDef.Z.mul = fun x y : BinNums.Z => match x with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos x' => match y with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.mul x' y') | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.mul x' y') end | BinNums.Zneg x' => match y with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos y' => BinNums.Zneg (BinPos.Pos.mul x' y') | BinNums.Zneg y' => BinNums.Zpos (BinPos.Pos.mul x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.mul (_ _)%Z_scope\nLexicographic_Product.Acc_swapprod : forall (A : Type) (R : A -> A -> Prop) (x y : A), Acc R x -> Acc R y -> Acc (Relation_Operators.swapprod A R) (x, y)\nfst = fun (A B : Type) (p : A * B) => let (x, _) := p in x : forall A B : Type, A * B -> A Arguments fst {A B}%type_scope\nRelation_Operators.left_sym : forall (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) (x x' : A), leA x x' -> forall y : B, Relation_Operators.symprod A B leA leB (x, y) (x', y)\nRelation_Operators.right_sym : forall (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) (y y' : B), leB y y' -> forall x : A, Relation_Operators.symprod A B leA leB (x, y) (x, y')\nLexicographic_Product.Acc_symprod : forall (A B : Type) (leA : A -> A -> Prop) (leB : B -> B -> Prop) (x : A), Acc leA x -> forall y : B, Acc leB y -> Acc (Relation_Operators.symprod A B leA leB) (x, y)\npair_equal_spec : forall (A B : Type) (a1 a2 : A) (b1 b2 : B), (a1, b1) = (a2, b2) < -> a1 = a2 /\\ b1 = b2\nZnat.Nat2Z.inj_iff : forall n m : nat, BinInt.Z.of_nat n = BinInt.Z.of_nat m < -> n = m\neq_add_S : forall n m : nat, S n = S m -> n = m\npartition_cons1 : forall (A : Type) (f : A -> bool) (a : A) (l l1 l2 : list A), partition f l = (l1, l2) -> f a = \u27d9 -> partition f (a :: l) = (a :: l1, l2)"}, {"role": "assistant", "content": "```coq\nrewrite <- bin_add_eq_00x. auto.\nQed.\n```"}], "original": "rewrite <- bin_add_eq_00x. auto.", "succ": true}]