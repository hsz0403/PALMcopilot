[{"history": {"proof": "qsimpl time: 1 use: vec_map_list_zero.", "repairs": ["no_subterm"], "exceptions": [{"ctx": ["unfold vec_map_list."], "tactic": "rewrite vec_map_list_zero.", "exn": "Found no subterm matching \"vec_map_list vec_zero ?M1447\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nX: Type\nn: nat\np: pos n\nf: pos n -> X\n\nGoal:\nvec_map_list (vec_one p) f = f p :: nil\n\nPremises:\nvec_map_list : forall (X : Type) (n : nat), vec nat n -> (pos n -> X) -> list X\nvec_one = fun (n : nat) (p : pos n) => vec_set_pos (fun q : pos n => if pos_eq_dec p q then 1 else 0) : forall n : nat, pos n -> vec nat n Arguments vec_one {n}%nat_scope\nNotation pos := Fin.t\nvec_map_list_zero : forall (n : nat) (f : pos n -> X), vec_map_list vec_zero f = nil\nFin.cast : pos ?m -> forall n0 : nat, ?m = n0 -> pos n0 where ?m : [X : Type n : nat p : pos n f : pos n -> X |- nat]\nFin.FS_inj : forall x y : pos ?n, pos_nxt x = pos_nxt y -> x = y where ?n : [X : Type n : nat p : pos n f : pos n -> X |- nat]\nFin.to_nat_inj : forall p0 q : pos ?n, proj1_sig (Fin.to_nat p0) = proj1_sig (Fin.to_nat q) -> p0 = q where ?n : [X : Type n : nat p : pos n f : pos n -> X |- nat]\npos_S_inv : forall p0 : pos (S ?n), (p0 = pos0) + {q : pos ?n | p0 = pos_nxt q} where ?n : [X : Type n : nat p : pos n f : pos n -> X |- nat]\nFinFun.Fin2Restrict.extend_n2f : forall (n : nat) (f : pos n -> pos n) (x : nat) (h : x < n), Fin.of_nat_lt (FinFun.Fin2Restrict.extend_ok f h) = f (Fin.of_nat_lt h)\nvec_sum_one : forall (n : nat) (p : pos n), vec_sum (vec_one p) = 1\nvec_sum_is_nzero : forall (n : nat) (v : vec nat n), 0 < vec_sum v -> {p : pos n & {w : vec nat n | v = vec_plus (vec_one p) w}}\nmap_cons_inv : forall (X Y : Type) (f : X -> Y) (ll : list X) (y : Y) (m : list Y), map f ll = y :: m -> {x : X & {l : list X | ll = x :: l /\\ f x = y /\\ map f l = m}}\nflat_map_single : forall (X Y : Type) (f : X -> Y) (l : list X), flat_map (fun x : X => f x :: nil) l = map f l\nvec_change_succ : forall (n : nat) (v : vec nat n) (p : pos n), v[(S (v#>p))/p] = vec_plus (vec_one p) v\nvec_change_pred : forall (n : nat) (v : vec nat n) (p : pos n) (u : nat), v#>p = S u -> v = vec_plus (vec_one p) (v[u/p])\npos_both_left : forall (n m : nat) (p : pos n), pos_both n m (pos_left m p) = inl p\nvec_change : forall (X : Type) (n : nat), vec X n -> pos n -> X -> vec X n\nmap_cons : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l\nvec_pos : forall (X : Type) (n : nat), vec X n -> pos n -> X\nvec_one_nxt : forall (n : nat) (p : pos n), vec_one (pos_nxt p) = 0 ## vec_one p\nmap_last : forall (A B : Type) (f : A -> B) (l : list A) (a : A), map f (l ++ a :: nil) = map f l ++ f a :: nil\nvec_nat_induction : forall (n : nat) (P : vec nat n -> Type), P vec_zero -> (forall p : pos n, P (vec_one p)) -> (forall v w : vec nat n, P v -> P w -> P (vec_plus v w)) -> forall v : vec nat n, P v\nmap_eq_cons : forall (A B : Type) (f : A -> B) (l : list A) (l' : list B) (b : B), map f l = b :: l' -> exists (a : A) (tl : list A), l = a :: tl /\\ f a = b /\\ map f tl = l'\nFin.of_nat_lt = fix of_nat_lt (p n : nat) {struct p} : p < n -> pos n := match n as n0 return (p < n0 -> pos n0) with | 0 => fun H : p < 0 => False_rect (pos 0) (Nat.nlt_0_r p H) | S n' => match p as p0 return (p0 < S n' -> pos (S n')) with | 0 => fun _ : 0 < S n' => pos0 | S p' => fun H : S p' < S n' => pos_nxt (of_nat_lt p' n' (lt_S_n p' n' H)) end end : forall p n : nat, p < n -> pos n Arguments Fin.of_nat_lt {p n}%nat_scope\nvec_pos_set : forall (X : Type) (n : nat) (g : pos n -> X) (p : pos n), vec_set_pos g#>p = g p\npos_iso : forall n m : nat, n = m -> pos n -> pos m\nvec_pos_ext : forall (X : Type) (n : nat) (v w : vec X n), (forall p : pos n, v#>p = w#>p) -> v = w\npos_O_inv = let pos_inv_t := fun n : nat => match n as x return (pos x -> Set) with | 0 => fun _ : pos 0 => False | S n0 => fun i : pos (S n0) => ((i = pos0) + {p : pos n0 | i = pos_nxt p})%type end in let pos_inv := fun (_tmp : nat) (p0 : pos _tmp) => match p0 as t in (pos n) return (pos_inv_t n t) with | @Fin.F1 n => inl eq_refl | @Fin.FS n p => inr (exist (fun p1 : pos n => pos_nxt p = pos_nxt p1) p eq_refl) end in pos_inv 0 : pos 0 -> False"}, {"role": "assistant", "content": "```coq\nunfold vec_map_list.\nrewrite vec_map_list_zero.\ninduction p using pos_S_inv.\n- simpl. rewrite vec_pos_set. auto.\n- simpl. rewrite IHp. auto.\nQed.\n```"}], "original": "unfold vec_map_list. rewrite vec_map_list_zero. induction p using pos_S_inv. - simpl. rewrite vec_pos_set. auto. - simpl. rewrite IHp. auto.", "succ": false}]