[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-"], "tactic": "apply Families.family_union_intro with (S := pwo_S WO).", "exn": "In environment T : Type WO : partial_WO x : T ni : ~ In (pwo_S WO) x Unable to unify \"Families.FamilyUnion ?M1679 ?M1681\" with \"forall x0 : T, In (pwo_S WO) x0 -> In (pwo_S {| pwo_S := Add (pwo_S WO) x; pwo_R := fun x1 y : T => pwo_R WO x1 y \\\\/ In (pwo_S WO) x1 /\\\\ y = x; pwo_R_lives_on_S := fun (x1 y : T) (H0 : pwo_R WO x1 y \\\\/ In (pwo_S WO) x1 /\\\\ y = x) => match H0 with | or_introl H1 => conj (Union_introl T (pwo_S WO) (Singleton x) x1 (and_ind (fun (H2 : In (pwo_S WO) x1) (_ : In (pwo_S WO) y) => H2) (pwo_R_lives_on_S WO x1 y H1))) (Union_introl T (pwo_S WO) (Singleton x) y (and_ind (fun (_ : In (pwo_S WO) x1) (H4 : In (pwo_S WO) y) => H4) (pwo_R_lives_on_S WO x1 y H1))) | or_intror (conj H2 H3) => conj (Union_introl T (pwo_S WO) (Singleton x) x1 H2) (Union_intror T (pwo_S WO) (Singleton x) y (eq_ind_r (fun y0 : T => In (Singleton x) y0) (In_singleton T x) H3)) end; pwo_wo := {| wo_well_founded := fun a0 : {z : T | In (Add (pwo_S WO) x) z} => let (x1, i) as s return (Acc (restriction_relation (fun x1 y : T => pwo_R WO x1 y \\\\/ In (pwo_S WO) x1 /\\\\ y = x) (Add (pwo_S WO) x)) s) := a0 in match i as u in (Union _ _ y) return (Acc (restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (pwo_S WO) x2 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (fun z : T => In (Add (pwo_S WO) x) z) y u)) with | Union_introl _ _ _ x2 i0 => eq_ind (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y : T => In (pwo_S WO) y) x2 i0)) i0) (fun i1 : In (Add (pwo_S WO) x) (proj1_sig (exist (In (pwo_S WO)) x2 i0)) => Acc (restriction_relation (fun x3 y : T => pwo_R WO x3 y \\\\/ In (pwo_S WO) x3 /\\\\ y = x) (Add (pwo_S WO) x)) (exist (fun z : T => In (Add (pwo_S WO) x) z) x2 i1)) (Acc_ind (fun x3 : {z : T | In (pwo_S WO) z} => Acc (restriction_relation (fun x4 y : T => pwo_R WO x4 y \\\\/ In (pwo_S WO) x4 /\\\\ y = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig x3) (let (x4, i1) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := x3 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y : T => In (pwo_S WO) y) x4 i1)) i1))) (fun (x3 : {z : T | In (pwo_S WO) z}) (H1 : forall y : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y x3 -> Acc (restriction_relation (pwo_R WO) (pwo_S WO)) y) (H2 : forall y : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y x3 -> Acc (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (pwo_S WO) x4 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig y) (let (x4, i1) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := y in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x4 i1)) i1))) => Acc_intro (exist (In (Add (pwo_S WO) x)) (proj1_sig x3) (let (x4, i1) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := x3 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y : T => In (pwo_S WO) y) x4 i1)) i1)) (fun (y : {z : T | In (Add (pwo_S WO) x) z}) (H3 : restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (pwo_S WO) x4 /\\\\ y0 = x) (Add (pwo_S WO) x) y (exist (In (Add (pwo_S WO) x)) (proj1_sig x3) (let (x4, i1) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := x3 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x4 i1)) i1))) => (let (x4, i1) as s return ((forall y0 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y0 s -> Acc (restriction_relation (pwo_R WO) (pwo_S WO)) y0) -> (forall y0 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y0 s -> Acc (restriction_relation (fun x4 y1 : T => pwo_R WO x4 y1 \\\\/ In (pwo_S WO) x4 /\\\\ y1 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig y0) (let (x4, i1) as s0 return (In (Add (pwo_S WO) x) (proj1_sig s0)) := y0 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x4 i1)) i1))) -> restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (pwo_S WO) x4 /\\\\ y0 = x) (Add (pwo_S WO) x) y (exist (In (Add (pwo_S WO) x)) (proj1_sig s) (let (x4, i1) as s0 return (In (Add (pwo_S WO) x) (proj1_sig s0)) := s in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x4 i1)) i1)) -> Acc (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (pwo_S WO) x4 /\\\\ y0 = x) (Add (pwo_S WO) x)) y) := x3 in fun (_ : forall y0 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y0 (exist (fun z : T => In (pwo_S WO) z) x4 i1) -> Acc (restriction_relation (pwo_R WO) (pwo_S WO)) y0) (H5 : forall y0 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y0 (exist (fun z : T => In (pwo_S WO) z) x4 i1) -> Acc (restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (pwo_S WO) x5 /\\\\ y1 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig y0) (let (x5, i2) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := y0 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i2)) i2))) (H6 : restriction_relation (fun x5 y0 : T => pwo_R WO x5 y0 \\\\/ In (pwo_S WO) x5 /\\\\ y0 = x) (Add (pwo_S WO) x) y (exist (In (Add (pwo_S WO) x)) (proj1_sig (exist (fun z : T => In (pwo_S WO) z) x4 i1)) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x4 i1)) i1))) => (let (x5, i2) as s return (restriction_relation (fun x5 y0 : T => pwo_R WO x5 y0 \\\\/ In (pwo_S WO) x5 /\\\\ y0 = x) (Add (pwo_S WO) x) s (exist (In (Add (pwo_S WO) x)) (proj1_sig (exist (fun z : T => In (pwo_S WO) z) x4 i1)) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x4 i1)) i1)) -> Acc (restriction_relation (fun x5 y0 : T => pwo_R WO x5 y0 \\\\/ In (pwo_S WO) x5 /\\\\ y0 = x) (Add (pwo_S WO) x)) s) := y in fun H7 : restriction_relation (fun x6 y0 : T => pwo_R WO x6 y0 \\\\/ In (pwo_S WO) x6 /\\\\ y0 = x) (Add (pwo_S WO) x) (exist (fun z : T => In (Add (pwo_S WO) x) z) x5 i2) (exist (In (Add (pwo_S WO) x)) (proj1_sig (exist (fun z : T => In (pwo_S WO) z) x4 i1)) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x4 i1)) i1)) => eq_ind_r (fun i3 : In (Add (pwo_S WO) x) x5 => restriction_relation (pwo_R WO) (pwo_S WO) (exist (In (pwo_S WO)) x5 match H7 with | or_introl H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : In (pwo_S WO) x4) => H9) (pwo_R_lives_on_S WO x5 x4 H8) | or_intror H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : x4 = x) => H9) H8 end) (exist (fun z : T => In (pwo_S WO) z) x4 i1) -> Acc (restriction_relation (fun x6 y0 : T => pwo_R WO x6 y0 \\\\/ In (pwo_S WO) x6 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) x5 i3)) (H5 (exist (In (pwo_S WO)) x5 match H7 with | or_introl H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : In (pwo_S WO) x4) => H9) (pwo_R_lives_on_S WO x5 x4 H8) | or_intror H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : x4 = x) => H9) H8 end)) (proof_irrelevance (In (Add (pwo_S WO) x) x5) i2 (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x5 match H7 with | or_introl H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : In (pwo_S WO) x4) => H9) (pwo_R_lives_on_S WO x5 x4 H8) | or_intror H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : x4 = x) => H9) H8 end)) match H7 with | or_introl H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : In (pwo_S WO) x4) => H9) (pwo_R_lives_on_S WO x5 x4 H8) | or_intror H8 => and_ind (fun (H9 : In (pwo_S WO) x5) (_ : x4 = x) => H9) H8 end)) match H7 with | or_introl H8 => H8 | or_intror (conj _ H10) => match ni (eq_ind x4 (fun a : T => In (pwo_S WO) a) i1 x H10) return (pwo_R WO x5 x4) with end end) H6) H1 H2 H3)) (wo_well_founded (pwo_wo WO) (exist (In (pwo_S WO)) x2 i0))) (Union_introl T (pwo_S WO) (Singleton x) x2 i0) (proof_irrelevance (In (Add (pwo_S WO) x) (proj1_sig (exist (In (pwo_S WO)) x2 i0))) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y : T => In (pwo_S WO) y) x2 i0)) i0) (Union_introl T (pwo_S WO) (Singleton x) x2 i0)) | Union_intror _ _ _ _ i0 => match i0 in (Singleton _ y) return (forall i1 : In (Singleton x) y, Acc (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (pwo_S WO) x3 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (fun z : T => In (Add (pwo_S WO) x) z) y (Union_intror T (pwo_S WO) (Singleton x) y i1))) with | In_singleton _ _ => fun i1 : In (Singleton x) x => Acc_intro (exist (fun z : T => In (Add (pwo_S WO) x) z) x (Union_intror T (pwo_S WO) (Singleton x) x i1)) (fun (y : {z : T | In (Add (pwo_S WO) x) z}) (H2 : restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (pwo_S WO) x3 /\\\\ y0 = x) (Add (pwo_S WO) x) y (exist (fun z : T => In (Add (pwo_S WO) x) z) x (Union_intror T (pwo_S WO) (Singleton x) x i1))) => (let (x3, i2) as s return (pwo_R WO (proj1_sig s) (proj1_sig (exist (fun z : T => In (Add (pwo_S WO) x) z) x (Union_intror T (pwo_S WO) (Singleton x) x i1))) \\\\/ In (pwo_S WO) (proj1_sig s) /\\\\ proj1_sig (exist (fun z : T => In (Add (pwo_S WO) x) z) x (Union_intror T (pwo_S WO) (Singleton x) x i1)) = x -> Acc (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (pwo_S WO) x3 /\\\\ y0 = x) (Add (pwo_S WO) x)) s) := y in fun H3 : pwo_R WO (proj1_sig (exist (fun z : T => In (Add (pwo_S WO) x) z) x3 i2)) (proj1_sig (exist (fun z : T => In (Add (pwo_S WO) x) z) x (Union_intror T (pwo_S WO) (Singleton x) x i1))) \\\\/ In (pwo_S WO) (proj1_sig (exist (fun z : T => In (Add (pwo_S WO) x) z) x3 i2)) /\\\\ proj1_sig (exist (fun z : T => In (Add (pwo_S WO) x) z) x (Union_intror T (pwo_S WO) (Singleton x) x i1)) = x => match H3 with | or_introl H4 => match ni (and_ind (fun (_ : In (pwo_S WO) x3) (H5 : In (pwo_S WO) x) => H5) (pwo_R_lives_on_S WO x3 x H4)) return (Acc (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (pwo_S WO) x4 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (fun z : T => In (Add (pwo_S WO) x) z) x3 i2)) with end | or_intror (conj H5 _) => eq_ind (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x3 H5)) H5) (fun i3 : In (Add (pwo_S WO) x) (proj1_sig (exist (In (pwo_S WO)) x3 H5)) => Acc (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (pwo_S WO) x4 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) x3 i3)) (Acc_ind (fun x4 : {z : T | In (pwo_S WO) z} => Acc (restriction_relation (fun x5 y0 : T => pwo_R WO x5 y0 \\\\/ In (pwo_S WO) x5 /\\\\ y0 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig x4) (let (x5, i3) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := x4 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x5 i3)) i3))) (fun (x4 : {z : T | In (pwo_S WO) z}) (H1 : forall y0 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y0 x4 -> Acc (restriction_relation (pwo_R WO) (pwo_S WO)) y0) (H7 : forall y0 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y0 x4 -> Acc (restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (pwo_S WO) x5 /\\\\ y1 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig y0) (let (x5, i3) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := y0 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i3)) i3))) => Acc_intro (exist (In (Add (pwo_S WO) x)) (proj1_sig x4) (let (x5, i3) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := x4 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x5 i3)) i3)) (fun (y0 : {z : T | In (Add (pwo_S WO) x) z}) (H8 : restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (pwo_S WO) x5 /\\\\ y1 = x) (Add (pwo_S WO) x) y0 (exist (In (Add (pwo_S WO) x)) (proj1_sig x4) (let (x5, i3) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := x4 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i3)) i3))) => (let (x5, i3) as s return ((forall y1 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y1 s -> Acc (restriction_relation (pwo_R WO) (pwo_S WO)) y1) -> (forall y1 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y1 s -> Acc (restriction_relation (fun x5 y2 : T => pwo_R WO x5 y2 \\\\/ In (pwo_S WO) x5 /\\\\ y2 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig y1) (let (x5, i3) as s0 return (In (Add (pwo_S WO) x) (proj1_sig s0)) := y1 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y2 : T => In (pwo_S WO) y2) x5 i3)) i3))) -> restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (pwo_S WO) x5 /\\\\ y1 = x) (Add (pwo_S WO) x) y0 (exist (In (Add (pwo_S WO) x)) (proj1_sig s) (let (x5, i3) as s0 return (In (Add (pwo_S WO) x) (proj1_sig s0)) := s in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i3)) i3)) -> Acc (restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (pwo_S WO) x5 /\\\\ y1 = x) (Add (pwo_S WO) x)) y0) := x4 in fun (_ : forall y1 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y1 (exist (fun z : T => In (pwo_S WO) z) x5 i3) -> Acc (restriction_relation (pwo_R WO) (pwo_S WO)) y1) (H10 : forall y1 : {z : T | In (pwo_S WO) z}, restriction_relation (pwo_R WO) (pwo_S WO) y1 (exist (fun z : T => In (pwo_S WO) z) x5 i3) -> Acc (restriction_relation (fun x6 y2 : T => pwo_R WO x6 y2 \\\\/ In (pwo_S WO) x6 /\\\\ y2 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) (proj1_sig y1) (let (x6, i4) as s return (In (Add (pwo_S WO) x) (proj1_sig s)) := y1 in Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y2 : T => In (pwo_S WO) y2) x6 i4)) i4))) (H11 : restriction_relation (fun x6 y1 : T => pwo_R WO x6 y1 \\\\/ In (pwo_S WO) x6 /\\\\ y1 = x) (Add (pwo_S WO) x) y0 (exist (In (Add (pwo_S WO) x)) (proj1_sig (exist (fun z : T => In (pwo_S WO) z) x5 i3)) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i3)) i3))) => (let (x6, i4) as s return (restriction_relation (fun x6 y1 : T => pwo_R WO x6 y1 \\\\/ In (pwo_S WO) x6 /\\\\ y1 = x) (Add (pwo_S WO) x) s (exist (In (Add (pwo_S WO) x)) (proj1_sig (exist (fun z : T => In (pwo_S WO) z) x5 i3)) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i3)) i3)) -> Acc (restriction_relation (fun x6 y1 : T => pwo_R WO x6 y1 \\\\/ In (pwo_S WO) x6 /\\\\ y1 = x) (Add (pwo_S WO) x)) s) := y0 in fun H12 : restriction_relation (fun x7 y1 : T => pwo_R WO x7 y1 \\\\/ In (pwo_S WO) x7 /\\\\ y1 = x) (Add (pwo_S WO) x) (exist (fun z : T => In (Add (pwo_S WO) x) z) x6 i4) (exist (In (Add (pwo_S WO) x)) (proj1_sig (exist (fun z : T => In (pwo_S WO) z) x5 i3)) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x5 i3)) i3)) => eq_ind_r (fun i5 : In (Add (pwo_S WO) x) x6 => restriction_relation (pwo_R WO) (pwo_S WO) (exist (In (pwo_S WO)) x6 match H12 with | or_introl H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : In (pwo_S WO) x5) => H14) (pwo_R_lives_on_S WO x6 x5 H13) | or_intror H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : x5 = x) => H14) H13 end) (exist (fun z : T => In (pwo_S WO) z) x5 i3) -> Acc (restriction_relation (fun x7 y1 : T => pwo_R WO x7 y1 \\\\/ In (pwo_S WO) x7 /\\\\ y1 = x) (Add (pwo_S WO) x)) (exist (In (Add (pwo_S WO) x)) x6 i5)) (H10 (exist (In (pwo_S WO)) x6 match H12 with | or_introl H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : In (pwo_S WO) x5) => H14) (pwo_R_lives_on_S WO x6 x5 H13) | or_intror H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : x5 = x) => H14) H13 end)) (proof_irrelevance (In (Add (pwo_S WO) x) x6) i4 (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y1 : T => In (pwo_S WO) y1) x6 match H12 with | or_introl H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : In (pwo_S WO) x5) => H14) (pwo_R_lives_on_S WO x6 x5 H13) | or_intror H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : x5 = x) => H14) H13 end)) match H12 with | or_introl H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : In (pwo_S WO) x5) => H14) (pwo_R_lives_on_S WO x6 x5 H13) | or_intror H13 => and_ind (fun (H14 : In (pwo_S WO) x6) (_ : x5 = x) => H14) H13 end)) match H12 with | or_introl H13 => H13 | or_intror (conj _ H15) => match ni (eq_ind x5 (fun a : T => In (pwo_S WO) a) i3 x H15) return (pwo_R WO x6 x5) with end end) H11) H1 H7 H8)) (wo_well_founded (pwo_wo WO) (exist (In (pwo_S WO)) x3 H5))) i2 (proof_irrelevance (In (Add (pwo_S WO) x) (proj1_sig (exist (In (pwo_S WO)) x3 H5))) (Union_introl T (pwo_S WO) (Singleton x) (proj1_sig (exist (fun y0 : T => In (pwo_S WO) y0) x3 H5)) H5) i2) end) H2) end i0 end; wo_total_strict_order := fun x1 y : {z : T | In (Add (pwo_S WO) x) z} => let (x2, i) as s return (restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (pwo_S WO) x2 /\\\\ y0 = x) (Add (pwo_S WO) x) s y \\\\/ s = y \\\\/ restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (pwo_S WO) x2 /\\\\ y0 = x) (Add (pwo_S WO) x) y s) := x1 in let (x3, i0) as s return (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (pwo_S WO) x3 /\\\\ y0 = x) (Add (pwo_S WO) x) (exist (fun z : T => In (Add (pwo_S WO) x) z) x2 i) s \\\\/ exist (fun z : T => In (Add (pwo_S WO) x) z) x2 i = s \\\\/ restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (pwo_S WO) x3 /\\\\ y0 = x) (Add (pwo_S WO) x) s (exist (fun z : T => In (Add (pwo_S WO) x) z) x2 i)) := y in match i as u in (Union _ _ y0) return ((pwo_R WO y0 x3 \\\\/ In (pwo_S WO) y0 /\\\\ x3 = x) \\\\/ exist (fun z : T => In (Add (pwo_S WO) x) z) y0 u = exist (fun z : T => In (Add (pwo_S WO) x) z) x3 i0 \\\\/ pwo_R WO x3 y0 \\\\/ In (pwo_S WO) x3 /\\\\ y0 = x) with | Union_introl _ _ _ x4 x5 => match i0 as u in (Union _ _ y0) return (forall (x6 : T) (i1 : In (pwo_S WO) x6), (pwo_R WO x6 y0 \\\\/ In (pwo_S WO) x6 /\\\\ y0 = x) \\\\/ exist (fun z : T => In (Add (pwo_S WO) x) z) x6 (Union_introl T (pwo_S WO) (Singleton x) x6 i1) = exist (fun z : T => In (Add (pwo_S WO) x) z) y0 u \\\\/ pwo_R WO y0 x6 \\\\/ In (pwo_S WO) y0 /\\\\ x6 = x) with | Union_introl _ _ _ x6 i1 => fun (x7 : T) (i2 : In (pwo_S WO) x7) => match wo_total_strict_order (pwo_wo WO) (exist (In (pwo_S WO)) x7 i2) (exist (In (pwo_S WO)) x6 i1) with | or_introl H0 => or_introl (or_introl H0) | or_intror (or_introl H1) => or_intror (or_introl (subset_eq_compat T (fun z : T => In (Add (pwo_S WO) x) z) x7 x6 (Union_introl T (pwo_S WO) (Singleton x) x7 i2) (Union_introl T (pwo_S WO) (Singleton x) x6 i1) (f_equal (fun e : {z : T | In (pwo_S WO) z} => let (x, _) := e in x) H1))) | or_intror (or_intror H1) => or_intror (or_intror (or_introl H1)) end | Union_intror _ _ _ x6 i1 => fun (x7 : T) (i2 : In (pwo_S WO) x7) => or_introl match i1 in (Singleton _ y0) return (pwo_R WO x7 y0 \\\\/ In (pwo_S WO) x7 /\\\\ y0 = x) with | In_singleton _ _ => or_intror (conj i2 eq_refl) end end x4 x5 | Union_intror _ _ _ x4 x5 => match i0 as u in (Union _ _ y0) return (forall (x6 : T) (i1 : In (Singleton x) x6), (pwo_R WO x6 y0 \\\\/ In (pwo_S WO) x6 /\\\\ y0 = x) \\\\/ exist (fun z : T => In (Add (pwo_S WO) x) z) x6 (Union_intror T (pwo_S WO) (Singleton x) x6 i1) = exist (fun z : T => In (Add (pwo_S WO) x) z) y0 u \\\\/ pwo_R WO y0 x6 \\\\/ In (pwo_S WO) y0 /\\\\ x6 = x) with | Union_introl _ _ _ x6 i1 => fun (x7 : T) (i2 : In (Singleton x) x7) => or_intror (or_intror match i2 in (Singleton _ y0) return (pwo_R WO x6 y0 \\\\/ In (pwo_S WO) x6 /\\\\ y0 = x) with | In_singleton _ _ => or_intror (conj i1 eq_refl) end) | Union_intror _ _ _ x6 i1 => fun (x7 : T) (i2 : In (Singleton x) x7) => or_intror (or_introl (subset_eq_compat T (fun z : T => In (Add (pwo_S WO) x) z) x7 x6 (Union_intror T (pwo_S WO) (Singleton x) x7 i2) (Union_intror T (pwo_S WO) (Singleton x) x6 i1) match i1 in (Singleton _ y0) return (x7 = y0) with | In_singleton _ _ => match i2 in (Singleton _ y0) return (y0 = x) with | In_singleton _ _ => eq_refl end end)) end x4 x5 end |} |}) x0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S."], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal."], "tactic": "apply ni.", "exn": "In environment T : Type e : partial_WO -> Ensemble T WO : partial_WO x : T ni : In (pwo_S WO) x -> False Unable to unify \"False\" with \"In Empty_set (e {| pwo_S := Add (e WO) x; pwo_R := fun x0 y : T => pwo_R WO x0 y \\\\/ In (e WO) x0 /\\\\ y = x; pwo_R_lives_on_S := fun (x0 y : T) (H0 : pwo_R WO x0 y \\\\/ In (e WO) x0 /\\\\ y = x) => match H0 with | or_introl H1 => conj (Union_introl T (e WO) (Singleton x) x0 (and_ind (fun (H2 : In (e WO) x0) (_ : In (e WO) y) => H2) (pwo_R_lives_on_S WO x0 y H1))) (Union_introl T (e WO) (Singleton x) y (and_ind (fun (_ : In (e WO) x0) (H4 : In (e WO) y) => H4) (pwo_R_lives_on_S WO x0 y H1))) | or_intror (conj H2 H3) => conj (Union_introl T (e WO) (Singleton x) x0 H2) (Union_intror T (e WO) (Singleton x) y (eq_ind_r (fun y0 : T => In (Singleton x) y0) (In_singleton T x) H3)) end; pwo_wo := {| wo_well_founded := fun a0 : {z : T | In (Add (e WO) x) z} => let (x0, i) as s return (Acc (restriction_relation (fun x0 y : T => pwo_R WO x0 y \\\\/ In (e WO) x0 /\\\\ y = x) (Add (e WO) x)) s) := a0 in match i as u in (Union _ _ y) return (Acc (restriction_relation (fun x1 y0 : T => pwo_R WO x1 y0 \\\\/ In (e WO) x1 /\\\\ y0 = x) (Add (e WO) x)) (exist (fun z : T => In (Add (e WO) x) z) y u)) with | Union_introl _ _ _ x1 i0 => eq_ind (Union_introl T (e WO) (Singleton x) x1 i0) (fun i1 : In (Add (e WO) x) x1 => Acc (restriction_relation (fun x2 y : T => pwo_R WO x2 y \\\\/ In (e WO) x2 /\\\\ y = x) (Add (e WO) x)) (exist (fun z : T => In (Add (e WO) x) z) x1 i1)) (Acc_ind (fun x2 : {z : T | In (e WO) z} => Acc (restriction_relation (fun x3 y : T => pwo_R WO x3 y \\\\/ In (e WO) x3 /\\\\ y = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig x2) (let (x3, i1) as s return (In (Add (e WO) x) (proj1_sig s)) := x2 in Union_introl T (e WO) (Singleton x) x3 i1))) (fun (x2 : {z : T | In (e WO) z}) (H1 : forall y : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y x2 -> Acc (restriction_relation (pwo_R WO) (e WO)) y) (H2 : forall y : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y x2 -> Acc (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (e WO) x3 /\\\\ y0 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig y) (let (x3, i1) as s return (In (Add (e WO) x) (proj1_sig s)) := y in Union_introl T (e WO) (Singleton x) x3 i1))) => Acc_intro (exist (In (Add (e WO) x)) (proj1_sig x2) (let (x3, i1) as s return (In (Add (e WO) x) (proj1_sig s)) := x2 in Union_introl T (e WO) (Singleton x) x3 i1)) (fun (y : {z : T | In (Add (e WO) x) z}) (H3 : restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (e WO) x3 /\\\\ y0 = x) (Add (e WO) x) y (exist (In (Add (e WO) x)) (proj1_sig x2) (let (x3, i1) as s return (In (Add (e WO) x) (proj1_sig s)) := x2 in Union_introl T (e WO) (Singleton x) x3 i1))) => (let (x3, i1) as s return ((forall y0 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y0 s -> Acc (restriction_relation (pwo_R WO) (e WO)) y0) -> (forall y0 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y0 s -> Acc (restriction_relation (fun x3 y1 : T => pwo_R WO x3 y1 \\\\/ In (e WO) x3 /\\\\ y1 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig y0) (let (x3, i1) as s0 return (In (Add (e WO) x) (proj1_sig s0)) := y0 in Union_introl T (e WO) (Singleton x) x3 i1))) -> restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (e WO) x3 /\\\\ y0 = x) (Add (e WO) x) y (exist (In (Add (e WO) x)) (proj1_sig s) (let (x3, i1) as s0 return (In (Add (e WO) x) (proj1_sig s0)) := s in Union_introl T (e WO) (Singleton x) x3 i1)) -> Acc (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (e WO) x3 /\\\\ y0 = x) (Add (e WO) x)) y) := x2 in fun (_ : forall y0 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y0 (exist (fun z : T => In (e WO) z) x3 i1) -> Acc (restriction_relation (pwo_R WO) (e WO)) y0) (H5 : forall y0 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y0 (exist (fun z : T => In (e WO) z) x3 i1) -> Acc (restriction_relation (fun x4 y1 : T => pwo_R WO x4 y1 \\\\/ In (e WO) x4 /\\\\ y1 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig y0) (let (x4, i2) as s return (In (Add (e WO) x) (proj1_sig s)) := y0 in Union_introl T (e WO) (Singleton x) x4 i2))) (H6 : restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (e WO) x4 /\\\\ y0 = x) (Add (e WO) x) y (exist (In (Add (e WO) x)) x3 (Union_introl T (e WO) (Singleton x) x3 i1))) => (let (x4, i2) as s return (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (e WO) x4 /\\\\ y0 = x) (Add (e WO) x) s (exist (In (Add (e WO) x)) x3 (Union_introl T (e WO) (Singleton x) x3 i1)) -> Acc (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (e WO) x4 /\\\\ y0 = x) (Add (e WO) x)) s) := y in fun H7 : restriction_relation (fun x5 y0 : T => pwo_R WO x5 y0 \\\\/ In (e WO) x5 /\\\\ y0 = x) (Add (e WO) x) (exist (fun z : T => In (Add (e WO) x) z) x4 i2) (exist (In (Add (e WO) x)) x3 (Union_introl T (e WO) (Singleton x) x3 i1)) => eq_ind_r (fun i3 : In (Add (e WO) x) x4 => restriction_relation (pwo_R WO) (e WO) (exist (In (e WO)) x4 match H7 with | or_introl H8 => and_ind (fun (H9 : In (e WO) x4) (_ : In (e WO) x3) => H9) (pwo_R_lives_on_S WO x4 x3 H8) | or_intror H8 => and_ind (fun (H9 : In (e WO) x4) (_ : x3 = x) => H9) H8 end) (exist (fun z : T => In (e WO) z) x3 i1) -> Acc (restriction_relation (fun x5 y0 : T => pwo_R WO x5 y0 \\\\/ In (e WO) x5 /\\\\ y0 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) x4 i3)) (H5 (exist (In (e WO)) x4 match H7 with | or_introl H8 => and_ind (fun (H9 : In (e WO) x4) (_ : In (e WO) x3) => H9) (pwo_R_lives_on_S WO x4 x3 H8) | or_intror H8 => and_ind (fun (H9 : In (e WO) x4) (_ : x3 = x) => H9) H8 end)) (proof_irrelevance (In (Add (e WO) x) x4) i2 (Union_introl T (e WO) (Singleton x) x4 match H7 with | or_introl H8 => and_ind (fun (H9 : In (e WO) x4) (_ : In (e WO) x3) => H9) (pwo_R_lives_on_S WO x4 x3 H8) | or_intror H8 => and_ind (fun (H9 : In (e WO) x4) (_ : x3 = x) => H9) H8 end)) match H7 with | or_introl H8 => H8 | or_intror (conj _ H10) => match ni (eq_ind x3 (fun a : T => In (e WO) a) i1 x H10) return (pwo_R WO x4 x3) with end end) H6) H1 H2 H3)) (wo_well_founded (pwo_wo WO) (exist (In (e WO)) x1 i0))) (Union_introl T (e WO) (Singleton x) x1 i0) (proof_irrelevance (In (Add (e WO) x) x1) (Union_introl T (e WO) (Singleton x) x1 i0) (Union_introl T (e WO) (Singleton x) x1 i0)) | Union_intror _ _ _ _ i0 => match i0 in (Singleton _ y) return (forall i1 : In (Singleton x) y, Acc (restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (e WO) x2 /\\\\ y0 = x) (Add (e WO) x)) (exist (fun z : T => In (Add (e WO) x) z) y (Union_intror T (e WO) (Singleton x) y i1))) with | In_singleton _ _ => fun i1 : In (Singleton x) x => Acc_intro (exist (fun z : T => In (Add (e WO) x) z) x (Union_intror T (e WO) (Singleton x) x i1)) (fun (y : {z : T | In (Add (e WO) x) z}) (H2 : restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (e WO) x2 /\\\\ y0 = x) (Add (e WO) x) y (exist (fun z : T => In (Add (e WO) x) z) x (Union_intror T (e WO) (Singleton x) x i1))) => (let (x2, i2) as s return (pwo_R WO (proj1_sig s) x \\\\/ In (e WO) (proj1_sig s) /\\\\ x = x -> Acc (restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (e WO) x2 /\\\\ y0 = x) (Add (e WO) x)) s) := y in fun H3 : pwo_R WO x2 x \\\\/ In (e WO) x2 /\\\\ x = x => match H3 with | or_introl H4 => match ni (and_ind (fun (_ : In (e WO) x2) (H5 : In (e WO) x) => H5) (pwo_R_lives_on_S WO x2 x H4)) return (Acc (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (e WO) x3 /\\\\ y0 = x) (Add (e WO) x)) (exist (fun z : T => In (Add (e WO) x) z) x2 i2)) with end | or_intror (conj H5 _) => eq_ind (Union_introl T (e WO) (Singleton x) x2 H5) (fun i3 : In (Add (e WO) x) x2 => Acc (restriction_relation (fun x3 y0 : T => pwo_R WO x3 y0 \\\\/ In (e WO) x3 /\\\\ y0 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) x2 i3)) (Acc_ind (fun x3 : {z : T | In (e WO) z} => Acc (restriction_relation (fun x4 y0 : T => pwo_R WO x4 y0 \\\\/ In (e WO) x4 /\\\\ y0 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig x3) (let (x4, i3) as s return (In (Add (e WO) x) (proj1_sig s)) := x3 in Union_introl T (e WO) (Singleton x) x4 i3))) (fun (x3 : {z : T | In (e WO) z}) (H1 : forall y0 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y0 x3 -> Acc (restriction_relation (pwo_R WO) (e WO)) y0) (H7 : forall y0 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y0 x3 -> Acc (restriction_relation (fun x4 y1 : T => pwo_R WO x4 y1 \\\\/ In (e WO) x4 /\\\\ y1 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig y0) (let (x4, i3) as s return (In (Add (e WO) x) (proj1_sig s)) := y0 in Union_introl T (e WO) (Singleton x) x4 i3))) => Acc_intro (exist (In (Add (e WO) x)) (proj1_sig x3) (let (x4, i3) as s return (In (Add (e WO) x) (proj1_sig s)) := x3 in Union_introl T (e WO) (Singleton x) x4 i3)) (fun (y0 : {z : T | In (Add (e WO) x) z}) (H8 : restriction_relation (fun x4 y1 : T => pwo_R WO x4 y1 \\\\/ In (e WO) x4 /\\\\ y1 = x) (Add (e WO) x) y0 (exist (In (Add (e WO) x)) (proj1_sig x3) (let (x4, i3) as s return (In (Add (e WO) x) (proj1_sig s)) := x3 in Union_introl T (e WO) (Singleton x) x4 i3))) => (let (x4, i3) as s return ((forall y1 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y1 s -> Acc (restriction_relation (pwo_R WO) (e WO)) y1) -> (forall y1 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y1 s -> Acc (restriction_relation (fun x4 y2 : T => pwo_R WO x4 y2 \\\\/ In (e WO) x4 /\\\\ y2 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig y1) (let (x4, i3) as s0 return (In (Add (e WO) x) (proj1_sig s0)) := y1 in Union_introl T (e WO) (Singleton x) x4 i3))) -> restriction_relation (fun x4 y1 : T => pwo_R WO x4 y1 \\\\/ In (e WO) x4 /\\\\ y1 = x) (Add (e WO) x) y0 (exist (In (Add (e WO) x)) (proj1_sig s) (let (x4, i3) as s0 return (In (Add (e WO) x) (proj1_sig s0)) := s in Union_introl T (e WO) (Singleton x) x4 i3)) -> Acc (restriction_relation (fun x4 y1 : T => pwo_R WO x4 y1 \\\\/ In (e WO) x4 /\\\\ y1 = x) (Add (e WO) x)) y0) := x3 in fun (_ : forall y1 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y1 (exist (fun z : T => In (e WO) z) x4 i3) -> Acc (restriction_relation (pwo_R WO) (e WO)) y1) (H10 : forall y1 : {z : T | In (e WO) z}, restriction_relation (pwo_R WO) (e WO) y1 (exist (fun z : T => In (e WO) z) x4 i3) -> Acc (restriction_relation (fun x5 y2 : T => pwo_R WO x5 y2 \\\\/ In (e WO) x5 /\\\\ y2 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) (proj1_sig y1) (let (x5, i4) as s return (In (Add (e WO) x) (proj1_sig s)) := y1 in Union_introl T (e WO) (Singleton x) x5 i4))) (H11 : restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (e WO) x5 /\\\\ y1 = x) (Add (e WO) x) y0 (exist (In (Add (e WO) x)) x4 (Union_introl T (e WO) (Singleton x) x4 i3))) => (let (x5, i4) as s return (restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (e WO) x5 /\\\\ y1 = x) (Add (e WO) x) s (exist (In (Add (e WO) x)) x4 (Union_introl T (e WO) (Singleton x) x4 i3)) -> Acc (restriction_relation (fun x5 y1 : T => pwo_R WO x5 y1 \\\\/ In (e WO) x5 /\\\\ y1 = x) (Add (e WO) x)) s) := y0 in fun H12 : restriction_relation (fun x6 y1 : T => pwo_R WO x6 y1 \\\\/ In (e WO) x6 /\\\\ y1 = x) (Add (e WO) x) (exist (fun z : T => In (Add (e WO) x) z) x5 i4) (exist (In (Add (e WO) x)) x4 (Union_introl T (e WO) (Singleton x) x4 i3)) => eq_ind_r (fun i5 : In (Add (e WO) x) x5 => restriction_relation (pwo_R WO) (e WO) (exist (In (e WO)) x5 match H12 with | or_introl H13 => and_ind (fun (H14 : In (e WO) x5) (_ : In (e WO) x4) => H14) (pwo_R_lives_on_S WO x5 x4 H13) | or_intror H13 => and_ind (fun (H14 : In (e WO) x5) (_ : x4 = x) => H14) H13 end) (exist (fun z : T => In (e WO) z) x4 i3) -> Acc (restriction_relation (fun x6 y1 : T => pwo_R WO x6 y1 \\\\/ In (e WO) x6 /\\\\ y1 = x) (Add (e WO) x)) (exist (In (Add (e WO) x)) x5 i5)) (H10 (exist (In (e WO)) x5 match H12 with | or_introl H13 => and_ind (fun (H14 : In (e WO) x5) (_ : In (e WO) x4) => H14) (pwo_R_lives_on_S WO x5 x4 H13) | or_intror H13 => and_ind (fun (H14 : In (e WO) x5) (_ : x4 = x) => H14) H13 end)) (proof_irrelevance (In (Add (e WO) x) x5) i4 (Union_introl T (e WO) (Singleton x) x5 match H12 with | or_introl H13 => and_ind (fun (H14 : In (e WO) x5) (_ : In (e WO) x4) => H14) (pwo_R_lives_on_S WO x5 x4 H13) | or_intror H13 => and_ind (fun (H14 : In (e WO) x5) (_ : x4 = x) => H14) H13 end)) match H12 with | or_introl H13 => H13 | or_intror (conj _ H15) => match ni (eq_ind x4 (fun a : T => In (e WO) a) i3 x H15) return (pwo_R WO x5 x4) with end end) H11) H1 H7 H8)) (wo_well_founded (pwo_wo WO) (exist (In (e WO)) x2 H5))) i2 (proof_irrelevance (In (Add (e WO) x) x2) (Union_introl T (e WO) (Singleton x) x2 H5) i2) end) H2) end i0 end; wo_total_strict_order := fun x0 y : {z : T | In (Add (e WO) x) z} => let (x1, i) as s return (restriction_relation (fun x1 y0 : T => pwo_R WO x1 y0 \\\\/ In (e WO) x1 /\\\\ y0 = x) (Add (e WO) x) s y \\\\/ s = y \\\\/ restriction_relation (fun x1 y0 : T => pwo_R WO x1 y0 \\\\/ In (e WO) x1 /\\\\ y0 = x) (Add (e WO) x) y s) := x0 in let (x2, i0) as s return (restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (e WO) x2 /\\\\ y0 = x) (Add (e WO) x) (exist (fun z : T => In (Add (e WO) x) z) x1 i) s \\\\/ exist (fun z : T => In (Add (e WO) x) z) x1 i = s \\\\/ restriction_relation (fun x2 y0 : T => pwo_R WO x2 y0 \\\\/ In (e WO) x2 /\\\\ y0 = x) (Add (e WO) x) s (exist (fun z : T => In (Add (e WO) x) z) x1 i)) := y in match i as u in (Union _ _ y0) return ((pwo_R WO y0 x2 \\\\/ In (e WO) y0 /\\\\ x2 = x) \\\\/ exist (fun z : T => In (Add (e WO) x) z) y0 u = exist (fun z : T => In (Add (e WO) x) z) x2 i0 \\\\/ pwo_R WO x2 y0 \\\\/ In (e WO) x2 /\\\\ y0 = x) with | Union_introl _ _ _ x3 x4 => match i0 as u in (Union _ _ y0) return (forall (x5 : T) (i1 : In (e WO) x5), (pwo_R WO x5 y0 \\\\/ In (e WO) x5 /\\\\ y0 = x) \\\\/ exist (fun z : T => In (Add (e WO) x) z) x5 (Union_introl T (e WO) (Singleton x) x5 i1) = exist (fun z : T => In (Add (e WO) x) z) y0 u \\\\/ pwo_R WO y0 x5 \\\\/ In (e WO) y0 /\\\\ x5 = x) with | Union_introl _ _ _ x5 i1 => fun (x6 : T) (i2 : In (e WO) x6) => match wo_total_strict_order (pwo_wo WO) (exist (In (e WO)) x6 i2) (exist (In (e WO)) x5 i1) with | or_introl H0 => or_introl (or_introl H0) | or_intror (or_introl H1) => or_intror (or_introl (subset_eq_compat T (fun z : T => In (Add (e WO) x) z) x6 x5 (Union_introl T (e WO) (Singleton x) x6 i2) (Union_introl T (e WO) (Singleton x) x5 i1) (f_equal (fun e0 : {z : T | In (e WO) z} => let (x, _) := e0 in x) H1))) | or_intror (or_intror H1) => or_intror (or_intror (or_introl H1)) end | Union_intror _ _ _ x5 i1 => fun (x6 : T) (i2 : In (e WO) x6) => or_introl match i1 in (Singleton _ y0) return (pwo_R WO x6 y0 \\\\/ In (e WO) x6 /\\\\ y0 = x) with | In_singleton _ _ => or_intror (conj i2 eq_refl) end end x3 x4 | Union_intror _ _ _ x3 x4 => match i0 as u in (Union _ _ y0) return (forall (x5 : T) (i1 : In (Singleton x) x5), (pwo_R WO x5 y0 \\\\/ In (e WO) x5 /\\\\ y0 = x) \\\\/ exist (fun z : T => In (Add (e WO) x) z) x5 (Union_intror T (e WO) (Singleton x) x5 i1) = exist (fun z : T => In (Add (e WO) x) z) y0 u \\\\/ pwo_R WO y0 x5 \\\\/ In (e WO) y0 /\\\\ x5 = x) with | Union_introl _ _ _ x5 i1 => fun (x6 : T) (i2 : In (Singleton x) x6) => or_intror (or_intror match i2 in (Singleton _ y0) return (pwo_R WO x5 y0 \\\\/ In (e WO) x5 /\\\\ y0 = x) with | In_singleton _ _ => or_intror (conj i1 eq_refl) end) | Union_intror _ _ _ x5 i1 => fun (x6 : T) (i2 : In (Singleton x) x6) => or_intror (or_introl (subset_eq_compat T (fun z : T => In (Add (e WO) x) z) x6 x5 (Union_intror T (e WO) (Singleton x) x6 i2) (Union_intror T (e WO) (Singleton x) x5 i1) match i1 in (Singleton _ y0) return (x6 = y0) with | In_singleton _ _ => match i2 in (Singleton _ y0) return (y0 = x) with | In_singleton _ _ => eq_refl end end)) end x3 x4 end |} |})\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-"], "tactic": "intros y z Hy Hz.", "exn": "y is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-"], "tactic": "intros y' z Hy Hz.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+"], "tactic": "destruct (classic (In (pwo_S WO) z)) as [z_in_WO | z_not_in_WO].", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind."], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++"], "tactic": "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "exn": "Found no subterm matching \"pwo_R WO ?t ?t0\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal."], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind."], "tactic": "+", "exn": "Wrong bullet +: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++"], "tactic": "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "exn": "Found no subterm matching \"pwo_R WO ?t ?t0\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction."], "tactic": "++", "exn": "Wrong bullet ++: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set."], "tactic": "-", "exn": "Wrong bullet -: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++"], "tactic": "intros y z Hy Hz Hzy.", "exn": "y is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++"], "tactic": "intros y' z Hy Hz Hzy.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+"], "tactic": "destruct (classic (In (pwo_S WO) z)) as [z_in_WO | z_not_in_WO].", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*"], "tactic": "apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "exn": "Unable to find an instance for the variable y.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction.", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction.", "shelve.", "*"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction.", "shelve.", "*", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction.", "shelve.", "*", "shelve.", "+"], "tactic": "apply In_Empty_set.", "exn": "The reference In_Empty_set was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction.", "shelve.", "*", "shelve.", "+", "apply Powerset.Empty_set_minimal."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros WO x ni.", "unfold extend_strictly_partial_WO.", "constructor; intros.", "-", "qsimpl time: 1 use: pwo_S,S.", "apply Powerset.Empty_set_minimal.", "qsimpl time: 1 use: pwo_S,S.", "shelve.", "-", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "shelve.", "*", "apply Powerset.Empty_set_minimal.", "apply Powerset.Power_set_PO.", "--", "shelve.", "--", "shelve.", "+", "rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).", "++", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "apply Empty_set_ind.", "shelve.", "++", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_restriction.", "-", "apply Powerset.Power_set_PO.", "++", "apply Empty_set.", "++", "destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].", "+", "destruct (classic (In (pwo_S WO) x0)) as [x0_in_WO | x0_not_in_WO].", "*", "qsimpl time: 1 use: pwo_S,S,extend_strictly_partial_WO,pwo_downward_closed,pwo_restriction.", "shelve.", "*", "shelve.", "+", "apply Powerset.Empty_set_minimal.", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nT: Type\n\nGoal:\nforall (WO : partial_WO) (x : T) (ni : ~ In (pwo_S WO) x), partial_WO_ord WO (extend_strictly_partial_WO WO x ni)\n\nPremises:\nRecord partial_WO : Type := Build_partial_WO { pwo_S : Ensemble T; pwo_R : relation T; pwo_R_lives_on_S : forall x y : T, pwo_R x y -> In pwo_S x /\\ In pwo_S y; pwo_wo : well_order (restriction_relation pwo_R pwo_S) } Arguments Build_partial_WO _ _ _%function_scope\nextend_strictly_partial_WO : forall (WO : partial_WO) (a : T), ~ In (pwo_S WO) a -> partial_WO\nRecord partial_WO_ord (WO1 WO2 : partial_WO) : Prop := Build_partial_WO_ord { pwo_S_incl : Included (pwo_S WO1) (pwo_S WO2); pwo_restriction : forall x y : T, In (pwo_S WO1) x -> In (pwo_S WO1) y -> pwo_R WO1 x y <-> pwo_R WO2 x y; pwo_downward_closed : forall x y : T, In (pwo_S WO1) y -> In (pwo_S WO2) x -> pwo_R WO2 x y -> In (pwo_S WO1) x } Arguments Build_partial_WO_ord _ _ _ (_ _)%function_scope\npwo_S = fun p : partial_WO => let (pwo_S, pwo_R, _, _) := p in pwo_S : partial_WO -> Ensemble T\nIn = fun (U : Type) (A : Ensemble U) (x : U) => A x : forall U : Type, Ensemble U -> U -> Prop Arguments In {U}%type_scope\npartial_WO_chain_ub_correct : forall (C : Ensemble partial_WO) (c : chain partial_WO_ord C) (WO : partial_WO), In C WO -> partial_WO_ord WO (partial_WO_chain_ub C c)\npwo_R_lives_on_S : forall (p : partial_WO) (x y : T), pwo_R p x y -> In (pwo_S p) x /\\ In (pwo_S p) y\npwo_downward_closed : forall WO1 WO2 : partial_WO, partial_WO_ord WO1 WO2 -> forall x y : T, In (pwo_S WO1) y -> In (pwo_S WO2) x -> pwo_R WO2 x y -> In (pwo_S WO1) x\npwo_restriction : forall WO1 WO2 : partial_WO, partial_WO_ord WO1 WO2 -> forall x y : T, In (pwo_S WO1) x -> In (pwo_S WO1) y -> pwo_R WO1 x y < -> pwo_R WO2 x y\nBuild_partial_WO_ord : forall WO1 WO2 : partial_WO, Included (pwo_S WO1) (pwo_S WO2) -> (forall x y : T, In (pwo_S WO1) x -> In (pwo_S WO1) y -> pwo_R WO1 x y <-> pwo_R WO2 x y) -> (forall x y : T, In (pwo_S WO1) y -> In (pwo_S WO2) x -> pwo_R WO2 x y -> In (pwo_S WO1) x) -> partial_WO_ord WO1 WO2\npwo_S_incl : forall WO1 WO2 : partial_WO, partial_WO_ord WO1 WO2 -> Included (pwo_S WO1) (pwo_S WO2)\nBuild_partial_WO : forall (pwo_S : Ensemble T) (pwo_R : relation T), (forall x y : T, pwo_R x y -> In pwo_S x /\\ In pwo_S y) -> well_order (restriction_relation pwo_R pwo_S) -> partial_WO\nFamilies.family_union_intro : forall (T : Type) (F : Families.Family T) (S : Ensemble T) (x : T), In F S -> In S x -> In (Families.FamilyUnion F) x\nConstructive_sets.Noone_in_empty : forall (U : Type) (x : U), ~ In Empty_set x\nIndexedFamilies.indexed_union_intro : forall (A T : Type) (F : IndexedFamilies.IndexedFamily A T) (a : A) (x : T), In (F a) x -> In (IndexedFamilies.IndexedUnion F) x\nConstructive_sets.Setminus_intro : forall (U : Type) (A B : Ensemble U) (x : U), In A x -> ~ In B x -> In (Setminus A B) x\nInductive FamilyUnion (T : Type) (F : Families.Family T) : Ensemble T := family_union_intro : forall (S : Ensemble T) (x : T), In F S -> In S x -> In (Families.FamilyUnion F) x Arguments Families.FamilyUnion [T]%type_scope Arguments Families.family_union_intro [T]%type_scope\nPowerset_Classical_facts.Simplify_add : forall (U : Type) (X X0 : Ensemble U) (x : U), ~ In X x -> ~ In X0 x -> Add X x = Add X0 x -> X = X0\nPowerset_facts.Non_disjoint_union' : forall (U : Type) (X : Ensemble U) (x : U), ~ In X x -> Subtract X x = X\nFamilies.FamilyUnion_sind : forall (T : Type) (F : Families.Family T) (P : T -> SProp), (forall (S : Ensemble T) (x : T), In F S -> In S x -> P x) -> forall t : T, Families.FamilyUnion F t -> P t\nFamilies.FamilyUnion_ind : forall (T : Type) (F : Families.Family T) (P : T -> Prop), (forall (S : Ensemble T) (x : T), In F S -> In S x -> P x) -> forall t : T, Families.FamilyUnion F t -> P t\nFamilies.family_intersection_intro : forall (T : Type) (F : Families.Family T) (x : T), (forall S : Ensemble T, In F S -> In S x) -> In (Families.FamilyIntersection F) x\nIndexedFamilies.indexed_intersection_intro : forall (A T : Type) (F : IndexedFamilies.IndexedFamily A T) (x : T), (forall a : A, In (F a) x) -> In (IndexedFamilies.IndexedIntersection F) x\nPowerset_Classical_facts.Sub_Add_new : forall (U : Type) (X : Ensemble U) (x : U), ~ In X x -> X = Subtract (Add X x) x\nchain = fun (T : Type) (R : relation T) (S : Ensemble T) => forall x y : T, In S x -> In S y -> R x y \\/ R y x : forall T : Type, relation T -> Ensemble T -> Prop Arguments chain {T}%type_scope\nPowerset_Classical_facts.incl_soustr_add_r : forall (U : Type) (X : Ensemble U) (x : U), ~ In X x -> Included X (Subtract (Add X x) x)\nInductive IndexedUnion (A T : Type) (F : IndexedFamilies.IndexedFamily A T) : Ensemble T := indexed_union_intro : forall (a : A) (x : T), In (F a) x -> In (IndexedFamilies.IndexedUnion F) x Arguments IndexedFamilies.IndexedUnion [A T]%type_scope Arguments IndexedFamilies.indexed_union_intro [A T]%type_scope\npremaximal = fun (T : Type) (R : relation T) (x : T) => forall y : T, R x y -> R y x : forall T : Type, relation T -> T -> Prop Arguments premaximal {T}%type_scope\nmaximal = fun (T : Type) (R : relation T) (x : T) => forall y : T, R x y -> x = y : forall T : Type, relation T -> T -> Prop Arguments maximal {T}%type_scope\nSetminus = fun (U : Type) (B C : Ensemble U) (x : U) => In B x /\\ ~ In C x : forall U : Type, Ensemble U -> Ensemble U -> Ensemble U Arguments Setminus {U}%type_scope"}, {"role": "assistant", "content": "```coq\nintros WO x ni.\nunfold extend_strictly_partial_WO.\nconstructor; intros.\n- apply Families.family_union_intro with (S := pwo_S WO).\n  + apply In_Empty_set.\n  + apply ni.\n- intros y z Hy Hz.\n  destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].\n  + destruct (classic (In (pwo_S WO) z)) as [z_in_WO | z_not_in_WO].\n    * rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n      ++ assumption.\n      ++ apply In_Empty_set.\n      ++ apply In_Empty_set.\n    * rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n      ++ assumption.\n      ++ apply In_Empty_set.\n      ++ apply In_Empty_set.\n  + rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n    ++ assumption.\n    ++ apply In_Empty_set.\n    ++ apply In_Empty_set.\n  + rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n    ++ assumption.\n    ++ apply In_Empty_set.\n    ++ apply In_Empty_set.\n- intros y z Hy Hz Hzy.\n  destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO].\n  + destruct (classic (In (pwo_S WO) z)) as [z_in_WO | z_not_in_WO].\n    * apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n      ++ assumption.\n      ++ apply In_Empty_set.\n      ++ assumption.\n    * apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n      ++ assumption.\n      ++ apply In_Empty_set.\n      ++ assumption.\n  + apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n    ++ assumption.\n    ++ apply In_Empty_set.\n    ++ assumption.\n  + apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni).\n    ++ assumption.\n    ++ apply In_Empty_set.\n    ++ assumption.\nQed.```"}], "original": "intros WO x ni. unfold extend_strictly_partial_WO. constructor; intros. - apply Families.family_union_intro with (S := pwo_S WO). + apply In_Empty_set. + apply ni. - intros y z Hy Hz. destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO]. + destruct (classic (In (pwo_S WO) z)) as [z_in_WO | z_not_in_WO]. * rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ apply In_Empty_set. * rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ apply In_Empty_set. + rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ apply In_Empty_set. + rewrite pwo_restriction with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ apply In_Empty_set. - intros y z Hy Hz Hzy. destruct (classic (In (pwo_S WO) y)) as [y_in_WO | y_not_in_WO]. + destruct (classic (In (pwo_S WO) z)) as [z_in_WO | z_not_in_WO]. * apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ auto. * apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ auto. + apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ auto. + apply pwo_downward_closed with (WO1 := WO) (WO2 := extend_strictly_partial_WO WO x ni). ++ auto. ++ apply In_Empty_set. ++ auto.", "succ": false}]