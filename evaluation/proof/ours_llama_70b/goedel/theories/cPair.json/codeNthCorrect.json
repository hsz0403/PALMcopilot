[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n l.", "induction l.", "-", "simpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n l.", "induction l.", "-", "simpl.", "shelve.", "-", "simpl."], "tactic": "rewrite IHl.", "exn": "Found no subterm matching \"codeNth n (codeList l)\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\ndrop: nat -> list nat -> list nat\n\nGoal:\nforall (n : nat) (l : list nat), codeNth n (codeList l) = nth n l 0\n\nPremises:\ncodeList = fix codeList (l : list nat) : nat := match l with | nil => 0 | n :: l' => S (cPair n (codeList l')) end : list nat -> nat Arguments codeList _%list_scope\nnth : forall A : Type, nat -> list A -> A -> A\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\ncodeNth = fun n m : nat => let H := nat_rec (fun _ : nat => nat) m (fun _ Hrecn : nat => cPairPi2 (Init.Nat.pred Hrecn)) n in cPairPi1 (Init.Nat.pred H) : nat -> nat -> nat Arguments codeNth (_ _)%nat_scope\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\napp_nth2 : forall (A : Type) (l l' : list A) (d : A) (n : nat), n >= length l -> nth n (l ++ l') d = nth (n - length l) l' d\nrev_nth : forall (A : Type) (l : list A) (d : A) (n : nat), n < length l -> nth n (rev l) d = nth (length l - S n) l d\nFin.L_R : forall n : nat, Fin.t ?m -> Fin.t (n + ?m) where ?m : [drop := fun n : nat => nat_rec (fun _ : nat => list nat -> list nat) (fun l : list nat => l) (fun (_ : nat) (Hrecn : list nat -> list nat) (l : list nat) => Hrecn match l with | nil => nil | _ :: l0 => l0 end) n : nat -> list nat -> list nat |- nat]\nmap_nth : forall (A B : Type) (f : A -> B) (l : list A) (d : A) (n : nat), nth n (map f l) (f d) = f (nth n l d)\napp_nth1 : forall (A : Type) (l l' : list A) (d : A) (n : nat), n < length l -> nth n (l ++ l') d = nth n l d\nnth_error_app2 : forall (A : Type) (l l' : list A) (n : nat), length l <= n -> nth_error (l ++ l') n = nth_error l' (n - length l)\nnth_indep : forall (A : Type) (l : list A) (n : nat) (d d' : A), n < length l -> nth n l d = nth n l d'\nnth_overflow : forall (A : Type) (l : list A) (n : nat) (d : A), length l <= n -> nth n l d = d\nnth_error_nth : forall (A : Type) (l : list A) (n : nat) (x d : A), nth_error l n = Some x -> nth n l d = x\ncombine_nth : forall (A B : Type) (l : list A) (l' : list B) (n : nat) (x : A) (y : B), length l = length l' -> nth n (combine l l') (x, y) = (nth n l x, nth n l' y)\nInit.Nat.sub = fix sub (n m : nat) {struct n} : nat := match n with | 0 => n | S k => match m with | 0 => n | S l => sub k l end end : nat -> nat -> nat Arguments Init.Nat.sub (_ _)%nat_scope\nnth_split : forall (A : Type) (n : nat) (l : list A) (d : A), n < length l -> exists l1 l2 : list A, l = l1 ++ nth n l d :: l2 /\\ length l1 = n\nnth_S_cons : forall (A : Type) (n : nat) (l : list A) (d a : A), In (nth n l d) l -> In (nth (S n) (a :: l) d) (a :: l)\nnth_default_eq : forall (A : Type) (n : nat) (l : list A) (d : A), nth_default d l n = nth n l d\nInit.Nat.mul = fix mul (n m : nat) {struct n} : nat := match n with | 0 => 0 | S p => m + mul p m end : nat -> nat -> nat Arguments Init.Nat.mul (_ _)%nat_scope\niterate = fun g : nat -> nat => nat_rec (fun _ : nat => nat -> nat) (fun x : nat => x) (fun (_ : nat) (rec : nat -> nat) (x : nat) => g (rec x)) : (nat -> nat) -> forall n : nat, (fun _ : nat => nat -> nat) n Arguments iterate _%function_scope (_ _)%nat_scope\nInit.Nat.add = fix add (n m : nat) {struct n} : nat := match n with | 0 => m | S p => S (add p m) end : nat -> nat -> nat Arguments Init.Nat.add (_ _)%nat_scope\nnaryRel = fix naryRel (n : nat) : Set := match n with | 0 => bool | S n0 => nat -> naryRel n0 end : nat -> Set Arguments naryRel _%nat_scope\nexistsb_nth : forall (A : Type) (f : A -> bool) (l : list A) (n : nat) (d : A), n < length l -> existsb f l = false -> f (nth n l d) = false\nnth_error_nth' : forall (A : Type) (l : list A) (n : nat) (d : A), n < length l -> nth_error l n = Some (nth n l d)\nnth_In : forall (A : Type) (n : nat) (l : list A) (d : A), n < length l -> In (nth n l d) l\nsplit_nth : forall (A B : Type) (l : list (A * B)) (n : nat) (d : A * B), nth n l d = (nth n (fst (split l)) (fst d), nth n (snd (split l)) (snd d))\nseq = fix seq (start len : nat) {struct len} : list nat := match len with | 0 => nil | S len0 => start :: seq (S start) len0 end : nat -> nat -> list nat Arguments seq (_ _)%nat_scope\nnth_error_split : forall (A : Type) (l : list A) (n : nat) (a : A), nth_error l n = Some a -> exists l1 l2 : list A, l = l1 ++ a :: l2 /\\ length l1 = n\nsumToN = fun n : nat => nat_rec (fun _ : nat => nat) 0 (fun x y : nat => S x + y) n : forall n : nat, (fun _ : nat => nat) n Arguments sumToN _%nat_scope"}, {"role": "assistant", "content": "```coq\nintros n l.\ninduction l.\n- simpl. auto.\n- simpl. rewrite IHl. auto.\nQed.\n```"}], "original": "intros n l. induction l. - simpl. auto. - simpl. rewrite IHl. auto.", "succ": false}]