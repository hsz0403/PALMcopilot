[{"history": {"proof": "intros Phi. unfold derivable_closed. srun best use: @derivable_falsep_elim unfold: truep, falsep. qsimpl time: 1 use: derivable_finite_witnessed. qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed. qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed. qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed.", "repairs": ["", "", "hammer", "wrong_type", "cannot_unify", "not_inductive_product", "cannot_unify"], "exceptions": [{"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc."], "tactic": "specialize (derivable_finite_witnessed Phi TT Hdc) as [xs [Hforall Himp]].", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP Phi : context Hdc : forall x : expr, Phi |-- x -> Phi x The term \"Hdc\" has type \"forall x : expr, Phi |-- x -> Phi x\" while it is expected to have type \"Phi |-- TT\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed."], "tactic": "assert (Himp' : Phi |-- fold_left prodp xs TT).", "exn": "The reference xs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed."], "tactic": "eapply derivable_provable.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP Phi : context Hdc : forall x : expr, Phi |-- x -> Phi x H : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y Unable to unify \"(?M2598 |-- ?M2599 -> exists xs : list expr, Forall (fun x : expr => ?M2598 x) xs /\\\\ |-- multi_imp xs ?M2599) /\\\\ ((exists xs : list expr, Forall (fun x : expr => ?M2598 x) xs /\\\\ |-- multi_imp xs ?M2599) -> ?M2598 |-- ?M2599)\" with \"Phi TT\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed."], "tactic": "exists xs.", "exn": "The reference xs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed."], "tactic": "split; eauto.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed."], "tactic": "eapply ProofTheoryPatterns.adjoint with (x := fold_left prodp xs TT) (y := TT) (z := TT).", "exn": "The reference xs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed."], "tactic": "eapply ProofTheoryPatterns.left_distr1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP Phi : context Hdc : forall x : expr, Phi |-- x -> Phi x H : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y H0 : forall (Phi : context) (y : expr), (Phi |-- y -> exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) /\\\\ ((exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) -> Phi |-- y) H3 : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y H2 : forall (Phi : context) (y : expr), (Phi |-- y -> exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) /\\\\ ((exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) -> Phi |-- y) Unable to unify \"(let (provable) := ?Gamma in provable) (?prodp ?M4288 (?sump ?M4289 ?M4290) --> ?sump (?prodp ?M4288 ?M4289) (?prodp ?M4288 ?M4290))\" with \"Phi TT\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi.", "unfold derivable_closed.", "intros Hdc.", "qsimpl time: 1 use: derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed.", "qsimpl time: 1 use: derivable_provable,derivable_finite_witnessed."], "tactic": "eapply ProofTheoryPatterns.prodp_mono.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP Phi : context Hdc : forall x : expr, Phi |-- x -> Phi x H : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y H0 : forall (Phi : context) (y : expr), (Phi |-- y -> exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) /\\\\ ((exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) -> Phi |-- y) H4 : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y H1 : forall (Phi : context) (y : expr), (Phi |-- y -> exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) /\\\\ ((exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\\\ |-- multi_imp xs y) -> Phi |-- y) Unable to unify \"(let (provable) := ?Gamma in provable) (?prodp ?M5170 ?M5171 --> ?prodp ?M5172 ?M5173)\" with \"Phi TT\".", "type": "cannot_unify", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nL: Language\nminL: MinimumLanguage L\npL: PropositionalLanguage L\nGammaP: Provable L\nGammaD: Derivable L\nSC: NormalSequentCalculus L GammaP GammaD\nbSC: BasicSequentCalculus L GammaD\nminSC: MinimumSequentCalculus L GammaD\nipSC: IntuitionisticPropositionalSequentCalculus L GammaD\nminAX: MinimumAxiomatization L GammaP\nipAX: IntuitionisticPropositionalLogic L GammaP\n\nGoal:\nforall Phi : context, derivable_closed Phi -> Phi TT\n\nPremises:\nderivable_closed = fun (L : Language) (Gamma : Derivable L) (Phi : context) => forall x : expr, Phi |-- x -> Phi x : forall L : Language, Derivable L -> context -> Prop Arguments L, Gamma are implicit and maximally inserted\nMinimumSequentCalculus : forall L : Language, MinimumLanguage L -> Derivable L -> Prop\nMinimumAxiomatization : forall L : Language, MinimumLanguage L -> Provable L -> Prop\nRecord Provable (L : Language) : Type := Build_Provable { provable : expr -> Prop } For Build_Provable: Argument scopes are [_ function_scope]\ncontext = fun L : Language => expr -> Prop : Language -> Type Argument L is implicit and maximally inserted\nRecord PropositionalLanguage (L : Language) : Type := Build_PropositionalLanguage { andp : expr -> expr -> expr; orp : expr -> expr -> expr; falsep : expr } For Build_PropositionalLanguage: Argument scopes are [_ function_scope function_scope _]\nRecord Derivable (L : Language) : Type := Build_Derivable { derivable : context -> expr -> Prop } For Build_Derivable: Argument scopes are [_ function_scope]\nIntuitionisticPropositionalLogic : forall (L : Language) (minL : MinimumLanguage L), PropositionalLanguage L -> forall Gamma : Provable L, MinimumAxiomatization L Gamma -> Prop\nBasicSequentCalculus : forall L : Language, Derivable L -> Prop\nIntuitionisticPropositionalSequentCalculus : forall L : Language, PropositionalLanguage L -> Derivable L -> Prop\nRecord MinimumLanguage (L : Language) : Type := Build_MinimumLanguage { impp : expr -> expr -> expr } For Build_MinimumLanguage: Argument scopes are [_ function_scope]\nNormalSequentCalculus : forall L : Language, Provable L -> Derivable L -> Prop\nRewriteClass.TestInAxiomatization.Unnamed_thm0 : forall (Phi : context) (x1 y1 x2 y2 : expr), |-- x2 --> x1 -> |-- y1 --> y2 -> Phi |-- x1 --> y1 -> Phi |-- x2 --> y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequent...\nderivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\ (fun x : expr => In x xs) |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L Gamma...\nRewriteClass.TestInAxiomatization.Unnamed_thm : forall (Phi : context) (y1 y2 : expr), |-- y1 --> y2 -> Phi |-- y1 -> Phi |-- y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD...\nderivable_closed_element_derivable : forall Phi : context, derivable_closed Phi -> forall x : expr, Phi x < -> Phi |-- x\ncontextual_derivable_finite_witnessed : forall (Phi Psi : context) (y : expr), Union expr Phi Psi |-- y -> exists xs : list expr, Forall Psi xs /\\ Union expr Phi (fun x : expr => In x xs) |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD b...\nderivable_provable : forall (Phi : context) (y : expr), Phi |-- y <-> (exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\ |-- multi_imp xs y) where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L...\nProofTheoryPatterns.funcp_mono : forall x1 y1 x2 y2 : expr, |-- x2 --> x1 -> |-- y1 --> y2 -> |-- ?funcp x1 y1 --> ?funcp x2 y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequent...\nProofTheoryPatterns.prodp_mono1 : forall x1 x2 y : expr, |-- x1 - -> x2 -> |-- ?prodp x1 y - ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nProofTheoryPatterns.funcp_mono2 : forall x y1 y2 : expr, |-- y1 - -> y2 -> |-- ?funcp x y1 - ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nfalsep_prodp : forall x : expr, |-- ?prodp FF x <- ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nprodp_falsep : forall x : expr, |-- ?prodp x FF <--> FF where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L...\nprodp_iffp : forall x1 x2 y1 y2 : expr, |-- x1 <- -> x2 -> |-- y1 <- -> y2 -> |-- ?prodp x1 y1 <- ->...-> expr] ?Mono : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nprodp_orp_distr_l : forall x y z : expr, |-- ?prodp (x || y) z <- ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nprodp_sump_distr_l : forall x y z : expr, |-- ?prodp x (?sump y z) <- ->...-> expr] ?LDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftDistr ?L ?Gamma ?prodp ?sump]\nprodp_sump_distr_r : forall x y z : expr, |-- ?prodp (?sump y z) x <- ->...-> expr] ?RDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.RightDistr ?L ?Gamma ?prodp ?sump]\nfuncp_andp_distr_r : forall x y z : expr, |-- ?funcp x (y && z) <- ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\norp_funcp : forall x y z : expr, |-- ?funcp (x || y) z <--> ?funcp x z && ?funcp y z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L Gamma...\nprodp_orp_distr_r : forall x y z : expr, |-- ?prodp x (y || z) <--> ?prodp x y || ?prodp x z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequent...\nProofTheoryPatterns.adjoint : forall x y z : expr, |-- ?prodp x y - -> z < -> |-- x - ->...-> expr] ?Adjointness : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Adjointness ?L ?Gamma ?prodp ?funcp]\nProofTheoryPatterns.left_distr2 : forall x y z : expr, |-- ?sump (?prodp x y) (?prodp x z) - ->...-> expr] ?LeftDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.right_distr1 : forall x y z : expr, |-- ?prodp (?sump y z) x - ->...-> expr] ?RightDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.RightDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.right_distr2 : forall x y z : expr, |-- ?sump (?prodp y x) (?prodp z x) - ->...-> expr] ?RightDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.RightDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.left_distr1 : forall x y z : expr, |-- ?prodp x (?sump y z) - ->...-> expr] ?LeftDistr : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.LeftDistr ?L ?Gamma ?prodp ?sump]\nProofTheoryPatterns.prodp_mono : forall x1 y1 x2 y2 : expr, |-- x1 - -> x2 -> |-- y1 - -> y2 -> |-- ?prodp x1 y1 - ->...-> expr] ?Monotonicity : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]\nfold_left_iffp : forall (x1 x2 : expr) (xs1 xs2 : list expr), Forall2 (fun x3 x4 : expr => |-- x3 <--> x4) xs1 xs2 -> |-- x1 <- -> x2 -> |-- fold_left ?prodp xs1 x1 <- ->...-> expr] ?Mono : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP |- ProofTheoryPatterns.Monotonicity ?L ?Gamma ?prodp]"}, {"role": "assistant", "content": "```coq\nintros Phi.\nunfold derivable_closed.\nintros Hdc.\nspecialize (derivable_finite_witnessed Phi TT Hdc) as [xs [Hforall Himp]].\nassert (Himp' : Phi |-- fold_left prodp xs TT).\n{ eapply derivable_provable.\n  exists xs.\n  split; eauto. }\neapply ProofTheoryPatterns.adjoint with (x := fold_left prodp xs TT) (y := TT) (z := TT).\neauto.\neapply ProofTheoryPatterns.left_distr1.\neauto.\neapply ProofTheoryPatterns.prodp_mono.\neauto.\neauto.\nQed."}], "original": "intros Phi. unfold derivable_closed. intros Hdc. specialize (derivable_finite_witnessed Phi TT Hdc) as [xs [Hforall Himp]]. assert (Himp' : Phi |-- fold_left prodp xs TT). { eapply derivable_provable. exists xs. split; eauto. } eapply ProofTheoryPatterns.adjoint with (x := fold_left prodp xs TT) (y := TT) (z := TT). eauto. eapply ProofTheoryPatterns.left_distr1. eauto. eapply ProofTheoryPatterns.prodp_mono. eauto. eauto.", "succ": true}]