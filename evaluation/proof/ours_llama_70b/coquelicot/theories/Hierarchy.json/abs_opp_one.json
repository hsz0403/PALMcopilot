[{"history": {"proof": "apply AbsRing.ax2.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nK: AbsRing\n\nGoal:\nabs (opp one) = 1\n\nPremises:\none = fun K : Ring => Ring.one (AbelianGroup.Pack K (Ring.class K) K) (Ring.class K) : forall K : Ring, K Argument K is implicit and maximally inserted\nabs = AbsRing.abs (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : K -> R\nopp = fun G : AbelianGroup => AbelianGroup.opp G (AbelianGroup.class G) : forall G : AbelianGroup, G -> G Argument G is implicit and maximally inserted\nAbsRing.Mixin : forall (K : Ring) (abs : K -> R), abs zero = 0 -> abs (opp one) = 1 -> (forall x y : K, abs (plus x y) <= abs x + abs y) -> (forall x y : K, abs (mult x y) <= abs x * abs y) -> (forall x : K, abs x = 0 -> x = zero) -> AbsRing.mixin_of K\nRecord mixin_of (K : Ring) : Type := Mixin { abs : K -> R; ax1 : abs zero = 0; ax2 : abs (opp one) = 1; ax3 : forall x y : K, abs (plus x y) <= abs x + abs y; ax4 : forall x y : K, abs (mult x y) <= abs x * abs y; ax5 : forall x : K, abs x = 0 -> x = zero } For Mixin: Argument scopes are [_ function_scope _ _ function_scope function_scope function_scope]\nAbsRing.ax2 : forall (K : Ring) (m : AbsRing.mixin_of K), AbsRing.abs K m (opp one) = 1\nopp_mult_m1 : forall x : ?K, opp x = mult (opp one) x where ?K : [K : AbsRing |- Ring]\nabs_zero = AbsRing.ax1 (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : abs zero = 0\nopp_zero = fun G : AbelianGroup => eq_ind (plus (opp zero) zero) (fun s : G => s = zero) (plus_opp_l zero) (opp zero) (plus_zero_r (opp zero)) : forall G : AbelianGroup, opp zero = zero Argument G is implicit and maximally inserted\nopp_plus : forall x y : ?G, opp (plus x y) = plus (opp x) (opp y) where ?G : [K : AbsRing |- AbelianGroup]\nopp_opp : forall x : ?G, opp (opp x) = x where ?G : [K : AbsRing |- AbelianGroup]\nplus_opp_r : forall x : ?G, plus x (opp x) = zero where ?G : [K : AbsRing |- AbelianGroup]\nplus_opp_l : forall x : ?G, plus (opp x) x = zero where ?G : [K : AbsRing |- AbelianGroup]\nRlt_0_1 = let H : 1\u00b2 = 1 := Rmult_1_r 1 in eq_ind 1\u00b2 (fun r : R => 0 < r) (Rlt_0_sqr 1 (fun H0 : 1 = 0 => R1_neq_R0 H0)) 1 H : 0 < 1\nopp_mult_r : forall x y : ?K, opp (mult x y) = mult x (opp y) where ?K : [K : AbsRing |- Ring]\nopp_mult_l : forall x y : ?K, opp (mult x y) = mult (opp x) y where ?K : [K : AbsRing |- Ring]\nRMicromega.Q2R_1 = RMicromega.Rinv_1 R1 : Qreals.Q2R {| QArith_base.Qnum := 1; QArith_base.Qden := 1 |} = 1\nsin_PI = let H : (sin PI)\u00b2 + (cos PI)\u00b2 = 1 := sin2_cos2 PI in let H0 : (sin PI)\u00b2 + (-1)\u00b2 = 1 := eq_ind (cos PI) (fun r : R => (sin PI)\u00b2 + r\u00b2 = 1) H (-1) cos_PI in let H1 : (sin PI)\u00b2 + 1\u00b2 = 1 := eq_ind_r (fun r : R => (sin PI)\u00b2 + r = 1) H0 (Rsqr_neg 1) in let H2 : (sin PI)\u00b2 + 1 = 1 := eq_ind 1\u00b2 (fun r : R => (sin PI)\u00b2 + r = 1) H1 1 Rsqr_1 in let H3 : (sin PI)\u00b2 = 0 := Rplus_eq_reg_l 1 (sin PI)\u00b2 0 (eq_ind_r (fun r : R => 1 + (sin PI)\u00b2 = r) (eq_ind_r (...\npowerRZ_R1 : forall n : Z, powerRZ 1 n = 1\nln_1 = eq_ind (exp 0) (fun r : R => ln r = 0) (eq_ind_r (fun r : R => r = 0) eq_refl (ln_exp 0)) 1 exp_0 : ln 1 = 0\nminus = fun (G : AbelianGroup) (x y : G) => plus x (opp y) : forall G : AbelianGroup, G -> G -> G Argument G is implicit and maximally inserted\nsqrt_1 = Rsqr_inj (sqrt 1) 1 (sqrt_positivity 1 (or_introl Rlt_0_1)) (or_introl Rlt_0_1) (eq_ind_r (fun r : R => r = 1 * 1) (let hyp_list := Datatypes.nil in let fv_list := Datatypes.nil in RField_ring_lemma1 ring_subst_niter fv_list hyp_list (Ring_polynom.PEc 1%Z) (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z) (Ring_polynom.PEc 1%Z)) I (eq_refl <: (let lmp := Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp Zeq_bool Z.quotrem hyp_list in Ring_polynom.Peq Zeq_bool (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp Zeq_bool Z.quotrem ring_subst_niter lmp...\nRmult_1_l : forall r : R, 1 * r = r\npowerRZ_O : forall x : R, powerRZ x 0 = 1\nC_n_n : forall n : nat, C n n = 1\nC_n_0 : forall n : nat, C n 0 = 1\nRmult_1_r : forall r : R, r * 1 = r\nRMicromega.Rinv_1 : forall x : R, x * / 1 = x\npow_1_even : forall n : nat, (-1) ^ (2 * n) = 1\nsucc_IZR : forall n : Z, IZR (Z.succ n) = IZR n + 1\nR1_sqrt2_neq_0 = (fun H : / sqrt 2 <> 0 => (fun H0 : 1 * / sqrt 2 <> 0 => H0) (Rmult_integral_contrapositive_currified 1 (/ sqrt 2) R1_neq_R0 H)) (Rinv_neq_0_compat (sqrt 2) sqrt2_neq_0) : 1 / sqrt 2 <> 0\nRinv_r : forall r : R, r <> 0 -> r * / r = 1\nRinv_r_sym : forall r : R, r <> 0 -> 1 = r * / r"}, {"role": "assistant", "content": "```coq\napply AbsRing.ax2.\nQed.\n```"}], "original": "apply AbsRing.ax2.", "succ": true}]