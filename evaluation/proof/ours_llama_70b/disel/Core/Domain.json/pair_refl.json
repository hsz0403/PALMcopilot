[{"history": {"proof": "split. - apply poset_refl. - apply poset_refl.", "repairs": ["", "", "", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nB: poset\nA: poset\nx: (A * B)%type\n\nGoal:\npair_leq x x\n\nPremises:\npair_leq = fun p1 p2 : A * B => p1.1 <== p2.1 /\\ p1.2 <== p2.2 : A * B -> A * B -> Prop\nfst = fun (A B : Type) (p : A * B) => let (x, _) := p in x : forall A B : Type, A * B -> A Arguments fst {A B}%type_scope\nInductive sig (A : Type) (P : A -> Prop) : Type := exist : forall x : A, P x -> {x : A | P x} Arguments sig [A]%type_scope _%type_scope Arguments exist [A]%type_scope _%function_scope\nsnd = fun (A B : Type) (p : A * B) => let (_, y) := p in y : forall A B : Type, A * B -> B Arguments snd {A B}%type_scope\nexist : forall (A : Type) (P : A -> Prop) (x : A), P x -> {x : A | P x}\nInductive prod (A B : Type) : Type := pair : A -> B -> A * B Arguments prod (_ _)%type_scope Arguments pair {A B}%type_scope\nPosetMixin : forall (T : Type) (mx_leq : T -> T -> Prop), (forall x : T, mx_leq x x) -> (forall x y : T, mx_leq x y -> mx_leq y x -> x = y) -> (forall x y z : T, mx_leq x y -> mx_leq y z -> mx_leq x z) -> Poset.mixin_of T\nRecord mixin_of (T : Type) : Type := Mixin { mx_leq : T -> T -> Prop; _ : forall x : T, mx_leq x x; _ : forall x y : T, mx_leq x y -> mx_leq y x -> x = y; _ : forall x y z : T, mx_leq x y -> mx_leq y z -> mx_leq x z } Arguments Poset.mixin_of _%type_scope Arguments Poset.Mixin [T]%type_scope [mx_leq]%function_scope (_ _ _)%function_scope\nZbool.Zeq_bool_neq : forall x y : BinNums.Z, Zbool.Zeq_bool x y = false -> x <> y\nposet_asym : forall (T : poset) (x y : T), x <== y -> y <== x -> x = y\nsub_refl : forall (T : poset) (s : Pred T) (x : {x : T | x \\In s}), sub_leq x x\nposet_trans : forall (T : poset) (y x z : T), x <== y -> y <== z -> x <== z\nZnumtheory.Zis_gcd_intro : forall a b g : BinNums.Z, BinInt.Z.divide g a -> BinInt.Z.divide g b -> (forall x : BinNums.Z, BinInt.Z.divide x a -> BinInt.Z.divide x b -> BinInt.Z.divide x g) -> Znumtheory.Zis_gcd a b g\nsub_asym : forall (T : poset) (s : Pred T) (x : {x : T | x \\In s}) (y : {x0 : T | x0 \\In s}), sub_leq x y -> sub_leq y x -> x = y\nposet_refl : forall (T : poset) (x : T), x <== x\nInductive Zis_gcd (a b g : BinNums.Z) : Prop := Zis_gcd_intro : BinInt.Z.divide g a -> BinInt.Z.divide g b -> (forall x : BinNums.Z, BinInt.Z.divide x a -> BinInt.Z.divide x b -> BinInt.Z.divide x g) -> Znumtheory.Zis_gcd a b g Arguments Znumtheory.Zis_gcd (_ _ _)%Z_scope Arguments Znumtheory.Zis_gcd_intro (_ _ _)%Z_scope _ _ _%function_scope\nsub_trans : forall (T : poset) (s : Pred T) (x : {x : T | x \\In s}) (y z : {x0 : T | x0 \\In s}), sub_leq x y -> sub_leq y z -> sub_leq x z\nBinInt.Z.gt = fun x y : BinNums.Z => BinInt.Z.compare x y = Gt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.gt (_ _)%Z_scope\nBinInt.Z.divide = fun x y : BinNums.Z => exists z : BinNums.Z, y = BinInt.Z.mul z x : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.divide (_ _)%Z_scope\nsub_leq : forall (T : poset) (s : Pred T), {x : T | x \\In s} -> {x : T | x \\In s} -> Prop\nBinIntDef.Z.add = fun x y : BinNums.Z => match x with | BinNums.Z0 => y | BinNums.Zpos x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.add x' y') | BinNums.Zneg y' => BinIntDef.Z.pos_sub x' y' end | BinNums.Zneg x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinIntDef.Z.pos_sub y' x' | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.add x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.add (_ _)%Z_scope\nZbool.Zeq_bool = fun x y : BinNums.Z => match BinInt.Z.compare x y with | Eq => true | _ => false end : BinNums.Z -> BinNums.Z -> bool Arguments Zbool.Zeq_bool (_ _)%Z_scope\nBinIntDef.Z.gtb = fun x y : BinNums.Z => match BinIntDef.Z.compare x y with | Gt => true | _ => false end : BinNums.Z -> BinNums.Z -> bool Arguments BinIntDef.Z.gtb (_ _)%Z_scope\nBinIntDef.Z.opp = fun x : BinNums.Z => match x with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos x0 => BinNums.Zneg x0 | BinNums.Zneg x0 => BinNums.Zpos x0 end : BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.opp _%Z_scope\n@sval : forall (A : Type) (P : A -> Prop), {x : A | P x} -> A\nsubPosetMixin : forall (T : poset) (s : Pred T), Poset.mixin_of {x : T | x \\In s}\nInductive option (A : Type) : Type := Some : A -> option A | None : option A Arguments option _%type_scope Arguments Some {A}%type_scope a : rename Arguments None {A}%type_scope\nRingMicromega.NFormula = fun C : Type => (RingMicromega.PolC C * RingMicromega.Op1)%type : Type -> Type Arguments RingMicromega.NFormula _%type_scope\nTauto.eval_tt : forall Env Term' Annot : Type, (Env -> Term' -> Prop) -> Env -> Term' * Annot -> Prop\nZMicromega.Zgcd_pol = fix Zgcd_pol (p : RingMicromega.PolC BinNums.Z) : BinNums.Z * BinNums.Z := match p with | EnvRing.Pc c => (BinNums.Z0, c) | EnvRing.Pinj _ p1 => Zgcd_pol p1 | EnvRing.PX p0 _ q => let (g1, c1) := Zgcd_pol p0 in let (g2, c2) := Zgcd_pol q in (ZMicromega.ZgcdM (ZMicromega.ZgcdM g1 c1) g2, c2) end : RingMicromega.PolC BinNums.Z -> BinNums.Z * BinNums.Z\nBinIntDef.Z.mul = fun x y : BinNums.Z => match x with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos x' => match y with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.mul x' y') | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.mul x' y') end | BinNums.Zneg x' => match y with | BinNums.Z0 => BinNums.Z0 | BinNums.Zpos y' => BinNums.Zneg (BinPos.Pos.mul x' y') | BinNums.Zneg y' => BinNums.Zpos (BinPos.Pos.mul x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.mul (_ _)%Z_scope"}, {"role": "assistant", "content": "```coq\nsplit.\n- apply poset_refl.\n- apply poset_refl.\nQed.\n```"}], "original": "split. - apply poset_refl. - apply poset_refl.", "succ": true}]