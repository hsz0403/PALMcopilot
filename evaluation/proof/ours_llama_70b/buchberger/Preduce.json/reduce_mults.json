[{"history": {"proof": "qsimpl time: 1 use: mults,reduce,reduce_ind. qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind. qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce. qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,canonical_spminusf_full_t,mults_dist_minuspf,reduce. qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce. qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce. qsimpl time: 1 use: reduce_ind,eqTerm_spminusf_com,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce. qsimpl time: 1 use: reduce_ind,eqTerm_spminusf_com,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,minuspf_eq_inv1,mults_dist_minuspf,reduce.", "repairs": ["no_instance_var", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros Q a p q Hred Hcan Hnz."], "tactic": "apply reduce_ind with (P := fun p q => reduce Q (mults multA (n:=n) a p) (mults multA (n:=n) a q)).", "exn": "Unable to find an instance for the variable Q.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind."], "tactic": "intros a b nZb p q r Hinp Hdiv Heq.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind."], "tactic": "intros a' b nZb p q r Hinp Hdiv Heq.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind."], "tactic": "intros a' b nZb p' q r Hinp Hdiv Heq.", "exn": "q is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind."], "tactic": "intros a' b nZb p' q' r Hinp Hdiv Heq.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind."], "tactic": "apply reducetop_sp with (Q := Q) (a := a) (b := b) (nZb := nZb) (p := p) (q := q).", "exn": "The reference b was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind."], "tactic": "apply Hcan.", "exn": "The reference Hcan was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER."], "tactic": "apply mults_dist_minuspf.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M5364 ?M5367 ?M5375 (mults ?M5371 ?M5381 (minuspf ?M5364 ?M5365 ?M5366 ?M5367 ?M5369 ?M5370 ?M5371 ?M5374 ?M5375 ?M5376 ?M5377 ?M5379 ?M5380)) (minuspf ?M5364 ?M5365 ?M5366 ?M5367 ?M5369 ?M5370 ?M5371 ?M5374 ?M5375 ?M5376 ?M5377 (mults ?M5371 ?M5381 ?M5379) (mults ?M5371 ?M5381 ?M5380))\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind."], "tactic": "apply mults_minusTerm.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M9720 ?M9723 ?M9731 (mults ?M9727 (minusTerm ?M9726 ?M9736 ?M9737) ?M9735) (minuspf ?M9720 ?M9721 ?M9722 ?M9723 ?M9725 ?M9726 ?M9727 ?M9730 ?M9731 ?M9732 ?M9733 (mults ?M9727 ?M9736 ?M9735) (mults ?M9727 ?M9737 ?M9735))\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce."], "tactic": "apply canonical_spminusf_full_t.", "exn": "In environment l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l1 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n a q)) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l1 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n b p)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"olist ?M15404 (pX ?M15407 (spminusf ?M15392 ?M15393 ?M15394 ?M15395 ?M15397 ?M15398 ?M15399 ?M15400 ?M15402 ?M15403 ?M15404 ?M15405 ?M15407 ?M15408 ?M15409 ?M15410 ?M15411)) /\\\\ nZterm ?M15393 ?M15395 (pX ?M15407 (spminusf ?M15392 ?M15393 ?M15394 ?M15395 ?M15397 ?M15398 ?M15399 ?M15400 ?M15402 ?M15403 ?M15404 ?M15405 ?M15407 ?M15408 ?M15409 ?M15410 ?M15411))\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,canonical_spminusf_full_t,mults_dist_minuspf,reduce."], "tactic": "apply eqptail_spminusf_com.", "exn": "In environment l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l2 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n a q)) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) b q) -> divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l2 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n b p)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l1 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n a q)) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l1 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n b p)) l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M23024 ?M23027 ?M23035 (spminusf ?M23024 ?M23025 ?M23026 ?M23027 ?M23029 ?M23030 ?M23031 ?M23032 ?M23034 ?M23035 ?M23036 ?M23037 ?M23039 ?M23040 ?M23041 ?M23042 ?M23044) (spminusf ?M23024 ?M23025 ?M23026 ?M23027 ?M23029 ?M23030 ?M23031 ?M23032 ?M23034 ?M23035 ?M23036 ?M23037 ?M23039 ?M23040 ?M23041 ?M23043 ?M23044)\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce."], "tactic": "apply eqp_spminusf_com.", "exn": "In environment l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l3 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n a q)) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) b q) -> divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb q r) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l3 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n b p)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l2 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n a q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l2 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n b p)) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l1 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n a q)) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l1 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n b p)) l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M32712 ?M32715 ?M32723 (spminusf ?M32712 ?M32713 ?M32714 ?M32715 ?M32717 ?M32718 ?M32719 ?M32720 ?M32722 ?M32723 ?M32724 ?M32725 ?M32727 ?M32729 ?M32730 ?M32731 ?M32733) (spminusf ?M32712 ?M32713 ?M32714 ?M32715 ?M32717 ?M32718 ?M32719 ?M32720 ?M32722 ?M32723 ?M32724 ?M32725 ?M32728 ?M32729 ?M32730 ?M32732 ?M32733)\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce."], "tactic": "apply eqTerm_spminusf_com.", "exn": "In environment l4 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l4 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l4 A multA n a p) (l4 A multA n a q)) H15 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) b q) -> divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)) H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb q r) H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> eqTerm eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc q r) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l4 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l4 A multA n a p) (l4 A multA n b p)) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l3 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n a q)) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l3 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n b p)) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l2 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n a q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l2 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n b p)) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l1 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n a q)) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l1 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n b p)) l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M44512 ?M44515 ?M44523 (spminusf ?M44512 ?M44513 ?M44514 ?M44515 ?M44517 ?M44518 ?M44519 ?M44520 ?M44522 ?M44523 ?M44524 ?M44525 ?M44527 ?M44529 ?M44530 ?M44531 ?M44532) (spminusf ?M44512 ?M44513 ?M44514 ?M44515 ?M44517 ?M44518 ?M44519 ?M44520 ?M44522 ?M44523 ?M44524 ?M44525 ?M44528 ?M44529 ?M44530 ?M44531 ?M44532)\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,eqTerm_spminusf_com,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce."], "tactic": "apply minuspf_eq_inv1.", "exn": "In environment l5 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H20 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l5 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l5 A multA n a p) (l5 A multA n a q)) H19 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) b q) -> divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)) H18 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb q r) H17 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> eqTerm eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc q r) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l5 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l5 A multA n a p) (l5 A multA n b p)) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqTerm eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc p q) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l4 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l4 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l4 A multA n a p) (l4 A multA n a q)) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l4 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l4 A multA n a p) (l4 A multA n b p)) l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l3 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n a q)) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l3 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n b p)) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l2 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n a q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l2 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n b p)) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l1 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n a q)) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l1 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n b p)) l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M58340 ?M58343 ?M58351 (pX ?M58355 (minuspf ?M58340 ?M58341 ?M58342 ?M58343 ?M58345 ?M58346 ?M58347 ?M58350 ?M58351 ?M58352 ?M58353 ?M58356 ?M58357)) (minuspf ?M58340 ?M58341 ?M58342 ?M58343 ?M58345 ?M58346 ?M58347 ?M58350 ?M58351 ?M58352 ?M58353 (pX ?M58355 ?M58356) ?M58357)\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q a p q Hred Hcan Hnz.", "qsimpl time: 1 use: mults,reduce,reduce_ind.", "apply Build_PER.", "qsimpl time: 1 use: mults,mults_dist_minuspf,reduce,reduce_ind.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,eqTerm_spminusf_com,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,mults_dist_minuspf,reduce.", "qsimpl time: 1 use: reduce_ind,eqTerm_spminusf_com,mults,mults_minusTerm,eqp_spminusf_com,eqptail_spminusf_com,canonical_spminusf_full_t,minuspf_eq_inv1,mults_dist_minuspf,reduce."], "tactic": "apply spminusf_minusTerm_z.", "exn": "In environment l6 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H24 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l6 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l6 A multA n a p) (l6 A multA n a q)) H23 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a : Term A n) (p q : list (Term A n)), canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a q) -> eqP A eqA n (pX (A:=A) (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) a p) q) H22 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) b q) -> divP A A0 eqA multA divA n a b -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)) H21 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb q r) H15 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> canonical A0 eqA ltM r -> eqP A eqA n p q -> eqTerm eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc q r) H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l6 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l6 A multA n a p) (l6 A multA n b p)) H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b c : Term A n) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q : list (Term A n)), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> eqTerm eqA (n:=n) a b -> divP A A0 eqA multA divA n a c -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc p q) A : Set A0, A1 : A eqA : A -> A -> Prop invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} H3 : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) -> (forall (a b : Term A n) (p q : list (Term A n)), reduce Q p q -> P p q -> eqTerm eqA (n:=n) a b -> P (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) -> forall l l0 : list (Term A n), reduce Q l l0 -> P l l0 l5 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H20 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l5 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l5 A multA n a p) (l5 A multA n a q)) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l5 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l5 A multA n a p) (l5 A multA n b p)) l4 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H16 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l4 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l4 A multA n a p) (l4 A multA n a q)) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l4 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l4 A multA n a p) (l4 A multA n b p)) l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l3 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n a q)) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l3 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l3 A multA n a p) (l3 A multA n b p)) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l2 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n a q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l2 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l2 A multA n a p) (l2 A multA n b p)) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l1 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n a q)) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p : list (Term A n)) (a b : Term A n), eqT (A:=A) (n:=n) a b -> (zeroP A0 eqA (n:=n) (minusTerm minusA (n:=n) a b) -> False) -> canonical A0 eqA ltM p -> eqP A eqA n (l1 A multA n (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l1 A multA n a p) (l1 A multA n b p)) l0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q : list (Term A n)) (a : Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> (zeroP A0 eqA (n:=n) a -> False) -> eqP A eqA n (l0 A multA n a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (l0 A multA n a p) (l0 A multA n a q)) l : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) plusA : A -> A -> A Q : list (poly A0 eqA ltM) a : Term A n p, q : list (Term A n) Hred : reduce Q p q Hnz : zeroP A0 eqA (n:=n) a -> False H0 : olist (A:=A) ltM p H1 : nZterm A0 eqA (n:=n) p M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M74056 ?M74059 ?M74067 (minuspf ?M74056 ?M74057 ?M74058 ?M74059 ?M74061 ?M74062 ?M74063 ?M74066 ?M74067 ?M74068 ?M74069 ?M74075 ?M74076) (minuspf ?M74056 ?M74057 ?M74058 ?M74059 ?M74061 ?M74062 ?M74063 ?M74066 ?M74067 ?M74068 ?M74069 (spminusf ?M74056 ?M74057 ?M74058 ?M74059 ?M74061 ?M74062 ?M74063 ?M74064 ?M74066 ?M74067 ?M74068 ?M74069 ?M74071 ?M74073 ?M74074 ?M74075 ?M74077) (spminusf ?M74056 ?M74057 ?M74058 ?M74059 ?M74061 ?M74062 ?M74063 ?M74064 ?M74066 ?M74067 ?M74068 ?M74069 ?M74072 ?M74073 ?M74074 ?M74076 ?M74077))\" with \"forall x y : list (Term A n), reduce Q x y -> reduce Q y x\".", "type": "cannot_unify", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nA: Set\nA1: A\nA0: A\neqA: A -> A -> Prop\nplusA: A -> A -> A\ninvA: A -> A\nmultA: A -> A -> A\nminusA: A -> A -> A\ndivA: A -> forall b : A, ~ eqA b A0 -> A\ncs: CoefStructure A A0 A1 eqA plusA invA minusA multA divA\neqA_dec: forall a b : A, {eqA a b} + {~ eqA a b}\nn: nat\nltM: mon n -> mon n -> Prop\nltM_dec: forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}\nos: OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)\n\nGoal:\nforall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce Q p q -> canonical A0 eqA ltM p -> ~ zeroP A0 eqA (n:=n) a -> reduce Q (mults multA (n:=n) a p) (mults multA (n:=n) a q)\n\nPremises:\nmults : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n)\nOrderStructure : forall A : Set, A -> (A -> A -> Prop) -> (A -> A -> A) -> Prop\ncanonical : forall A : Set, A -> (A -> A -> Prop) -> forall n : nat, (mon n -> mon n -> Prop) -> list (Term A n) -> Prop\nRecord Q : Set := Qmake { Qnum : BinNums.Z; Qden : BinNums.positive } Arguments QArith_base.Qmake _%Z_scope _%positive_scope\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\npoly : forall A : Set, A -> (A -> A -> Prop) -> forall n : nat, (mon n -> mon n -> Prop) -> Set\nCoefStructure : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, ~ eqA b A0 -> A) -> Prop\nzeroP : forall A : Set, A -> (A -> A -> Prop) -> forall n : nat, Term A n -> Prop\nInductive reduce (Q : list (poly A0 eqA ltM)) : list (Term A n) -> list (Term A n) -> Prop := reducetop : forall (a b : Term A n) (nZb : ~ zeroP A0 eqA (n:=n) b) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b n\nzero_mon : forall d : nat, mon d\nmult_mon : forall d : nat, mon d -> mon d -> mon d\nInductive mon : nat -> Set := n_0 : mon 0 | c_n : forall d : nat, nat -> mon d -> mon (S d) Arguments mon _%nat_scope Arguments c_n (_ _)%nat_scope\nmults_comp_minuspf : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q)) (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q))\nmults_dist_minuspf : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (mults multA (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) a q))\nspminusf_multTerm : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b...\nmults_dist_pluspf : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (p q...\nreduce_ind : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (a b : Term A n) (nZb : ~ zeroP A0 eqA (n:=n) b) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) ->...-> P l l0\nreduce_sind : forall (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> SProp), (forall (a b : Term A n) (nZb : ~ zeroP A0 eqA (n:=n) b) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> P (pX (A:=A) (n:=n) a p) r) ->...-> P l l0\nmults_minusTerm : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (mults multA (n:=n) (minusTerm minusA (n:=n) a b) p) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) b p))\nmults_dist1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (mults multA (n:=n) (plusTerm plusA (n:=n) a b) p) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) b p))\nmults_dist2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (pO A n) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) b p))\nmults_pO : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (pO A n) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (mults multA (n:=n) a p) (mults multA (n:=n) b p))\ncanonical_spminusf_full_t : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> canonical A0 eqA ltM (pX (A:=A) (n:=n) a (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q))\nreducetop : forall (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : ~ zeroP A0 eqA (n:=n) b) (p q r : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r -> reduce Q (pX (A:=A) (n:=n) a p) r\ncanonical_spminusf_full : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> canonical A0 eqA ltM (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)\nspminusf_extend : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b :...\nreducetop_sp : forall (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : ~ zeroP A0 eqA (n:=n) b) (p q : list (Term A n)), inPolySet (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a b -> reduce Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)\ncanonical_spminusf : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> canonical A0 eqA ltM (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q)\ncanonical_mults_inv : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) ->...-> canonical A0 eqA ltM p\neqptail_spminusf_com : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb q r)\neqp_spminusf_com : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc q r)\neqTerm_spminusf_com : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p q) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec b c nZc p q)\nminuspf_eq_inv1 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (pX (A:=A) (n:=n) a (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p q)) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) a p) q)\nspminusf_minusTerm_z : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a...\nreduce_mults_invf : forall (a : Term A n) (nZa : ~ zeroP A0 eqA (n:=n) a), eqT (A:=A) (n:=n) a (T1 A1 n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), canonical A0 eqA ltM p -> reduce Q (mults multA (n:=n) a p) q -> reduce Q p (mults multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) (T1 A1 n) (b:=a) nZa) q)\nminuspf_eq_inv2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a :...\npluspf_is_minuspf : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p q) (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults multA (n:=n) (invTerm invA (n:=n) (T1 A1 n)) q))"}, {"role": "assistant", "content": "```coq\nintros Q a p q Hred Hcan Hnz.\napply reduce_ind with (P := fun p q => reduce Q (mults multA (n:=n) a p) (mults multA (n:=n) a q)).\nintros a b nZb p q r Hinp Hdiv Heq.\napply reducetop_sp with (Q := Q) (a := a) (b := b) (nZb := nZb) (p := p) (q := q).\nauto.\napply Hcan.\napply mults_dist_minuspf.\nauto.\napply mults_minusTerm.\nauto.\napply canonical_spminusf_full_t.\nauto.\napply eqptail_spminusf_com.\nauto.\napply eqp_spminusf_com.\nauto.\napply eqTerm_spminusf_com.\nauto.\napply minuspf_eq_inv1.\nauto.\napply spminusf_minusTerm_z.\nauto.\napply reduce_mults_invf.\nauto.\napply minuspf_eq_inv2.\nauto.\napply pluspf_is_minuspf.\nauto.\nQed."}], "original": "intros Q a p q Hred Hcan Hnz. apply reduce_ind with (P := fun p q => reduce Q (mults multA (n:=n) a p) (mults multA (n:=n) a q)). intros a b nZb p q r Hinp Hdiv Heq. apply reducetop_sp with (Q := Q) (a := a) (b := b) (nZb := nZb) (p := p) (q := q). auto. apply Hcan. apply mults_dist_minuspf. auto. apply mults_minusTerm. auto. apply canonical_spminusf_full_t. auto. apply eqptail_spminusf_com. auto. apply eqp_spminusf_com. auto. apply eqTerm_spminusf_com. auto. apply minuspf_eq_inv1. auto. apply spminusf_minusTerm_z. auto. apply reduce_mults_invf. auto. apply minuspf_eq_inv2. auto. apply pluspf_is_minuspf. auto.", "succ": false}]