[{"history": {"proof": "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear. qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear. qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind. qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind. qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind. qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind. qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "repairs": ["no_instance_var", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros Q p q Cp Cq H1 H2."], "tactic": "apply SpolyQ_ind with (P := CombLinear Q (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)).", "exn": "Unable to find an instance for the variables A, A0, A1, eqA, invA, minusA, multA, divA, eqA_dec, n, ltM, ltM_dec, Q.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear."], "tactic": "intros p0 q0 Cp0 Cq0.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear."], "tactic": "apply CombLinear_1 with (a := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p0 q0 Cp0 Cq0).", "exn": "The reference Cq0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear."], "tactic": "apply reduce_inv2.", "exn": "In environment H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA ltM p -> inPolySet A A0 eqA n ltM q Q -> canonical A0 eqA ltM q -> Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q) -> P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> P l : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) p, q : list (Term A n) Cp : canonical A0 eqA ltM p Cq : canonical A0 eqA ltM q H1 : inPolySet A A0 eqA n ltM p Q H2 : inPolySet A A0 eqA n ltM q Q M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"exists (x : list (Term ?M6530 ?M6541)) (a : Term ?M6530 ?M6541), ~ zeroP ?M6531 ?M6533 a /\\\\ inPolySet ?M6530 ?M6531 ?M6533 ?M6541 ?M6542 x ?M6545 /\\\\ canonical ?M6531 ?M6533 ?M6542 x /\\\\ eqP ?M6530 ?M6533 ?M6541 ?M6547 (minuspf ?M6530 ?M6531 ?M6532 ?M6533 ?M6535 ?M6536 ?M6537 ?M6540 ?M6541 ?M6542 ?M6543 ?M6546 (mults ?M6537 a x))\" with \"CombLinear Q (l A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear."], "tactic": "apply reduce_plus_top.", "exn": "In environment H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA ltM p -> inPolySet A A0 eqA n ltM q Q -> canonical A0 eqA ltM q -> Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q) -> P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> P X : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> exists (x : list (Term A n)) (a : Term A n), (zeroP A0 eqA (n:=n) a -> False) /\\\\ inPolySet A A0 eqA n ltM x Q /\\\\ canonical A0 eqA ltM x /\\\\ eqP A eqA n q (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults multA (n:=n) a x)) l : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) p, q : list (Term A n) Cp : canonical A0 eqA ltM p Cq : canonical A0 eqA ltM q H1 : inPolySet A A0 eqA n ltM p Q H2 : inPolySet A A0 eqA n ltM q Q M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"exists s : list (Term ?M9940 ?M9951), reduceplus ?M9940 ?M9941 ?M9942 ?M9943 ?M9945 ?M9946 ?M9947 ?M9948 ?M9950 ?M9951 ?M9952 ?M9953 ?M9955 (pluspf ?M9941 ?M9944 ?M9950 ?M9953 (pX ?M9958 ?M9961) ?M9956) s /\\\\ reduceplus ?M9940 ?M9941 ?M9942 ?M9943 ?M9945 ?M9946 ?M9947 ?M9948 ?M9950 ?M9951 ?M9952 ?M9953 ?M9955 (pluspf ?M9941 ?M9944 ?M9950 ?M9953 (spminusf ?M9940 ?M9941 ?M9942 ?M9943 ?M9945 ?M9946 ?M9947 ?M9948 ?M9950 ?M9951 ?M9952 ?M9953 ?M9958 ?M9959 ?M9960 ?M9961 ?M9962) ?M9956) s\" with \"CombLinear Q (l A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind."], "tactic": "apply confl_top_simpl.", "exn": "In environment H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA ltM p -> inPolySet A A0 eqA n ltM q Q -> canonical A0 eqA ltM q -> Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q) -> P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> P H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> exists (x : list (Term A n)) (a : Term A n), (zeroP A0 eqA (n:=n) a -> False) /\\\\ inPolySet A A0 eqA n ltM x Q /\\\\ canonical A0 eqA ltM x /\\\\ eqP A eqA n q (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults multA (n:=n) a x)) H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (r : list (Term A n)), canonical A0 eqA ltM r -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> exists s : list (Term A n), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) r) s /\\\\ reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s X0, X, l : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) p, q : list (Term A n) Cp : canonical A0 eqA ltM p Cq : canonical A0 eqA ltM q H1 : inPolySet A A0 eqA n ltM p Q H2 : inPolySet A A0 eqA n ltM q Q M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M14118 ?M14121 ?M14129 ?M14153 ?M14154\" with \"CombLinear Q (l A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "intros p0 q0 Cp0 Cq0.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply CombLinear_1 with (a := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p0 q0 Cp0 Cq0).", "exn": "The reference Cq0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply reduce_inv2.", "exn": "In environment H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA ltM p -> inPolySet A A0 eqA n ltM q Q -> canonical A0 eqA ltM q -> Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q) -> P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> P l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a b c : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)) (Cpxc : canonical A0 eqA ltM (pX (A:=A) (n:=n) c r)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) c r) (pX (A:=A) (n:=n) b q) Cpxc Cpxb) (pO A n) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a c -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) c r) Q -> (forall q0 : list (Term A n), canonical A0 eqA ltM q0 -> ltP (A:=A) ltM q0 (pX (A:=A) (n:=n) a p) -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q0) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) -> forall r1 s1 : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r1 -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) s1 -> eqP A eqA n r1 s1 H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> exists (x : list (Term A n)) (a : Term A n), (zeroP A0 eqA (n:=n) a -> False) /\\\\ inPolySet A A0 eqA n ltM x Q /\\\\ canonical A0 eqA ltM x /\\\\ eqP A eqA n q (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults multA (n:=n) a x)) H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (r : list (Term A n)), canonical A0 eqA ltM r -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> exists s : list (Term A n), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) r) s /\\\\ reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s X0, X, l : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) p, q : list (Term A n) Cp : canonical A0 eqA ltM p Cq : canonical A0 eqA ltM q H1 : inPolySet A A0 eqA n ltM p Q H2 : inPolySet A A0 eqA n ltM q Q M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"exists (x : list (Term ?M19298 ?M19309)) (a : Term ?M19298 ?M19309), ~ zeroP ?M19299 ?M19301 a /\\\\ inPolySet ?M19298 ?M19299 ?M19301 ?M19309 ?M19310 x ?M19313 /\\\\ canonical ?M19299 ?M19301 ?M19310 x /\\\\ eqP ?M19298 ?M19301 ?M19309 ?M19315 (minuspf ?M19298 ?M19299 ?M19300 ?M19301 ?M19303 ?M19304 ?M19305 ?M19308 ?M19309 ?M19310 ?M19311 ?M19314 (mults ?M19305 a x))\" with \"CombLinear Q (l A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply reduce_plus_top.", "exn": "In environment H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA ltM p -> inPolySet A A0 eqA n ltM q Q -> canonical A0 eqA ltM q -> Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q) -> P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> P l1 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a b c : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)) (Cpxc : canonical A0 eqA ltM (pX (A:=A) (n:=n) c r)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) c r) (pX (A:=A) (n:=n) b q) Cpxc Cpxb) (pO A n) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a c -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) c r) Q -> (forall q0 : list (Term A n), canonical A0 eqA ltM q0 -> ltP (A:=A) ltM q0 (pX (A:=A) (n:=n) a p) -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q0) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) -> forall r1 s1 : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r1 -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) s1 -> eqP A eqA n r1 s1 H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> exists (x : list (Term A n)) (a : Term A n), (zeroP A0 eqA (n:=n) a -> False) /\\\\ inPolySet A A0 eqA n ltM x Q /\\\\ canonical A0 eqA ltM x /\\\\ eqP A eqA n q (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults multA (n:=n) a x)) H : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (r : list (Term A n)), canonical A0 eqA ltM r -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> exists s : list (Term A n), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) r) s /\\\\ reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a b c : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)) (Cpxc : canonical A0 eqA ltM (pX (A:=A) (n:=n) c r)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) c r) (pX (A:=A) (n:=n) b q) Cpxc Cpxb) (pO A n) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a c -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) c r) Q -> (forall q0 : list (Term A n), canonical A0 eqA ltM q0 -> ltP (A:=A) ltM q0 (pX (A:=A) (n:=n) a p) -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q0) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) -> forall r1 s1 : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r1 -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) s1 -> eqP A eqA n r1 s1 X0, X, l : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) p, q : list (Term A n) Cp : canonical A0 eqA ltM p Cq : canonical A0 eqA ltM q H1 : inPolySet A A0 eqA n ltM p Q H2 : inPolySet A A0 eqA n ltM q Q M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"exists s : list (Term ?M25468 ?M25479), reduceplus ?M25468 ?M25469 ?M25470 ?M25471 ?M25473 ?M25474 ?M25475 ?M25476 ?M25478 ?M25479 ?M25480 ?M25481 ?M25483 (pluspf ?M25469 ?M25472 ?M25478 ?M25481 (pX ?M25486 ?M25489) ?M25484) s /\\\\ reduceplus ?M25468 ?M25469 ?M25470 ?M25471 ?M25473 ?M25474 ?M25475 ?M25476 ?M25478 ?M25479 ?M25480 ?M25481 ?M25483 (pluspf ?M25469 ?M25472 ?M25478 ?M25481 (spminusf ?M25468 ?M25469 ?M25470 ?M25471 ?M25473 ?M25474 ?M25475 ?M25476 ?M25478 ?M25479 ?M25480 ?M25481 ?M25486 ?M25487 ?M25488 ?M25489 ?M25490) ?M25484) s\" with \"CombLinear Q (l A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply confl_top_simpl.", "exn": "In environment H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA ltM p -> inPolySet A A0 eqA n ltM q Q -> canonical A0 eqA ltM q -> Spoly_1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q) -> P) -> SpolyQ A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q -> P l2 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a b c : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)) (Cpxc : canonical A0 eqA ltM (pX (A:=A) (n:=n) c r)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l2 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) c r) (pX (A:=A) (n:=n) b q) Cpxc Cpxb) (pO A n) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a c -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) c r) Q -> (forall q0 : list (Term A n), canonical A0 eqA ltM q0 -> ltP (A:=A) ltM q0 (pX (A:=A) (n:=n) a p) -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q0) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) -> forall r1 s1 : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r1 -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) s1 -> eqP A eqA n r1 s1 H3 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> exists (x : list (Term A n)) (a : Term A n), (zeroP A0 eqA (n:=n) a -> False) /\\\\ inPolySet A A0 eqA n ltM x Q /\\\\ canonical A0 eqA ltM x /\\\\ eqP A eqA n q (minuspf A A0 A1 eqA invA minusA multA eqA_dec n ltM ltM_dec p (mults multA (n:=n) a x)) H0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (r : list (Term A n)), canonical A0 eqA ltM r -> forall (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> exists s : list (Term A n), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) r) s /\\\\ reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r) s l1 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H5 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a b c : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)) (Cpxc : canonical A0 eqA ltM (pX (A:=A) (n:=n) c r)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) c r) (pX (A:=A) (n:=n) b q) Cpxc Cpxb) (pO A n) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a c -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) c r) Q -> (forall q0 : list (Term A n), canonical A0 eqA ltM q0 -> ltP (A:=A) ltM q0 (pX (A:=A) (n:=n) a p) -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q0) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) -> forall r1 s1 : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r1 -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) s1 -> eqP A eqA n r1 s1 l0 : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a b c : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (nZc : zeroP A0 eqA (n:=n) c -> False) (p q r : list (Term A n)) (Cpxc : canonical A0 eqA ltM (pX (A:=A) (n:=n) c r)) (Cpxb : canonical A0 eqA ltM (pX (A:=A) (n:=n) b q)), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l0 A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec (pX (A:=A) (n:=n) c r) (pX (A:=A) (n:=n) b q) Cpxc Cpxb) (pO A n) -> canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) -> divP A A0 eqA multA divA n a b -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q -> divP A A0 eqA multA divA n a c -> inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) c r) Q -> (forall q0 : list (Term A n), canonical A0 eqA ltM q0 -> ltP (A:=A) ltM q0 (pX (A:=A) (n:=n) a p) -> ReduStarConfluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q0) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) -> forall r1 s1 : list (Term A n), reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) r1 -> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a c nZc p r) s1 -> eqP A eqA n r1 s1 X0, X, l : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, (eqA b A0 -> False) -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0 eqA ltM p -> canonical A0 eqA ltM q -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) p, q : list (Term A n) Cp : canonical A0 eqA ltM p Cq : canonical A0 eqA ltM q H1 : inPolySet A A0 eqA n ltM p Q H2 : inPolySet A A0 eqA n ltM q Q M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M32628 ?M32631 ?M32639 ?M32663 ?M32664\" with \"CombLinear Q (l A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q p q Cp Cq H1 H2.", "qsimpl time: 1 use: spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: reduce_inv2,spolyf,SpolyQ_ind,CombLinear.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind.", "qsimpl time: 1 use: spolyf,reduce_plus_top,CombLinear,reduce_inv2,confl_top_simpl,SpolyQ_ind."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nA: Set\nA1: A\nA0: A\neqA: A -> A -> Prop\nplusA: A -> A -> A\ninvA: A -> A\nmultA: A -> A -> A\nminusA: A -> A -> A\ndivA: A -> forall b : A, ~ eqA b A0 -> A\ncs: CoefStructure A A0 A1 eqA plusA invA minusA multA divA\neqA_dec: forall a b : A, {eqA a b} + {~ eqA a b}\nn: nat\nltM: mon n -> mon n -> Prop\nltM_dec: forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}\nos: OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)\n\nGoal:\nforall (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)) (Cp : canonical A0 eqA ltM p) (Cq : canonical A0 eqA ltM q), inPolySet A A0 eqA n ltM p Q -> inPolySet A A0 eqA n ltM q Q -> CombLinear Q (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\n\nPremises:\nInductive mon : nat -> Set := n_0 : mon 0 | c_n : forall d : nat, nat -> mon d -> mon (S d) Arguments mon _%nat_scope Arguments c_n (_ _)%nat_scope\nspolyf : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, ~ eqA b A0 -> A) -> (forall a b : A, {eqA a b} + {~ eqA a b}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> forall p q : list (Term A n), canonical A0\nRecord Q : Set := Qmake { Qnum : BinNums.Z; Qden : BinNums.positive } Arguments QArith_base.Qmake _%Z_scope _%positive_scope\nInductive CombLinear (Q : list (poly A0 eqA ltM)) : list (Term A n) -> Prop := CombLinear_0 : CombLinear Q (pO A n) | CombLinear_1 : forall (a : Term A n) (p q s : list (Term A n)), ~ zeroP A0 eqA (n:=n) a -> inPolySet A A0 eqA n ltM q Q -> CombLinear Q p -> eqP A eqA n s (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a q) p) ->\ncanonical : forall A : Set, A -> (A -> A -> Prop) -> forall n : nat, (mon n -> mon n -> Prop) -> list (Term A n) -> Prop\nmult_mon : forall d : nat, mon d -> mon d -> mon d\nCoefStructure : forall (A : Set) (A0 : A), A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (A -> A) -> (A -> A -> A) -> (A -> A -> A) -> (A -> forall b : A, ~ eqA b A0 -> A) -> Prop\ninPolySet : forall (A : Set) (A0 : A) (eqA : A -> A -> Prop) (n : nat) (ltM : mon n -> mon n -> Prop), list (Term A n) -> list (poly A0 eqA ltM) -> Prop\nOrderStructure : forall A : Set, A -> (A -> A -> Prop) -> (A -> A -> A) -> Prop\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\npoly : forall A : Set, A -> (A -> A -> Prop) -> forall n : nat, (mon n -> mon n -> Prop) -> Set\nzero_mon : forall d : nat, mon d\nSpoly_10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (p q : list (Term A n)) (Cp : canonical A0 eqA ltM p) (Cq : canonical A0 eqA ltM q),...\nspolyf_canonical : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> forall (p q : list (Term A n)) (Cp : canonical A0 eqA ltM p) (Cq : canonical A0 eqA ltM q), canonical A0 eqA ltM (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)\nreduce_inv2 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)...\nSpoly_1_sind : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> SProp), (forall (p q : list (Term A n)) (C...\nSpoly_1_ind : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : list (Term A n) -> list (Term A n) -> Prop), (forall (p q : list (Term A n)) (Cp :...\nreduce_plus_top : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)...\nred_minus_zero_reduce : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> exists r1 : list (Term A n), reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p r1 /\\ reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q r1\nconfl_top_simpl : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n r1 s1\nconfl_mix : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n r1 s1\nfconfl_top : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> Confluent A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q r\nconfl_top : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> eqP A eqA n r1 s1\nred_plus_zero_reduce : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n...\nrep_plus_zero_reduce : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n...\nrep_minus_reduce : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)...\nSpolyQ_rec : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Set), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA lt...\nSpolyQ_ind : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Prop), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA lt...\nSpolyQ_rect : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : Type), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eqA lt...\nSpolyQ_sind : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (P : SProp), ((forall p q : list (Term A n), inPolySet A A0 eqA n ltM p Q -> canonical A0 eq...\nreducestar_in_pO : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> reducestar A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (mults multA (n:=n) a p) (pO A n)\nirreducible_eqp_com : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> irreducible A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q q\nInductive Spoly_1 (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A) (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) : list (Term A n) -> list (Term A n) -> Prop := Spoly_10 : forall (p q : list (Term A n)) (Cp...\nreducestar_inv : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n)...\nreduce_in_pO : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p (pO A n)\nreduceplus_mults_invf0 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q r s\nreduceplus_mults : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, ~ eqA b A0 -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA ->...-> reduceplus A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (mults multA (n:=n) a p) (mults multA (n:=n) a q)"}, {"role": "assistant", "content": "```coq\nintros Q p q Cp Cq H1 H2.\napply SpolyQ_ind with (P := CombLinear Q (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)).\n- intros p0 q0 Cp0 Cq0.\n  apply CombLinear_1 with (a := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p0 q0 Cp0 Cq0).\n  + apply reduce_inv2.\n    apply cs.\n  + apply reduce_plus_top.\n    apply cs.\n  + apply confl_top_simpl.\n    apply cs.\n- intros p0 q0 Cp0 Cq0.\n  apply CombLinear_1 with (a := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p0 q0 Cp0 Cq0).\n  + apply reduce_inv2.\n    apply cs.\n  + apply reduce_plus_top.\n    apply cs.\n  + apply confl_top_simpl.\n    apply cs.\nQed."}], "original": "intros Q p q Cp Cq H1 H2. apply SpolyQ_ind with (P := CombLinear Q (spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p q Cp Cq)). - intros p0 q0 Cp0 Cq0. apply CombLinear_1 with (a := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p0 q0 Cp0 Cq0). + apply reduce_inv2. apply cs. + apply reduce_plus_top. apply cs. + apply confl_top_simpl. apply cs. - intros p0 q0 Cp0 Cq0. apply CombLinear_1 with (a := spolyf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec p0 q0 Cp0 Cq0). + apply reduce_inv2. apply cs. + apply reduce_plus_top. apply cs. + apply confl_top_simpl. apply cs.", "succ": false}]