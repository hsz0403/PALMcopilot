[{"history": {"proof": "intros x y Hxy. inversion Hxy. trivial.", "repairs": ["", "", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nA: Type\nI: A -> Prop\n\nGoal:\nCoreflexive (psat I)\n\nPremises:\nInductive psat (A : Type) (I : A -> Prop) (x : A) : A -> Prop := psat_intro : I x -> psat I x x Arguments psat {A}%type_scope _%function_scope Arguments psat_intro {A}%type_scope _%function_scope\nCoreflexive = fun (A : Type) (R : relation A) => forall x y : A, R x y -> x = y : forall A : Type, relation A -> Prop Arguments Coreflexive {A}%type_scope _%rel_scope\nprod_rel_corefl : forall (R1 : rel ?A ?A) (R2 : rel ?B ?B), Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 * R2) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nsum_rel_corefl : forall (R1 : rel ?A ?A) (R2 : rel ?B ?B), Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 + R2) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nrel_push_corefl : forall (f : ?A -> ?B) (R : rel ?A ?A), Coreflexive R -> Coreflexive R !! (f) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nrel_union_corefl : forall R1 R2 : rel ?A ?A, Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 \\/ R2) where ?A : [A : Type I : A -> Prop |- Type]\nrel_inter_corefl_r : forall R1 R2 : rel ?A ?A, Coreflexive R2 -> Coreflexive (R1 /\\ R2) where ?A : [A : Type I : A -> Prop |- Type]\nrel_inter_corefl_l : forall R1 R2 : rel ?A ?A, Coreflexive R1 -> Coreflexive (R1 /\\ R2) where ?A : [A : Type I : A -> Prop |- Type]\narrow_refl : forall (RA : relation ?A) (RB : relation ?B), Coreflexive RA -> Reflexive RB -> Reflexive (RA ++> RB) where ?A : [A : Type I : A -> Prop |- Type] ?B : [A : Type I : A -> Prop |- Type]\nreq_corefl : forall a : ?A, Coreflexive (req a) where ?A : [A : Type I : A -> Prop |- Type]\nsubrel_eq : forall R : relation ?A, Coreflexive R -> Related R eq subrel where ?A : [A : Type I : A -> Prop |- Type]\nrelation = fun A : Type => A -> A -> Prop : Type -> Type Arguments relation _%type_scope\nInductive prod (A B : Type) : Type := pair : A -> B -> A * B Arguments prod (_ _)%type_scope Arguments pair {A B}%type_scope\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\nrel = fun A1 A2 : Type => A1 -> A2 -> Prop : Type -> Type -> Type Arguments rel (_ _)%type_scope\nlist_rel_corefl = fun (A : Type) (R : relation A) (HR : Coreflexive R) (l1 l2 : list A) (Hl : list_rel R l1 l2) => list_rel_ind A A R (fun l3 l4 : list A => l3 = l4) (let H : A = A := eq_refl in (fun _ : A = A => eq_refl) H) (fun (x1 x2 : A) (Hx : R x1 x2) (l3 l4 : list A) (_ : list_rel R l3 l4) (IHl : l3 = l4) => let H : l3 = l4 := IHl in (let H0 : x1 = x2 := coreflexivity x1 x2 Hx in (let H1 : A = A := eq_refl in (fun (_ : A = A) (H3 : x1 = x2) (H4 : l3 = l4) => eq_trans (f_equal (fun f :...\nInductive sum (A B : Type) : Type := inl : A -> A + B | inr : B -> A + B Arguments sum (_ _)%type_scope Arguments inl {A B}%type_scope, [A] _ _ Arguments inr {A B}%type_scope, _ [B] _\ncoreflexivity : forall x y : ?A, x = y -> x = y where ?A : [A : Type I : A -> Prop |- Type]\npsat_intro : forall (I0 : ?A -> Prop) (x : ?A), I0 x -> psat I0 x x where ?A : [A : Type I : A -> Prop |- Type]\nssrbool.rel = fun T : Type => T -> ssrbool.pred T : Type -> Type Arguments ssrbool.rel _%type_scope\nCompSpec = fun (A : Type) (eq lt : A -> A -> Prop) (x y : A) => CompareSpec (eq x y) (lt x y) (lt y x) : forall A : Type, (A -> A -> Prop) -> (A -> A -> Prop) -> A -> A -> comparison -> Prop Arguments CompSpec {A}%type_scope (_ _)%function_scope\neq_corefl = fun (A : Type) (x y : A) (H : x = y) => H : forall A : Type, Coreflexive eq Arguments eq_corefl {A}%type_scope\nList.map : forall A B : Type, (A -> B) -> list A -> list B\nRelated = fun (A B : Type) (f : A) (g : B) (R : rel A B) => R f g : forall A B : Type, A -> B -> rel A B -> Prop Arguments Related {A B}%type_scope _ _ _%rel_scope\ntransitive : forall A : Type, relation A -> Prop\nsymmetric : forall A : Type, relation A -> Prop\nreflexive : forall A : Type, relation A -> Prop"}, {"role": "assistant", "content": "```coq\nintros x y Hxy.\ninversion Hxy.\ntrivial.\nQed.\n```"}], "original": "intros x y Hxy. inversion Hxy. trivial.", "succ": true}]