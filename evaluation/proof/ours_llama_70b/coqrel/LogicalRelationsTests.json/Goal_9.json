[{"history": {"proof": "intros A a. reflexivity.", "repairs": ["", ""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall (A : Type) (a : A), a = a\n\nPremises:\nInductive GFormula (TA TX AA AF : Type) : Type := TT : Tauto.GFormula | FF : Tauto.GFormula | X : TX -> Tauto.GFormula | A : TA -> AA -> Tauto.GFormula | Cj : Tauto.GFormula -> Tauto.GFormula -> Tauto.GFormula | D : Tauto.GFormula -> Tauto.GFormula -> Tauto.GFormula | N : Tauto.GFormula -> Tauto.GFormula | I : Tauto.GFormula -> option AF -> Tauto.GFormula -> Tauto.GFormula Arguments Tauto.GFormula {TA TX AA AF}%type_scope Arguments Tauto.TT {TA TX AA AF}%type_scope Arguments Tauto.FF {TA TX AA AF}%type_scope Arguments Tauto.X {TA TX AA AF}%type_scope Arguments Tauto.A {TA TX AA AF}%type_scope Arguments Tauto.Cj {TA TX AA AF}%type_scope Arguments Tauto.D {TA TX AA AF}%type_scope Arguments Tauto.N {TA TX AA AF}%type_scope Arguments Tauto.I {TA TX AA AF\nVectorSpec.shiftin_last : forall (A : Type) (a : A) (n : nat) (v : VectorDef.t A n), VectorDef.last (VectorDef.shiftin a v) = a\nJMeq.JMeq_eq : forall (A : Type) (x y : A), JMeq.JMeq x y -> x = y\nlist_ind : forall (A : Type) (P : list A -> Prop), P nil -> (forall (a : A) (l : list A), P l -> P (a :: l)) -> forall l : list A, P l\nPeanoNat.Nat.shiftl_mul_pow2 : forall a n : nat, PeanoNat.Nat.shiftl a n = (a * PeanoNat.Nat.pow 2 n)%nat\nVectorDef.shiftin = fix shiftin (A : Type) (n : nat) (a : A) (v : VectorDef.t A n) {struct v} : VectorDef.t A (S n) := match v in (VectorDef.t _ n0) return (VectorDef.t A (S n0)) with | VectorDef.nil _ => VectorDef.cons A a 0 (VectorDef.nil A) | VectorDef.cons _ h n0 t => VectorDef.cons A h (S n0) (shiftin A n0 a t) end : forall (A : Type) (n : nat), A -> VectorDef.t A n -> VectorDef.t A (S n) Arguments VectorDef.shiftin {A}%type_scope {n}%nat_scope\nsplit_combine : forall (A B : Type) (l : list (A * B)), let (l1, l2) := split l in combine l1 l2 = l\nPeanoNat.Nat.mod_add : forall a b c : nat, c <> 0 -> PeanoNat.Nat.modulo (a + b * c) c = PeanoNat.Nat.modulo a c\nBinNat.N.ldiff_0_r : forall a : BinNums.N, BinNat.N.ldiff a BinNums.N0 = a\nPeanoNat.Nat.div_1_r : forall a : nat, PeanoNat.Nat.div a 1 = a\nPeanoNat.Nat.shiftl_0_r : forall a : nat, PeanoNat.Nat.shiftl a 0 = a\nZdiv.Zdiv_1_r : forall a : BinNums.Z, BinInt.Z.div a (BinNums.Zpos BinNums.xH) = a\nBinInt.Z.div_1_r : forall a : BinNums.Z, BinInt.Z.div a (BinNums.Zpos BinNums.xH) = a\nZnumtheory.prime_divisors : forall p : BinNums.Z, Znumtheory.prime p -> forall a : BinNums.Z, BinInt.Z.divide a p -> a = BinNums.Zneg BinNums.xH \\/ a = BinNums.Zpos BinNums.xH \\/ a = p \\/ a = BinInt.Z.opp p\nBinNat.N.bits_inj_0 : forall a : BinNums.N, (forall n : BinNums.N, BinNat.N.testbit a n = false) -> a = BinNums.N0\nBinInt.Z.lxor_eq : forall a a' : BinNums.Z, BinInt.Z.lxor a a' = BinNums.Z0 -> a = a'\nBinInt.Z.land_m1_r : forall a : BinNums.Z, BinInt.Z.land a (BinInt.Z.opp (BinNums.Zpos BinNums.xH)) = a\nBinInt.Z.land_m1_l : forall a : BinNums.Z, BinInt.Z.land (BinInt.Z.opp (BinNums.Zpos BinNums.xH)) a = a\nZdiv.Zdiv_0_l : forall a : BinNums.Z, BinInt.Z.div BinNums.Z0 a = BinNums.Z0\nPeanoNat.Nat.pow_0_r : forall a : nat, PeanoNat.Nat.pow a 0 = 1\nBinInt.Z.land_comm : forall a b : BinNums.Z, BinInt.Z.land a b = BinInt.Z.land b a\nPeanoNat.Nat.mod_small : forall a b : nat, a < b -> PeanoNat.Nat.modulo a b = a\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\nBinNat.N.div_mod' : forall a b : BinNums.N, a = BinNat.N.add (BinNat.N.mul b (BinNat.N.div a b)) (BinNat.N.modulo a b)\nBool.eqb_false_iff : forall a b : bool, Bool.eqb a b = false < -> a <> b\nZnumtheory.Zdivide_mod : forall a b : BinNums.Z, BinInt.Z.divide b a -> BinInt.Z.modulo a b = BinNums.Z0"}, {"role": "assistant", "content": "```coq\nintros A a.\nreflexivity.\nQed.```"}], "original": "intros A a. reflexivity.", "succ": true}]