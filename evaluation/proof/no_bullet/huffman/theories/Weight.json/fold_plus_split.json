[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros B l c f.", "induction l as [| x xs IHxs].", "-", "simpl.", "auto.", "-", "simpl."], "tactic": "rewrite <- IHxs.", "exn": "Found no subterm matching \"fold_left (fun (a : nat) (b : B) => a + f b) xs c\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros B l c f.", "induction l as [| x xs IHxs].", "-", "simpl.", "auto.", "-", "simpl.", "qsimpl."], "tactic": "rewrite fold_left_app.", "exn": "Found no subterm matching \"fold_left ?M1711 (?M1712 ++ ?M1713) ?M1714\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros B l c f.", "induction l as [| x xs IHxs].", "-", "simpl.", "auto.", "-", "simpl.", "qsimpl.", "qsimpl use: fold_left_app."], "tactic": "reflexivity.", "exn": "In environment H : forall (A B : Type) (f : A -> B -> A) (l l' : list B) (i : A), fold_left f (l ++ l') i = fold_left f l' (fold_left f l i) A : Type eqA_dec : forall a b : A, {a = b} + {a = b -> False} B : Type x : B xs : list B c : nat f : B -> nat IHxs : c + fold_left (fun (a : nat) (b : B) => a + f b) xs 0 = fold_left (fun (a : nat) (b : B) => a + f b) xs c Unable to unify \"fold_left (fun (a : nat) (b : B) => a + f b) xs (c + f x)\" with \"c + fold_left (fun (a : nat) (b : B) => a + f b) xs (f x)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros B l c f. induction l as [| x xs IHxs]. - simpl. auto. - simpl. rewrite <- IHxs. rewrite fold_left_app. reflexivity.", "succ": false}]