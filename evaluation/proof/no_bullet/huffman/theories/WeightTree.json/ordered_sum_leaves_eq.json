[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros A f l1 l2 H1 H2 H3."], "tactic": "apply (ordered_perm_antisym_eq _ _ (sum_order f) (exist_first_max (map (sum_leaves f) l1)) (exist_first_max (map (sum_leaves f) l2))).", "exn": "In environment A : Type f : A -> nat l1, l2 : list (btree A) H1 : permutation l1 l2 H2 : ordered (sum_order f) l1 H3 : ordered (sum_order f) l2 The term \"sum_order f\" has type \"btree A -> btree A -> Prop\" while it is expected to have type \"forall a b c : btree A, ?order a b -> ?order b c -> ?order a c\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros A f l1 l2 H1 H2 H3.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves."], "tactic": "apply permutation_map.", "exn": "In environment n : forall A : Type, (A -> nat) -> btree A -> nat H0 : forall l : list nat, (l = [] -> False) -> exists (a : nat) (l1 l2 : list nat), l = l1 ++ a :: l2 /\\\\ (forall n1 : nat, In n1 l1 -> n1 < a) /\\\\ (forall n1 : nat, In n1 l2 -> n1 <= a) H : forall (A : Type) (order : A -> A -> Prop), (forall a b c : A, order a b -> order b c -> order a c) -> (forall a b : A, order a b -> order b a -> a = b) -> forall l1 l2 : list A, permutation l1 l2 -> ordered order l1 -> ordered order l2 -> l1 = l2 X : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l : forall A B : Type, (A -> B) -> list A -> list B A : Type f : A -> nat l1, l2 : list (btree A) H1 : permutation l1 l2 H2 : ordered (sum_order f) l1 H3 : ordered (sum_order f) l2 Unable to unify \"permutation (map ?M2535 ?M2536) (map ?M2535 ?M2537)\" with \"l (btree A) nat (n A f) l1 = l (btree A) nat (n A f) l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A f l1 l2 H1 H2 H3.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves,permutation_map."], "tactic": "apply H1.", "exn": "In environment l0 : forall A B : Type, (A -> B) -> list A -> list B H6 : forall (A B : Type) (f : A -> B) (l1 l2 : list A), permutation l1 l2 -> permutation (l0 A B f l1) (l0 A B f l2) X1 : forall A : Type, (A -> nat) -> btree A -> nat H5 : forall l : list nat, (l = [] -> False) -> exists (a : nat) (l1 l2 : list nat), l = l1 ++ a :: l2 /\\\\ (forall n1 : nat, In n1 l1 -> n1 < a) /\\\\ (forall n1 : nat, In n1 l2 -> n1 <= a) H4 : forall (A : Type) (order : A -> A -> Prop), (forall a b c : A, order a b -> order b c -> order a c) -> (forall a b : A, order a b -> order b a -> a = b) -> forall l1 l2 : list A, permutation l1 l2 -> ordered order l1 -> ordered order l2 -> l1 = l2 X0 : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop n : forall A : Type, (A -> nat) -> btree A -> nat X : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l : forall A B : Type, (A -> B) -> list A -> list B A : Type f : A -> nat l1, l2 : list (btree A) H1 : permutation l1 l2 H2 : ordered (sum_order f) l1 H3 : ordered (sum_order f) l2 Unable to unify \"permutation l1 l2\" with \"l (btree A) nat (n A f) l1 = l (btree A) nat (n A f) l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A f l1 l2 H1 H2 H3.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves,permutation_map.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves,permutation_map."], "tactic": "apply H2.", "exn": "In environment l3 : forall A B : Type, (A -> B) -> list A -> list B H7 : forall (A B : Type) (f : A -> B) (l1 l2 : list A), permutation l1 l2 -> permutation (l3 A B f l1) (l3 A B f l2) X3 : forall A : Type, (A -> nat) -> btree A -> nat H0 : forall l : list nat, (l = [] -> False) -> exists (a : nat) (l1 l2 : list nat), l = l1 ++ a :: l2 /\\\\ (forall n1 : nat, In n1 l1 -> n1 < a) /\\\\ (forall n1 : nat, In n1 l2 -> n1 <= a) H : forall (A : Type) (order : A -> A -> Prop), (forall a b c : A, order a b -> order b c -> order a c) -> (forall a b : A, order a b -> order b a -> a = b) -> forall l1 l2 : list A, permutation l1 l2 -> ordered order l1 -> ordered order l2 -> l1 = l2 X2 : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l0 : forall A B : Type, (A -> B) -> list A -> list B H6 : forall (A B : Type) (f : A -> B) (l1 l2 : list A), permutation l1 l2 -> permutation (l0 A B f l1) (l0 A B f l2) X1 : forall A : Type, (A -> nat) -> btree A -> nat X0 : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop n : forall A : Type, (A -> nat) -> btree A -> nat X : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l : forall A B : Type, (A -> B) -> list A -> list B A : Type f : A -> nat l1, l2 : list (btree A) H1 : permutation l1 l2 H2 : ordered (sum_order f) l1 H3 : ordered (sum_order f) l2 Unable to unify \"ordered (sum_order f) l1\" with \"l (btree A) nat (n A f) l1 = l (btree A) nat (n A f) l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A f l1 l2 H1 H2 H3.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves,permutation_map.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves,permutation_map.", "qsimpl use: map,sum_order,ordered_perm_antisym_eq,exist_first_max,sum_leaves,permutation_map."], "tactic": "apply H3.", "exn": "In environment l4 : forall A B : Type, (A -> B) -> list A -> list B H8 : forall (A B : Type) (f : A -> B) (l1 l2 : list A), permutation l1 l2 -> permutation (l4 A B f l1) (l4 A B f l2) X5 : forall A : Type, (A -> nat) -> btree A -> nat H5 : forall l : list nat, (l = [] -> False) -> exists (a : nat) (l1 l2 : list nat), l = l1 ++ a :: l2 /\\\\ (forall n1 : nat, In n1 l1 -> n1 < a) /\\\\ (forall n1 : nat, In n1 l2 -> n1 <= a) H4 : forall (A : Type) (order : A -> A -> Prop), (forall a b c : A, order a b -> order b c -> order a c) -> (forall a b : A, order a b -> order b a -> a = b) -> forall l1 l2 : list A, permutation l1 l2 -> ordered order l1 -> ordered order l2 -> l1 = l2 X4 : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l3 : forall A B : Type, (A -> B) -> list A -> list B H7 : forall (A B : Type) (f : A -> B) (l1 l2 : list A), permutation l1 l2 -> permutation (l3 A B f l1) (l3 A B f l2) X3 : forall A : Type, (A -> nat) -> btree A -> nat X2 : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l0 : forall A B : Type, (A -> B) -> list A -> list B H6 : forall (A B : Type) (f : A -> B) (l1 l2 : list A), permutation l1 l2 -> permutation (l0 A B f l1) (l0 A B f l2) X1 : forall A : Type, (A -> nat) -> btree A -> nat X0 : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop n : forall A : Type, (A -> nat) -> btree A -> nat X : forall A : Type, (A -> nat) -> btree A -> btree A -> Prop l : forall A B : Type, (A -> B) -> list A -> list B A : Type f : A -> nat l1, l2 : list (btree A) H1 : permutation l1 l2 H2 : ordered (sum_order f) l1 H3 : ordered (sum_order f) l2 Unable to unify \"ordered (sum_order f) l2\" with \"l (btree A) nat (n A f) l1 = l (btree A) nat (n A f) l2\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros A f l1 l2 H1 H2 H3. apply (ordered_perm_antisym_eq _ _ (sum_order f) (exist_first_max (map (sum_leaves f) l1)) (exist_first_max (map (sum_leaves f) l2))). - apply permutation_map. apply H1. - apply H2. - apply H3.", "succ": false}]