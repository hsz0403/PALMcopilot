[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros l1 l2 l3 l4 H.", "induction l1 as [|a l1' IH].", "-", "simpl.", "destruct l2.", "+", "reflexivity.", "+", "discriminate.", "-", "simpl.", "destruct l2 as [|b l2'].", "+", "discriminate.", "+"], "tactic": "apply IH.", "exn": "In environment A : Type B : Type C : Type f : A -> B -> C a : A l1' : list A b : B l2' : list B l3 : list A l4 : list B H : length (a :: l1') = length (b :: l2') IH : length l1' = length (b :: l2') -> map2 (l1' ++ l3) ((b :: l2') ++ l4) = map2 l1' (b :: l2') ++ map2 l3 l4 Unable to unify \"map2 (l1' ++ l3) ((b :: l2') ++ l4) = map2 l1' (b :: l2') ++ map2 l3 l4\" with \"match (b :: l2') ++ l4 with | [] => [] | b :: l4 => f a b :: map2 (l1' ++ l3) l4 end = (f a b :: map2 l1' l2') ++ map2 l3 l4\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l1 l2 l3 l4 H. induction l1 as [|a l1' IH]. - simpl. destruct l2. + reflexivity. + discriminate. - simpl. destruct l2 as [|b l2']. + discriminate. + f_equal. apply IH.", "succ": false}]