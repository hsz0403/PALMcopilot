[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0."], "tactic": "apply permutation_nil.", "exn": "In environment A : Type l1 : list A H0 : In l1 (all_permutations_aux [] 0) H : [] = l1 Unable to unify \"permutation [] []\" with \"permutation l1 []\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+"], "tactic": "inversion H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq."], "tactic": "rewrite split_eq in H0.", "exn": "Found no subterm matching \"split_one l2\" in H0.", "type": "no_subterm", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq.", "qsimpl use: permutation_nil."], "tactic": "apply in_flat_map in H0.", "exn": "Unable to apply lemma of type \"forall (A B : Type) (f : A -> list B) (l : list A) (y : B), In y (flat_map f l) <-> (exists x : A, In x l /\\\\ In y (f x))\" on hypothesis of type \"In l1 (map (cons a) ((fix all_permutations_aux (l : list A) (n : nat) {struct n} : list (list A) := match n with | 0 => [[]] | S n1 => flat_map (fun p : A * list A => map (cons (fst p)) (all_permutations_aux (snd p) n1)) (split_one l) end) l2 (length l2)) ++ [])\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil,in_flat_map."], "tactic": "destruct H0 as [p [H1 H2]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map."], "tactic": "apply in_map_iff in H1.", "exn": "Unable to apply lemma of type \"forall (A B : Type) (f : A -> B) (l : list A) (y : B), In y (map f l) <-> (exists x : A, f x = y /\\\\ In x l)\" on hypothesis of type \"forall (A B : Type) (f : A -> list B) (l : list A) (y : B), (exists x : A, In x l /\\\\ In y (f x)) -> In y (flat_map f l)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map,in_map_iff."], "tactic": "destruct H1 as [p' [H3 H4]].", "exn": "Unable to find an instance for the variables A, B, f, l, y.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map,in_map_iff.", "qsimpl use: permutation_nil,in_flat_map,in_map_iff."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "intros l1 l2 H H0.", "destruct H.", "destruct l2.", "+", "inversion H0.", "qsimpl use: permutation_nil.", "shelve.", "+", "qsimpl use: permutation_nil.", "shelve.", "-", "intros l1 l2 H H0.", "destruct l2.", "+", "inversion H.", "+", "simpl in H0.", "unfold all_permutations_aux in H0.", "destruct (split_one l2) eqn:split_eq.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map.", "qsimpl use: permutation_nil,in_flat_map,in_map_iff.", "qsimpl use: permutation_nil,in_flat_map,in_map_iff.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros n. induction n. - intros l1 l2 H H0. destruct H. destruct l2. + inversion H0. apply permutation_nil. + inversion H. - intros l1 l2 H H0. destruct l2. + inversion H. + simpl in H0. unfold all_permutations_aux in H0. destruct (split_one l2) eqn:split_eq. rewrite split_eq in H0. apply in_flat_map in H0. destruct H0 as [p [H1 H2]]. apply in_map_iff in H1. destruct H1 as [p' [H3 H4]]. inversion H2. subst. clear H2. eapply (permutation_trans _ _ (map (cons (fst p')) (all_permutations_aux (snd p') n))). * apply permutation_trans with (l2 := map (cons (fst p')) (all_permutations_aux (snd p') (S n))). { eapply permutation_sind; try apply H4; try auto. - intros. apply in_map_iff in H2. destruct H2 as [a [H2 H3]]. subst. apply in_split in H3. destruct H3 as [l1 [l2 H3]]. rewrite H3. apply split_one_permutation. rewrite split_one_app. apply in_or_app. right. left. apply in_split. - apply permutation_skip. apply IHn. apply H4. } { apply permutation_swap. } * apply IHn. apply H1.", "succ": false}]