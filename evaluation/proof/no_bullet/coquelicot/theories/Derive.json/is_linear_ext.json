[{"history": {"proof": "intros l_eq l1_linear. qsimpl time: 1 use: is_linear. split. - intros x' y. qsimpl time: 1 use: linear_plus,is_linear. - scongruence depth: 3. - hauto lq: on depth: 3.", "repairs": ["", "not_evaluable", "", "", "used_var", "wrong_type", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros l_eq l1_linear."], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl time: 1 use: is_linear.", "split.", "-"], "tactic": "intros x y.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl time: 1 use: is_linear.", "split.", "-", "intros x' y."], "tactic": "rewrite <- (linear_plus l1 x y).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x linear_plus0 : forall x y : U, l1 (plus x y) = plus (l1 x) (l1 y) linear_scal0 : forall (k : K) (x : U), l1 (scal k x) = scal k (l1 x) x : R H0 : 0 < x H1 : forall x0 : U, norm (l1 x0) <= x * norm x0 x', y : U The term \"x\" has type \"R\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros l_eq l1_linear. unfold is_linear. split. - intros x y. rewrite <- (linear_plus l1 x y). rewrite -> (linear_plus l2 x y). apply f_equal, l_eq. - intros k x. rewrite <- (linear_scal l1 k x). rewrite -> (linear_scal l2 k x). apply f_equal, l_eq. - destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]]. destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]. exists (Rmax M1 M2). split. + apply Rmax_case_strong; auto. + intros x. specialize (norm_bound1 x). specialize (norm_bound2 x). apply Rle_trans with (r2 := M1 * norm x). * apply norm_bound1. * apply Rmult_le_compat_r; [apply Rmax_l | apply norm_bound2].", "succ": true}]