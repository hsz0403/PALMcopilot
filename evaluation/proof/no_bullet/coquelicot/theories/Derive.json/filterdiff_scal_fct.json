[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Hmult Hf Hg."], "tactic": "intros x0 P lH.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-"], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+"], "tactic": "intros x y.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus."], "tactic": "rewrite Hmult.", "exn": "The LHS of Hmult (mult _ _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear."], "tactic": "rewrite (Hf_linear x y).", "exn": "The reference Hf_linear was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear."], "tactic": "rewrite (Hg_linear x y).", "exn": "The reference Hg_linear was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear."], "tactic": "reflexivity.", "exn": "In environment K : AbsRing U, V : NormedModule K sort0 : Type c0 : NormedModule.class_of K sort0 T0 : Type x : sort0 f : sort0 -> K sort : Type c : NormedModule.class_of K sort T : Type g : sort0 -> sort lf : sort0 -> K lg : sort0 -> sort Hmult : forall n m : K, mult n m = mult m n Hf_dom : forall x0 : sort0, is_filter_lim (locally x) x0 -> is_domin (locally x) (fun y : sort0 => minus y x0) (fun y : sort0 => minus (minus (f y) (f x0)) (lf (minus y x0))) Hg_dom : forall x0 : sort0, is_filter_lim (locally x) x0 -> is_domin (locally x) (fun y : sort0 => minus y x0) (fun y : sort0 => minus (minus (g y) (g x0)) (lg (minus y x0))) H : Prop linear_plus0 : forall x y : sort0, lg (plus x y) = plus (lg x) (lg y) linear_scal0 : forall (k : K) (x : sort0), lg (scal k x) = scal k (lg x) x0 : R H1 : 0 < x0 H2 : forall x : sort0, norm (lg x) <= x0 * norm x linear_plus1 : forall x y : sort0, lf (plus x y) = plus (lf x) (lf y) linear_scal1 : forall (k : K) (x : sort0), lf (scal k x) = scal k (lf x) x1 : R H3 : 0 < x1 H4 : forall x : sort0, norm (lf x) <= x1 * norm x x', y : sort0 Unable to unify \"AbelianGroup.plus sort c (AbelianGroup.plus sort c (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (lf x') (g x)) (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (f x) (lg x'))) (AbelianGroup.plus sort c (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (lf y) (g x)) (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (f x) (lg y)))\" with \"AbelianGroup.plus sort c (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (lf (AbelianGroup.plus sort0 c0 x' y)) (g x)) (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (f x) (lg (AbelianGroup.plus sort0 c0 x' y)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus."], "tactic": "rewrite Hmult.", "exn": "The LHS of Hmult (mult _ _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear."], "tactic": "pose (HlH := Hf_dom t).", "exn": "In environment K : AbsRing U, V : NormedModule K sort0 : Type c0 : NormedModule.class_of K sort0 T0 : Type x : sort0 f : sort0 -> K sort : Type c : NormedModule.class_of K sort T : Type g : sort0 -> sort lf : sort0 -> K lg : sort0 -> sort Hmult : forall n m : K, mult n m = mult m n Hf_dom : forall x0 : sort0, is_filter_lim (locally x) x0 -> is_domin (locally x) (fun y : sort0 => minus y x0) (fun y : sort0 => minus (minus (f y) (f x0)) (lf (minus y x0))) Hg_dom : forall x0 : sort0, is_filter_lim (locally x) x0 -> is_domin (locally x) (fun y : sort0 => minus y x0) (fun y : sort0 => minus (minus (g y) (g x0)) (lg (minus y x0))) H : Prop linear_plus0 : forall x y : sort0, lg (plus x y) = plus (lg x) (lg y) linear_scal0 : forall (k : K) (x : sort0), lg (scal k x) = scal k (lg x) x0 : R H1 : 0 < x0 H2 : forall x : sort0, norm (lg x) <= x0 * norm x linear_plus1 : forall x y : sort0, lf (plus x y) = plus (lf x) (lf y) linear_scal1 : forall (k : K) (x : sort0), lf (scal k x) = scal k (lf x) x1 : R H3 : 0 < x1 H4 : forall x : sort0, norm (lf x) <= x1 * norm x t : K x2 : sort0 The term \"t\" has type \"AbsRing.sort K\" while it is expected to have type \"sort0\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear."], "tactic": "pose (HrH := Hg_dom t).", "exn": "In environment K : AbsRing U, V : NormedModule K sort0 : Type c0 : NormedModule.class_of K sort0 T0 : Type x : sort0 f : sort0 -> K sort : Type c : NormedModule.class_of K sort T : Type g : sort0 -> sort lf : sort0 -> K lg : sort0 -> sort Hmult : forall n m : K, mult n m = mult m n Hf_dom : forall x0 : sort0, is_filter_lim (locally x) x0 -> is_domin (locally x) (fun y : sort0 => minus y x0) (fun y : sort0 => minus (minus (f y) (f x0)) (lf (minus y x0))) Hg_dom : forall x0 : sort0, is_filter_lim (locally x) x0 -> is_domin (locally x) (fun y : sort0 => minus y x0) (fun y : sort0 => minus (minus (g y) (g x0)) (lg (minus y x0))) H : Prop linear_plus0 : forall x y : sort0, lg (plus x y) = plus (lg x) (lg y) linear_scal0 : forall (k : K) (x : sort0), lg (scal k x) = scal k (lg x) x0 : R H1 : 0 < x0 H2 : forall x : sort0, norm (lg x) <= x0 * norm x linear_plus1 : forall x y : sort0, lf (plus x y) = plus (lf x) (lf y) linear_scal1 : forall (k : K) (x : sort0), lf (scal k x) = scal k (lf x) x1 : R H3 : 0 < x1 H4 : forall x : sort0, norm (lf x) <= x1 * norm x t : K x2 : sort0 X : (V -> V) -> Prop The term \"t\" has type \"AbsRing.sort K\" while it is expected to have type \"sort0\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear."], "tactic": "destruct HlH as [HlH_incl HlH_dom].", "exn": "The reference HlH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom]."], "tactic": "destruct HrH as [HrH_incl HrH_dom].", "exn": "The reference HrH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom]."], "tactic": "split.", "exn": "Unable to find an instance for the variable sort.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*"], "tactic": "intros eps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*"], "tactic": "specialize (HlH_incl eps).", "exn": "The reference HlH_incl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*"], "tactic": "intros Hlim.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*"], "tactic": "apply HlH_incl in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear."], "tactic": "unfold is_domin in HlH_dom.", "exn": "No such hypothesis: HlH_dom", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear."], "tactic": "apply HlH_dom in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear."], "tactic": "unfold minus, scal, plus in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "rewrite Hmult in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "apply Hlim.", "exn": "The reference Hlim was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros eps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "specialize (HrH_incl eps).", "exn": "The reference HrH_incl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros Hlim.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply HrH_incl in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "unfold is_domin in HrH_dom.", "exn": "No such hypothesis: HrH_dom", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "apply HrH_dom in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "unfold minus, scal, plus in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hmult Hf Hg.", "destruct Hf as [Hf_linear Hf_dom].", "destruct Hg as [Hg_linear Hg_dom].", "split.", "-", "qsimpl use: is_linear.", "split.", "+", "intros x' y.", "unfold scal, plus.", "qsimpl use: is_linear.", "shelve.", "+", "intros t.", "unfold scal, plus.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "qsimpl use: is_linear.", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "destruct prod_AbelianGroup as [prod_AbelianGroup_incl prod_AbelianGroup_dom].", "qsimpl use: is_linear.", "*", "qsimpl use: is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: is_domin,is_linear.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal.", "qsimpl use: plus,minus,is_domin,is_linear,scal."], "tactic": "rewrite Hmult in Hlim.", "exn": "No such hypothesis: Hlim", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros Hmult Hf Hg. intros x0 P lH. destruct Hf as [Hf_linear Hf_dom]. destruct Hg as [Hg_linear Hg_dom]. split. - unfold is_linear. split. + intros x y. unfold scal, plus. rewrite Hmult. rewrite (Hf_linear x y). rewrite (Hg_linear x y). reflexivity. + intros t. unfold scal, plus. rewrite Hmult. pose (HlH := Hf_dom t). pose (HrH := Hg_dom t). destruct HlH as [HlH_incl HlH_dom]. destruct HrH as [HrH_incl HrH_dom]. split. * intros eps. specialize (HlH_incl eps). intros Hlim. apply HlH_incl in Hlim. unfold is_domin in HlH_dom. apply HlH_dom in Hlim. unfold minus, scal, plus in Hlim. rewrite Hmult in Hlim. apply Hlim. * intros eps. specialize (HrH_incl eps). intros Hlim. apply HrH_incl in Hlim. unfold is_domin in HrH_dom. apply HrH_dom in Hlim. unfold minus, scal, plus in Hlim. rewrite Hmult in Hlim. apply Hlim.", "succ": false}]