[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal."], "tactic": "rewrite linear_plus.", "exn": "The LHS of linear_plus (_ (plus _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal.", "qsimpl use: linear_plus."], "tactic": "reflexivity.", "exn": "In environment K : AbsRing sort : Type c : NormedModule.class_of K sort T : Type x : sort x0, y : K H : forall l : NormedModule.Pack K sort c T -> NormedModule.Pack K sort c T, is_linear l -> forall x y : NormedModule.Pack K sort c T, l (plus x y) = plus (l x) (l y) sort0 : Type X0 : Type base : NormedModuleAux.class_of K sort0 norm : sort0 -> R norm_factor : R ax1 : forall x y : sort0, norm (plus x y) <= norm x + norm y ax2 : forall (l : K) (x : sort0), norm (scal l x) <= abs l * norm x ax3 : forall (x y : sort0) (eps : R), norm (minus y x) < eps -> ball x eps y ax4 : forall (x y : sort0) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ax5 : forall x : sort0, norm x = 0 -> x = zero Unable to unify \"plus (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c x0 x) (ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c y x)\" with \"ModuleSpace.scal K (AbelianGroup.Pack sort c sort) c (plus x0 y) x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal.", "qsimpl use: linear_plus."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal.", "qsimpl use: linear_plus.", "shelve.", "-", "intros.", "unfold scal.", "rewrite linear_scal."], "tactic": "reflexivity.", "exn": "In environment K : AbsRing V : NormedModule K x : V k : K x0 : AbsRing_NormedModule K Unable to unify \"scal x0 (ModuleSpace.scal K (AbelianGroup.Pack V (ModuleSpace.class K V) V) (ModuleSpace.class K V) k x)\" with \"ModuleSpace.scal K (AbelianGroup.Pack V (ModuleSpace.class K V) V) (ModuleSpace.class K V) (ModuleSpace.scal K (AbelianGroup.Pack (AbsRing_NormedModule K) (ModuleSpace.class K (AbsRing_NormedModule K)) (AbsRing_NormedModule K)) (ModuleSpace.class K (AbsRing_NormedModule K)) k x0) x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal.", "qsimpl use: linear_plus.", "shelve.", "-", "intros.", "unfold scal.", "rewrite linear_scal."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal.", "qsimpl use: linear_plus.", "shelve.", "-", "intros.", "unfold scal.", "rewrite linear_scal.", "+", "shelve.", "+", "shelve.", "-", "exists 1.", "split.", "+", "apply Rlt_0_1.", "+", "intros."], "tactic": "rewrite scal_one.", "exn": "The LHS of scal_one (scal one _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["apply Build_is_linear.", "-", "intros.", "unfold scal.", "qsimpl use: linear_plus.", "shelve.", "-", "intros.", "unfold scal.", "rewrite linear_scal.", "+", "shelve.", "+", "shelve.", "-", "exists 1.", "split.", "+", "apply Rlt_0_1.", "+", "intros.", "qsimpl use: scal_one,linear_plus."], "tactic": "apply Rle_refl.", "exn": "In environment K : AbsRing V : NormedModule K x : V x0 : K H0 : forall l : V -> V, is_linear l -> forall x y : V, l (plus x y) = plus (l x) (l y) H : forall u : ?V, scal one u = u Unable to unify \"1 * norm x0\" with \"norm (scal x0 x)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "apply Build_is_linear. - intros. unfold scal. rewrite linear_plus. reflexivity. - intros. unfold scal. rewrite linear_scal. reflexivity. - exists 1. split. + apply Rlt_0_1. + intros. rewrite scal_one. apply Rle_refl.", "succ": false}]