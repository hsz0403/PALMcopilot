[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx."], "tactic": "rewrite SF_rev_surj.", "exn": "The LHS of SF_rev_surj (SF_rev _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx.", "qsimpl use: SF_rev_surj."], "tactic": "rewrite SF_sup_ly.", "exn": "The LHS of SF_sup_ly (SF_ly (SF_sup_seq _ _ _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx.", "qsimpl use: SF_rev_surj.", "qsimpl use: SF_sup_ly,SF_rev_surj."], "tactic": "rewrite rev_unif_part.", "exn": "The reference rev_unif_part was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold SF_sup_seq.", "unfold SF_rev.", "unfold SF_make.", "unfold SF_seq_f2.", "unfold Sup_fct.", "unfold unif_part.", "rewrite SF_sup_lx.", "qsimpl use: SF_rev_surj.", "qsimpl use: SF_sup_ly,SF_rev_surj."], "tactic": "reflexivity.", "exn": "In environment f : R -> R a, b : R n : nat H : forall s s0 : SF_seq, s = s0 -> SF_rev s = SF_rev s0 e : a + 0 * (b - a) / (INR n + 1) = a + 1 * (b - a) / (INR n + 1) Heqs : Req_EM_T (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1)) = left e e0 : b + 0 * (a - b) / (INR n + 1) = b + 1 * (a - b) / (INR n + 1) Heqs0 : Req_EM_T (b + 0 * (a - b) / (INR n + 1)) (b + 1 * (a - b) / (INR n + 1)) = left e0 H1 : forall s s0 : SF_seq, s = s0 -> SF_rev s = SF_rev s0 H0 : forall (f : R -> R) (a b : R) (n : nat), SF_ly (SF_sup_seq f a b n) = Sup_fct f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1)) :: pairmap (Sup_fct f) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] Unable to unify \"{| SF_h := b + 0 * (a - b) / (INR n + 1); SF_t := (b + 1 * (a - b) / (INR n + 1), 0) :: pairmap (fun x y : R => (y, if Req_EM_T x y then 0 else Lub_Rbar (fun y0 : R => exists x0 : R, y0 = f x0 /\\\\ Rmin x y < x0 < Rmax x y))) (b + 1 * (a - b) / (INR n + 1)) [seq b + INR i * (a - b) / (INR n + 1) | i <- seq.iota 2 n] |}\" with \"{| SF_h := head 0 (rev (unif_part a b n)); SF_t := zip (behead (rev (unif_part a b n))) (rev (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), 0) :: pairmap (fun x y : R => (y, if Req_EM_T x y then 0 else Lub_Rbar (fun y0 : R => exists x0 : R, y0 = f x0 /\\\\ Rmin x y < x0 < Rmax x y))) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |})) |}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold SF_sup_seq. unfold SF_rev. unfold SF_make. unfold SF_seq_f2. unfold Sup_fct. unfold unif_part. rewrite SF_sup_lx. rewrite SF_rev_surj. rewrite SF_sup_ly. simpl. rewrite rev_unif_part. reflexivity.", "succ": false}]