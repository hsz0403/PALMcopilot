[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold Riemann_sum.", "simpl."], "tactic": "rewrite Riemann_sum_cons.", "exn": "The LHS of Riemann_sum_cons (Riemann_sum _ (SF_cons _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "simpl.", "qsimpl use: Riemann_sum_cons.", "unfold plus, scal."], "tactic": "rewrite scal_distr_r.", "exn": "The LHS of scal_distr_r (scal (plus _ _) _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "simpl.", "qsimpl use: Riemann_sum_cons.", "unfold plus, scal.", "qsimpl use: scal_distr_r,Riemann_sum_cons."], "tactic": "rewrite scal_distr_l.", "exn": "The LHS of scal_distr_l (scal _ (plus _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "simpl.", "qsimpl use: Riemann_sum_cons.", "unfold plus, scal.", "qsimpl use: scal_distr_r,Riemann_sum_cons.", "qsimpl use: scal_distr_l,scal_distr_r,Riemann_sum_cons."], "tactic": "reflexivity.", "exn": "In environment V : ModuleSpace R_Ring H3 : forall (f : R -> V) (h0 : R * R) (ptd : SF_seq), Riemann_sum f (SF_cons h0 ptd) = plus (scal (SF_h ptd - fst h0) (f (snd h0))) (Riemann_sum f ptd) f : R -> V ptd : SF_seq l1, l2 : R H0 : forall (x y : ?K) (u : ?V), scal (plus x y) u = plus (scal x u) (scal y u) H2 : forall (x y : ?K0) (u : ?V0), scal (plus x y) u = plus (scal x u) (scal y u) H : forall (x : ?K1) (u v : ?V1), scal x (plus u v) = plus (scal x u) (scal x v) Unable to unify \"AbelianGroup.plus V (ModuleSpace.class R_Ring V) (foldr (AbelianGroup.plus V (ModuleSpace.class R_Ring V)) zero (pairmap (fun x y : R * R => ModuleSpace.scal R_Ring (AbelianGroup.Pack V (ModuleSpace.class R_Ring V) V) (ModuleSpace.class R_Ring V) (fst y - fst x) (f (snd y))) (SF_h ptd, zero) (SF_t ptd))) (ModuleSpace.scal R_Ring (AbelianGroup.Pack V (ModuleSpace.class R_Ring V) V) (ModuleSpace.class R_Ring V) (l1 - last (SF_h ptd) (unzip1 (SF_t ptd))) (f l2))\" with \"foldr (AbelianGroup.plus V (ModuleSpace.class R_Ring V)) zero (pairmap (fun x y : R * R => ModuleSpace.scal R_Ring (AbelianGroup.Pack V (ModuleSpace.class R_Ring V) V) (ModuleSpace.class R_Ring V) (fst y - fst x) (f (snd y))) (SF_h ptd, zero) (rcons (SF_t ptd) (l1, l2)))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold Riemann_sum. simpl. rewrite Riemann_sum_cons. unfold plus, scal. rewrite scal_distr_r. rewrite scal_distr_l. reflexivity.", "succ": false}]