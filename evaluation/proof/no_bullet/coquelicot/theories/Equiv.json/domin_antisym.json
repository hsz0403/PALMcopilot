[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros T K V F FF f Hf Hd.", "exn": "T is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' K V F FF f Hf Hd.", "exn": "K is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' K' V F FF f Hf Hd.", "exn": "V is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' K' V' F FF f Hf Hd.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_domin."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}]}, "chat": [], "original": "intros T K V F FF f Hf Hd. unfold is_domin. intros H. destruct (ClassicalFacts.F (fun x => norm (f x) = 0) H). - apply Hd. intros eps. apply H0. exists eps. intros x y Hxy. apply Rnot_lt_le. intro Hf. apply H. apply Rle_not_lt. split. + apply norm_pos. + rewrite Hxy. apply norm_zero. - apply Hf. apply not_all_ex_not in H0 as [x Hx]. apply imply_to_and in Hx as [H1 H2]. exists x. intros y1 y2 Hy1 Hy2. apply eq_R_norm. rewrite <- H2. apply Rle_antisym. + apply norm_triangle with (f y1) (minus (f y1) (f x)). + rewrite Hy2. apply norm_zero.", "succ": false}]