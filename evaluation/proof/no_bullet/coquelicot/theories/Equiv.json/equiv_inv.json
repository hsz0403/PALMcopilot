[{"history": {"proof": "qsimpl time: 1 use: Rinv_mult_distr. qsimpl time: 1 use: Rinv_mult_distr. qsimpl time: 1 use: Rinv_mult_distr,domin_mult. qsimpl time: 1 use: Rinv_mult_distr,domin_mult. qsimpl time: 1 use: Rinv_mult_distr,domin_mult. qsimpl time: 1 use: domin_mult_l,Rinv_mult_distr,domin_mult. qsimpl time: 1 use: domin_mult_l,Rinv_mult_distr,domin_mult. qsimpl time: 1 use: domin_mult_l,Rinv_mult_distr,domin_mult.", "repairs": ["no_match_term", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *."], "tactic": "intros x.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *."], "tactic": "rewrite Rinv_mult_distr.", "exn": "The LHS of Rinv_mult_distr (/ (_ * _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr."], "tactic": "apply HF.", "exn": "In environment H : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q Unable to unify \"is_domin F g (fun x : T => minus (g x) (f x))\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr."], "tactic": "apply domin_mult.", "exn": "In environment H0 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q Unable to unify \"forall eps : posreal, ?F (fun x : ?T => norm ((fun x0 : ?T => ?M2998 x0 * ?M2999 x0) x) <= eps * norm ((fun x0 : ?T => ?M2996 x0 * ?M2997 x0) x))\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult."], "tactic": "apply domin_is_equiv.", "exn": "In environment H0 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q H1 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) Unable to unify \"posreal\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult."], "tactic": "apply HF.", "exn": "In environment H0 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q H1 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) H2 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) Unable to unify \"is_domin F g (fun x : T => minus (g x) (f x))\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult."], "tactic": "apply domin_mult_l.", "exn": "In environment H0 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q H1 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) H3 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) Unable to unify \"forall eps : posreal, ?F (fun x : ?T => norm ((fun x0 : ?T => ?M5290 x0 * ?M5289 x0) x) <= eps * norm ((fun x0 : ?T => ?M5290 x0 * ?M5288 x0) x))\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: domin_mult_l,Rinv_mult_distr,domin_mult."], "tactic": "apply domin_is_equiv.", "exn": "In environment H0 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q H1 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) H4 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) H : forall f g h : T -> R, is_domin F f g -> is_domin F (fun x : T => h x * f x) (fun x : T => h x * g x) Unable to unify \"posreal\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros T F Hfilter f g Hfg HF domin_is_equiv.", "unfold is_equiv in *.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: domin_mult_l,Rinv_mult_distr,domin_mult.", "qsimpl time: 1 use: domin_mult_l,Rinv_mult_distr,domin_mult."], "tactic": "apply HF.", "exn": "In environment H0 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> / (r1 * r2) = / r1 * / r2 T : Type F : (T -> Prop) -> Prop f, g : T -> R Hfg : F (fun x : T => g x = 0 -> False) HF : is_domin F g (fun x : T => minus (g x) (f x)) domin_is_equiv : posreal filter_true : F (fun _ : T => True) filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) filter_imp : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q H1 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) H : forall f g h : T -> R, is_domin F f g -> is_domin F (fun x : T => h x * f x) (fun x : T => h x * g x) H5 : forall f1 f2 g1 g2 : T -> R, is_domin F f1 g1 -> is_domin F f2 g2 -> is_domin F (fun x : T => f1 x * f2 x) (fun x : T => g1 x * g2 x) H2 : forall f g h : T -> R, is_domin F f g -> is_domin F (fun x : T => h x * f x) (fun x : T => h x * g x) Unable to unify \"is_domin F g (fun x : T => minus (g x) (f x))\" with \"F (fun x : T => norm (minus (/ g x) (/ f x)) <= domin_is_equiv * norm (/ g x))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros T F Hfilter f g Hfg HF domin_is_equiv. unfold is_equiv in *. intros x. unfold Rdiv. rewrite Rinv_mult_distr. apply HF. apply domin_mult. apply domin_is_equiv. apply HF. apply domin_mult_l. apply domin_is_equiv. apply HF.", "succ": false}]