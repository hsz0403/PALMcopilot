[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-"], "tactic": "apply filter_and.", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal Unable to unify \"?F ?M2367\" with \"T\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and."], "tactic": "apply equiv_carac_0.", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal H0 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) x : T H1 : norm (g x) <= sqrt eps * norm (f x) Unable to unify \"{o : T -> V | (forall x : T, ?M2614 x = plus (?M2615 x) (o x)) /\\\\ is_domin ?F ?M2615 o}\" with \"norm (minus (g x) (f x)) < eps * norm (g x) \\\\/ norm (minus (g x) (f x)) = eps * norm (g x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0."], "tactic": "intros x y H0 H1.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0."], "tactic": "intros x' y H0 H1.", "exn": "H0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0."], "tactic": "intros x' y H0' H1.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0."], "tactic": "intros x' y H0' H1'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0."], "tactic": "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal H0 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) x : T H1 : norm (g x) <= sqrt eps * norm (f x) X : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H2 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) Unable to unify \"?F\" with \"Rle (norm (minus (g x) (f x)))\" (unable to find a well-typed instantiation for \"?F\": cannot ensure that \"R -> Prop\" is a subtype of \"(T -> Prop) -> Prop\").", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0."], "tactic": "apply filter_imp with (fun x : T => norm (f x) <= sqrt eps * norm (g x)).", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal H0 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) x : T H1 : norm (g x) <= sqrt eps * norm (f x) X : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} X1 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H5 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q X0 : V -> R H4 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) Unable to unify \"?F\" with \"Rle (norm (minus (g x) (f x)))\" (unable to find a well-typed instantiation for \"?F\": cannot ensure that \"R -> Prop\" is a subtype of \"(T -> Prop) -> Prop\").", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0."], "tactic": "apply equiv_carac_0.", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal H0 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) x : T H1 : norm (g x) <= sqrt eps * norm (f x) X, X1 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H5 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q X0 : V -> R X3 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H6 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q X2 : V -> R H3 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) Unable to unify \"{o : T -> V | (forall x : T, ?M5025 x = plus (?M5026 x) (o x)) /\\\\ is_domin ?F ?M5026 o}\" with \"norm (minus (g x) (f x)) < eps * norm (g x) \\\\/ norm (minus (g x) (f x)) = eps * norm (g x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0."], "tactic": "apply filter_and.", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal H0 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) x : T H1 : norm (g x) <= sqrt eps * norm (f x) X, X1 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H5 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q X0 : V -> R X3 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} X2 : V -> R X5 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H7 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q X4 : V -> R H4 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) Unable to unify \"?F (fun x : ?T => ?M6432 x /\\\\ ?M6433 x)\" with \"norm (minus (g x) (f x)) < eps * norm (g x) \\\\/ norm (minus (g x) (f x)) = eps * norm (g x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0."], "tactic": "apply equiv_le_2.", "exn": "Found no subterm matching \"fun x0 : ?T => norm (?M8026 x0) <= 2 * norm (?M8025 x0) /\\\\ norm (?M8025 x0) <= 2 * norm (?M8026 x0)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0."], "tactic": "apply equiv_le_2.", "exn": "Found no subterm matching \"fun x0 : ?T => norm (?M10028 x0) <= 2 * norm (?M10027 x0) /\\\\ norm (?M10027 x0) <= 2 * norm (?M10028 x0)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0."], "tactic": "apply equiv_carac_1.", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal H0 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) x : T H1 : norm (g x) <= sqrt eps * norm (f x) X, X1 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H5 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q X0 : V -> R X3 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} X2 : V -> R X5 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} X4 : V -> R X7 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} X6 : V -> R X9 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H7 : forall F : (T -> Prop) -> Prop, Filter F -> forall f g : T -> V, is_equiv F f g -> F (fun x : T => norm (g x) <= 2 * norm (f x) /\\\\ norm (f x) <= 2 * norm (g x)) X8 : V -> R X11 : forall f g : T -> V, is_equiv F f g -> {o : T -> V | (forall x : T, f x = plus (g x) (o x)) /\\\\ is_domin F g o} H9 : forall P Q : T -> Prop, (forall x : T, P x -> Q x) -> F P -> F Q H6 : forall F : (T -> Prop) -> Prop, Filter F -> forall f g : T -> V, is_equiv F f g -> F (fun x : T => norm (g x) <= 2 * norm (f x) /\\\\ norm (f x) <= 2 * norm (g x)) X10 : V -> R H3 : forall P Q : T -> Prop, F P -> F Q -> F (fun x : T => P x /\\\\ Q x) Unable to unify \"forall eps0 : posreal, ?F (fun x : T => norm ((fun x0 : T => minus (?M12366 x0) (?M12365 x0)) x) <= eps0 * norm (?M12366 x))\" with \"norm (minus (g x) (f x)) < eps * norm (g x) \\\\/ norm (minus (g x) (f x)) = eps * norm (g x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "-", "apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)).", "+"], "tactic": "apply equiv_carac_0.", "exn": "In environment T : Type K : AbsRing V : NormedModule K F : (T -> Prop) -> Prop FF : Filter F f, g : T -> V H : F (fun x : T => f x = g x) eps : posreal Unable to unify \"T -> V\" with \"T\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "-", "apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)).", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "-", "apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)).", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "+"], "tactic": "intros x H0.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "-", "apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)).", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "+"], "tactic": "apply H in H0.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "-", "apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)).", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1."], "tactic": "unfold ball_norm in H0.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros H.", "unfold is_equiv, is_domin.", "intros eps.", "apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)).", "-", "qsimpl time: 1 use: filter_and.", "qsimpl time: 1 use: filter_and,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "-", "apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)).", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "shelve.", "+", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,equiv_carac_1.", "qsimpl time: 1 use: sqrt,filter_and,norm,equiv_le_2,filter_imp,equiv_carac_0,ball_norm,equiv_carac_1."], "tactic": "apply H0.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros H. unfold is_equiv, is_domin. intros eps. apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)). - apply filter_and. + apply equiv_carac_0. + intros x y H0 H1. apply filter_imp with (fun x : T => norm (g x) <= sqrt eps * norm (f x)). * apply filter_imp with (fun x : T => norm (f x) <= sqrt eps * norm (g x)). ++ apply equiv_carac_0. ++ apply filter_and. -- apply equiv_le_2. -- apply equiv_le_2. * apply equiv_carac_1. - apply filter_imp with (fun x : T => norm (minus (g x) (f x)) <= eps * norm (f x)). + apply equiv_carac_0. + intros x H0. apply H in H0. unfold ball_norm in H0. apply H0.", "succ": false}]