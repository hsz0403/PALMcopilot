[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Hlimf Hlimg Hplus.", "unfold is_lim in *.", "unfold is_Rbar_plus in *."], "tactic": "intros P [HP1 HP2].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Hlimf Hlimg Hplus.", "unfold is_lim in *.", "unfold is_Rbar_plus in *."], "tactic": ["apply filterlim_comp_2 with (f0 := (fun y : R => f y)) (g0 := (fun y : R => g y)) (h := Rplus) (H := Rbar_locally lf) (I := Rbar_locally l).", ""], "exn": "No such bound variable H (possible names are: f0, g0 and h).", "type": "no_such_bound", "handled": false}]}, "chat": [], "original": "intros Hlimf Hlimg Hplus. unfold is_lim in *. unfold is_Rbar_plus in *. intros P [HP1 HP2]. apply filterlim_comp_2 with (f0 := (fun y : R => f y)) (g0 := (fun y : R => g y)) (h := Rplus) (H := Rbar_locally lf) (I := Rbar_locally l). - apply filterlim_ext_loc with (f0 := (fun y : R => f y)) (g0 := (fun y : R => f y) + (fun y : R => g y)). + intros x0. unfold Rplus. reflexivity. + apply Hlimf. + apply HP1. - apply filterlim_ext_loc with (f0 := (fun y : R => g y)) (g0 := (fun y : R => f y) + (fun y : R => g y)). + intros x0. unfold Rplus. rewrite Rplus_comm. reflexivity. + apply Hlimg. + apply HP2. - apply filterlim_Rbar_plus. apply Hplus.", "succ": false}]