[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *."], "tactic": "unfold is_RInt_point, ex_RInt in *.", "exn": "Cannot coerce is_RInt_point to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt."], "tactic": "unfold ex_RInt_point in *.", "exn": "Cannot coerce ex_RInt_point to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt."], "tactic": "unfold Rminus_le_0, Rle_minus_l in *.", "exn": "Cannot coerce Rminus_le_0 to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps)."], "tactic": "intros P [eps_pos P_eps].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros."], "tactic": "specialize (H (eps / 2)).", "exn": "In environment V : NormedModule R_AbsRing H4 : forall (f : R -> V) (a : R), is_RInt f a a zero H0 : forall (f : R -> V) (a : R), ex_RInt f a a f : R -> V a, b : R If : V eps : V -> Prop H : locally If eps -> filtermap (fun ptd : SF_seq => scal (sign (a - b)) (Riemann_sum f ptd)) (Riemann_fine b a) eps X0, X1, X2 : Prop H1 : forall a b : R, 0 <= b - a -> a <= b H2 : forall a b : R, a <= b -> 0 <= b - a H3 : forall a b c : R, a <= b + c -> a - c <= b H5 : forall a b c : R, a - c <= b -> a <= b + c H6 : locally (AbelianGroup.opp V (AbelianGroup.class V) If) eps The term \"eps\" has type \"V -> Prop\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "assert (Heps2_pos : 0 < eps / 2) by lra.", "exn": "In environment V : NormedModule R_AbsRing H9 : forall (f : R -> V) (a : R), is_RInt f a a zero H7 : forall (f : R -> V) (a : R), ex_RInt f a a f : R -> V a, b : R If : V eps : V -> Prop H : locally If eps -> filtermap (fun ptd : SF_seq => scal (sign (a - b)) (Riemann_sum f ptd)) (Riemann_fine b a) eps X0, X1, X2 : Prop H1 : forall a b : R, 0 <= b - a -> a <= b H2 : forall a b : R, a <= b -> 0 <= b - a H3 : forall a b c : R, a <= b + c -> a - c <= b H5 : forall a b c : R, a - c <= b -> a <= b + c X3 : Prop x : posreal H0 : forall y : V, ball (AbelianGroup.opp V (NormedModule.class R_AbsRing V) If) x y -> eps y The term \"eps\" has type \"V -> Prop\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "specialize (H Heps2_pos).", "exn": "The reference Heps2_pos was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "destruct H as [delta [delta_pos H]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "exists delta.", "exn": "The reference delta was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "split; auto.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "intros c Hc.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l."], "tactic": "apply P_eps.", "exn": "The reference P_eps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "qsimpl use: is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,is_RInt_point,ex_RInt.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "qsimpl use: ex_RInt_point,ex_RInt,Rminus_le_0,is_RInt_point,Rle_minus_l.", "apply last."], "tactic": "apply H.", "exn": "In environment V : NormedModule R_AbsRing H8 : forall (f : R -> V) (a : R), is_RInt f a a zero H4 : forall (f : R -> V) (a : R), ex_RInt f a a f : R -> V a, b : R If : V eps : V -> Prop H : locally If eps -> filtermap (fun ptd : SF_seq => scal (sign (a - b)) (Riemann_sum f ptd)) (Riemann_fine b a) eps X0, X1, X2 : Prop H1 : forall a b : R, 0 <= b - a -> a <= b H2 : forall a b : R, a <= b -> 0 <= b - a H3 : forall a b c : R, a <= b + c -> a - c <= b H5 : forall a b c : R, a - c <= b -> a <= b + c X3 : Prop x : posreal H0 : forall y : V, ball (AbelianGroup.opp V (NormedModule.class R_AbsRing V) If) x y -> eps y X4, X5, X6 : Prop Unable to unify \"filtermap (fun ptd : SF_seq => scal (sign (a - b)) (Riemann_sum f ptd)) (Riemann_fine b a) eps\" with \"filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b) eps\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros f a b If H. unfold is_RInt in *. unfold filterlim in *. unfold is_RInt_point, ex_RInt in *. unfold ex_RInt_point in *. unfold Rminus_le_0, Rle_minus_l in *. unfold opp. unfold filterlim. intros eps. specialize (H eps). intros P [eps_pos P_eps]. specialize (H (eps / 2)). assert (Heps2_pos : 0 < eps / 2) by lra. specialize (H Heps2_pos). destruct H as [delta [delta_pos H]]. exists delta. split; auto. intros c Hc. apply P_eps. apply H. auto.", "succ": false}]