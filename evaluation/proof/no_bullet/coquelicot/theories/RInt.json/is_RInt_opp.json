[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *."], "tactic": "apply (filterlim_comp _ _ _ _ _ (Riemann_sum f) _ loc_AbsRing).", "exn": "The reference loc_AbsRing was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *."], "tactic": "apply (is_RInt_comp_opp _ _ _ _ H).", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a, b : R If : V H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) The term \"H\" has type \"filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If)\" while it is expected to have type \"is_RInt ?f (- ?a) (- ?b) If\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *.", "qsimpl use: is_RInt_comp_opp."], "tactic": "apply (filterlim_locally_ball_norm _ _ _ _ _ _ loc_AbsRing).", "exn": "The reference loc_AbsRing was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *.", "qsimpl use: is_RInt_comp_opp.", "intros eps."], "tactic": "exists eps.", "exn": "In environment V : NormedModule R_AbsRing H0 : forall (f : R -> V) (a b : R) (l : V), is_RInt f (- a) (- b) l -> is_RInt (fun y : R => opp (f (- y))) a b l f : R -> V a, b : R If : V H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) eps : V -> Prop H1 : locally (AbelianGroup.opp V (NormedModule.class R_AbsRing V) If) eps The term \"eps\" has type \"V -> Prop\" while it is expected to have type \"posreal\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *.", "qsimpl use: is_RInt_comp_opp.", "intros eps.", "qsimpl use: is_RInt_comp_opp."], "tactic": "intros y Hball.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *.", "qsimpl use: is_RInt_comp_opp.", "intros eps.", "qsimpl use: is_RInt_comp_opp."], "tactic": "unfold ball_norm in Hball.", "exn": "No such hypothesis: Hball", "type": "no_hypos", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp in *.", "qsimpl use: is_RInt_comp_opp.", "intros eps.", "qsimpl use: is_RInt_comp_opp.", "qsimpl use: is_RInt_comp_opp,ball_norm."], "tactic": "apply Hball.", "exn": "The reference Hball was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros f a b If H. unfold is_RInt in *. unfold filterlim in *. unfold opp in *. apply (filterlim_comp _ _ _ _ _ (Riemann_sum f) _ loc_AbsRing). - apply (is_RInt_comp_opp _ _ _ _ H). - apply (filterlim_locally_ball_norm _ _ _ _ _ _ loc_AbsRing). intros eps. exists eps. intros y Hball. unfold ball_norm in Hball. apply Hball.", "succ": false}]