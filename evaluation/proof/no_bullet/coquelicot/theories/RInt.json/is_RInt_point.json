[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a.", "unfold is_RInt."], "tactic": "apply filterlim_ext.", "exn": "Unable to find an instance for the variable f.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f a.", "unfold is_RInt.", "qsimpl use: filterlim_ext.", "intros ptd.", "unfold Riemann_sum.", "unfold locally."], "tactic": "unfold filterMap.", "exn": "The reference filterMap was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a.", "unfold is_RInt.", "qsimpl use: filterlim_ext.", "intros ptd.", "unfold Riemann_sum.", "unfold locally.", "unfold Riemann_fine.", "simpl.", "intros.", "unfold plus.", "unfold zero.", "unfold scal.", "simpl.", "unfold sign."], "tactic": "rewrite Rle_minus_l.", "exn": "The LHS of Rle_minus_l (_ - _ <= _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a.", "unfold is_RInt.", "qsimpl use: filterlim_ext.", "intros ptd.", "unfold Riemann_sum.", "unfold locally.", "unfold Riemann_fine.", "simpl.", "intros.", "unfold plus.", "unfold zero.", "unfold scal.", "simpl.", "unfold sign.", "qsimpl use: Rle_minus_l,filterlim_ext."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f a.", "unfold is_RInt.", "qsimpl use: filterlim_ext.", "intros ptd.", "unfold Riemann_sum.", "unfold locally.", "unfold Riemann_fine.", "simpl.", "intros.", "unfold plus.", "unfold zero.", "unfold scal.", "simpl.", "unfold sign.", "qsimpl use: Rle_minus_l,filterlim_ext.", "qsimpl use: Rle_minus_l,filterlim_ext."], "tactic": "apply Rminus_le_0.", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a : R H : forall f0 g : ?T -> ?U, (forall x : ?T, f0 x = g x) -> filterlim f0 ?F ?G -> filterlim g ?F ?G ptd : V -> Prop H0 : exists eps : posreal, forall y : V, ball zero eps y -> ptd y H2 : forall f0 g : ?T0 -> ?U0, (forall x : ?T0, f0 x = g x) -> filterlim f0 ?F0 ?G0 -> filterlim g ?F0 ?G0 H1 : forall a b c : R, (a - c <= b -> a <= b + c) /\\\\ (a <= b + c -> a - c <= b) H4 : forall f0 g : ?T1 -> ?U1, (forall x : ?T1, f0 x = g x) -> filterlim f0 ?F1 ?G1 -> filterlim g ?F1 ?G1 Unable to unify \"(?M4907 <= ?M4908 -> 0 <= ?M4908 - ?M4907) /\\\\ (0 <= ?M4908 - ?M4907 -> ?M4907 <= ?M4908)\" with \"exists delta : posreal, forall y : SF_seq, (fun ptd : SF_seq => seq_step (SF_lx ptd)) y < delta -> (fun x : SF_seq => (fun ptd : SF_seq => pointed_subdiv ptd /\\\\ SF_h ptd = Rmin a a /\\\\ last (SF_h ptd) (unzip1 (SF_t ptd)) = Rmax a a) x -> (fun x0 : SF_seq => ptd ((fun ptd : SF_seq => ModuleSpace.scal R_Ring (AbelianGroup.Pack V (NormedModule.class R_AbsRing V) V) (NormedModule.class R_AbsRing V) match total_order_T 0 (a - a) with | inleft (left _) => 1 | inleft (right _) => 0 | inright _ => -1 end (foldr (AbelianGroup.plus V (NormedModule.class R_AbsRing V)) (AbelianGroup.zero V (NormedModule.class R_AbsRing V)) (pairmap (fun x1 y0 : R * R => ModuleSpace.scal R_Ring (AbelianGroup.Pack V (NormedModule.class R_AbsRing V) V) (NormedModule.class R_AbsRing V) (fst y0 - fst x1) (f (snd y0))) (SF_h ptd, 0) (SF_t ptd)))) x0)) x) y\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros f a. unfold is_RInt. apply filterlim_ext. intros ptd. unfold Riemann_sum. unfold filterlim. unfold locally. unfold within. unfold at_point. unfold filterMap. unfold Riemann_fine. unfold Riemann_sum. simpl. intros. unfold sum_n_m. unfold Iter.iter_nat. unfold plus. unfold zero. unfold scal. simpl. unfold sign. simpl. unfold Riemann_sum. unfold Iter.iter_nat. unfold plus. unfold zero. simpl. rewrite Rle_minus_l. split. apply Rminus_le_0. intuition. auto.", "succ": false}]