[{"history": {"proof": "intros. unfold is_LimSup_seq in *. qsimpl time: 1 use: is_LimSup_seq. destruct BinIntDef.Z.compare. - specialize (Boule eps). intros eps'. qsimpl time: 1 use: is_LimSup_seq. - sfirstorder depth: 3use: N, is_LimSup_seq. - hecrush depth: 3use: N, is_LimSup_seq. - hecrush depth: 3use: N, is_LimSup_seq. - hecrush depth: 3use: N, is_LimSup_seq. - qauto l: on depth: 3use: N, is_LimSup_seq. - hfcrush depth: 3use: N, is_LimSup_seq. - qauto l: on depth: 3use: N, is_LimSup_seq.", "repairs": ["no_product", "", "no_hypos", "ref_not_found", "", "ref_not_found", "", "not_inductive_goal", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": [], "tactic": "intros v u l Huv Hlimsupu.", "exn": "v is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros v' u l Huv Hlimsupu.", "exn": "u is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros v' u' l Huv Hlimsupu.", "exn": "l is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros v' u' l' Huv Hlimsupu.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *."], "tactic": "unfold is_LimSup_seq in Hlimsupu.", "exn": "No such hypothesis: Hlimsupu", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *.", "qsimpl time: 1 use: is_LimSup_seq."], "tactic": "destruct l.", "exn": "The reference l was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *.", "qsimpl time: 1 use: is_LimSup_seq.", "destruct BinIntDef.Z.compare.", "-"], "tactic": "intros eps.", "exn": "eps is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *.", "qsimpl time: 1 use: is_LimSup_seq.", "destruct BinIntDef.Z.compare.", "-"], "tactic": "intros eps'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *.", "qsimpl time: 1 use: is_LimSup_seq.", "destruct BinIntDef.Z.compare.", "-"], "tactic": "specialize (Hlimsupu eps).", "exn": "The reference Hlimsupu was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *.", "qsimpl time: 1 use: is_LimSup_seq.", "destruct BinIntDef.Z.compare.", "-", "specialize (Boule eps).", "intros eps'."], "tactic": "destruct Hlimsupu as [Hlimsupu1 Hlimsupu2].", "exn": "The reference Hlimsupu was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq in *.", "qsimpl time: 1 use: is_LimSup_seq.", "destruct BinIntDef.Z.compare.", "-", "specialize (Boule eps).", "intros eps'."], "tactic": "split; intros; apply Hlimsupu1 in H; destruct H as [n Hn]; exists n; split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros v u l Huv Hlimsupu. unfold is_LimSup_seq in *. unfold is_LimSup_seq in Hlimsupu. unfold is_LimSup_seq. destruct l. - intros eps. specialize (Hlimsupu eps). intros eps'. destruct Hlimsupu as [Hlimsupu1 Hlimsupu2]. split; intros; apply Hlimsupu1 in H; destruct H as [n Hn]; exists n; split. + apply Hn. + rewrite <- Huv. apply Hn. + apply Hlimsupu2 in H. destruct H as [N HN]. exists N. intros. apply H. apply Hn. - intros M N. specialize (Hlimsupu M N). destruct Hlimsupu as [n Hn]. exists n. apply Hn. - intros M. specialize (Hlimsupu M). intros.", "succ": true}]