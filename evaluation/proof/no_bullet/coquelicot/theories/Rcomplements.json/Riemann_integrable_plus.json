[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f g a b Hf Hg.", "intros eps."], "tactic": "destruct (Hf (mkposreal eps (pos_eps eps))) as [phi [psi [H1 H2]]].", "exn": "The reference pos_eps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]]."], "tactic": "destruct (Hg (mkposreal eps (pos_eps eps))) as [phi' [psi' [H1' H2']]].", "exn": "The reference pos_eps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]]."], "tactic": "exists (fun x => phi x + phi' x).", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H1 : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t H2 : Rabs (RiemannInt_SF psi) < {| pos := eps; cond_pos := cond_pos eps |} phi', psi' : StepFun a b H1' : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H2' : Rabs (RiemannInt_SF psi') < {| pos := eps; cond_pos := cond_pos eps |} The term \"fun x : R => phi x + phi' x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "qsimpl time: 2."], "tactic": "exists (fun x => psi x + psi' x).", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H2 : Rabs (RiemannInt_SF psi) < eps phi', psi' : StepFun a b H2' : Rabs (RiemannInt_SF psi') < eps H : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H0 : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (f t - phi t) <= psi t The term \"fun x : R => psi x + psi' x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "qsimpl time: 2."], "tactic": "split; intros.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "qsimpl time: 2."], "tactic": "rewrite <- Rplus_assoc.", "exn": "Found no subterm matching \"?M2999 + (?M3000 + ?M3001)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "qsimpl time: 2.", "qsimpl time: 2 use: Rplus_assoc."], "tactic": "apply Rplus_le_compat; [apply H1 | apply H1'].", "exn": "In environment H1 : forall r1 r2 r3 : R, r1 + r2 + r3 = r1 + (r2 + r3) f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H2 : Rabs (RiemannInt_SF psi) < eps phi', psi' : StepFun a b H2' : Rabs (RiemannInt_SF psi') < eps H : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H0 : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (f t - phi t) <= psi t Unable to unify \"?M3773 + ?M3775 < ?M3774 + ?M3776 \\\\/ ?M3773 + ?M3775 = ?M3774 + ?M3776\" with \"{phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t + g t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "qsimpl time: 2.", "qsimpl time: 2 use: Rplus_assoc.", "qsimpl time: 2 use: Rplus_assoc,Rplus_le_compat."], "tactic": "rewrite Rabs_RiemannInt_SF.", "exn": "The reference Rabs_RiemannInt_SF was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf (mkposreal eps (cond_pos eps))) as [phi [psi [H1 H2]]].", "destruct (Hg (mkposreal eps (cond_pos eps))) as [phi' [psi' [H1' H2']]].", "qsimpl time: 2.", "qsimpl time: 2 use: Rplus_assoc.", "qsimpl time: 2 use: Rplus_assoc,Rplus_le_compat."], "tactic": "apply Rplus_lt_compat; [apply H2 | apply H2'].", "exn": "In environment H4 : forall r1 r2 r3 r4 : R, r1 <= r2 -> r3 <= r4 -> r1 + r3 <= r2 + r4 H3 : forall r1 r2 r3 : R, r1 + r2 + r3 = r1 + (r2 + r3) f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi, psi : StepFun a b H2 : Rabs (RiemannInt_SF psi) < eps phi', psi' : StepFun a b H2' : Rabs (RiemannInt_SF psi') < eps H : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (g t - phi' t) <= psi' t H0 : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (f t - phi t) <= psi t Unable to unify \"?M4767 + ?M4769 < ?M4768 + ?M4770\" with \"{phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t + g t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros f g a b Hf Hg. intros eps. destruct (Hf (mkposreal eps (pos_eps eps))) as [phi [psi [H1 H2]]]. destruct (Hg (mkposreal eps (pos_eps eps))) as [phi' [psi' [H1' H2']]]. exists (fun x => phi x + phi' x). exists (fun x => psi x + psi' x). split; intros. - rewrite <- Rplus_assoc. apply Rplus_le_compat; [apply H1 | apply H1']. - simpl. rewrite Rabs_RiemannInt_SF. apply Rplus_lt_compat; [apply H2 | apply H2'].", "succ": false}]