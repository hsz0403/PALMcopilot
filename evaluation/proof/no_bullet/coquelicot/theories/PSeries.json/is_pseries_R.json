[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *."], "tactic": "apply is_series_scal.", "exn": "In environment a : nat -> R x, l : R H_series : filterlim (sum_n (fun k : nat => scal (pow_n x k) (a k))) eventually (locally l) P : ?V -> Prop Unable to unify \"exists eps : posreal, forall y : ?V, ball (scal ?M2367 ?M2369) eps y -> P y\" with \"exists eps : posreal, forall y : R_NormedModule, ball l eps y -> P y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n."], "tactic": ["rewrite <- H_series.", ""], "exn": "Cannot find an homogeneous relation to rewrite.", "type": "no_rewrite_homo", "handled": false}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n.", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n.", "shelve.", "+", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n.", "shelve.", "+", "shelve.", "+"], "tactic": "intros H_series.", "exn": "H_series is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n.", "shelve.", "+", "shelve.", "+"], "tactic": "intros H_series'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n.", "shelve.", "+", "shelve.", "+", "unfold scal, pow_n in *."], "tactic": "specialize (H_series 1%nat).", "exn": "In environment a : nat -> R x, l : R H_series : filterlim (sum_n (fun k : nat => ModuleSpace.scal R_AbsRing (AbelianGroup.Pack R_NormedModule (ModuleSpace.class R_AbsRing R_NormedModule) R_NormedModule) (ModuleSpace.class R_AbsRing R_NormedModule) ((fix pow_n (x : R_AbsRing) (N : nat) {struct N} : R_AbsRing := match N with | 0%nat => one | S i => mult x (pow_n x i) end) x k) (a k))) eventually (locally l) The term \"1%nat\" has type \"nat\" while it is expected to have type \"R_NormedModule -> Prop\".", "type": "wrong_type", "handled": true}, {"ctx": ["split.", "-", "intros H_series.", "unfold is_pseries, is_series in *.", "qsimpl use: is_series_scal.", "+", "intros n.", "shelve.", "+", "shelve.", "+", "unfold scal, pow_n in *.", "qsimpl use: pow_n,is_series_scal,nat,scal."], "tactic": "rewrite Rmult_1_l in H_series.", "exn": "The LHS of Rmult_1_l (1 * _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}]}, "chat": [], "original": "intros. split. - intros H_series. unfold is_pseries, is_series in *. apply is_series_scal. + intros n. rewrite <- H_series. unfold scal, pow_n. reflexivity. + auto. - intros H_series. unfold is_pseries, is_series in *. unfold scal, pow_n in *. specialize (H_series 1%nat). rewrite Rmult_1_l in H_series. auto.", "succ": false}]