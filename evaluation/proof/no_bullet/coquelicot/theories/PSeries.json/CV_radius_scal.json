[{"history": {"proof": "qsimpl time: 1 use: PSeries_scal. qsimpl time: 1 use: Series_scal_l,PSeries_scal. qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal. qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal. qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div. qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div. qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div. qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,CV_radius_finite_DAlembert,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "repairs": ["no_match_term", "no_match_term", "no_match_term", "no_subterm", "no_match_term", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": [], "tactic": "intros c a not_zero_c.", "exn": "c is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros c' a not_zero_c.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros c' a' not_zero_c.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal."], "tactic": "rewrite PSeries_scal.", "exn": "The LHS of PSeries_scal (PSeries (PS_scal _ _) _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal."], "tactic": "rewrite Series_scal_l.", "exn": "The LHS of Series_scal_l (Series (fun n : nat => _ * _ n)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n)))."], "tactic": "rewrite Rabs_div.", "exn": "The LHS of Rabs_div (Rabs (_ / _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal."], "tactic": "rewrite <- Rabs_Ropp.", "exn": "Found no subterm matching \"Rabs ?M3096\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal."], "tactic": "rewrite Rabs_Rabsolu.", "exn": "The LHS of Rabs_Rabsolu (Rabs (Rabs _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry."], "tactic": "apply Rmult_integral_contrapositive_currified.", "exn": "In environment H8 : forall a b : R, (b = 0 -> False) -> Rabs (a / b) = Rabs a / Rabs b H7 : forall x : R, Rabs (Rabs x) = Rabs x H4 : forall (c : R) (a : nat -> R) (x : R), PSeries (PS_scal c a) x = c * PSeries a x H3 : forall (c : R) (a : nat -> R), Series (fun n : nat => c * a n) = c * Series a H0 : forall x : R, Rabs (- x) = Rabs x c : R a : nat -> R H : c = 0 -> False n : nat Unable to unify \"?M3785 * ?M3786 = 0 -> False\" with \"a n = scal c (a n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div."], "tactic": "apply not_zero_c.", "exn": "The reference not_zero_c was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base."], "tactic": "apply pow_nonzero.", "exn": "In environment H10 : forall a b : R, (b = 0 -> False) -> Rabs (a / b) = Rabs a / Rabs b H9 : forall x : R, Rabs (Rabs x) = Rabs x H6 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> r1 * r2 = 0 -> False H5 : forall (c : R) (a : nat -> R) (x : R), PSeries (PS_scal c a) x = c * PSeries a x H2 : forall (c : R) (a : nat -> R), Series (fun n : nat => c * a n) = c * Series a H1 : forall x : R, Rabs (- x) = Rabs x c : R a : nat -> R H : c = 0 -> False n : nat Unable to unify \"?M4267 ^ ?M4268 = 0 -> False\" with \"Ring.class_of (a n = scal c (a n))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div."], "tactic": "apply not_zero_c.", "exn": "The reference not_zero_c was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base."], "tactic": "apply CV_radius_finite_DAlembert.", "exn": "In environment H12 : forall a b : R, (b = 0 -> False) -> Rabs (a / b) = Rabs a / Rabs b H11 : forall x : R, Rabs (Rabs x) = Rabs x H8 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> r1 * r2 = 0 -> False H7 : forall (c : R) (a : nat -> R) (x : R), PSeries (PS_scal c a) x = c * PSeries a x H4 : forall (c : R) (a : nat -> R), Series (fun n : nat => c * a n) = c * Series a H3 : forall x : R, Rabs (- x) = Rabs x H0 : forall (x : R) (n : nat), (x = 0 -> False) -> x ^ n = 0 -> False c : R a : nat -> R H : c = 0 -> False n : nat Unable to unify \"CV_radius ?M4882 = / ?M4883\" with \"Ring.class_of (Ring.class_of (a n = scal c (a n)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,CV_radius_finite_DAlembert,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div."], "tactic": "intros n.", "exn": "n is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,CV_radius_finite_DAlembert,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div."], "tactic": "intros n'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,CV_radius_finite_DAlembert,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div."], "tactic": "apply pow_nonzero.", "exn": "In environment H14 : forall a b : R, (b = 0 -> False) -> Rabs (a / b) = Rabs a / Rabs b H13 : forall x : R, Rabs (Rabs x) = Rabs x H10 : forall r1 r2 : R, (r1 = 0 -> False) -> (r2 = 0 -> False) -> r1 * r2 = 0 -> False H9 : forall (a : nat -> R) (l : R), (forall n : nat, a n = 0 -> False) -> 0 < l -> is_lim_seq (fun n : nat => Rabs (a (S n) / a n)) l -> CV_radius a = / l H6 : forall (c : R) (a : nat -> R) (x : R), PSeries (PS_scal c a) x = c * PSeries a x H5 : forall (c : R) (a : nat -> R), Series (fun n : nat => c * a n) = c * Series a H2 : forall x : R, Rabs (- x) = Rabs x H1 : forall (x : R) (n : nat), (x = 0 -> False) -> x ^ n = 0 -> False c : R a : nat -> R H : c = 0 -> False n : nat Unable to unify \"?M5612 ^ ?M5613 = 0 -> False\" with \"Ring.class_of (Ring.class_of (a n = scal c (a n)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "qsimpl time: 1 use: PSeries_scal.", "qsimpl time: 1 use: Series_scal_l,PSeries_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "qsimpl time: 1 use: Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,Rabs_div,PSeries_scal.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rabs_Rabsolu,Rabs_div.", "symmetry.", "qsimpl time: 1 use: Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "apply Ring.base.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,CV_radius_finite_DAlembert,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div.", "qsimpl time: 1 use: pow_nonzero,Rabs_Ropp,Series_scal_l,PSeries_scal,CV_radius_finite_DAlembert,Rmult_integral_contrapositive_currified,Rabs_Rabsolu,Rabs_div."], "tactic": "apply not_zero_c.", "exn": "The reference not_zero_c was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros c a not_zero_c. unfold CV_radius, Lub_Rbar. apply CV_radius_ext. intros n. unfold PS_scal. rewrite PSeries_scal. rewrite Series_scal_l. unfold Rdiv. replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))). rewrite Rabs_div. rewrite <- Rabs_Ropp. rewrite Rabs_Rabsolu. symmetry. apply Rmult_integral_contrapositive_currified. apply not_zero_c. apply pow_nonzero. apply not_zero_c. apply CV_radius_finite_DAlembert. intros n. apply pow_nonzero. apply not_zero_c. apply is_lim_seq_mult. apply is_lim_seq_const. apply ex_series_lim_0. apply ex_series_le with (b := fun n => Rabs (a n)). intros n. rewrite Rabs_right. - apply Rle_ge. apply Rlt_le. apply Rlt_div_l. + apply Rabs_pos_lt. apply not_zero_c. + apply Rlt_div_r. * apply Rabs_pos_lt. apply not_zero_c. * apply is_lim_seq_const. - apply Rabs_pos_lt. apply not_zero_c.", "succ": false}]