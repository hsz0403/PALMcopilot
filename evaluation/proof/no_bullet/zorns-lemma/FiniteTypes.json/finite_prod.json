[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-"], "tactic": "apply empty_finite.", "exn": "Unable to unify \"FiniteT False\" with \"FiniteT (False * False)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-"], "tactic": "apply empty_finite.", "exn": "In environment T : Type HY : FiniteT T IHHY : FiniteT (False * T) Unable to unify \"FiniteT False\" with \"FiniteT (False * option T)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+"], "tactic": "apply (finite_sum _ _ HX HY).", "exn": "The reference HX was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+"], "tactic": "apply surj_finite with (f:=fun xy => match xy with | None => inl tt | Some a => inr a end); intros.", "exn": "In environment X : Type Y : Type f : X -> Y HY : FiniteT X H : invertible f IHHY : FiniteT (False * X) Unable to unify \"FiniteT (unit + ?T)\" with \"invertible (fun xy : option (False * Y) * (False * Y) => let (x, y) := xy in match x with | Some a => a | None => y end)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-"], "tactic": "destruct y1, y2; simpl; auto; right; discriminate.", "exn": "The reference y1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-"], "tactic": "unfold invertible.", "exn": "Cannot coerce invertible to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "exists (fun xy => match xy with | inl _ => (None, y) | inr a => (Some a, y) end); split; intros.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-"], "tactic": "apply (add_finite _ (finite_sum _ _ HX HY)).", "exn": "In environment T : Type HX : FiniteT T T0 : Type HY : FiniteT T0 IHHX : FiniteT (T * option T0) IHHY : FiniteT (T * T0) -> FiniteT (option T * T0) Unable to unify \"FiniteT (option (T + T0))\" with \"FiniteT (option T * option T0)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-"], "tactic": "apply finite_sum; auto.", "exn": "In environment T : Type HX : FiniteT T X : Type Y : Type f : X -> Y HY : FiniteT X H : invertible f IHHX : FiniteT (T * Y) IHHY : FiniteT (T * X) -> FiniteT (option T * X) Unable to unify \"FiniteT (?M5994 + ?M5995)\" with \"FiniteT (option T * Y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+"], "tactic": "apply (finite_sum _ _ HY HX).", "exn": "The reference HY was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+"], "tactic": "apply surj_finite with (f:=fun xy => match xy with | None => inl tt | Some a => inr a end); intros.", "exn": "In environment X : Type Y0 : Type f : X -> Y0 HX : FiniteT X H : invertible f IHHX : FiniteT (X * False) Unable to unify \"FiniteT (unit + ?T)\" with \"invertible (fun xy : Y0 * False * option (Y0 * False) => let (x, y) := xy in match y with | Some a => a | None => x end)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-"], "tactic": "destruct y1, y2; simpl; auto; right; discriminate.", "exn": "The reference y1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-"], "tactic": "unfold invertible.", "exn": "Cannot coerce invertible to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "exists (fun xy => match xy with | inl _ => (None, y) | inr a => (Some a, y) end); split; intros.", "exn": "The reference y was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "destruct x; reflexivity.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "inversion H; subst; reflexivity.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-"], "tactic": "apply (add_finite _ (finite_sum _ _ HY HX)).", "exn": "In environment X : Type Y0 : Type f : X -> Y0 HX : FiniteT X H : invertible f X0 : Type Y : Type f0 : X0 -> Y HY : FiniteT X0 H0 : invertible f0 IHHX : FiniteT (X * Y) IHHY : FiniteT (X * X0) -> FiniteT (Y0 * X0) Unable to unify \"FiniteT (option (X0 + X))\" with \"FiniteT (Y0 * Y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros X Y HX HY.", "induction HX; induction HY.", "-", "qsimpl use: empty_finite.", "-", "qsimpl use: empty_finite.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)).", "+", "shelve.", "+", "qsimpl use: empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: invertible,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)).", "+", "shelve.", "+", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve.", "-", "qsimpl use: add_finite,invertible,finite_sum,empty_finite,Some,surj_finite,inr,tt,None,inl.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros X Y HX HY. induction HX; induction HY. - apply empty_finite. - apply empty_finite. - apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match x with | Some a => a | None => y end end)). + apply (finite_sum _ _ HX HY). + apply surj_finite with (f:=fun xy => match xy with | None => inl tt | Some a => inr a end); intros. * destruct y1, y2; simpl; auto; right; discriminate. + unfold invertible. exists (fun xy => match xy with | inl _ => (None, y) | inr a => (Some a, y) end); split; intros. * destruct x; reflexivity. * inversion H; subst; reflexivity. - apply (add_finite _ (finite_sum _ _ HX HY)). - apply finite_sum; auto. - apply (bij_finite _ _ (fun xy => match xy with | (x, y) => match y with | Some a => a | None => x end end)). + apply (finite_sum _ _ HY HX). + apply surj_finite with (f:=fun xy => match xy with | None => inl tt | Some a => inr a end); intros. * destruct y1, y2; simpl; auto; right; discriminate. + unfold invertible. exists (fun xy => match xy with | inl _ => (None, y) | inr a => (Some a, y) end); split; intros. * destruct x; reflexivity. * inversion H; subst; reflexivity. - apply (add_finite _ (finite_sum _ _ HY HX)). - apply finite_sum; auto.", "succ": false}]