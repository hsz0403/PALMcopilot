[{"history": {"proof": "intros s1 s2 x H1 H2. unfold set_minus. induction s1. - reflexivity. - destruct (exds_dec s2 x) as [H|H]. + qsimpl time: 1. * hauto use: exds_Ds. * qauto use: exds_Ds. + sfirstorder depth: 3.", "repairs": ["", "", "", "", "", "", "", "", "cannot_unify", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros s1 s2 x H1 H2.", "unfold set_minus.", "induction s1.", "-", "reflexivity.", "-", "destruct (exds_dec s2 x) as [H|H].", "+"], "tactic": "apply IHs1.", "exn": "In environment s1 : set d : dart s2 : set x : dart H1 : ~ exds (Is s1 d) x H2 : exds s2 x IHs1 : ~ exds s1 x -> (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 (Ds s2 x) = (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2 H : exds s2 x Unable to unify \"(fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 (Ds s2 x) = (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2\" with \"(if exds_dec (Ds s2 x) d then (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 (Ds s2 x) else Is ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 (Ds s2 x)) d) = (if exds_dec s2 d then (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2 else Is ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) d)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s1 s2 x H1 H2. unfold set_minus. induction s1. - reflexivity. - simpl. destruct (exds_dec s2 x) as [H|H]. + apply IHs1. + simpl. rewrite IHs1. reflexivity.", "succ": true}]