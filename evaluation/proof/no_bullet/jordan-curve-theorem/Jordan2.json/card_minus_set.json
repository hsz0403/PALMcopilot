[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s1 s2 H."], "tactic": "unfold incls in H.", "exn": "Cannot coerce incls to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus."], "tactic": "destruct H as [H].", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl."], "tactic": "rewrite Zegal_left with (n := 0) (m := card s2).", "exn": "In environment s2 : set H0 : forall z : dart, exds s2 z -> exds Vs z The term \"card s2\" has type \"nat\" while it is expected to have type \"Z\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left."], "tactic": "rewrite Rplus_comm.", "exn": "Found no subterm matching \"(?M2675 + ?M2676)%R\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "apply Nat.eq_add_0.", "exn": "In environment H4 : forall r1 r2 : R, (r1 + r2)%R = (r2 + r1)%R H3 : forall n m : Z, n = m -> n + - m = 0 s2 : set H0 : forall z : dart, exds s2 z -> False H2, H5 : nat Unable to unify \"((?M2938 + ?M2939)%nat = 0%nat -> ?M2938 = 0%nat /\\\\ ?M2939 = 0%nat) /\\\\ (?M2938 = 0%nat /\\\\ ?M2939 = 0%nat -> (?M2938 + ?M2939)%nat = 0%nat)\" with \"(fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2 = 0%nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+"], "tactic": "apply IHs1.", "exn": "In environment s1 : set d : dart s2 : set H0 : forall z : dart, exds s2 z -> exds (Is s1 d) z IHs1 : (forall z : dart, exds s2 z -> exds s1 z) -> ((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else (1 + card s0)%nat end) s1 e : exds s1 d Unable to unify \"((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else (1 + card s0)%nat end) s1\" with \"((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) (if exds_dec s2 d then (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2 else Is ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) d) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "intros z H1.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "intros z H1'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not."], "tactic": "apply exds2 with z.", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not."], "tactic": "apply exds2 with z in H1.", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not."], "tactic": "apply H1.", "exn": "In environment H2 : forall r1 r2 : R, (r1 + r2)%R = (r2 + r1)%R H1 : forall n m : Z, n = m -> n + - m = 0 s1 : set d : dart s2 : set H0 : forall z : dart, exds s2 z -> d = z \\\\/ exds s1 z IHs1 : (forall z : dart, exds s2 z -> exds s1 z) -> ((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1 e : exds s1 d H3 : nat e0 : exds s2 d Heqs : exds_dec s2 d = left e0 Unable to unify \"?M4893 + - ?M4894 = 0\" with \"((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1 \\\\/ ((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2)%nat <> (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm."], "tactic": "apply IHs1.", "exn": "In environment s1 : set d : dart s2 : set H0 : forall z : dart, exds s2 z -> exds (Is s1 d) z IHs1 : (forall z : dart, exds s2 z -> exds s1 z) -> ((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else (1 + card s0)%nat end) s1 n : ~ exds s1 d Unable to unify \"((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else 1 + card s0 end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else (1 + card s0)%nat end) s1\" with \"((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2 + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) (if exds_dec s2 d then (fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2 else Is ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) d))%nat = S ((fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "intros z H1.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "intros z H1'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not."], "tactic": "apply exds2 with z.", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not."], "tactic": "apply exds2 with z in H1.", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s1 s2 H.", "qsimpl use: incls.", "unfold card, set_minus.", "induction s1.", "-", "simpl.", "qsimpl use: card,incls,Zegal_left.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "shelve.", "-", "simpl.", "destruct (exds_dec s1 d).", "+", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "rewrite Nat.add_comm.", "qsimpl use: card,incls,Zegal_left,Rplus_comm.", "apply Decidable.dec_not_not."], "tactic": "apply H1.", "exn": "In environment H2 : forall r1 r2 : R, (r1 + r2)%R = (r2 + r1)%R H1 : forall n m : Z, n = m -> n + - m = 0 s1 : set d : dart s2 : set H0 : forall z : dart, exds s2 z -> d = z \\\\/ exds s1 z IHs1 : (forall z : dart, exds s2 z -> exds s1 z) -> ((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2) + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2)%nat = (fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1 n : exds s1 d -> False H3 : nat e : exds s2 d Heqs : exds_dec s2 d = left e Unable to unify \"?M7398 + - ?M7399 = 0\" with \"((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2 + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2))%nat = S ((fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1) \\\\/ ((fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s2 + (fix card (s : set) : nat := match s with | Vs => 0 | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) ((fix set_minus (s1 s2 : set) {struct s1} : set := match s1 with | Vs => Vs | Is s0 x => if exds_dec s2 x then set_minus s0 s2 else Is (set_minus s0 s2) x end) s1 s2))%nat <> S ((fix card (s : set) : nat := match s with | Vs => 0%nat | Is s0 x => if exds_dec s0 x then card s0 else S (card s0) end) s1)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s1 s2 H. unfold incls in H. unfold card, set_minus. destruct H as [H]. induction s1. - simpl. rewrite Zegal_left with (n := 0) (m := card s2). + rewrite Rplus_comm. auto. + apply Nat.eq_add_0. - simpl. destruct (exds_dec s1 d). + apply IHs1. intros z H1. apply H. apply exds2 with z. apply exds2 with z in H1. apply H1. + simpl. rewrite Nat.add_comm. f_equal. apply IHs1. intros z H1. apply H. apply exds2 with z. apply exds2 with z in H1. apply H1.", "succ": false}]