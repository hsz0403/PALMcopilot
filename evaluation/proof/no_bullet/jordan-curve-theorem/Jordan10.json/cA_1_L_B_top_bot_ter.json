[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA."], "tactic": "destruct H1.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2."], "tactic": "destruct (eq_dim_dec k0 k).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+"], "tactic": "destruct (eq_dart_dec x0 x).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*"], "tactic": "subst x0.", "exn": "No such hypothesis: x0", "type": "no_hypos", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl."], "tactic": "reflexivity.", "exn": "No such goal. Focus next goal with bullet *.", "type": "next_goal", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*"], "tactic": "rewrite cA_1_B.", "exn": "Found no subterm matching \"cA_1 (B ?M3621 ?M3622 ?M3623) ?M3622 ?M3624\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B."], "tactic": "destruct (eq_dart_dec x z) as [Hdz|Hdz].", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+"], "tactic": "rewrite H4.", "exn": "The reference H4 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind."], "tactic": "reflexivity.", "exn": "In environment m : fmap k : dim x : dart H1 : inv_hmap m e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) = left eq_refl n : one <> k Unable to unify \"0%nat\" with \"let (v, _) := MA1.degree_aux_terminate ?Goal2 ?Goal3 (A m k x) in v\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++"], "tactic": "rewrite H8.", "exn": "The reference H8 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind."], "tactic": "reflexivity.", "exn": "In environment m : fmap k : dim x : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) = right n Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) = left eq_refl n0 : bottom m k x <> top m k x Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x))\" with \"let (v, _) := MA1.degree_aux_terminate ?Goal9 ?Goal10 ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x)) in v\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-"], "tactic": "destruct (eq_dart_dec (top m k x) z) as [Htxz|Htxz].", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-"], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-"], "tactic": "subst z.", "exn": "No such hypothesis: z", "type": "no_hypos", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-"], "tactic": "qsimpl use: contradiction,cA_1_B.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-"], "tactic": "apply top_bottom.", "exn": "In environment m : fmap k : dim x : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) = right n Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) = left eq_refl n0 : bottom m k x <> top m k x Unable to unify \"dim\" with \"nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-"], "tactic": "qsimpl use: contradiction,cA_1_B,top_bottom.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "apply H5.", "exn": "The reference H5 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "++", "exn": "Wrong bullet ++: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "apply H6.", "exn": "The reference H6 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-"], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z."], "tactic": "apply top_top.", "exn": "In environment m : fmap k : dim x : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n0 : (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) = top m k x -> False Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) (top m k x) = right n0 n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = top m k x -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) (top m k x) = right n Unable to unify \"top ?M3693 ?M3694 (top ?M3693 ?M3694 ?M3695) = top ?M3693 ?M3694 ?M3695\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) (top m k x) = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) (top m k x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z."], "tactic": "qsimpl use: contradiction,cA_1_B,top_top,top_bottom.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++"], "tactic": "apply cA_cA_1_B_bis.", "exn": "In environment m : fmap k : dim x, z : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = z -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) z = right n n0 : (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) = z -> False Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) z = right n0 n1 : top m k x <> z Unable to unify \"cA (B ?M4471 ?M4472 ?M4473) ?M4472 ?M4474 = cA ?M4471 ?M4472 ?M4474 /\\\\ cA_1 (B ?M4471 ?M4472 ?M4473) ?M4472 ?M4474 = cA_1 ?M4471 ?M4472 ?M4474\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) z = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++"], "tactic": "qsimpl use: cA_1_B,top_top,contradiction,top_bottom,cA_cA_1_B_bis.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis."], "tactic": "apply not_succ_top.", "exn": "In environment H4 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> exd m z -> (succ m k z -> False) -> top m k (bottom m k z) = z H0 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> top m k (top m k z) = top m k z H : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> cA_1 (B m k x) k z = (if eq_dart_dec (A m k x) z then top m k x else if eq_dart_dec (bottom m k x) z then x else cA_1 m k z) m : fmap k : dim x, z : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = z -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) z = right n n0 : (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) = z -> False Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) z = right n0 n1 : top m k x = z -> False H6 : Z H3 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> (succ m k x -> False) -> cA_1 (B m k x) k z = cA_1 m k z H5 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> (succ m k x -> False) -> cA (B m k x) k z = cA m k z Unable to unify \"succ ?M5597 ?M5598 (top ?M5597 ?M5598 ?M5599) -> False\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) z = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis."], "tactic": "qsimpl use: not_succ_top,cA_1_B,top_top,contradiction,top_bottom,cA_cA_1_B_bis.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis."], "tactic": "apply H9.", "exn": "In environment H11 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> exd m z -> (succ m k z -> False) -> top m k (bottom m k z) = z H9 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> top m k (top m k z) = top m k z H8 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> cA_1 (B m k x) k z = (if eq_dart_dec (A m k x) z then top m k x else if eq_dart_dec (bottom m k x) z then x else cA_1 m k z) H7 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> succ m k (top m k z) -> False m : fmap k : dim x, z : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = z -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) z = right n n0 : (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) = z -> False Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) z = right n0 n1 : top m k x = z -> False H6 : Z H3 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> (succ m k x -> False) -> cA_1 (B m k x) k z = cA_1 m k z H5 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> (succ m k x -> False) -> cA (B m k x) k z = cA m k z H0 : forall (m : fmap) (x y x' y' : dart), inv_hmap m -> prec_L m zero x y -> prec_L (L m zero x y) one x' y' -> expf m (cA_1 m one x) y -> expf m x' (cA m zero y') -> expf (L m zero x y) x' (if eq_dart_dec x y' then y else if eq_dart_dec (cA_1 m zero y) y' then cA m zero x else cA m zero y') -> (expf (L m one x' y') (if eq_dart_dec y' x then x' else if eq_dart_dec (cA m one x') x then cA_1 m one y' else cA_1 m one x) y -> False) -> (cA_1 m zero y = y' -> False) -> (x = y' -> False) -> False Unable to unify \"top ?M7914 ?M7915 (top ?M7914 ?M7915 ?M7916) = top ?M7914 ?M7915 ?M7916\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) z = (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis."], "tactic": "qsimpl use: not_succ_top,cA_1_B,top_top,contradiction,top_bottom,cA_cA_1_B_bis.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis."], "tactic": "rewrite cA_1_B_bis.", "exn": "Found no subterm matching \"cA_1 (B ?M10371 ?M10372 ?M10373) ?M10372 ?M10374\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis."], "tactic": "qsimpl use: not_succ_top,cA_1_B,top_top,contradiction,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis."], "tactic": "destruct (eq_dart_dec x0 z).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z."], "tactic": "reflexivity.", "exn": "In environment H14 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> exd m z -> (succ m k z -> False) -> top m k (bottom m k z) = z H12 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> (succ m k x -> False) -> cA_1 (B m k x) k z = cA_1 m k z H9 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> top m k (top m k z) = top m k z H8 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> succ m k x -> cA_1 (B m k x) k z = (if eq_dart_dec (A m k x) z then top m k x else if eq_dart_dec (bottom m k x) z then x else cA_1 m k z) H7 : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> succ m k (top m k z) -> False m : fmap k : dim x : dart H1 : inv_hmap m H2 : succ m k x e : k = dim_opp k Heqs : eq_dim_dec k (dim_opp k) = left e n1 : top m k x = nil -> False n0 : (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x) = nil -> False Heqs1 : eq_dart_dec ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) (B m k x) (dim_opp k) ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k x)) nil = right n0 n : (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x = nil -> False Heqs0 : eq_dart_dec ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k x) nil = right n H6 : Z H5 : forall (m : fmap) (k : dim) (x z : dart), inv_hmap m -> (succ m k x -> False) -> cA (B m k x) k z = cA m k z H0 : forall (m : fmap) (x y x' y' : dart), inv_hmap m -> prec_L m zero x y -> prec_L (L m zero x y) one x' y' -> expf m (cA_1 m one x) y -> expf m x' (cA m zero y') -> expf (L m zero x y) x' (if eq_dart_dec x y' then y else if eq_dart_dec (cA_1 m zero y) y' then cA m zero x else cA m zero y') -> (expf (L m one x' y') (if eq_dart_dec y' x then x' else if eq_dart_dec (cA m one x') x then cA_1 m one y' else cA_1 m one x) y -> False) -> (cA_1 m zero y = y' -> False) -> (x = y' -> False) -> False Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) nil\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z.", "shelve.", "-"], "tactic": "rewrite cA_1_L_B_top_bot.", "exn": "Found no subterm matching \"cA_1 (L (B ?M12840 ?M12841 ?M12842) ?M12841 (top ?M12840 ?M12841 ?M12842) (bottom ?M12840 ?M12841 ?M12842)) ?M12841 ?M12843\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z.", "shelve.", "-"], "tactic": "qsimpl use: not_succ_top,cA_1_B,cA_1_L_B_top_bot,top_top,contradiction,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z.", "shelve.", "-", "qsimpl use: not_succ_top,cA_1_B,cA_1_L_B_top_bot,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis."], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z.", "shelve.", "-", "qsimpl use: not_succ_top,cA_1_B,cA_1_L_B_top_bot,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "shelve.", "+"], "tactic": "reflexivity.", "exn": "In environment m : fmap k : dim x, z : dart H1 : inv_hmap m H2 : succ m k x n : k = dim_opp k -> False Heqs : eq_dim_dec k (dim_opp k) = right n Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m (dim_opp k) z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) (B m k x) (dim_opp k) z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z.", "shelve.", "-", "qsimpl use: not_succ_top,cA_1_B,cA_1_L_B_top_bot,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x z H1 H2.", "unfold bottom, top, cA_1, cA.", "qsimpl.", "destruct H2.", "destruct (eq_dim_dec one k).", "+", "destruct (eq_dart_dec nil x).", "*", "qsimpl.", "*", "qsimpl use: cA_1_B.", "+", "rewrite MA1.degree_aux_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (eq_dart_dec (bottom m k x) (top m k x)).", "++", "shelve.", "++", "rewrite MA1.degree_aux_ind.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "-", "shelve.", "+", "destruct (eq_dart_dec (top m k x) z).", "++", "subst z.", "qsimpl use: genus,cA_1_B,top_top,top_bottom.", "shelve.", "++", "qsimpl use: cA_1_B,top_top,genus,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,top_bottom,cA_cA_1_B_bis.", "qsimpl use: not_succ_top,cA_1_B,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "destruct (eq_dart_dec nil z).", "-", "subst z.", "shelve.", "-", "qsimpl use: not_succ_top,cA_1_B,cA_1_L_B_top_bot,top_top,nf_L0L1_IA,cA_1_B_bis,top_bottom,cA_cA_1_B_bis.", "shelve.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros m k x z H1 H2. unfold bottom, top, cA_1, cA. destruct H1. destruct H2. simpl. destruct (eq_dim_dec k0 k). + destruct (eq_dart_dec x0 x). * subst x0. reflexivity. * rewrite cA_1_B. { destruct (eq_dart_dec x z) as [Hdz|Hdz]. - subst z. destruct (eq_dart_dec (A m k x) (top m k x)). + rewrite H4. reflexivity. + destruct (eq_dart_dec (bottom m k x) (top m k x)). ++ contradiction. ++ rewrite H8. reflexivity. - destruct (eq_dart_dec (top m k x) z) as [Htxz|Htxz]. + subst z. apply top_bottom. ++ auto. ++ apply H5. ++ apply H6. + destruct (eq_dart_dec (top m k x) z). ++ subst z. apply top_top. auto. ++ apply cA_cA_1_B_bis. ** auto. ** apply not_succ_top. auto. ** apply H9. } * rewrite cA_1_B_bis. { destruct (eq_dart_dec x0 z). - subst z. reflexivity. - rewrite cA_1_L_B_top_bot. + reflexivity. + auto. + auto. } + rewrite cA_1_B_ter. * subst k0. reflexivity. * intro. apply H. symmetry. auto.", "succ": false}]