[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *."], "tactic": "assert (H0: succ m zero x).", "exn": "H0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0."], "tactic": "assert (H1: exd m z).", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z)."], "tactic": "apply H1.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x <> nil x0 := (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x : dart x_1 := (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one x : dart xb0 := (fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x : dart xh0 := (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x : dart xh0_1 := (fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one xh0 : dart p := MF.Iter_upb m xh0_1 : nat z := (fix Iter (g : dart -> dart) (n : nat) (z : dart) {struct n} : dart := match n with | 0 => z | S n0 => g (Iter g n0 z) end) (fun z : dart => cA_1 m one (cA_1 m zero z)) i xh0_1 : dart H1 : ~ (inv_hmap m /\\\\ MF.expo m x0 xb0) H2 : i < p H0' : succ m zero x Unable to unify \"~ (inv_hmap m /\\\\ MF.expo m x0 xb0)\" with \"exd m z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl."], "tactic": "assert (H2: exd m t).", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl."], "tactic": "apply H2.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False Unable to unify \"i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x))\" with \"exd m ((fix Iter (g : dart -> dart) (n : nat) (z : dart) {struct n} : dart := match n with | 0 => z | S n0 => g (Iter g n0 z) end) (fun z : dart => cA_1 m one (cA_1 m zero z)) i ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl."], "tactic": "assert (H3: inv_hmap m).", "exn": "H3 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m)."], "tactic": "apply H3.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False Unable to unify \"False\" with \"inv_hmap m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m)."], "tactic": "apply H4.", "exn": "The reference H4 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x))."], "tactic": "apply H5.", "exn": "The reference H5 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m)."], "tactic": "apply H6.", "exn": "The reference H6 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m)."], "tactic": "apply H7.", "exn": "The reference H7 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m)."], "tactic": "apply H8.", "exn": "The reference H8 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m)."], "tactic": "apply H9.", "exn": "The reference H9 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m)."], "tactic": "apply H10.", "exn": "The reference H10 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m)."], "tactic": "apply H11.", "exn": "The reference H11 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m)."], "tactic": "apply H12.", "exn": "The reference H12 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m)."], "tactic": "apply H13.", "exn": "The reference H13 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x))."], "tactic": "apply H14.", "exn": "The reference H14 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x))."], "tactic": "apply H15.", "exn": "The reference H15 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x)."], "tactic": "apply H0.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False H3' : inv_hmap m Unable to unify \"False\" with \"succ m zero x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x)."], "tactic": "apply H0.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False H3' : inv_hmap m H16 : succ m zero x Unable to unify \"False\" with \"succ m zero x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl."], "tactic": "assert (H18: exd m z).", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl."], "tactic": "apply H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not."], "tactic": "assert (H19: exd m t).", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not."], "tactic": "apply H2.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False H3' : inv_hmap m H16, H17 : succ m zero x Unable to unify \"i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x))\" with \"Decidable.decidable (inv_hmap m)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl."], "tactic": "assert (H20: exd (B m zero x) z).", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl."], "tactic": "apply H18.", "exn": "The reference H18 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not."], "tactic": "assert (H21: exd (B m zero x) t).", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not."], "tactic": "apply H19.", "exn": "The reference H19 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x)."], "tactic": "reflexivity.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False H3' : inv_hmap m H16, H17 : succ m zero x Unable to unify \"bottom m zero x\" with \"cA m zero x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x))."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl."], "tactic": "apply H6.", "exn": "The reference H6 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B."], "tactic": "apply H9.", "exn": "The reference H9 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x)."], "tactic": "reflexivity.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False Unable to unify \"Iter (cF m) 0 x\" with \"cA m zero x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x)."], "tactic": "assert (H27: z = Iter (cF m) i (cA_1 m one (top m zero x))).", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x)."], "tactic": "reflexivity.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False Unable to unify \"Iter (cF m) 0 x\" with \"cA m zero x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x)))."], "tactic": "apply H7.", "exn": "The reference H7 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x))."], "tactic": "apply H3.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False Unable to unify \"False\" with \"expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl."], "tactic": "assert (H30: betweenf m (cA_1 m one (top m zero x)) z (cA m zero x)).", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl."], "tactic": "apply H31.", "exn": "The reference H31 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x)))."], "tactic": "apply H7.", "exn": "The reference H7 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not."], "tactic": "assert (H32: z = Iter (cF m) i (cA_1 m one (top m zero x))).", "exn": "The reference z was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not."], "tactic": "apply H27.", "exn": "The reference H27 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not."], "tactic": "rewrite H26, H22, H23, H32.", "exn": "The reference H26 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not."], "tactic": "apply expf_B0_CS_1_b_aux.", "exn": "In environment m : fmap x : dart i : nat H : inv_hmap m H0 : A m zero x = nil -> False H2 : i < MF.Iter_upb m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA_1) m one ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m zero x)) H3 : MF.expo m ((fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m zero x) ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m zero x) -> False Unable to unify \"inv_hmap (B ?M3643 zero ?M3644) /\\\\ MF.expo (B ?M3643 zero ?M3644) ?M3645 ?M3646\" with \"Decidable.decidable (i < MF.Iter_upb m (cA_1 m one (top m zero x))) \\\\/ ~ Decidable.decidable (i < MF.Iter_upb m (cA_1 m one (top m zero x)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux."], "tactic": "apply H13.", "exn": "The reference H13 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not."], "tactic": "apply H28.", "exn": "The reference H28 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not."], "tactic": "apply H18.", "exn": "The reference H18 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not."], "tactic": "apply H19.", "exn": "The reference H19 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not."], "tactic": "apply H25.", "exn": "The reference H25 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux."], "tactic": "apply H30.", "exn": "The reference H30 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *.", "assert (H0': succ m zero x).", "apply H0.", "assert (H1': exd m z).", "qsimpl.", "assert (H3': inv_hmap m).", "qsimpl.", "assert (H4: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H5: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H6: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H7: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H8: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H9: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H10: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H11: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H12: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H13: inv_hmap m).", "apply Decidable.dec_not_not.", "assert (H14: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H15: inv_hmap (B m zero x)).", "apply inv_hmap_L_B.", "assert (H16: succ m zero x).", "qsimpl.", "assert (H17: succ m zero x).", "qsimpl.", "apply Decidable.dec_not_not.", "qsimpl.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "assert (H22: cA m zero x = bottom m zero x).", "assert (H23: top m zero x = top m zero x).", "reflexivity.", "assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)).", "reflexivity.", "assert (H25: inv_hmap (B m zero x)).", "qsimpl.", "apply inv_hmap_L_B.", "apply Decidable.dec_not_not.", "assert (H26: cA m zero x = Iter (cF m) 0 x).", "assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)).", "qsimpl.", "apply Decidable.dec_not_not.", "assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))).", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "apply Decidable.dec_not_not.", "qsimpl use: expf_B0_CS_1_b_aux.", "apply Decidable.dec_not_not."], "tactic": "apply H30.", "exn": "The reference H30 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. unfold expf, succ, exd, betweenf, Iter, bottom, top, cA, cA_1, cF, B in *. intros. simpl in *. assert (H0: succ m zero x). { apply H0. } assert (H1: exd m z). { apply H1. } assert (H2: exd m t). { apply H2. } assert (H3: inv_hmap m). { apply H3. } assert (H4: inv_hmap m). { apply H4. } assert (H5: inv_hmap (B m zero x)). { apply H5. } assert (H6: inv_hmap m). { apply H6. } assert (H7: inv_hmap m). { apply H7. } assert (H8: inv_hmap m). { apply H8. } assert (H9: inv_hmap m). { apply H9. } assert (H10: inv_hmap m). { apply H10. } assert (H11: inv_hmap m). { apply H11. } assert (H12: inv_hmap m). { apply H12. } assert (H13: inv_hmap m). { apply H13. } assert (H14: inv_hmap (B m zero x)). { apply H14. } assert (H15: inv_hmap (B m zero x)). { apply H15. } assert (H16: succ m zero x). { apply H0. } assert (H17: succ m zero x). { apply H0. } assert (H18: exd m z). { apply H1. } assert (H19: exd m t). { apply H2. } assert (H20: exd (B m zero x) z). { apply H18. } assert (H21: exd (B m zero x) t). { apply H19. } assert (H22: cA m zero x = bottom m zero x). { reflexivity. } assert (H23: top m zero x = top m zero x). { reflexivity. } assert (H24: cA_1 m one (top m zero x) = cA_1 m one (top m zero x)). { reflexivity. } assert (H25: inv_hmap (B m zero x)). { split. { apply H6. } { apply H9. } } assert (H26: cA m zero x = Iter (cF m) 0 x). { reflexivity. } assert (H27: z = Iter (cF m) i (cA_1 m one (top m zero x))). { reflexivity. } assert (H28: i < MF.Iter_upb m (cA_1 m one (top m zero x))). { apply H7. } assert (H29: expf m (Iter (cF m) i (cA m zero x)) (bottom m zero x)). { apply H3. } assert (H30: betweenf m (cA_1 m one (top m zero x)) z (cA m zero x)). { apply H31. } assert (H31: i < MF.Iter_upb m (cA_1 m one (top m zero x))). { apply H7. } assert (H32: z = Iter (cF m) i (cA_1 m one (top m zero x))). { apply H27. } rewrite H26, H22, H23, H32. apply expf_B0_CS_1_b_aux. apply H13. apply H28. apply H18. apply H19. apply H25. split. { apply H30. } { apply H30. }", "succ": false}]