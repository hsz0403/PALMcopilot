[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p."], "tactic": "reflexivity.", "exn": "In environment m : fmap d : dart t : tag r, r0 : R k, j : dim u, v : dart Unable to unify \"I ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) k u) d t (r, r0)\" with \"I ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k u) j v) d t (r, r0)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p.", "shelve.", "-", "destruct d.", "+"], "tactic": "reflexivity.", "exn": "In environment m : fmap d0, d1 : dart k, j : dim u, v : dart Unable to unify \"(fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) (if eq_dim_dec zero j then if eq_dart_dec d0 v then m else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) zero d0 d1 else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) zero d0 d1) k u\" with \"(fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) (if eq_dim_dec zero k then if eq_dart_dec d0 u then m else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k u) zero d0 d1 else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k u) zero d0 d1) j v\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p.", "shelve.", "-", "destruct d.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p.", "shelve.", "-", "destruct d.", "+", "shelve.", "+"], "tactic": "destruct (eq_dim_dec d k) eqn:Eq_dim_dec.", "exn": "The reference d was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p.", "shelve.", "-", "destruct d.", "+", "shelve.", "+", "destruct (eq_dart_dec d0 u) eqn:Eq_dart_dec.", "--"], "tactic": "reflexivity.", "exn": "In environment m : fmap d0, d1 : dart k, j : dim u, v : dart e : d0 = u Eq_dart_dec : eq_dart_dec d0 u = left e Unable to unify \"(fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) (if eq_dim_dec one j then if eq_dart_dec d0 v then m else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) one d0 d1 else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) one d0 d1) k u\" with \"(fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) (if eq_dim_dec one k then m else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k u) one d0 d1) j v\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p.", "shelve.", "-", "destruct d.", "+", "shelve.", "+", "destruct (eq_dart_dec d0 u) eqn:Eq_dart_dec.", "--"], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j u v.", "unfold B.", "destruct m.", "-", "reflexivity.", "-", "destruct p.", "shelve.", "-", "destruct d.", "+", "shelve.", "+", "destruct (eq_dart_dec d0 u) eqn:Eq_dart_dec.", "--", "shelve.", "--"], "tactic": "apply cA_B_bis.", "exn": "In environment m : fmap d0, d1 : dart k, j : dim u, v : dart n : d0 <> u Eq_dart_dec : eq_dart_dec d0 u = right n Unable to unify \"cA (B ?M2287 ?M2288 ?M2289) ?M2288 ?M2290 = cA ?M2287 ?M2288 ?M2290\" with \"(fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) (if eq_dim_dec one k then L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k u) one d0 d1 else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k u) one d0 d1) j v = (fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) (if eq_dim_dec one j then if eq_dart_dec d0 v then m else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) one d0 d1 else L ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m j v) one d0 d1) k u\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m k j u v. unfold B. destruct m. - reflexivity. - destruct p. reflexivity. - destruct d. + reflexivity. + destruct (eq_dim_dec d k) eqn:Eq_dim_dec. * destruct (eq_dart_dec d0 u) eqn:Eq_dart_dec. -- reflexivity. -- apply cA_B_bis. easy. * apply cA_B_bis. easy.", "succ": false}]