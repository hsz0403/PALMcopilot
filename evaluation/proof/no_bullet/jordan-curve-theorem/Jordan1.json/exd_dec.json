[{"history": {"proof": "intros m x. induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH]. - right. intros H. inversion H. - destruct (eq_dart_dec x d) as [Eq|Neq]. + left. left. qsimpl time: 1. + destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx]. * qsimpl time: 1. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. * sfirstorder depth: 3. - sfirstorder depth: 3.", "repairs": ["", "", "", "", "", "", "", "", "", "", "", "cannot_unify", "", "ref_not_found", "", "not_inductive_goal", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left."], "tactic": "apply Eq.", "exn": "In environment fm : fmap d : dart t : tag p : point x : dart IHfm : {exd fm x} + {~ exd fm x} Eq : x = d Unable to unify \"x = d\" with \"d = x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "qsimpl time: 1.", "+"], "tactic": "destruct (IH Neq) as [Ex|NEx].", "exn": "The reference IH was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x.", "induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH].", "-", "right.", "intros H.", "inversion H.", "-", "destruct (eq_dart_dec x d) as [Eq|Neq].", "+", "left.", "left.", "qsimpl time: 1.", "+", "destruct (Ring_polynom.mk_monpol_list Neq) as [Ex|NEx].", "*"], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros m x. induction m as [|fm IHfm d t p IH|fm IHfm d d0 d1 IH]. - right. intros H. inversion H. - destruct (eq_dart_dec x d) as [Eq|Neq]. + left. left. apply Eq. + destruct (IH Neq) as [Ex|NEx]. * left. right. apply Ex. * right. intros [H|H]. ++ apply Neq. inversion H. reflexivity. ++ apply NEx. apply H. - destruct (IH x) as [Ex|NEx]. + left. right. apply Ex. + right. intros [H|H]. * apply NEx. apply H. * apply NEx. apply H.", "succ": true}]