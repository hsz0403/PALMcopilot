[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x y m1 y0 IH1 Hnotexpf MAX.", "unfold MF.degree_aux.", "unfold MAX."], "tactic": "rewrite (degree_y0_y_1 m x y IH1).", "exn": "In environment m : fmap x, y : dart m1 := L m one x y : fmap y0 := cA m zero y : dart IH1 : inv_hmap m1 Hnotexpf : ~ expf m x y0 MAX := MF.degree m x + MF.degree m y0 : nat The term \"IH1\" has type \"inv_hmap m1\" while it is expected to have type \"inv_hmap m\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m x y m1 y0 IH1 Hnotexpf MAX.", "unfold MF.degree_aux.", "unfold MAX.", "qsimpl use: degree_y0_y_1."], "tactic": "reflexivity.", "exn": "In environment H : forall (m : fmap) (x y : dart), inv_hmap m -> prec_L m one x y -> MF.degree m (cA m zero y) = MF.degree m (cA_1 m one y) m : fmap x, y : dart Hnotexpf : expf m x (cA m zero y) -> False H0 : inv_hmap m x0 : nat e : exists p : nat, forall k : nat, p < k -> forall def : fmap -> dart -> nat -> nat, Recdef.iter (fmap -> dart -> nat -> nat) k MF.degree_aux_F def (L m one x y) x (MF.degree m x + MF.degree m (cA m zero y)) = x0 Heqs : MF.degree_aux_terminate (L m one x y) x (MF.degree m x + MF.degree m (cA m zero y)) = exist (fun v : nat => exists p : nat, forall k : nat, p < k -> forall def : fmap -> dart -> nat -> nat, Recdef.iter (fmap -> dart -> nat -> nat) k MF.degree_aux_F def (L m one x y) x (MF.degree m x + MF.degree m (cA m zero y)) = v) x0 e H2 : exd m x H1 : exd m y H3 : succ m one x -> False H4 : pred m one y -> False H6 : cA m one x = y -> False Unable to unify \"MF.degree m x + MF.degree m (cA m zero y)\" with \"x0\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m x y m1 y0 IH1 Hnotexpf MAX. unfold MF.degree_aux. unfold MAX. rewrite (degree_y0_y_1 m x y IH1). reflexivity.", "succ": false}]