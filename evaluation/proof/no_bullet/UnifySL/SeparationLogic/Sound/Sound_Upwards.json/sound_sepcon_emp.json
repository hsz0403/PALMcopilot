[{"history": {"proof": "qsimpl time: 2. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp. qsimpl time: 2 use: emp.", "repairs": ["not_inductive_product", "not_inductive_product", "not_inductive_product", "not_inductive_product", "cannot_unify", "not_inductive_product", "not_inductive_product", "cannot_unify", "not_inductive_product", "wrong_type", "no_instance_var", "cannot_unify", "not_inductive_product", "not_inductive_product", "cannot_unify", "not_inductive_product", "cannot_unify"], "exceptions": [{"ctx": ["intros x m."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2."], "tactic": "unfold sat in *.", "exn": "The reference sat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2."], "tactic": "split; intros.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m)."], "tactic": "destruct H as [_ H].", "exn": "Unable to find an instance for the variables n, n, n'.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m)."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation Unable to unify \"Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m\" with \"KRIPKE: M, m |= x * emp <--> x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m)."], "tactic": "exists emp, x.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_assoc2.", "exn": "The reference env_assoc2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_pure.", "exn": "The reference env_pure was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_emp.", "exn": "The reference env_emp was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros [m1 [m2 [H1 [H2 H3]]]].", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros [m1 [m2 [H1' [H2 H3]]]].", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros [m1 [m2 [H1' [H2' H3]]]].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply H.", "exn": "In environment L : Language X0, X, e : expr minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation Unable to unify \"Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m\" with \"KRIPKE: M, m |= x * e <--> x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "exists m1, m2.", "exn": "The reference m1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_assoc1.", "exn": "The reference env_assoc1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply H2.", "exn": "In environment L : Language X3, X2, X1, X0, X, e : expr minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation Unable to unify \"Included (Kworlds M) Semantics.falsep (Kdenotation M FF)\" with \"KRIPKE: M, m |= x * e <--> x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply H3.", "exn": "The reference H3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "unfold sat in *.", "exn": "The reference sat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "split; intros.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "specialize (H m).", "exn": "In environment L : Language X5, X4, X3, X2, X1, X0, X, e : expr minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation The term \"m\" has type \"Kworlds M\" while it is expected to have type \"Ensembles.In (Kworlds M) (Kdenotation M emp) m\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "destruct H as [H _].", "exn": "Unable to find an instance for the variables n, n, n'.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply H.", "exn": "In environment L : Language X7, X6, X5, X4, X3, X2, X1, X0, X, e : expr minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation Unable to unify \"Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m\" with \"KRIPKE: M, m |= x * e <--> x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "exists emp.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_emp.", "exn": "The reference env_emp was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_pure.", "exn": "The reference env_pure was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros [m' [H1 H2]].", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros [m' [H1' H2]].", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "intros [m' [H1' H2']].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply H.", "exn": "In environment L : Language X10, X9, X8, X7, X6, X5, X4, X3, X2, X1, X0, X, e : expr minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation Unable to unify \"Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m\" with \"KRIPKE: M, m |= x * e <--> x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "exists m'.", "exn": "The reference m' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply env_emp.", "exn": "The reference env_emp was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x m.", "qsimpl time: 2.", "specialize (H m).", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp.", "qsimpl time: 2 use: emp."], "tactic": "apply H2.", "exn": "In environment L : Language X12, X11, X10, X9, X8, X7, X6, X5, X4, X3, X2, X1, X0, X, e : expr minL : MinimumLanguage L pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) SM : Semantics L MD usepconSM : SepconSemantics L MD M SM uwandSM : WandSemantics L MD M SM empL : EmpLanguage L x : expr m : Kworlds M incr'_exists : forall n : Kworlds M, exists m : Kworlds M, residue n m /\\\\ increasing' m H : Ensembles.In (Kworlds M) (Kdenotation M emp) m -> Ensembles.In (Kworlds M) StrongSemantics.StrongSemantics.emp m H0 : Included (Kworlds M) StrongSemantics.StrongSemantics.emp (Kdenotation M emp) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation Unable to unify \"Included (Kworlds M) Semantics.falsep (Kdenotation M FF)\" with \"KRIPKE: M, m |= x * e <--> x\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros x m. split. - intros H. unfold sat in *. split; intros. + specialize (H m). destruct H as [_ H]. apply H. exists emp, x. split. * apply env_assoc2. * split. -- apply env_pure. auto. -- apply env_emp. + intros [m1 [m2 [H1 [H2 H3]]]]. apply H. exists m1, m2. split. * apply env_assoc1. auto. * split. -- apply H2. -- apply H3. - intros H. unfold sat in *. split; intros. + specialize (H m). destruct H as [H _]. apply H. exists emp. split. * apply env_emp. * apply env_pure. auto. + intros [m' [H1 H2]]. apply H. exists m'. split. * apply env_emp. * apply H2.", "succ": false}]