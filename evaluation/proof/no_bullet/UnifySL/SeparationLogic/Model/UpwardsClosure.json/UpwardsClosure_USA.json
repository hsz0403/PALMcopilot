[{"history": {"proof": "qsimpl time: 2 use: unital_is_residual. qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual. qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual. qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual. qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual. qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "repairs": ["not_evaluable", "wrong_type", "no_instance_var", "wrong_type", "no_instance_var", "not_evaluable"], "exceptions": [{"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n."], "tactic": "unfold unital_is_residual.", "exn": "Cannot coerce unital_is_residual to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual."], "tactic": "destruct (incr_unital_iff_residual n).", "exn": "In environment worlds : Type R : Relation worlds J : Join worlds dSA : DownwardsClosedSeparationAlgebra worlds n : worlds residue_exists : forall n : worlds, exists m : worlds, residue n m incr_exists : forall n : worlds, exists m : worlds, residue n m /\\\\ increasing m join_comm : forall m1 m2 m : worlds, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : worlds, join mx my mxy -> join mxy mz mxyz -> exists myz : worlds, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation The term \"n\" has type \"worlds\" while it is expected to have type \"IncreasingSeparationAlgebra ?worlds\".", "type": "wrong_type", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "destruct (H n) as [m [residue_inc]].", "exn": "In environment worlds : Type R : Relation worlds J : Join worlds dSA : DownwardsClosedSeparationAlgebra worlds n : worlds residue_exists : forall n : worlds, exists m : worlds, residue n m incr_exists : forall n : worlds, exists m : worlds, residue n m /\\\\ increasing m join_comm : forall m1 m2 m : worlds, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : worlds, join mx my mxy -> join mxy mz mxyz -> exists myz : worlds, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation H0 : UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H2 : UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H : IncreasingSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds H3 : IncreasingSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H1 : IncreasingSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds H4 : IncreasingSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds The term \"n\" has type \"worlds\" while it is expected to have type \"IncreasingSeparationAlgebra worlds\".", "type": "wrong_type", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "exists m.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "apply residue_inc.", "exn": "The reference residue_inc was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "intros m [residue_m increasing_m].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "unfold residue_exists.", "exn": "Cannot coerce residue_exists to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "exists m.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "apply residue_m.", "exn": "The reference residue_m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["apply Build_UnitalSeparationAlgebra.", "intros n.", "qsimpl time: 2 use: unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual.", "qsimpl time: 2 use: incr_unital_iff_residual,unital_is_residual."], "tactic": "apply all_increasing.", "exn": "In environment worlds : Type R : Relation worlds J : Join worlds dSA : DownwardsClosedSeparationAlgebra worlds n : worlds residue_exists : forall n : worlds, exists m : worlds, residue n m incr_exists : forall n : worlds, exists m : worlds, residue n m /\\\\ increasing m join_comm : forall m1 m2 m : worlds, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : worlds, join mx my mxy -> join mxy mz mxyz -> exists myz : worlds, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation H0 : UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H2 : UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H : IncreasingSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds H3 : IncreasingSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H1 : IncreasingSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds H4 : IncreasingSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H6 : UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds H5 : IncreasingSeparationAlgebra worlds -> (UnitalSeparationAlgebra worlds -> ResidualSeparationAlgebra worlds) /\\\\ (ResidualSeparationAlgebra worlds -> UnitalSeparationAlgebra worlds) Unable to unify \"forall n0 n' : ?worlds, join ?M18232 n0 n' -> n0 <= n'\" with \"exists m : worlds, residue n m /\\\\ increasing m\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "apply Build_UnitalSeparationAlgebra. intros n. unfold unital_is_residual. destruct (incr_unital_iff_residual n). split. - destruct (H n) as [m [residue_inc]]. exists m. apply residue_inc. - intros m [residue_m increasing_m]. split. + unfold residue_exists. exists m. apply residue_m. + apply all_increasing.", "succ": false}]