[{"history": {"proof": "intros Phi H1 H2 x y. split. - intros H3. apply H2 in H3. destruct H3 as [H3 | H3]. + left. apply H1. sfirstorder depth: 3. + right. apply H1. sfirstorder depth: 3. - intros H3. destruct H3 as [H3 | H3]. + qsimpl time: 2. + qsimpl time: 2.", "repairs": ["", "", "", "", "", "", "", "", "", "hammer", "", "", "", "hammer", "", "", "", "", "cannot_unify", "", "cannot_unify"], "exceptions": [{"ctx": ["intros Phi H1 H2 x y.", "split.", "-", "intros H3.", "apply H2 in H3.", "destruct H3 as [H3 | H3].", "+", "left.", "apply H1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi H1 H2 x y.", "split.", "-", "intros H3.", "apply H2 in H3.", "destruct H3 as [H3 | H3].", "+", "left.", "apply H1.", "shelve.", "+", "right.", "apply H1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi H1 H2 x y.", "split.", "-", "intros H3.", "apply H2 in H3.", "destruct H3 as [H3 | H3].", "+", "left.", "apply H1.", "shelve.", "+", "right.", "apply H1.", "shelve.", "-", "intros H3.", "destruct H3 as [H3 | H3].", "+"], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP Phi : context H1 : derivable_closed Phi H2 : orp_witnessed Phi x, y : expr H3 : Phi x Unable to unify \"orp_witnessed Phi\" with \"Phi (x || y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi H1 H2 x y.", "split.", "-", "intros H3.", "apply H2 in H3.", "destruct H3 as [H3 | H3].", "+", "left.", "apply H1.", "shelve.", "+", "right.", "apply H1.", "shelve.", "-", "intros H3.", "destruct H3 as [H3 | H3].", "+", "qsimpl time: 2."], "tactic": "left.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros Phi H1 H2 x y.", "split.", "-", "intros H3.", "apply H2 in H3.", "destruct H3 as [H3 | H3].", "+", "left.", "apply H1.", "shelve.", "+", "right.", "apply H1.", "shelve.", "-", "intros H3.", "destruct H3 as [H3 | H3].", "+", "qsimpl time: 2.", "+"], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP Phi : context H1 : derivable_closed Phi H2 : orp_witnessed Phi x, y : expr H3 : Phi y Unable to unify \"orp_witnessed Phi\" with \"Phi (x || y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi H1 H2 x y.", "split.", "-", "intros H3.", "apply H2 in H3.", "destruct H3 as [H3 | H3].", "+", "left.", "apply H1.", "shelve.", "+", "right.", "apply H1.", "shelve.", "-", "intros H3.", "destruct H3 as [H3 | H3].", "+", "qsimpl time: 2.", "+", "qsimpl time: 2."], "tactic": "right.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros Phi H1 H2 x y. split. - intros H3. apply H2 in H3. destruct H3 as [H3 | H3]. + left. apply H1. auto. + right. apply H1. auto. - intros H3. destruct H3 as [H3 | H3]. + apply H2. left. apply H1. auto. + apply H2. right. apply H1. auto.", "succ": true}]