[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Phi xs y.", "split.", "-", "intros H."], "tactic": "apply (deduction_subst1 Phi (multi_imp xs y) y).", "exn": "In environment L : Language GammaD : Derivable L bSC : BasicSequentCalculus L GammaD minL : MinimumLanguage L minSC : MinimumSequentCalculus L GammaD Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y Unable to unify \"(let (derivable) := ?Gamma in derivable) Phi y\" with \"(let (derivable) := GammaD in derivable) Phi (multi_imp xs y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp."], "tactic": "apply H.", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y Unable to unify \"Union expr Phi (fun x : expr => In x xs) |-- y\" with \"Phi |-- e xs y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp."], "tactic": "apply deduction_weaken1 with (x := multi_imp xs y).", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y X : expr Unable to unify \"(let (derivable) := ?Gamma in derivable) (?M3932;; multi_imp xs y) ?M3934\" with \"(let (derivable) := GammaD in derivable) Phi (e xs y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp."], "tactic": "apply provable_multi_imp_arg_switch1.", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H3 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr Unable to unify \"(let (provable) := ?Gamma in provable) ((?M5747 --> multi_imp ?M5746 ?M5748) --> multi_imp ?M5746 (?M5747 --> ?M5748))\" with \"(let (derivable) := GammaD in derivable) Phi (e xs y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp."], "tactic": "apply H.", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H1 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X1 : expr Unable to unify \"Union expr Phi (fun x : expr => In x xs) |-- y\" with \"Phi |-- e xs y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*"], "tactic": "apply provable_multi_imp_shrink.", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1 : expr H7 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H6 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H3 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X2 : expr Unable to unify \"(let (provable) := ?Gamma in provable) ((?M13555 --> multi_imp ?M13554 (?M13555 --> ?M13556)) --> multi_imp ?M13554 (?M13555 --> ?M13556))\" with \"(let (derivable) := GammaD in derivable) Phi (e xs y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink."], "tactic": "apply provable_multi_imp_split in H.", "exn": "Unable to apply lemma of type \"forall (Phi1 Phi2 : Ensemble expr) (xs0 : list expr) (y0 : expr), Forall (Union expr Phi1 Phi2) xs0 -> |-- multi_imp xs0 y0 -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y0)\" on hypothesis of type \"Union expr Phi (fun x : expr => In x xs) |-- y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink."], "tactic": "destruct H as [xs1 [xs2 [H1 [H2 H3]]]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink."], "tactic": "apply provable_multi_imp_weaken with (x := multi_imp xs1 y).", "exn": "The reference xs1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++"], "tactic": "apply H1.", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> Phi (multi_imp xs y) -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ Phi (multi_imp xs1 (multi_imp xs2 y)) X4 : expr H13 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H12 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H8 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H1 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X5 : expr Unable to unify \"(let (derivable) := GammaD in derivable) (?M38986;; ?M38987) ?M38988\" with \"(let (derivable) := GammaD in derivable) Phi (e xs y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "apply provable_multi_imp_modus_ponens.", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H11 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H10 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H6 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H3 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X4 : expr Unable to unify \"(let (provable) := ?Gamma in provable) (multi_imp ?M49937 ?M49938 --> multi_imp ?M49937 (?M49938 --> ?M49939) --> multi_imp ?M49937 ?M49939)\" with \"MinimumAxiomatization L {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens."], "tactic": "apply H3.", "exn": "The reference H3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind."], "tactic": "apply provable_multi_imp_arg_switch2.", "exn": "In environment L : Language GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> Phi (multi_imp xs y) -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ Phi (multi_imp xs1 (multi_imp xs2 y)) X4 : expr H14 : forall (xs : list expr) (y z : expr), |-- multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z H13 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H12 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H8 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H1 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X5, X6 : expr Unable to unify \"(let (provable) := ?Gamma in provable) (multi_imp ?M64433 (?M64434 --> ?M64435) --> ?M64434 --> multi_imp ?M64433 ?M64435)\" with \"Empty_set (Provable L) {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens."], "tactic": "apply H2.", "exn": "In environment L : Language GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> Phi (multi_imp xs y) -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ Phi (multi_imp xs1 (multi_imp xs2 y)) X4 : expr H14 : forall (xs : list expr) (y z : expr), Phi (multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z) X5, X6 : expr H17 : forall (xs : list expr) (y z : expr), |-- multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z H16 : forall (xs : list expr) (x y : expr), |-- multi_imp xs (x --> y) --> x --> multi_imp xs y H15 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H11 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H10 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H6 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H3 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X7 : expr Unable to unify \"(let (derivable) := GammaD in derivable) (?M80880;; ?M80881) ?M80882\" with \"Empty_set (Provable L) {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens."], "tactic": "-", "exn": "Wrong bullet -: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++"], "tactic": "apply deduction_weaken1 with (x := y).", "exn": "In environment L : Language e : list expr -> expr -> expr GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H11 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H10 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H6 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H3 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X4 : expr Unable to unify \"(let (derivable) := ?Gamma in derivable) (?M98627;; y) ?M98629\" with \"MinimumAxiomatization L {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens."], "tactic": "apply provable_multi_imp_shrink.", "exn": "In environment L : Language GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> Phi (multi_imp xs y) -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ Phi (multi_imp xs1 (multi_imp xs2 y)) X4 : expr H15 : forall (xs : list expr) (y z : expr), |-- multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z H14 : forall (xs : list expr) (x y : expr), |-- multi_imp xs (x --> y) --> x --> multi_imp xs y H13 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H12 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H8 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H1 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X5, X6 : expr Unable to unify \"(let (provable) := ?Gamma in provable) ((?M115635 --> multi_imp ?M115634 (?M115635 --> ?M115636)) --> multi_imp ?M115634 (?M115635 --> ?M115636))\" with \"MinimumAxiomatization L {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens."], "tactic": "apply provable_multi_imp_arg_switch1.", "exn": "In environment L : Language GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> Phi (multi_imp xs y) -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ Phi (multi_imp xs1 (multi_imp xs2 y)) X4 : expr H15 : forall (xs : list expr) (y z : expr), Phi (multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z) H14 : forall (xs : list expr) (x y : expr), Phi (multi_imp xs (x --> y) --> x --> multi_imp xs y) X5, X6 : expr H18 : forall (xs : list expr) (y z : expr), |-- multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z H17 : forall (xs : list expr) (x y : expr), |-- multi_imp xs (x --> y) --> x --> multi_imp xs y H16 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H11 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H10 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H6 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H3 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X7 : expr Unable to unify \"(let (provable) := ?Gamma in provable) ((?M135034 --> multi_imp ?M135033 ?M135035) --> multi_imp ?M135033 (?M135034 --> ?M135035))\" with \"MinimumAxiomatization L {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi xs y.", "split.", "-", "intros H.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,provable_multi_imp_arg_switch1,multi_imp.", "*", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_modus_ponens.", "apply Empty_set_ind.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "**", "shelve.", "++", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens.", "qsimpl time: 2 use: deduction_weaken1,deduction_subst1,multi_imp,provable_multi_imp_split,provable_multi_imp_arg_switch1,provable_multi_imp_shrink,provable_multi_imp_arg_switch2,provable_multi_imp_modus_ponens."], "tactic": "apply H.", "exn": "In environment L : Language GammaD : Derivable L H0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y minL : MinimumLanguage L Phi : context xs : list expr y : expr H : Union expr Phi (fun x : expr => In x xs) |-- y deduction_modus_ponens0 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros0 : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y X : expr H2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X0 : expr H5 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs y) --> multi_imp xs (x --> y)) X1, X2 : expr H9 : forall (xs : list expr) (x y : expr), Phi ((x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y)) X3 : expr H7 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> Phi (multi_imp xs y) -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ Phi (multi_imp xs1 (multi_imp xs2 y)) X4 : expr H15 : forall (xs : list expr) (y z : expr), Phi (multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z) H14 : forall (xs : list expr) (x y : expr), Phi (multi_imp xs (x --> y) --> x --> multi_imp xs y) X5, X6, X7 : expr H20 : forall (xs : list expr) (y z : expr), |-- multi_imp xs y --> multi_imp xs (y --> z) --> multi_imp xs z H19 : forall (xs : list expr) (x y : expr), |-- multi_imp xs (x --> y) --> x --> multi_imp xs y H13 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs (x --> y)) --> multi_imp xs (x --> y) H12 : forall (xs : list expr) (x y : expr), |-- (x --> multi_imp xs y) --> multi_imp xs (x --> y) H8 : forall (Phi1 Phi2 : Ensemble expr) (xs : list expr) (y : expr), Forall (Union expr Phi1 Phi2) xs -> |-- multi_imp xs y -> exists xs1 xs2 : list expr, Forall Phi1 xs1 /\\\\ Forall Phi2 xs2 /\\\\ |-- multi_imp xs1 (multi_imp xs2 y) H4 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi;; x |-- y -> Phi |-- y H1 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi;; x |-- y X8 : expr Unable to unify \"Union expr Phi (fun x : expr => In x xs) |-- y\" with \"MinimumAxiomatization L {| provable := Phi |}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros Phi xs y. split. - intros H. apply (deduction_subst1 Phi (multi_imp xs y) y). + apply H. + apply deduction_weaken1 with (x := multi_imp xs y). * apply provable_multi_imp_arg_switch1. apply H. * apply provable_multi_imp_shrink. apply provable_multi_imp_split in H. destruct H as [xs1 [xs2 [H1 [H2 H3]]]]. apply provable_multi_imp_weaken with (x := multi_imp xs1 y). ++ apply H1. ++ apply provable_multi_imp_modus_ponens. apply H3. apply provable_multi_imp_arg_switch2. apply H2. - intros H. apply deduction_weaken1 with (x := y). apply provable_multi_imp_shrink. apply provable_multi_imp_arg_switch1. apply H.", "succ": false}]