[{"history": {"proof": "qsimpl time: 2. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp. qsimpl time: 2 use: sat_orp.", "repairs": ["not_inductive_product", "cannot_apply_in", "no_instance_var", "not_inductive_product", "not_inductive_goal", "cannot_unify", "no_instance_var", "not_inductive_goal", "not_inductive_goal", "no_instance_var", "not_inductive_goal", "cannot_unify", "not_inductive_goal", "cannot_unify", "not_inductive_goal", "cannot_unify", "no_hypos", "not_inductive_goal", "cannot_unify", "not_inductive_goal", "cannot_unify"], "exceptions": [{"ctx": ["intros x y m."], "tactic": "split; intros H.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2."], "tactic": "split; intros n Hn.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2."], "tactic": "apply sat_orp in H.", "exn": "Unable to apply lemma of type \"forall (m0 : Kworlds ?M) (x0 y0 : expr), KRIPKE: ?M, m0 |= x0 || y0 <-> KRIPKE: ?M, m0 |= x0 \\\\/ KRIPKE: ?M, m0 |= y0\" on hypothesis of type \"Included (Kworlds M) (Kdenotation M FF) Semantics.falsep\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp."], "tactic": "destruct H as [Hx | Hy].", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hx.", "exn": "The reference Hx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind."], "tactic": "apply Hn.", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hy.", "exn": "The reference Hy was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hn.", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply sat_orp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R1 : KI.Relation (Kworlds M) R2 : Relation (Kworlds M) SM : Semantics L MD pf_R2 : PartialFunctional Krelation x, y : expr m : Kworlds M denote_boxp : forall x : expr, Same_set (Kworlds M) (Kdenotation M (\u25a1 x)) (Semantics.boxp (Kdenotation M x)) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H0 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) KM_relation_up : forall m m' n' : Kworlds M, m <= m' -> Krelation m' n' -> exists n : Kworlds M, n <= n' /\\\\ Krelation m n PreOrder_Reflexive : Reflexive KI.Krelation PreOrder_Transitive : Transitive KI.Krelation H1 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) H2 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) Unable to unify \"(KRIPKE: ?M, ?M12517 |= ?M12518 || ?M12519 -> KRIPKE: ?M, ?M12517 |= ?M12518 \\\\/ KRIPKE: ?M, ?M12517 |= ?M12519) /\\\\ (KRIPKE: ?M, ?M12517 |= ?M12518 \\\\/ KRIPKE: ?M, ?M12517 |= ?M12519 -> KRIPKE: ?M, ?M12517 |= ?M12518 || ?M12519)\" with \"Empty_set expr (\u25a1 (x || y) <--> \u25a1 x || \u25a1 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "destruct H as [Hx Hy].", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hx.", "exn": "The reference Hx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hn.", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hy.", "exn": "The reference Hy was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hn.", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "destruct H as [Hx Hy].", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "split; intros n Hn.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply sat_orp.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R1 : KI.Relation (Kworlds M) R2 : Relation (Kworlds M) SM : Semantics L MD pf_R2 : PartialFunctional Krelation x, y : expr m : Kworlds M denote_boxp : forall x : expr, Same_set (Kworlds M) (Kdenotation M (\u25a1 x)) (Semantics.boxp (Kdenotation M x)) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H0 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) KM_relation_up : forall m m' n' : Kworlds M, m <= m' -> Krelation m' n' -> exists n : Kworlds M, n <= n' /\\\\ Krelation m n PreOrder_Reflexive : Reflexive KI.Krelation PreOrder_Transitive : Transitive KI.Krelation H1 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) H2 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) Unable to unify \"(KRIPKE: ?M, ?M27667 |= ?M27668 || ?M27669 -> KRIPKE: ?M, ?M27667 |= ?M27668 \\\\/ KRIPKE: ?M, ?M27667 |= ?M27669) /\\\\ (KRIPKE: ?M, ?M27667 |= ?M27668 \\\\/ KRIPKE: ?M, ?M27667 |= ?M27669 -> KRIPKE: ?M, ?M27667 |= ?M27668 || ?M27669)\" with \"Empty_set expr (\u25a1 (x || y) <--> \u25a1 x || \u25a1 y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "destruct Hn.", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hx.", "exn": "The reference Hx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R1 : KI.Relation (Kworlds M) R2 : Relation (Kworlds M) SM : Semantics L MD pf_R2 : PartialFunctional Krelation x, y : expr m : Kworlds M boxp : expr -> expr denote_boxp : forall x : expr, Same_set (Kworlds M) (Kdenotation M (boxp x)) (Semantics.boxp (Kdenotation M x)) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H0 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) KM_relation_up : forall m m' n' : Kworlds M, m <= m' -> Krelation m' n' -> exists n : Kworlds M, n <= n' /\\\\ Krelation m n PreOrder_Reflexive : Reflexive KI.Krelation PreOrder_Transitive : Transitive KI.Krelation H1 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) H2 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) Unable to unify \"Included (Kworlds M) (Kdenotation M FF) Semantics.falsep\" with \"Empty_set expr (boxp (x || y) <--> boxp x || boxp y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hy.", "exn": "The reference Hy was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R1 : KI.Relation (Kworlds M) R2 : Relation (Kworlds M) SM : Semantics L MD pf_R2 : PartialFunctional Krelation x, y : expr m : Kworlds M boxp : expr -> expr denote_boxp : forall x : expr, Same_set (Kworlds M) (Kdenotation M (boxp x)) (Semantics.boxp (Kdenotation M x)) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H0 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) KM_relation_up : forall m m' n' : Kworlds M, m <= m' -> Krelation m' n' -> exists n : Kworlds M, n <= n' /\\\\ Krelation m n PreOrder_Reflexive : Reflexive KI.Krelation PreOrder_Transitive : Transitive KI.Krelation H1 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) H2 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) Unable to unify \"Included (Kworlds M) (Kdenotation M FF) Semantics.falsep\" with \"Empty_set expr (boxp (x || y) <--> boxp x || boxp y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply sat_orp in Hn.", "exn": "No such hypothesis: Hn", "type": "no_hypos", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "destruct Hn.", "exn": "The reference Hn was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hx.", "exn": "The reference Hx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R1 : KI.Relation (Kworlds M) R2 : Relation (Kworlds M) SM : Semantics L MD pf_R2 : PartialFunctional Krelation x, y : expr m : Kworlds M boxp : expr -> expr denote_boxp : forall x : expr, Same_set (Kworlds M) (Kdenotation M (boxp x)) (Semantics.boxp (Kdenotation M x)) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H0 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) KM_relation_up : forall m m' n' : Kworlds M, m <= m' -> Krelation m' n' -> exists n : Kworlds M, n <= n' /\\\\ Krelation m n PreOrder_Reflexive : Reflexive KI.Krelation PreOrder_Transitive : Transitive KI.Krelation H1 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) H3 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) Unable to unify \"Included (Kworlds M) (Kdenotation M FF) Semantics.falsep\" with \"Empty_set expr (boxp (x || y) <--> boxp x || boxp y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply Hy.", "exn": "The reference Hy was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros x y m.", "qsimpl time: 2.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "apply Empty_set_ind.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "destruct mL.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp.", "qsimpl time: 2 use: sat_orp."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L mL : ModalLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R1 : KI.Relation (Kworlds M) R2 : Relation (Kworlds M) SM : Semantics L MD pf_R2 : PartialFunctional Krelation x, y : expr m : Kworlds M boxp : expr -> expr denote_boxp : forall x : expr, Same_set (Kworlds M) (Kdenotation M (boxp x)) (Semantics.boxp (Kdenotation M x)) denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H0 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) KM_relation_up : forall m m' n' : Kworlds M, m <= m' -> Krelation m' n' -> exists n : Kworlds M, n <= n' /\\\\ Krelation m n PreOrder_Reflexive : Reflexive KI.Krelation PreOrder_Transitive : Transitive KI.Krelation H1 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) H3 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x || y -> KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y) /\\\\ (KRIPKE: M, m |= x \\\\/ KRIPKE: M, m |= y -> KRIPKE: M, m |= x || y) Unable to unify \"Included (Kworlds M) (Kdenotation M FF) Semantics.falsep\" with \"Empty_set expr (boxp (x || y) <--> boxp x || boxp y)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros x y m. split; intros H. - split; intros n Hn. + apply sat_orp in H. destruct H as [Hx | Hy]. * left. apply Hx. apply Hn. * right. apply Hy. apply Hn. + apply sat_orp. destruct H as [Hx Hy]. * left. apply Hx. apply Hn. * right. apply Hy. apply Hn. - destruct H as [Hx Hy]. split; intros n Hn. + apply sat_orp. destruct Hn. * left. apply Hx. apply H. * right. apply Hy. apply H. + apply sat_orp in Hn. destruct Hn. * left. apply Hx. apply H. * right. apply Hy. apply H.", "succ": false}]