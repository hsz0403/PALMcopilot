[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold fun2vec, vec_set_pos."], "tactic": "rewrite vec_pos_set.", "exn": "Found no subterm matching \"vec_set_pos ?M1448#>?M1449\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold fun2vec, vec_set_pos.", "qsimpl use: vec_pos_set."], "tactic": "rewrite pos2nat_right.", "exn": "Found no subterm matching \"pos2nat (pos_right ?M1646 ?M1648)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold fun2vec, vec_set_pos.", "qsimpl use: vec_pos_set.", "qsimpl use: vec_pos_set,pos2nat_right."], "tactic": "reflexivity.", "exn": "In environment H1 : forall (n m : nat) (p : pos m), pos2nat (pos_right n p) = n + pos2nat p H0 : forall (X : Type) (n : nat) (g : pos n -> X) (p : pos n), vec_set_pos g#>p = g p X : Type i, n : nat f : nat -> X Unable to unify \"(fix vec_set_pos (n : nat) : (pos n -> X) -> vec X n := match n as n0 return ((pos n0 -> X) -> vec X n0) with | 0 => fun _ : pos 0 -> X => vec_nil | S n0 => fun g : pos (S n0) -> X => g pos0 ## vec_set_pos n0 (fun p : pos n0 => g (pos_nxt p)) end) n (fun p : pos n => f (i + pos2nat p))\" with \"(fix fun2vec (i n : nat) (f : nat -> X) {struct n} : vec X n := match n as n0 return (vec X n0) with | 0 => vec_nil | S n0 => f i ## fun2vec (S i) n0 f end) i n f\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold fun2vec, vec_set_pos. rewrite vec_pos_set. rewrite pos2nat_right. reflexivity.", "succ": false}]