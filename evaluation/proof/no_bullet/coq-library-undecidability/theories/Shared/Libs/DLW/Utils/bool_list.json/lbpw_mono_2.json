[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "split; intros.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros."], "tactic": "apply lbpw_mono_1.", "exn": "In environment f : bool -> bool -> bool Hf1 : forall x a b : bool, a \u2aa6 b -> f x a \u2aa6 f x b Hf2 : f \u27d8 \u27d8 = \u27d8 lbpw_mono_1 : forall l m : lb, lb_pointwise l nil \u2aaf lb_pointwise l m lbpw_mono_f_0 : forall (g : bool -> bool) (l m : lb), g \u27d8 = \u27d8 -> g \u27d8 \u2aa6 g \u27d9 -> l \u2aaf m -> map g l \u2aaf map g m l, m : lb H : m \u2aaf nil Unable to unify \"lb_pointwise ?M1434 nil \u2aaf lb_pointwise ?M1434 ?M1435\" with \"lb_pointwise l m \u2aaf lb_pointwise l nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros."], "tactic": "apply lb_mask_inv_cons in H.", "exn": "Unable to apply lemma of type \"forall (x y : bool) (l m : lb), x :: l \u2aaf y :: m -> x \u2aa6 y /\\\\ l \u2aaf m\" on hypothesis of type \"m \u2aaf nil\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros.", "qsimpl use: lb_mask_inv_cons."], "tactic": ["destruct H as [H1 H2].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros. intros H. split; intros. - apply lbpw_mono_1. auto. - apply lb_mask_inv_cons in H. destruct H as [H1 H2]. apply lbpw_mono_1. auto. - apply lb_mask_inv_cons in H. destruct H as [H1 H2]. apply lb_mask_leb in H. apply lb_mask_leb. auto. - apply lbpw_mono_1. apply lb_mask_inv_cons in H. destruct H as [H1 H2]. auto.", "succ": false}]