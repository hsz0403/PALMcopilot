[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold vec_map_list.", "unfold vec_one.", "unfold vec_set_pos."], "tactic": "rewrite vec_change_pred.", "exn": "Unable to find an instance for the variables n, v, p, u.", "type": "no_instance_var", "handled": true}, {"ctx": ["unfold vec_map_list.", "unfold vec_one.", "unfold vec_set_pos.", "qsimpl use: vec_change_pred."], "tactic": "reflexivity.", "exn": "In environment H : forall (n : nat) (v : vec nat n) (p : pos n) (u : nat), v#>p = S u -> v = vec_plus (vec_one p) (v[u/p]) X : Type n : nat p : pos n f : pos n -> X Unable to unify \"f p :: nil\" with \"(fix vec_map_list (X : Type) (n : nat) (v : vec nat n) {struct v} : (pos n -> X) -> list X := match v in (vec _ m) return ((pos m -> X) -> list X) with | vec_nil => fun _ : pos 0 -> X => nil | Vector.cons _ a n0 v0 => fun f : pos (S n0) -> X => list_repeat (f pos0) a ++ vec_map_list X n0 v0 (fun p : pos n0 => f (pos_nxt p)) end) X n ((fix vec_set_pos (n : nat) : (pos n -> nat) -> vec nat n := match n as n0 return ((pos n0 -> nat) -> vec nat n0) with | 0 => fun _ : pos 0 -> nat => vec_nil | S n0 => fun g : pos (S n0) -> nat => g pos0 ## vec_set_pos n0 (fun p : pos n0 => g (pos_nxt p)) end) n (fun q : pos n => if pos_eq_dec p q then 1 else 0)) f\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold vec_map_list. unfold vec_one. unfold vec_set_pos. simpl. rewrite vec_change_pred. reflexivity.", "succ": false}]