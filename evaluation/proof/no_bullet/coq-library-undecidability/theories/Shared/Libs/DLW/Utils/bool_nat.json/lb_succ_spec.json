[{"history": {"proof": "hauto use: lb_succ_spec_1, lb_succ_spec_0 unfold: add, bool2nat inv: bool.", "repairs": ["hammer"], "exceptions": [{"ctx": ["unfold lb_succ.", "simpl."], "tactic": "rewrite lb_succ_spec_1.", "exn": "Found no subterm matching \"\u27e6 lb_succ \u27d9 ?M1514 \u27e7\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold lb_succ.", "simpl.", "qsimpl use: lb_succ_spec_1."], "tactic": "rewrite lb_nat_fix_3.", "exn": "Found no subterm matching \"\u27e6 ?M1623 :: ?M1624 \u27e7\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold lb_succ.", "simpl.", "qsimpl use: lb_succ_spec_1.", "qsimpl use: lb_nat_fix_3,lb_succ_spec_1."], "tactic": "rewrite <- plus_n_Sm.", "exn": "Found no subterm matching \"?M1780 + S ?M1781\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold lb_succ.", "simpl.", "qsimpl use: lb_succ_spec_1.", "qsimpl use: lb_nat_fix_3,lb_succ_spec_1.", "qsimpl use: lb_nat_fix_3,lb_succ_spec_1,plus_n_Sm."], "tactic": "reflexivity.", "exn": "In environment H3 : forall n m : nat, S (n + m) = n + S m H2 : forall l : lb, \u27e6 lb_succ \u27d9 l \u27e7 = S \u27e6 l \u27e7 H : forall (x : bool) (l : lb), bool2nat x + (\u27e6 l \u27e7 + (\u27e6 l \u27e7 + 0)) = bool2nat x + (\u27e6 l \u27e7 + (\u27e6 l \u27e7 + 0)) a : bool l : lb Unable to unify \"bool2nat a + \u27e6 l \u27e7\" with \"\u27e6 (fix lb_succ (a : bool) (l : lb) {struct l} : lb := match l with | nil => a :: nil | x :: l0 => let (r, z) := if a then if x then (\u27d9, \u27d8) else (\u27d8, \u27d9) else if x then (\u27d8, \u27d9) else (\u27d8, \u27d8) in z :: lb_succ r l0 end) a l \u27e7\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. unfold lb_succ. simpl. rewrite lb_succ_spec_1. rewrite lb_nat_fix_3. rewrite <- plus_n_Sm. reflexivity.", "succ": true}]