[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": ["destruct c.", ""], "exn": "Abstracting over the terms \"n\" and \"t\" leads to a term fun (n0 : nat) (t0 : pos n0) => pos n0 -> forall h0 l0 : pos n0, t0 <> h0 -> t0 <> l0 -> h0 <> l0 -> let decoder_error0 := PUSH t0 Zero :: POP t0 q q :: nil in forall v0 : vec (list bool) n0, v0#>t0 = list_nat_bool ln -> v0#>h0 = nil -> v0#>l0 = nil -> let (hh, ll) := tile_concat ln lt in (i, full_decoder i lt) // (i, v0) ->> (p, v0[nil/t0][hh/h0][ll/l0]) which is ill-typed. Reason is: Illegal application: The term \"@pair\" of type \"forall A B : Type, A -> B -> A * B\" cannot be applied to the terms \"nat\" : \"Set\" \"list (bsm_instr n0)\" : \"Set\" \"i\" : \"nat\" \"full_decoder i lt\" : \"list (bsm_instr n)\" The 4th term has type \"list (bsm_instr n)\" which should be coercible to \"list (bsm_instr n0)\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. destruct c. unfold_ShiftNat_shift. simpl. unfold list_nat_bool in H0. rewrite H0. intros. apply nth_nth_nth_map. intro H4. inversion H4. intros. apply bsm_steps_POP_0_inv with (x:=l) (ll:=ll) (v:=v) (st:=v). auto. auto. rewrite H1. auto.", "succ": false}]