[{"history": {"proof": "hauto use: mm_div2_progress inv: prod, bool.", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "apply mm_div2_progress.", "exn": "In environment n : nat src, quo, rem : pos n Hsq : src <> quo Hsr : src <> rem Hqr : quo <> rem i : nat mm_div2_spec_0 : forall (k : nat) (v w : vec nat n), v#>src = 2 * k -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo] -> (i, mm_div2) // (i, v) -+> (6 + i, w) mm_div2_spec_1 : forall (k : nat) (v w : vec nat n), v#>src = 1 + 2 * k -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo][1/rem] -> (i, mm_div2) // (i, v) -+> (6 + i, w) v : vec nat n k : nat st : nat * vec nat n H : v#>quo = 0 H0 : v#>rem = 0 H1 : div2 (v#>src) = (k, One) H2 : st = (6 + i, v[0/src][k/quo][1/rem]) Unable to unify \"let (k, b) := div2 (?M1453#>src) in (i, mm_div2) // (i, ?M1453) -+> (6 + i, ?M1453[0/src][k/quo][(if b then 1 else 0)/rem])\" with \"exists k : nat, 0 < k /\\\\ (i, mm_div2) // (i, v) -[k]-> st\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: mm_div2_progress."], "tactic": "apply H.", "exn": "In environment n : nat src, quo, rem : pos n i : nat H3 : forall v : vec nat n, v#>quo = 0 -> v#>rem = 0 -> let (k, b) := div2 (v#>src) in (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][(if b then 1 else 0)/rem]) Hsq : src = quo -> False Hsr : src = rem -> False Hqr : quo = rem -> False mm_div2_spec_0 : forall (k : nat) (v w : vec nat n), v#>src = k + (k + 0) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) mm_div2_spec_1 : forall (k : nat) (v w : vec nat n), v#>src = S (k + (k + 0)) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo][1/rem] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) v : vec nat n k : nat H : v#>quo = 0 H0 : v#>rem = 0 H1 : div2 (v#>src) = (k, One) Unable to unify \"v#>quo = 0\" with \"(i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][1/rem])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: mm_div2_progress.", "qsimpl use: mm_div2_progress."], "tactic": "apply H0.", "exn": "In environment n : nat src, quo, rem : pos n i : nat H2 : forall v : vec nat n, v#>quo = 0 -> v#>rem = 0 -> let (k, b) := div2 (v#>src) in (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][(if b then 1 else 0)/rem]) Hsq : src = quo -> False Hsr : src = rem -> False Hqr : quo = rem -> False mm_div2_spec_0 : forall (k : nat) (v w : vec nat n), v#>src = k + (k + 0) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) mm_div2_spec_1 : forall (k : nat) (v w : vec nat n), v#>src = S (k + (k + 0)) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo][1/rem] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) v : vec nat n k : nat H : v#>quo = 0 H0 : v#>rem = 0 H1 : div2 (v#>src) = (k, One) Unable to unify \"v#>rem = 0\" with \"(i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][1/rem])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: mm_div2_progress.", "qsimpl use: mm_div2_progress.", "qsimpl use: mm_div2_progress."], "tactic": "apply H1.", "exn": "In environment n : nat src, quo, rem : pos n i : nat H3 : forall v : vec nat n, v#>quo = 0 -> v#>rem = 0 -> let (k, b) := div2 (v#>src) in (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][(if b then 1 else 0)/rem]) Hsq : src = quo -> False Hsr : src = rem -> False Hqr : quo = rem -> False mm_div2_spec_0 : forall (k : nat) (v w : vec nat n), v#>src = k + (k + 0) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) mm_div2_spec_1 : forall (k : nat) (v w : vec nat n), v#>src = S (k + (k + 0)) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo][1/rem] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) v : vec nat n k : nat H : v#>quo = 0 H0 : v#>rem = 0 H1 : div2 (v#>src) = (k, One) Unable to unify \"div2 (v#>src) = (k, One)\" with \"(i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][1/rem])\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: mm_div2_progress.", "qsimpl use: mm_div2_progress.", "qsimpl use: mm_div2_progress.", "qsimpl use: mm_div2_progress."], "tactic": "apply H2.", "exn": "In environment n : nat src, quo, rem : pos n i : nat H2 : forall v : vec nat n, v#>quo = 0 -> v#>rem = 0 -> let (k, b) := div2 (v#>src) in (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), v[0/src][k/quo][(if b then 1 else 0)/rem]) Hsq : src = quo -> False Hsr : src = rem -> False Hqr : quo = rem -> False mm_div2_spec_0 : forall (k : nat) (v w : vec nat n), v#>src = k + (k + 0) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) mm_div2_spec_1 : forall (k : nat) (v w : vec nat n), v#>src = S (k + (k + 0)) -> v#>rem = 0 -> w = v[0/src][(k + (v#>quo))/quo][1/rem] -> (i, mm_div2) // (i, v) -+> (S (S (S (S (S (S i))))), w) v : vec nat n k : nat H : v#>quo = 0 H0 : v#>rem = 0 H1 : div2 (v#>src) = (k, One) Unable to unify \"let (k, b) := div2 (?M5200#>src) in (i, mm_div2) // (i, ?M5200) -+> (S (S (S (S (S (S i))))), ?M5200[0/src][k/quo][(if b then 1 else 0)/rem])\" with \"exists k0 : nat, 0 < k0 /\\\\ (i, mm_div2) // (i, v) -[k0]-> (S (S (S (S (S (S i))))), v[0/src][k/quo][1/rem])\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. intros. intros. intros. intros. intros. intros. intros. intros. apply mm_div2_progress. apply H. apply H0. apply H1. apply H2.", "succ": true}]