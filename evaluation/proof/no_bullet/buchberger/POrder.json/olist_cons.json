[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros l a b H1 H2."], "tactic": "induction H1.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros l a b H1 H2.", "qsimpl."], "tactic": "apply eqT_compat_ltTl with (c:=a) in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros l a b H1 H2.", "qsimpl.", "qsimpl use: eqT_compat_ltTl."], "tactic": "apply ltT_dec in H0 as [H0|H0]; auto.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros l a b H1 H2.", "qsimpl.", "qsimpl use: eqT_compat_ltTl.", "qsimpl use: eqT_compat_ltTl,ltT_dec."], "tactic": "apply IHpX; auto.", "exn": "The reference IHpX was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l a b H1 H2.", "qsimpl.", "qsimpl use: eqT_compat_ltTl.", "qsimpl use: eqT_compat_ltTl,ltT_dec.", "apply BinNat.N.binary_rec; auto.", "+"], "tactic": "apply ltT_dec in H0 as [H0|H0]; auto.", "exn": "Unable to apply lemma of type \"forall x y : Term A n, {ltT x y} + {ltT y x} + {eqT (A:=A) (n:=n) x y}\" on hypothesis of type \"forall a b c : Term A n, eqT (A:=A) (n:=n) b c -> ltT b a -> ltT c a\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros l a b H1 H2.", "qsimpl.", "qsimpl use: eqT_compat_ltTl.", "qsimpl use: eqT_compat_ltTl,ltT_dec.", "apply BinNat.N.binary_rec; auto.", "+", "qsimpl use: eqT_compat_ltTl,ltT_dec."], "tactic": "apply ltT_dec in H0 as [H0|H0]; auto.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros l a b H1 H2. induction H1. - auto. - apply eqT_compat_ltTl with (c:=a) in H. apply ltT_dec in H0 as [H0|H0]; auto. + apply IHpX; auto. + apply ltT_dec in H0 as [H0|H0]; auto. * apply ltT_dec in H0 as [H0|H0]; auto. * contradiction.", "succ": false}]