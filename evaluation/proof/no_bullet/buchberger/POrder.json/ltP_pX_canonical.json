[{"history": {"proof": "intros a p Hcanonic Hnz HltP. unfold canonical in Hcanonic. unfold canonical. split. - destruct Hcanonic as [H1 H2]. unfold olist in H1. srun best use: ltP_pX_olist unfold: olist. - sfirstorder depth: 3.", "repairs": ["", "", "", "", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros a p Hcanonic Hnz HltP.", "unfold canonical in Hcanonic.", "unfold canonical.", "split.", "-", "destruct Hcanonic as [H1 H2].", "unfold olist in H1."], "tactic": ["destruct H1 as [H1 H1'].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros a p Hcanonic Hnz HltP. unfold canonical in Hcanonic. unfold canonical. split. - destruct Hcanonic as [H1 H2]. unfold olist in H1. destruct H1 as [H1 H1']. split. + apply ltP_pX_olist. * apply H1. * apply HltP. + intros x Hin. destruct (eqT_dec a x) as [Heq | Hneq]. * rewrite Heq. apply Hnz. * apply H2. apply H1'. apply Hin. - intro Heq. apply Hnz. apply zeroP_invTerm_zeroP with (A0:=A0)(A1:=A1)(eqA:=eqA)(plusA:=plusA)(invA:=invA)(minusA:=minusA)(multA:=multA)(divA:=divA). + apply cs. + apply Heq.", "succ": true}]