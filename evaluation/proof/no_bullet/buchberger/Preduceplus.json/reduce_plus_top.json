[{"history": {"proof": "qsimpl time: 1 use: mults,pX,pluspf. qsimpl time: 1 use: mults,pX,pluspf. qsimpl time: 1 use: mults,pX,reduce_mults,pluspf. qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults. qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults. qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults. qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults. qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "repairs": ["wrong_type", "no_instance_var", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP."], "tactic": "exists (mults multA (n:=n) a ((pluspf A0 eqA plusA eqA_dec ltM ltM_dec (pX a p) r))).", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) Q : list (poly A0 eqA ltM) r : list (Term A n) Hcanon : canonical A0 eqA ltM r a, b : Term A n HnZb : ~ zeroP A0 eqA (n:=n) b p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q Hcanonab : canonical A0 eqA ltM (pX (A:=A) (n:=n) a p) HdivP : divP A A0 eqA multA divA n a b The term \"eqA\" has type \"A -> A -> Prop\" while it is expected to have type \"A -> A -> A\" (cannot unify \"Prop\" and \"A\").", "type": "wrong_type", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf."], "tactic": "apply reduce_mults.", "exn": "In environment X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reduce ?M13763 ?M13764 ?M13765 ?M13766 ?M13768 ?M13769 ?M13770 ?M13771 ?M13773 ?M13774 ?M13775 ?M13776 ?M13778 (mults ?M13770 ?M13779 ?M13780) (mults ?M13770 ?M13779 ?M13781)\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf."], "tactic": "apply Hcanonab.", "exn": "The reference Hcanonab was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf."], "tactic": "apply reduceheadO.", "exn": "In environment X4 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A multA n a p) (l1 A multA n a q) X3 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reducehead ?M19727 ?M19728 ?M19729 ?M19730 ?M19731 ?M19732 ?M19733 ?M19734 ?M19735 ?M19736 ?M19737 ?M19738 ?M19739 (pX ?M19740 ?M19743) (spminusf ?M19727 ?M19728 ?M19729 ?M19730 ?M19731 ?M19732 ?M19733 ?M19734 ?M19735 ?M19736 ?M19737 ?M19738 ?M19740 ?M19741 ?M19742 ?M19743 ?M19744)\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults."], "tactic": "apply pluspf_inv1.", "exn": "In environment l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l2 A multA n a p) (l2 A multA n a q) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), pickinSetp A A0 eqA multA divA n ltM a (pX (A:=A) (n:=n) b q) Q -> reducehead A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) X4 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A multA n a p) (l1 A multA n a q) X3 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M27371 ?M27374 ?M27382 (pX ?M27386 (pluspf ?M27372 ?M27375 ?M27381 ?M27384 ?M27388 (pX ?M27387 ?M27389))) (pluspf ?M27372 ?M27375 ?M27381 ?M27384 (pX ?M27386 ?M27388) (pX ?M27387 ?M27389))\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply cs.", "exn": "The reference cs was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply eqA_dec.", "exn": "In environment l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l3 A multA n a p) (l3 A multA n a q) X8 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X7 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (p q : list (Term A n)), ltT (A:=A) ltM b a -> eqP A eqA n (pX (A:=A) (n:=n) a (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (pX (A:=A) (n:=n) b q))) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), pickinSetp A A0 eqA multA divA n ltM a (pX (A:=A) (n:=n) b q) Q -> reducehead A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l2 A multA n a p) (l2 A multA n a q) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A multA n a p) (l1 A multA n a q) X3 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"{eqA ?M36735 ?M36736} + {eqA ?M36735 ?M36736 -> False}\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply os.", "exn": "The reference os was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply HinPolySet.", "exn": "In environment l4 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l4 A multA n a p) (l4 A multA n a q) X10 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X9 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (p q : list (Term A n)), ltT (A:=A) ltM b a -> eqP A eqA n (pX (A:=A) (n:=n) a (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (pX (A:=A) (n:=n) b q))) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), pickinSetp A A0 eqA multA divA n ltM a (pX (A:=A) (n:=n) b q) Q -> reducehead A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l3 A multA n a p) (l3 A multA n a q) X8 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X7 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l2 A multA n a p) (l2 A multA n a q) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A multA n a p) (l1 A multA n a q) X3 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply Hcanon.", "exn": "The reference Hcanon was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply reduceheadO.", "exn": "In environment l5 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l5 A multA n a p) (l5 A multA n a q) X12 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X11 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) H9 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (p q : list (Term A n)), ltT (A:=A) ltM b a -> eqP A eqA n (pX (A:=A) (n:=n) a (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (pX (A:=A) (n:=n) b q))) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) H8 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), pickinSetp A A0 eqA multA divA n ltM a (pX (A:=A) (n:=n) b q) Q -> reducehead A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) l4 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l4 A multA n a p) (l4 A multA n a q) X10 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X9 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l3 A multA n a p) (l3 A multA n a q) X8 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X7 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l2 A multA n a p) (l2 A multA n a q) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A multA n a p) (l1 A multA n a q) X3 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"reducehead ?M58931 ?M58932 ?M58933 ?M58934 ?M58935 ?M58936 ?M58937 ?M58938 ?M58939 ?M58940 ?M58941 ?M58942 ?M58943 (pX ?M58944 ?M58947) (spminusf ?M58931 ?M58932 ?M58933 ?M58934 ?M58935 ?M58936 ?M58937 ?M58938 ?M58939 ?M58940 ?M58941 ?M58942 ?M58944 ?M58945 ?M58946 ?M58947 ?M58948)\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,pluspf.", "qsimpl time: 1 use: mults,pX,reduce_mults,pluspf.", "qsimpl time: 1 use: reduceheadO,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults.", "qsimpl time: 1 use: reduceheadO,pluspf_inv1,pX,pluspf,mults,reduce_mults."], "tactic": "apply pluspf_inv3a.", "exn": "In environment l6 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H14 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l6 A multA n a p) (l6 A multA n a q) X14 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X13 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) H11 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (a b : Term A n) (p q : list (Term A n)), ltT (A:=A) ltM b a -> eqP A eqA n (pX (A:=A) (n:=n) a (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec p (pX (A:=A) (n:=n) b q))) (pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (pX (A:=A) (n:=n) a p) (pX (A:=A) (n:=n) b q)) H6 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A) (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) (Q : list (poly A0 eqA ltM)) (a b : Term A n) (nZb : zeroP A0 eqA (n:=n) b -> False) (p q : list (Term A n)), pickinSetp A A0 eqA multA divA n ltM a (pX (A:=A) (n:=n) b q) Q -> reducehead A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (pX (A:=A) (n:=n) a p) (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b nZb p q) l5 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H13 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l5 A multA n a p) (l5 A multA n a q) X12 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X11 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) l4 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H12 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l4 A multA n a p) (l4 A multA n a q) X10 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X9 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) l3 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H10 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l3 A multA n a p) (l3 A multA n a q) X8 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X7 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) l2 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H7 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l2 A multA n a p) (l2 A multA n a q) X6 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X5 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X4 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l1 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) H4 : forall (A : Set) (A0 A1 : A) (eqA : A -> A -> Prop) (plusA : A -> A -> A) (invA : A -> A) (minusA multA : A -> A -> A) (divA : A -> forall b : A, (eqA b A0 -> False) -> A), CoefStructure A A0 A1 eqA plusA invA minusA multA divA -> forall (eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False}) (n : nat) (ltM : mon n -> mon n -> Prop) (ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}), OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) -> forall (Q : list (poly A0 eqA ltM)) (a : Term A n) (p q : list (Term A n)), reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q p q -> canonical A0 eqA ltM p -> (zeroP A0 eqA (n:=n) a -> False) -> reduce A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec Q (l1 A multA n a p) (l1 A multA n a q) X3 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X2 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) X1 : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X0 : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) l0 : forall A : Set, A -> forall eqA : A -> A -> Prop, (A -> A -> A) -> (forall a b : A, {eqA a b} + {eqA a b -> False}) -> forall (n : nat) (ltM : mon n -> mon n -> Prop), (forall a b : mon n, {ltM a b} + {ltM b a} + {a = b}) -> list (Term A n) -> list (Term A n) -> list (Term A n) l : forall (A : Set) (n : nat), Term A n -> list (Term A n) -> list (Term A n) X : forall A : Set, (A -> A -> A) -> forall n : nat, Term A n -> list (Term A n) -> list (Term A n) A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, (eqA b A0 -> False) -> A eqA_dec : forall a b : A, {eqA a b} + {eqA a b -> False} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} Q : list (poly A0 eqA ltM) r : list (Term A n) a, b : Term A n HnZb : zeroP A0 eqA (n:=n) b -> False p, q : list (Term A n) HinPolySet : inPolySet A A0 eqA n ltM (pX (A:=A) (n:=n) b q) Q nZb : zeroP A0 eqA (n:=n) b -> False H : zeroP A0 eqA (n:=n) a -> False H0 : eqTerm eqA (n:=n) a (multTerm multA (n:=n) (divTerm (A0:=A0) (eqA:=eqA) divA (n:=n) a (b:=b) nZb) b) H1 : olist (A:=A) ltM (pX (A:=A) (n:=n) a p) H3 : nZterm A0 eqA (n:=n) p H2 : olist (A:=A) ltM r H5 : nZterm A0 eqA (n:=n) r M1_min : forall x : mon n, ltM x (zero_mon n) -> False ltM_nonrefl : forall x : mon n, ltM x x -> False ltM_trans : transitive (mon n) ltM ltM_wf : well_founded ltM ltM_plusr : forall x y z : mon n, ltM x y -> ltM (mult_mon n x z) (mult_mon n y z) ltM_plusl : forall x y z : mon n, ltM x y -> ltM (mult_mon n z x) (mult_mon n z y) A1_diff_A0 : eqA A1 A0 -> False eqA_ref : reflexive A eqA eqA_sym : symmetric A eqA eqA_trans : transitive A eqA plusA_assoc : forall a b c : A, eqA (plusA a (plusA b c)) (plusA (plusA a b) c) plusA_com : forall a b : A, eqA (plusA a b) (plusA b a) plusA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (plusA a b) (plusA c d) plusA_A0 : forall a : A, eqA a (plusA a A0) invA_plusA : forall a : A, eqA A0 (plusA a (invA a)) invA_eqA_comp : forall a b : A, eqA a b -> eqA (invA a) (invA b) minusA_def : forall a b : A, eqA (minusA a b) (plusA a (invA b)) multA_eqA_comp : forall a b c d : A, eqA a c -> eqA b d -> eqA (multA a b) (multA c d) multA_assoc : forall a b c : A, eqA (multA a (multA b c)) (multA (multA a b) c) multA_com : forall a b : A, eqA (multA a b) (multA b a) multA_dist_l : forall a b c : A, eqA (plusA (multA c a) (multA c b)) (multA c (plusA a b)) multA_A0_l : forall a : A, eqA (multA A0 a) A0 multA_A1_l : forall a : A, eqA (multA A1 a) a divA_rew : forall (a b : A) (nZ1 nZ2 : eqA b A0 -> False), divA a b nZ1 = divA a b nZ2 divA_is_multA : forall (a b : A) (nZb : eqA b A0 -> False), eqA a (multA (divA a b nZb) b) divA_eqA_comp : forall (a b c d : A) (nZb : eqA b A0 -> False) (nZd : eqA d A0 -> False), eqA a c -> eqA b d -> eqA (divA a b nZb) (divA c d nZd) divA_multA_comp_r : forall (a b c : A) (nZc : eqA c A0 -> False), eqA (divA (multA a b) c nZc) (multA (divA a c nZc) b) divA_invA_r : forall (a b : A) (nZb : eqA b A0 -> False) (nZib : eqA (invA b) A0 -> False), eqA (divA a (invA b) nZib) (invA (divA a b nZb)) Unable to unify \"eqP ?M71751 ?M71754 ?M71762 (pluspf ?M71752 ?M71755 ?M71761 ?M71764 ?M71768 ?M71769) (pluspf ?M71752 ?M71755 ?M71761 ?M71764 (pX ?M71766 ?M71768) (pX ?M71767 ?M71769))\" with \"exists s : list (Term A n), reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (l A n a p) r) s /\\\\ reduceplus Q (l0 A A0 eqA plusA eqA_dec n ltM ltM_dec (spminusf A A0 A1 eqA invA minusA multA divA eqA_dec n ltM ltM_dec a b HnZb p q) r) s\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros Q r Hcanon a b HnZb p q HinPolySet Hcanonab HdivP. exists (mults multA (n:=n) a ((pluspf A0 eqA plusA eqA_dec ltM ltM_dec (pX a p) r))). split. - apply reduce_mults. + apply Hcanonab. + apply reduceheadO. * apply pluspf_inv1. ++ apply cs. ++ apply eqA_dec. ++ apply os. * apply HinPolySet. * apply Hcanon. + apply reduceheadO. * apply pluspf_inv3a. ++ apply cs. ++ apply eqA_dec. ++ apply os. * apply reducehead_ind. ++ apply Hcanonab. ++ apply reducehead_sind. ** apply Hcanonab. ** apply reducehead_ind. *** apply Hcanonab. *** apply reducehead_sind. **** apply Hcanonab. **** unfold reduce. eapply reduce_inv. apply cs. apply reduce_mults_invf.", "succ": false}]