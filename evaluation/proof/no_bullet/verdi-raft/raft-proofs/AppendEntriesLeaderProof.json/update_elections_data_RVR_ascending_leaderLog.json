[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type.", "shelve.", "+", "exists (log sd)."], "tactic": "apply handleRequestVoteReply_spec' in HhandleReply_type.", "exn": "Unable to apply lemma of type \"forall (h : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output) (h' : name) (t : nat) (r : bool) (st' : raft_data), handleRequestVoteReply h st h' t r = st' -> type st' = Follower \\\\/ st' = st \\\\/ type st' = Candidate \\\\/ type st' = Leader /\\\\ type st = Candidate /\\\\ log st' = log st /\\\\ r = true /\\\\ t = currentTerm st /\\\\ wonElection (dedup name_eq_dec (h' :: votesReceived st)) = true /\\\\ currentTerm st' = currentTerm st\" on hypothesis of type \"type match type sd with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output sd ((if v then [src] else []) ++ votesReceived sd)) (if v && wonElection (dedup name_eq_dec (src :: votesReceived sd)) then Leader else type sd)) (assoc_set name_eq_dec [] h (maxIndex (log sd)))) []) ((if v && wonElection (dedup name_eq_dec (src :: votesReceived sd)) then [(currentTerm sd, src :: votesReceived sd, log sd)] else []) ++ electoralVictories sd) | _ => sd end = Leader\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type.", "shelve.", "+", "exists (log sd).", "qsimpl use: handleRequestVoteReply_spec'."], "tactic": "destruct HhandleReply_type as [Heq_log [Hin [Heq_type [Heq_Follower [Htrue [Heq_currentTerm Hwon]]]]]].", "exn": "The reference HhandleReply_type was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type.", "shelve.", "+", "exists (log sd).", "qsimpl use: handleRequestVoteReply_spec'.", "destruct H0 as [Heq_log [Hin [Heq_type [Heq_Follower [Htrue [Heq_currentTerm Hwon]]]]]]."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type.", "shelve.", "+", "exists (log sd).", "qsimpl use: handleRequestVoteReply_spec'.", "destruct H0 as [Heq_log [Hin [Heq_type [Heq_Follower [Htrue [Heq_currentTerm Hwon]]]]]].", "qsimpl use: handleRequestVoteReply_spec'.", "*"], "tactic": "rewrite Heq_log.", "exn": "The reference Heq_log was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type.", "shelve.", "+", "exists (log sd).", "qsimpl use: handleRequestVoteReply_spec'.", "destruct H0 as [Heq_log [Hin [Heq_type [Heq_Follower [Htrue [Heq_currentTerm Hwon]]]]]].", "qsimpl use: handleRequestVoteReply_spec'.", "*", "rewrite one_leaderLog_per_term_log_invariant."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st Hst_type HhandleReply_type.", "destruct st as [ed sd].", "simpl in Hst_type, HhandleReply_type.", "unfold handleRequestVoteReply in HhandleReply_type.", "destruct (currentTerm sd <? t1) eqn:Heq.", "-", "inv HhandleReply_type.", "-", "destruct (t1 <? currentTerm sd) eqn:Heq'.", "+", "inv HhandleReply_type.", "shelve.", "+", "exists (log sd).", "qsimpl use: handleRequestVoteReply_spec'.", "destruct H0 as [Heq_log [Hin [Heq_type [Heq_Follower [Htrue [Heq_currentTerm Hwon]]]]]].", "qsimpl use: handleRequestVoteReply_spec'.", "*", "rewrite one_leaderLog_per_term_log_invariant.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply (ex_intro _ (currentTerm sd) Hin).", "exn": "The reference Hin was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros h src t1 v st Hst_type HhandleReply_type. destruct st as [ed sd]. simpl in Hst_type, HhandleReply_type. unfold handleRequestVoteReply in HhandleReply_type. destruct (currentTerm sd <? t1) eqn:Heq. - inv HhandleReply_type. - destruct (t1 <? currentTerm sd) eqn:Heq'. + inv HhandleReply_type. + exists (log sd). apply handleRequestVoteReply_spec' in HhandleReply_type. destruct HhandleReply_type as [Heq_log [Hin [Heq_type [Heq_Follower [Htrue [Heq_currentTerm Hwon]]]]]]. split. * rewrite Heq_log. reflexivity. * apply (ex_intro _ (currentTerm sd) Hin).", "succ": false}]