[{"history": {"proof": "intros net ps' st' H_gt H_in. unfold packets_gt_prevIndex in H_gt. intros p t n pli plt entries c e H_in_p H_body H_in_e. hauto lq: on depth: 3.", "repairs": ["", "", "", "hammer"], "exceptions": [{"ctx": ["intros net ps' st' H_gt H_in.", "unfold packets_gt_prevIndex in H_gt.", "intros p t n pli plt entries c e H_in_p H_body H_in_e."], "tactic": "apply H_gt with (p:=p) (t:=t) (n:=n) (pli:=pli) (plt:=plt) (entries:=entries) (c:=c) (e:=e) in H_in_p as H_gt_prevIndex.", "exn": "Unable to apply lemma of type \"forall (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (entries : list entry) (c : logIndex) (e : entry), In p (nwPackets net) -> pBody p = AppendEntries t n pli plt entries c -> In e entries -> eIndex e > pli\" on hypothesis of type \"In p (nwPackets {| nwPackets := ps'; nwState := st' |})\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros net ps' st' H_gt H_in. unfold packets_gt_prevIndex in H_gt. intros p t n pli plt entries c e H_in_p H_body H_in_e. apply H_gt with (p:=p) (t:=t) (n:=n) (pli:=pli) (plt:=plt) (entries:=entries) (c:=c) (e:=e) in H_in_p as H_gt_prevIndex. apply H_gt_prevIndex; auto.", "succ": true}]