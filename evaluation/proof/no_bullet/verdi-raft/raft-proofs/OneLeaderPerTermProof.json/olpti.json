[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "unfold one_leader_per_term_interface.", "exn": "Cannot coerce one_leader_per_term_interface to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["qsimpl use: one_leader_per_term_interface."], "tactic": "constructor.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}]}, "chat": [], "original": "intros. unfold one_leader_per_term_interface. constructor. intros. apply one_leader_per_term_invariant. apply refined_raft_net_invariant with (P := (fun net : network => one_leader_per_term net)). - apply refined_raft_net_invariant_init. - apply refined_raft_net_invariant_client_request. - apply refined_raft_net_invariant_timeout. - apply refined_raft_net_invariant_append_entries. - apply refined_raft_net_invariant_append_entries_reply. - apply refined_raft_net_invariant_request_vote. - apply refined_raft_net_invariant_request_vote_reply. - apply refined_raft_net_invariant_do_leader. - apply refined_raft_net_invariant_do_generic_server. - apply refined_raft_net_invariant_state_same_packet_subset. - apply refined_raft_net_invariant_reboot. - apply H.", "succ": false}]