[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = [] H : ([], RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output st (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st), []) = (out, st', ms) H1 : [] = out H2 : mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st) (stateMachine st) (nextIndex st) (matchIndex st) (shouldSend st) (votesReceived st) (type st) (clientCache st) (electoralVictories st) = st' H3 : [] = ms Unable to unify \"lastApplied st\" with \"lastApplied (mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st) (stateMachine st) (nextIndex st) (matchIndex st) (shouldSend st) (votesReceived st) (type st) (clientCache st) (electoralVictories st))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-"], "tactic": "destruct p as [out' st''].", "exn": "The reference p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+"], "tactic": "right.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) e : entry l : list entry Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = e :: l H : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out', state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out', state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out', state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out', state) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output state (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state), [])) = (out, st', ms) out' : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term net st'' : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_log net one_leaderLog_per_term_host_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_host net H1 : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out', state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out', state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out', state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out', state) in (out, mkRaft_data (currentTerm state) (votedFor state) (leaderId state) (log state) (commitIndex state) (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state) (stateMachine state) (nextIndex state) (matchIndex state) (shouldSend state) (votesReceived state) (type state) (clientCache state) (electoralVictories state), [])) = (out, st', ms) Unable to unify \"?M3416 <= S ?M3417\" with \"S (lastApplied st) <= commitIndex st\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2."], "tactic": "split; [auto |].", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq."], "tactic": "apply filter_In in Heq.", "exn": "Unable to apply lemma of type \"forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x (filter f l) <-> In x l /\\\\ f x = true\" on hypothesis of type \"e :: l = rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq']."], "tactic": "apply andb_true_iff in Heq'.", "exn": "No such hypothesis: Heq'", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq']."], "tactic": "destruct Heq' as [H1 H2].", "exn": "The reference Heq' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq']."], "tactic": "apply Nat.ltb_lt in H1.", "exn": "Unable to apply lemma of type \"forall n m : nat, (n <? m) = true <-> n < m\" on hypothesis of type \"forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x l -> f x = true -> In x (filter f l)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq']."], "tactic": "apply Nat.leb_le in H2.", "exn": "Unable to apply lemma of type \"forall n m : nat, (n <=? m) = true <-> n <= m\" on hypothesis of type \"forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x (filter f l) -> f x = true\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq']."], "tactic": "apply findGtIndex_In in Hin.", "exn": "No such hypothesis: Hin", "type": "no_hypos", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq']."], "tactic": "destruct Hin as [Hin _].", "exn": "The reference Hin was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq'].", "destruct Build_one_leaderLog_per_term_interface as [Build_one_leaderLog_per_term_interface _]."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq'].", "destruct Build_one_leaderLog_per_term_interface as [Build_one_leaderLog_per_term_interface _].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply Nat.lt_le_incl.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) e : entry l : list entry Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = e :: l H : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out', state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out', state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out', state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out', state) in (out, RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output state (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state), [])) = (out, st', ms) out' : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term net st'' : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_log net one_leaderLog_per_term_host_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_host net H1 : (let (out, state) := let (out, st) := cacheApplyEntry st e in let (out', state) := (fix applyEntries (h : name) (st0 : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st0) | e :: es => let (out0, st1) := cacheApplyEntry st0 e in let (out', state) := applyEntries h st1 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out0 else []) ++ out', state) end) h st l in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out', state) in (out, mkRaft_data (currentTerm state) (votedFor state) (leaderId state) (log state) (commitIndex state) (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state) (stateMachine state) (nextIndex state) (matchIndex state) (shouldSend state) (votesReceived state) (type state) (clientCache state) (electoralVictories state), [])) = (out, st', ms) Unable to unify \"?M43228 <= ?M43229\" with \"lastApplied st' = commitIndex st\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq'].", "destruct Build_one_leaderLog_per_term_interface as [Build_one_leaderLog_per_term_interface _].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "qsimpl time: 2 use: auto,filter_In.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq'].", "destruct Build_one_leaderLog_per_term_interface as [Build_one_leaderLog_per_term_interface _].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 2 use: filter_In."], "tactic": "apply Nat.ltb_lt.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params st : raft_data e : entry l : list entry Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = e :: l l0 : list output r : RaftState.raft_data term name entry logIndex serverType data clientId output Heqp : cacheApplyEntry st e = (l0, r) l1 : list raft_output r0 : raft_data Heqp0 : (fix applyEntries (h : name) (st : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st) | e :: es => let (out, st0) := cacheApplyEntry st e in let (out', state) := applyEntries h st0 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out', state) end) (eAt e) r l = (l1, r0) Heqs : name_eq_dec (eAt e) (eAt e) = left eq_refl out' : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term net st'' : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_log net one_leaderLog_per_term_host_invariant : forall net : network, refined_raft_intermediate_reachable net -> one_leaderLog_per_term_host net H1 : forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x l -> f x = true -> In x (filter f l) H2 : forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x (filter f l) -> f x = true H3 : forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x (filter f l) -> In x l H0 : lastApplied r0 < commitIndex r0 msg_refined_raft_net_invariant : forall (P : network -> Prop) (net : network), msg_refined_raft_net_invariant_init P -> msg_refined_raft_net_invariant_client_request P -> msg_refined_raft_net_invariant_timeout P -> msg_refined_raft_net_invariant_append_entries P -> msg_refined_raft_net_invariant_append_entries_reply P -> msg_refined_raft_net_invariant_request_vote P -> msg_refined_raft_net_invariant_request_vote_reply P -> msg_refined_raft_net_invariant_do_leader P -> msg_refined_raft_net_invariant_do_generic_server P -> msg_refined_raft_net_invariant_state_same_packet_subset P -> msg_refined_raft_net_invariant_reboot P -> msg_refined_raft_intermediate_reachable net -> P net msg_refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), msg_refined_raft_net_invariant_init P -> msg_refined_raft_net_invariant_client_request' P -> msg_refined_raft_net_invariant_timeout' P -> msg_refined_raft_net_invariant_append_entries' P -> msg_refined_raft_net_invariant_append_entries_reply' P -> msg_refined_raft_net_invariant_request_vote' P -> msg_refined_raft_net_invariant_request_vote_reply' P -> msg_refined_raft_net_invariant_do_leader' P -> msg_refined_raft_net_invariant_do_generic_server' P -> msg_refined_raft_net_invariant_state_same_packet_subset' P -> msg_refined_raft_net_invariant_reboot' P -> msg_refined_raft_intermediate_reachable net -> P net msg_lift_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P net) -> forall net : network, msg_refined_raft_intermediate_reachable net -> P (mgv_deghost net) msg_lift_prop_all_the_way : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, msg_refined_raft_intermediate_reachable net -> P (deghost (mgv_deghost net)) msg_lower_prop : forall P : network -> Prop, (forall net : network, msg_refined_raft_intermediate_reachable net -> P (mgv_deghost net)) -> forall net : network, refined_raft_intermediate_reachable net -> P net msg_lower_prop_all_the_way : forall P : network -> Prop, (forall net : network, msg_refined_raft_intermediate_reachable net -> P (deghost (mgv_deghost net))) -> forall net : network, raft_intermediate_reachable net -> P net msg_deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => nwState h end = nwState net h msg_simulation_1 : forall net : network, msg_refined_raft_intermediate_reachable net -> refined_raft_intermediate_reachable (mgv_deghost net) leaders_have_leaderLogs_strong_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaders_have_leaderLogs_strong net no_entries_past_current_term_invariant : forall net : network, raft_intermediate_reachable net -> no_entries_past_current_term net transitive_commit_invariant : forall net : network, refined_raft_intermediate_reachable net -> transitive_commit net ghost_log_entries_match_invariant : forall net : network, msg_refined_raft_intermediate_reachable net -> ghost_log_entries_match_host net log_properties_hold_on_ghost_logs_invariant : forall net : network, msg_refined_raft_intermediate_reachable net -> log_properties_hold_on_ghost_logs net ghost_log_correct_invariant : forall net : network, msg_refined_raft_intermediate_reachable net -> ghost_log_correct net terms_and_indices_from_one_log_invariant : forall net : network, raft_intermediate_reachable net -> terms_and_indices_from_one_log net terms_and_indices_from_one_log_nw_invariant : forall net : network, raft_intermediate_reachable net -> terms_and_indices_from_one_log_nw net leader_sublog_invariant_invariant : forall net : network, raft_intermediate_reachable net -> leader_sublog_invariant net leader_completeness_invariant : forall net : network, refined_raft_intermediate_reachable net -> leader_completeness net leaders_have_leaderLogs_invariant : forall net : network, refined_raft_intermediate_reachable net -> leaders_have_leaderLogs net match_index_all_entries_invariant : forall net : network, refined_raft_intermediate_reachable net -> match_index_all_entries net lastApplied_le_commitIndex_invariant : forall net : network, raft_intermediate_reachable net -> lastApplied_le_commitIndex net current_term_gt_zero_invariant : forall net : network, raft_intermediate_reachable net -> current_term_gt_zero net prevLog_leader_sublog_invariant : forall net : network, raft_intermediate_reachable net -> prevLog_leader_sublog net entries_contiguous_nw_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_contiguous_nw net entries_gt_0_nw_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_gt_0_nw net entries_sorted_nw_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_sorted_nw net entries_gt_0_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_gt_0 net entries_contiguous_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_contiguous net entries_sorted_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_sorted net entries_match_invariant : forall (net : network) (h h' : name), refined_raft_intermediate_reachable net -> entries_match (log (snd (nwState net h))) (log (snd (nwState net h'))) entries_match_nw_1_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_match_nw_1 net entries_match_nw_host_invariant : forall net : network, refined_raft_intermediate_reachable net -> entries_match_nw_host net allEntries_gt_0_invariant : forall (net : network) (h : name) (e : entry), refined_raft_intermediate_reachable net -> In e (map snd (allEntries (fst (nwState net h)))) -> eIndex e > 0 state_machine_safety'_invariant : forall net : network, refined_raft_intermediate_reachable net -> state_machine_safety' net log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (deghost net) Unable to unify \"((?M87419 <? ?M87420) = true -> ?M87419 < ?M87420) /\\\\ (?M87419 < ?M87420 -> (?M87419 <? ?M87420) = true)\" with \"commitIndex r0 = commitIndex st\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left.", "shelve.", "-", "destruct ollpti as [out' st''].", "inversion H; subst.", "right.", "split.", "+", "qsimpl time: 2.", "symmetry in Heq.", "qsimpl time: 2 use: filter_In.", "destruct Heq as [Hin Heq'].", "destruct Build_one_leaderLog_per_term_interface as [Build_one_leaderLog_per_term_interface _].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl time: 2 use: filter_In."], "tactic": "qsimpl time: 2 use: auto,filter_In.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros h st out st' ms H. unfold doGenericServer, applyEntries in H. destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq. - inversion H. left. reflexivity. - destruct p as [out' st'']. inversion H; subst. right. split. + right. split; [auto |]. symmetry in Heq. apply filter_In in Heq. destruct Heq as [Hin Heq']. apply andb_true_iff in Heq'. destruct Heq' as [H1 H2]. apply Nat.ltb_lt in H1. apply Nat.leb_le in H2. apply findGtIndex_In in Hin. destruct Hin as [Hin _]. exists e. split; auto. + apply Nat.lt_le_incl. apply Nat.ltb_lt. auto.", "succ": false}]