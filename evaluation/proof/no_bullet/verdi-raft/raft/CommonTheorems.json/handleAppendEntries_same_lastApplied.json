[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st t n pli plt es ci st' ps HhandleApp.", "unfold handleAppendEntries in HhandleApp.", "destruct (currentTerm st <? t) eqn:E1.", "-", "inversion HhandleApp."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps HhandleApp.", "unfold handleAppendEntries in HhandleApp.", "destruct (currentTerm st <? t) eqn:E1.", "-", "inversion HhandleApp.", "shelve.", "-", "destruct (pli =? 0) eqn:E2.", "+", "destruct (haveNewEntries st es) eqn:E3.", "*", "inversion HhandleApp; subst; clear HhandleApp."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st : raft_data t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st' : raft_data ps : msg E2 : (pli =? 0) = true E3 : haveNewEntries st es = true E1 : (currentTerm st <? t) = false H0 : (if t <? currentTerm st then (st, AppendEntriesReply (currentTerm st) es false) else (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) es (Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex es))) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true)) = (st', ps) Unable to unify \"lastApplied st\" with \"lastApplied st'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps HhandleApp.", "unfold handleAppendEntries in HhandleApp.", "destruct (currentTerm st <? t) eqn:E1.", "-", "inversion HhandleApp.", "shelve.", "-", "destruct (pli =? 0) eqn:E2.", "+", "destruct (haveNewEntries st es) eqn:E3.", "*", "inversion HhandleApp; subst; clear HhandleApp."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps HhandleApp.", "unfold handleAppendEntries in HhandleApp.", "destruct (currentTerm st <? t) eqn:E1.", "-", "inversion HhandleApp.", "shelve.", "-", "destruct (pli =? 0) eqn:E2.", "+", "destruct (haveNewEntries st es) eqn:E3.", "*", "inversion HhandleApp; subst; clear HhandleApp.", "shelve.", "*", "inversion HhandleApp."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps HhandleApp.", "unfold handleAppendEntries in HhandleApp.", "destruct (currentTerm st <? t) eqn:E1.", "-", "inversion HhandleApp.", "shelve.", "-", "destruct (pli =? 0) eqn:E2.", "+", "destruct (haveNewEntries st es) eqn:E3.", "*", "inversion HhandleApp; subst; clear HhandleApp.", "shelve.", "*", "inversion HhandleApp.", "shelve.", "+", "inversion HhandleApp; subst; clear HhandleApp."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st : raft_data t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st' : raft_data ps : msg E2 : (pli =? 0) = false E1 : (currentTerm st <? t) = false H0 : (if t <? currentTerm st then (st, AppendEntriesReply (currentTerm st) es false) else match findAtIndex (log st) pli with | Some e => if negb (plt =? eTerm e) then (st, AppendEntriesReply (currentTerm st) es false) else if haveNewEntries st es then (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) (es ++ removeAfterIndex (log st) pli) (Init.Nat.max (commitIndex st) (Init.Nat.min ci (maxIndex (es ++ removeAfterIndex (log st) pli)))) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true) else (mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (Some n) (log (advanceCurrentTerm st t)) (commitIndex (advanceCurrentTerm st t)) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)), AppendEntriesReply t es true) | None => (st, AppendEntriesReply (currentTerm st) es false) end) = (st', ps) Unable to unify \"lastApplied st\" with \"lastApplied st'\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st t n pli plt es ci st' ps HhandleApp. unfold handleAppendEntries in HhandleApp. destruct (currentTerm st <? t) eqn:E1. - inversion HhandleApp. - destruct (pli =? 0) eqn:E2. + destruct (haveNewEntries st es) eqn:E3. * inversion HhandleApp; subst; clear HhandleApp. simpl. reflexivity. * inversion HhandleApp. + inversion HhandleApp; subst; clear HhandleApp. simpl. reflexivity.", "succ": false}]