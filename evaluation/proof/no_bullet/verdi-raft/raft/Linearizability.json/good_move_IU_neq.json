[{"history": {"proof": "intros k k' h. unfold good_move. split; [intros k'' k''' [H1 H2]; inversion H1 | ]. split; [intros k'' [H1 H2]; inversion H1 | ]. - sfirstorder depth: 3. - sfirstorder depth: 3.", "repairs": ["", "", "used_var", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros k k' h.", "unfold good_move."], "tactic": "split; [intros k'' k [H1 H2]; inversion H1 | ].", "exn": "k is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros k k' h.", "unfold good_move.", "split; [intros k'' k''' [H1 H2]; inversion H1 | ].", "split; [intros k'' [H1 H2]; inversion H1 | ]."], "tactic": "intros k'' [H1 H2]; inversion H1.", "exn": "k'' is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros k k' h.", "unfold good_move.", "split; [intros k'' k''' [H1 H2]; inversion H1 | ].", "split; [intros k'' [H1 H2]; inversion H1 | ]."], "tactic": "intros k''' [H1 H2]; inversion H1.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros k k' h.", "unfold good_move.", "split; [intros k'' k''' [H1 H2]; inversion H1 | ].", "split; [intros k'' [H1 H2]; inversion H1 | ]."], "tactic": "intros k''' [H1' H2]; inversion H1.", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros k k' h.", "unfold good_move.", "split; [intros k'' k''' [H1 H2]; inversion H1 | ].", "split; [intros k'' [H1 H2]; inversion H1 | ]."], "tactic": "intros k''' [H1' H2']; inversion H1.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros k k' h. unfold good_move. split; [intros k'' k [H1 H2]; inversion H1 | ]. split; [intros k'' [H1 H2]; inversion H1 | ]. intros k'' [H1 H2]; inversion H1.", "succ": true}]