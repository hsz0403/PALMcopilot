[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H."], "tactic": "split; reflexivity.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+"], "tactic": "assert (haveNewEntries (snd st) es = false \\/ log st' = log (snd st) \\/ currentTerm st' = t /\\ log st' = es) as Hor by apply handleAppendEntries_log; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface h : name st : electionsData * raft_data t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st' : raft_data ps : name H : msg Heq1 : (t <? currentTerm (snd st)) = false Heq2 : (pli =? 0) = true Unable to unify \"log ?M5411 = log ?M5404 \\\\/ currentTerm ?M5404 <= ?M5405 /\\\\ ?M5409 <> [] /\\\\ ?M5407 = 0 /\\\\ log ?M5411 = ?M5409 \\\\/ (currentTerm ?M5404 <= ?M5405 /\\\\ ?M5409 <> [] /\\\\ ?M5407 <> 0 /\\\\ (exists e : entry, In e (log ?M5404) /\\\\ eIndex e = ?M5407 /\\\\ eTerm e = ?M5408)) /\\\\ log ?M5411 = ?M5409 ++ removeAfterIndex (log ?M5404) ?M5407\" with \"haveNewEntries (snd st) es = false \\\\/ log st' = log (snd st) \\\\/ currentTerm st' = t /\\\\ log st' = es\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log."], "tactic": "destruct Hor as [Hor_false | [Hor_log | [Hor_term_log | Hor_log_es]]].", "exn": "The reference Hor was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left."], "tactic": "auto.", "exn": "No such goal. Focus next goal with bullet *.", "type": "next_goal", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left."], "tactic": "right.", "exn": "No such goal. Focus next goal with bullet *.", "type": "next_goal", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*"], "tactic": "destruct (es =? []) eqn:Heq3.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params l : RaftState.raft_data term name entry logIndex serverType data clientId output -> list entry t0 : RaftState.raft_data term name entry logIndex serverType data clientId output -> term H0 : forall (h : name) (st : raft_data) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (ps : msg), handleAppendEntries h st t n pli plt es ci = (st', ps) -> l st' = l st \\\\/ t0 st <= t /\\\\ (es = [] -> False) /\\\\ pli = 0 /\\\\ l st' = es \\\\/ (t0 st <= t /\\\\ (es = [] -> False) /\\\\ (pli = 0 -> False) /\\\\ (exists e : entry, In e (l st) /\\\\ eIndex e = pli /\\\\ eTerm e = plt)) /\\\\ l st' = es ++ removeAfterIndex (l st) pli b0 : bool one_node_params : OneNodeParams orig_base_params h : name st0 : electionsData st1 : raft_data t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st' : raft_data ps : name H : msg Heq1 : (t <? currentTerm st1) = false Heq2 : (pli =? 0) = true b : raft_data -> list entry -> bool H1 : handleAppendEntries h st1 t n pli plt es ci = (st', H) H2 : raft_data refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) The term \"es\" has type \"list entry\" while it is expected to have type \"nat\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H."], "tactic": "split; [reflexivity | left].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "reflexivity.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "auto."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "auto.", "*", "right."], "tactic": "split; [reflexivity | split; [auto | right; split; [auto | right; split; [auto | auto ]]]].", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params l : RaftState.raft_data term name entry logIndex serverType data clientId output -> list entry t0 : RaftState.raft_data term name entry logIndex serverType data clientId output -> term H0 : forall (h : name) (st : raft_data) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (ps : msg), handleAppendEntries h st t n pli plt es ci = (st', ps) -> l st' = l st \\\\/ t0 st <= t /\\\\ (es = [] -> False) /\\\\ pli = 0 /\\\\ l st' = es \\\\/ (t0 st <= t /\\\\ (es = [] -> False) /\\\\ (pli = 0 -> False) /\\\\ (exists e : entry, In e (l st) /\\\\ eIndex e = pli /\\\\ eTerm e = plt)) /\\\\ l st' = es ++ removeAfterIndex (l st) pli b0 : bool one_node_params : OneNodeParams orig_base_params h : name st0 : electionsData st1 : raft_data t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st' : raft_data ps : name H : msg Heq1 : (t <? currentTerm st1) = false Heq2 : (pli =? 0) = true b : raft_data -> list entry -> bool H1 : handleAppendEntries h st1 t n pli plt es ci = (st', H) H2 : raft_data refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Unable to unify \"map (fun e : entry => (t, e)) es ++ allEntries st0\" with \"allEntries (update_elections_data_appendEntries h (st0, st1) t ps pli plt es ci)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "auto.", "*", "right.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "auto.", "*", "right.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros h st t n pli plt es ci st' ps H.", "destruct (t <? currentTerm (snd st)) eqn:Heq1.", "-", "inversion H.", "qsimpl.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "destruct (pli =? 0) eqn:Heq2.", "+", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "destruct moreUpToDate as [moreUpToDate_false | [moreUpToDate_log | [moreUpToDate_term_log | moreUpToDate_log_es]]].", "*", "left.", "*", "left.", "*", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "inversion H.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "auto.", "*", "right.", "qsimpl use: haveNewEntries,snd,currentTerm,log,false,handleAppendEntries_log.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "inversion H."], "tactic": "split; [reflexivity | right; split; [reflexivity | split; [assumption | right; split; [assumption | right; split; [assumption | auto ]]]]].", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros h st t n pli plt es ci st' ps H. unfold handleAppendEntries in H. destruct (t <? currentTerm (snd st)) eqn:Heq1. - inversion H. subst. split; reflexivity. - destruct (pli =? 0) eqn:Heq2. + assert (haveNewEntries (snd st) es = false \\/ log st' = log (snd st) \\/ currentTerm st' = t /\\ log st' = es) as Hor by apply handleAppendEntries_log; auto. destruct Hor as [Hor_false | [Hor_log | [Hor_term_log | Hor_log_es]]]. * right. left. auto. * left. right. auto. * destruct (es =? []) eqn:Heq3. { inversion H. subst. split; [reflexivity | left]. } { inversion H. subst. split. + reflexivity. + right. split; [reflexivity | split; [auto | right; split; [auto | right; split; [auto | auto ]]]]. } + inversion H. subst. split; [reflexivity | right; split; [reflexivity | split; [assumption | right; split; [assumption | right; split; [assumption | auto ]]]]].", "succ": false}]