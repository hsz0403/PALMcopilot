[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity."], "tactic": "split; [reflexivity|].", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface h, src : name t1 : nat v : bool st : electionsData * RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm (snd st) <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v st)) H : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower H4 : (t1 <? currentTerm (snd st)) = true H0 : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower H5 : type (snd st) = Follower H6 : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower Unable to unify \"Leader\" with \"type (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl."], "tactic": "split; [reflexivity|].", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h, src : name t1 : nat v : bool st0 : electionsData st1 : RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm st1 <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v (st0, st1))) H4 : (t1 <? currentTerm st1) = true H5 : type st1 = Follower refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Unable to unify \"Leader\" with \"Follower\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl."], "tactic": "apply eq_nat_dec.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h, src : name t1 : nat v : bool st0 : electionsData st1 : RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm st1 <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v (st0, st1))) H4 : (t1 <? currentTerm st1) = true H5 : type st1 = Follower refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Unable to unify \"{?M3043 = ?M3044} + {?M3043 <> ?M3044}\" with \"Follower = Leader\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity."], "tactic": "split; [reflexivity|].", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface h, src : name t1 : nat v : bool st : electionsData * RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm (snd st) <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v st)) H : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower H4 : (t1 <? currentTerm (snd st)) = true H0 : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower H5 : type (snd st) = Candidate H6 : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower Unable to unify \"Leader\" with \"type (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec."], "tactic": "split; [reflexivity|].", "exn": "In environment H1 : forall n m : nat, {n = m} + {n = m -> False} orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h, src : name t1 : nat v : bool st0 : electionsData st1 : RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm st1 <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v (st0, st1))) H4 : (t1 <? currentTerm st1) = true H5 : type st1 = Candidate refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Unable to unify \"Leader\" with \"Follower\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec."], "tactic": "apply eq_nat_dec.", "exn": "In environment H, H1 : forall n m : nat, {n = m} + {n = m -> False} orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h, src : name t1 : nat v : bool st0 : electionsData st1 : RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm st1 <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v (st0, st1))) H4 : (t1 <? currentTerm st1) = true H5 : type st1 = Candidate refined_raft_net_invariant : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request P -> refined_raft_net_invariant_timeout P -> refined_raft_net_invariant_append_entries P -> refined_raft_net_invariant_append_entries_reply P -> refined_raft_net_invariant_request_vote P -> refined_raft_net_invariant_request_vote_reply P -> refined_raft_net_invariant_do_leader P -> refined_raft_net_invariant_do_generic_server P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot P -> refined_raft_intermediate_reachable net -> P net refined_raft_net_invariant' : forall (P : network -> Prop) (net : network), refined_raft_net_invariant_init P -> refined_raft_net_invariant_client_request' P -> refined_raft_net_invariant_timeout' P -> refined_raft_net_invariant_append_entries' P -> refined_raft_net_invariant_append_entries_reply' P -> refined_raft_net_invariant_request_vote' P -> refined_raft_net_invariant_request_vote_reply' P -> refined_raft_net_invariant_do_leader' P -> refined_raft_net_invariant_do_generic_server' P -> refined_raft_net_invariant_state_same_packet_subset P -> refined_raft_net_invariant_reboot' P -> refined_raft_intermediate_reachable net -> P net lift_prop : forall P : network -> Prop, (forall net : network, raft_intermediate_reachable net -> P net) -> forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net) lower_prop : forall P : network -> Prop, (forall net : network, refined_raft_intermediate_reachable net -> P (GhostSimulations.deghost net)) -> forall net : network, raft_intermediate_reachable net -> P net deghost_spec : forall (net : network) (h : name), match net with | {| nwState := nwState |} => let (_, d) := nwState h in d end = snd (nwState net h) simulation_1 : forall net : network, refined_raft_intermediate_reachable net -> raft_intermediate_reachable (GhostSimulations.deghost net) Unable to unify \"{?M6438 = ?M6439} + {?M6438 <> ?M6439}\" with \"Follower = Leader\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "exn": "The reference voteGranted was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "+", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left."], "tactic": "apply H2.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface h, src : name t1 : nat v : bool st : electionsData * RaftState.raft_data term name entry logIndex serverType data clientId output t2 : term ll : list entry H3 : (currentTerm (snd st) <? t1) = true H2 : In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v st)) H : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower H4 : (t1 <? currentTerm (snd st)) = true H0 : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower H7 : type (snd st) = Follower H5 : Follower = Leader H6 : v && wonElection (dedup name_eq_dec (src :: votesReceived (snd st))) = true H8 : RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower = RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (advanceCurrentTerm (snd st) t1) Follower Unable to unify \"In (t2, ll) (leaderLogs (update_elections_data_requestVoteReply h src t1 v st))\" with \"In (t2, ll) (leaderLogs (fst st))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "+", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "qsimpl use: eq_nat_dec.", "*", "inversion H1."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "+", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "qsimpl use: eq_nat_dec.", "*", "inversion H1.", "shelve.", "*", "inversion H1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "+", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "qsimpl use: eq_nat_dec.", "*", "inversion H1.", "shelve.", "*", "inversion H1.", "shelve.", "+", "destruct (type (snd st)) eqn:H8.", "*", "inversion H1."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h src t1 v st t2 ll st' H1 H2.", "unfold handleRequestVoteReply in H1.", "destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|].", "destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|].", "destruct (type (snd st)) eqn:H5.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "inversion H1; subst.", "right.", "split; try reflexivity.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "qsimpl use: eq_nat_dec.", "+", "shelve.", "+", "shelve.", "-", "destruct (v && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6.", "+", "destruct (type (snd st)) eqn:H7.", "*", "inversion H1; subst.", "left.", "qsimpl use: eq_nat_dec.", "*", "inversion H1.", "shelve.", "*", "inversion H1.", "shelve.", "+", "destruct (type (snd st)) eqn:H8.", "*", "inversion H1.", "shelve.", "*", "inversion H1."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros h src t1 v st t2 ll st' H1 H2. unfold handleRequestVoteReply in H1. destruct (currentTerm (snd st) <? t1) eqn:H3; [inversion H1|]. destruct (t1 <? currentTerm (snd st)) eqn:H4; [inversion H1|]. destruct (type (snd st)) eqn:H5. - inversion H1; subst. right. split; try reflexivity. split; [reflexivity|]. split; [reflexivity|]. apply eq_nat_dec. - inversion H1; subst. right. split; try reflexivity. split; [reflexivity|]. split; [reflexivity|]. apply eq_nat_dec. - destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived (snd st)))) eqn:H6. + destruct (type (snd st)) eqn:H7. * inversion H1; subst. left. apply H2. * inversion H1. * inversion H1. + destruct (type (snd st)) eqn:H8. * inversion H1. * inversion H1. * inversion H1.", "succ": false}]