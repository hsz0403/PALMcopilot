[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st t h' pli plt es ci te e Hin.", "unfold update_elections_data_appendEntries in Hin.", "destruct (handleAppendEntries h (snd st) t h' pli plt es ci) as [d m] eqn:Heq."], "tactic": ["destruct m as [t0 entries0 []] eqn:Hm.", ""], "exn": "Expects a disjunctive pattern with 4 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros h st t h' pli plt es ci te e Hin. unfold update_elections_data_appendEntries in Hin. simpl in Hin. destruct (handleAppendEntries h (snd st) t h' pli plt es ci) as [d m] eqn:Heq. destruct m as [t0 entries0 []] eqn:Hm. assert (Heq_entries: (te, e) = (t0, e) \\/ In (te, e) (allEntries (update_elections_data_appendEntries h st t h' pli plt es ci))). { rewrite <- Heq. rewrite Hm. left. reflexivity. } clear Hin. unfold allEntries. rewrite Hm. apply in_app_or. left. apply in_map. apply Heq_entries.", "succ": false}]