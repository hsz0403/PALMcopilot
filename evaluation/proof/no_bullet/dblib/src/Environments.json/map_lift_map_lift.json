[{"history": {"proof": "qsimpl time: 1 use: map_map_exchange,lift. sfirstorder depth: 3use: map_ext, map_map_exchange, lift. qsimpl time: 1 use: map_map_exchange,lift. qsimpl time: 1 use: map_ext,map_map_exchange,lift. qsimpl time: 1 use: map_ext,map_map_exchange,lift.", "repairs": ["cannot_unify", "hammer", "cannot_unify", "cannot_unify", "cannot_unify"], "exceptions": [{"ctx": [], "tactic": "intros T k s wk ws e H Lift1 LL k_le_s.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "rewrite map_map_exchange with (F:=fun l x => lift ws (l + s) x) (G:=fun l x => lift (wk + s) l x).", "exn": "In environment T : Type k, s, wk, ws : nat e : env T H : Lift T H0 : LiftLift H1 : k <= s Unable to unify \"forall l : nat, ?T0 -> ?T0\" with \"Type\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: map_map_exchange,lift."], "tactic": "rewrite map_map_exchange with (F:=fun l x => lift wk (l + k) x) (G:=fun l x => lift ws l x).", "exn": "In environment T : Type t : nat -> nat -> T -> T H2 : forall (A F G B : Type) (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) (e : env A), (forall d : A, f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e) k, s, wk, ws : nat e : env T H : Lift T H1 : k <= s lift_lift : forall (t : T) (k s wk ws : nat), k <= s -> lift wk k (lift ws s t) = lift ws (wk + s) (lift wk k t) Unable to unify \"forall l : nat, ?T0 -> ?T0\" with \"Type\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_map_exchange,lift."], "tactic": "apply map_ext.", "exn": "In environment T : Type H0 : forall (A F G B : Type) (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) (e : env A), (forall d : A, f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e) t : nat -> nat -> T -> T k, s, wk, ws : nat e : env T H : Lift T H1 : k <= s lift_lift : forall (t : T) (k s wk ws : nat), k <= s -> lift wk k (lift ws s t) = lift ws (wk + s) (lift wk k t) Unable to unify \"List.map ?M3299 ?M3302 = List.map ?M3300 ?M3302\" with \"map (t wk k) (map (t ws s) e) = map (t ws (wk + s)) (map (t wk k) e)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_ext,map_map_exchange,lift."], "tactic": "intros d.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_ext,map_map_exchange,lift."], "tactic": "apply lift_lift.", "exn": "In environment T : Type H3 : forall (A F G B : Type) (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) (e : env A), (forall d : A, f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e) H2 : forall (A B : Type) (f g : A -> B), (forall a : A, f a = g a) -> forall l : list A, List.map f l = List.map g l t : nat -> nat -> T -> T k, s, wk, ws : nat e : env T H : Lift T H1 : k <= s lift_lift : forall (t : T) (k s wk ws : nat), k <= s -> lift wk k (lift ws s t) = lift ws (wk + s) (lift wk k t) Unable to unify \"lift ?M4141 ?M4139 (lift ?M4142 ?M4140 ?M4138) = lift ?M4142 (?M4141 + ?M4140) (lift ?M4141 ?M4139 ?M4138)\" with \"map (t wk k) (map (t ws s) e) = map (t ws (wk + s)) (map (t wk k) e)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_map_exchange,lift.", "qsimpl time: 1 use: map_ext,map_map_exchange,lift.", "qsimpl time: 1 use: map_ext,map_map_exchange,lift."], "tactic": "apply k_le_s.", "exn": "The reference k_le_s was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros T k s wk ws e H Lift1 LL k_le_s. rewrite map_map_exchange with (F:=fun l x => lift ws (l + s) x) (G:=fun l x => lift (wk + s) l x). rewrite map_map_exchange with (F:=fun l x => lift wk (l + k) x) (G:=fun l x => lift ws l x). apply map_ext. intros d. apply lift_lift. apply k_le_s.", "succ": true}]