[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "simpl. unfold tot_map_name_msgs. extensionality src. extensionality dst. unfold collate. destruct (name_eq_dec (tot_map_name_inv src) (tot_map_name h)) eqn:Heq. - apply functional_extensionality. intros n. destruct (name_eq_dec n h) eqn:Hn. + subst. rewrite e. rewrite tot_map_name_inv_inverse. reflexivity. + apply map2snd_prod; auto. - destruct (name_eq_dec dst h) eqn:Hdst. + subst. rewrite <- e. apply update2_not_in_eq. * intros contra. apply n. apply in_map_iff in contra. destruct contra as [x [Heqcontr Hinx]]. subst. apply tot_map_in_in with (m:=tot_map_msg (f (tot_map_name_inv src) (tot_map_name_inv x))); auto. * apply map2snd_add_eq. apply in_map_iff. exists (tot_map_name_inv src, f (tot_map_name_inv src) (tot_map_name_inv dst)). split; auto. apply tot_map_name_inv_inverse. + apply update2_neq_eq; auto. intros Heqcontr. apply n. apply in_map_iff in Heqcontr. destruct Heqcontr as [x [Heqnx Hinx]]. apply tot_map_in_in with (m:=tot_map_msg (f (tot_map_name_inv src) (tot_map_name_inv x))); auto.", "hammer_times": 2, "succ": false, "time": 63.58808636665344}]