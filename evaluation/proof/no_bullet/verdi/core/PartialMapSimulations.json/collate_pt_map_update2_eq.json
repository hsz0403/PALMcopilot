[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "apply functional_extensionality.", "intros.", "apply functional_extensionality.", "intros."], "tactic": "apply functional_extensionality.", "exn": "In environment base_fst, base_snd : BaseParams multi_fst : MultiParams base_fst multi_snd : MultiParams base_snd base_map : BaseParamsPartialMap base_fst base_snd name_map : MultiParamsNameTotalMap multi_fst multi_snd msg_map : MultiParamsMsgPartialMap multi_fst multi_snd name_map_bijective : MultiParamsNameTotalMapBijective name_map multi_map_congr : MultiParamsPartialMapCongruency base_map name_map msg_map fail_fst : FailureParams multi_fst fail_snd : FailureParams multi_snd fail_map_congr : FailureParamsPartialMapCongruency fail_fst fail_snd base_map f : name -> name -> list msg from, to : name ms : list msg l : list (name * msg) x, x0 : name Unable to unify \"?M1641 = ?M1642\" with \"filterMap pt_map_msg (collate name_eq_dec to (update2 name_eq_dec f from to ms) l (tot_map_name_inv x) (tot_map_name_inv x0)) = collate name_eq_dec (tot_map_name to) (update2 name_eq_dec (fun src dst : name => filterMap pt_map_msg (f (tot_map_name_inv src) (tot_map_name_inv dst))) (tot_map_name from) (tot_map_name to) (filterMap pt_map_msg ms)) (filterMap pt_map_name_msg l) x x0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "apply functional_extensionality.", "intros.", "apply functional_extensionality.", "intros.", "qsimpl use: functional_extensionality.", "unfold update2."], "tactic": "extensionality src.", "exn": "In environment base_fst, base_snd : BaseParams multi_fst : MultiParams base_fst multi_snd : MultiParams base_snd base_map : BaseParamsPartialMap base_fst base_snd name_map : MultiParamsNameTotalMap multi_fst multi_snd msg_map : MultiParamsMsgPartialMap multi_fst multi_snd fail_fst : FailureParams multi_fst fail_snd : FailureParams multi_snd f : name -> name -> list msg from, to : name ms : list msg l : list (name * msg) x, x0 : name H : forall f0 g : ?A -> ?B, (forall x1 : ?A, f0 x1 = g x1) -> f0 = g pt_reboot_eq0 : forall d : data, pt_map_data (reboot d) = reboot (pt_map_data d) pt_init_handlers_eq0 : forall n : name, pt_map_data (init_handlers n) = init_handlers (tot_map_name n) pt_net_handlers_some0 : forall (me src : name) (m : msg) (st : data) (m' : msg), pt_map_msg m = Some m' -> pt_mapped_net_handlers me src m st = net_handlers (tot_map_name me) (tot_map_name src) m' (pt_map_data st) pt_net_handlers_none0 : forall (me src : name) (m : msg) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_msg m = None -> net_handlers me src m st = (out, st', ps) -> pt_map_data st' = pt_map_data st /\\\\ filterMap pt_map_name_msg ps = [] /\\\\ filterMap pt_map_output out = [] pt_input_handlers_some0 : forall (me : name) (inp : input) (st : data) (inp' : input), pt_map_input inp = Some inp' -> pt_mapped_input_handlers me inp st = input_handlers (tot_map_name me) inp' (pt_map_data st) tot_map_name_inv_inverse : forall n : name, tot_map_name_inv (tot_map_name n) = n tot_map_name_inverse_inv : forall n : name, tot_map_name (tot_map_name_inv n) = n H1 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_output out = [] H2 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_name_msg ps = [] H0 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> pt_map_data st' = pt_map_data st Unable to unify \"(forall x1 : ?A0, ?B0 x1) = (forall x1 : ?A0, ?C x1)\" with \"filterMap pt_map_msg (collate name_eq_dec to (fun x' y' : name => if sumbool_and (from = x') (from <> x') (to = y') (to <> y') (name_eq_dec from x') (name_eq_dec to y') then ms else f x' y') l (tot_map_name_inv x) (tot_map_name_inv x0)) = collate name_eq_dec (tot_map_name to) (fun x' y' : name => if sumbool_and (tot_map_name from = x') (tot_map_name from <> x') (tot_map_name to = y') (tot_map_name to <> y') (name_eq_dec (tot_map_name from) x') (name_eq_dec (tot_map_name to) y') then filterMap pt_map_msg ms else filterMap pt_map_msg (f (tot_map_name_inv x') (tot_map_name_inv y'))) (filterMap pt_map_name_msg l) x x0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "apply functional_extensionality.", "intros.", "apply functional_extensionality.", "intros.", "qsimpl use: functional_extensionality.", "unfold update2.", "qsimpl use: functional_extensionality."], "tactic": "extensionality dst.", "exn": "In environment base_fst, base_snd : BaseParams multi_fst : MultiParams base_fst multi_snd : MultiParams base_snd base_map : BaseParamsPartialMap base_fst base_snd name_map : MultiParamsNameTotalMap multi_fst multi_snd msg_map : MultiParamsMsgPartialMap multi_fst multi_snd fail_fst : FailureParams multi_fst fail_snd : FailureParams multi_snd f : name -> name -> list msg from, to : name ms : list msg l : list (name * msg) x, x0 : name H : forall f0 g : ?A -> ?B, (forall x1 : ?A, f0 x1 = g x1) -> f0 = g pt_reboot_eq0 : forall d : data, pt_map_data (reboot d) = reboot (pt_map_data d) pt_init_handlers_eq0 : forall n : name, pt_map_data (init_handlers n) = init_handlers (tot_map_name n) pt_net_handlers_some0 : forall (me src : name) (m : msg) (st : data) (m' : msg), pt_map_msg m = Some m' -> pt_mapped_net_handlers me src m st = net_handlers (tot_map_name me) (tot_map_name src) m' (pt_map_data st) pt_net_handlers_none0 : forall (me src : name) (m : msg) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_msg m = None -> net_handlers me src m st = (out, st', ps) -> pt_map_data st' = pt_map_data st /\\\\ filterMap pt_map_name_msg ps = [] /\\\\ filterMap pt_map_output out = [] pt_input_handlers_some0 : forall (me : name) (inp : input) (st : data) (inp' : input), pt_map_input inp = Some inp' -> pt_mapped_input_handlers me inp st = input_handlers (tot_map_name me) inp' (pt_map_data st) tot_map_name_inv_inverse : forall n : name, tot_map_name_inv (tot_map_name n) = n tot_map_name_inverse_inv : forall n : name, tot_map_name (tot_map_name_inv n) = n H1 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_output out = [] H2 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_name_msg ps = [] H0 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> pt_map_data st' = pt_map_data st H3 : forall f0 g : ?A0 -> ?B0, (forall x1 : ?A0, f0 x1 = g x1) -> f0 = g Unable to unify \"(forall x1 : ?A1, ?B1 x1) = (forall x1 : ?A1, ?C x1)\" with \"filterMap pt_map_msg (collate name_eq_dec to (fun x' y' : name => if sumbool_and (from = x') (from = x' -> False) (to = y') (to = y' -> False) (name_eq_dec from x') (name_eq_dec to y') then ms else f x' y') l (tot_map_name_inv x) (tot_map_name_inv x0)) = collate name_eq_dec (tot_map_name to) (fun x' y' : name => if sumbool_and (tot_map_name from = x') (tot_map_name from = x' -> False) (tot_map_name to = y') (tot_map_name to = y' -> False) (name_eq_dec (tot_map_name from) x') (name_eq_dec (tot_map_name to) y') then filterMap pt_map_msg ms else filterMap pt_map_msg (f (tot_map_name_inv x') (tot_map_name_inv y'))) (filterMap pt_map_name_msg l) x x0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "apply functional_extensionality.", "intros.", "apply functional_extensionality.", "intros.", "qsimpl use: functional_extensionality.", "unfold update2.", "qsimpl use: functional_extensionality.", "qsimpl use: functional_extensionality."], "tactic": "extensionality src0.", "exn": "In environment base_fst, base_snd : BaseParams multi_fst : MultiParams base_fst multi_snd : MultiParams base_snd base_map : BaseParamsPartialMap base_fst base_snd name_map : MultiParamsNameTotalMap multi_fst multi_snd msg_map : MultiParamsMsgPartialMap multi_fst multi_snd fail_fst : FailureParams multi_fst fail_snd : FailureParams multi_snd f : name -> name -> list msg from, to : name ms : list msg l : list (name * msg) x, x0 : name H : forall f0 g : ?A -> ?B, (forall x1 : ?A, f0 x1 = g x1) -> f0 = g pt_reboot_eq0 : forall d : data, pt_map_data (reboot d) = reboot (pt_map_data d) pt_init_handlers_eq0 : forall n : name, pt_map_data (init_handlers n) = init_handlers (tot_map_name n) pt_net_handlers_some0 : forall (me src : name) (m : msg) (st : data) (m' : msg), pt_map_msg m = Some m' -> pt_mapped_net_handlers me src m st = net_handlers (tot_map_name me) (tot_map_name src) m' (pt_map_data st) pt_net_handlers_none0 : forall (me src : name) (m : msg) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_msg m = None -> net_handlers me src m st = (out, st', ps) -> pt_map_data st' = pt_map_data st /\\\\ filterMap pt_map_name_msg ps = [] /\\\\ filterMap pt_map_output out = [] pt_input_handlers_some0 : forall (me : name) (inp : input) (st : data) (inp' : input), pt_map_input inp = Some inp' -> pt_mapped_input_handlers me inp st = input_handlers (tot_map_name me) inp' (pt_map_data st) tot_map_name_inv_inverse : forall n : name, tot_map_name_inv (tot_map_name n) = n tot_map_name_inverse_inv : forall n : name, tot_map_name (tot_map_name_inv n) = n H1 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_output out = [] H2 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_name_msg ps = [] H0 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> pt_map_data st' = pt_map_data st H3 : forall f0 g : ?A0 -> ?B0, (forall x1 : ?A0, f0 x1 = g x1) -> f0 = g H4 : forall f0 g : ?A1 -> ?B1, (forall x1 : ?A1, f0 x1 = g x1) -> f0 = g Unable to unify \"(forall x1 : ?A2, ?B2 x1) = (forall x1 : ?A2, ?C x1)\" with \"filterMap pt_map_msg (collate name_eq_dec to (fun x' y' : name => if sumbool_and (from = x') (from = x' -> False) (to = y') (to = y' -> False) (name_eq_dec from x') (name_eq_dec to y') then ms else f x' y') l (tot_map_name_inv x) (tot_map_name_inv x0)) = collate name_eq_dec (tot_map_name to) (fun x' y' : name => if sumbool_and (tot_map_name from = x') (tot_map_name from = x' -> False) (tot_map_name to = y') (tot_map_name to = y' -> False) (name_eq_dec (tot_map_name from) x') (name_eq_dec (tot_map_name to) y') then filterMap pt_map_msg ms else filterMap pt_map_msg (f (tot_map_name_inv x') (tot_map_name_inv y'))) (filterMap pt_map_name_msg l) x x0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "apply functional_extensionality.", "intros.", "apply functional_extensionality.", "intros.", "qsimpl use: functional_extensionality.", "unfold update2.", "qsimpl use: functional_extensionality.", "qsimpl use: functional_extensionality.", "qsimpl use: functional_extensionality."], "tactic": "extensionality dst0.", "exn": "In environment base_fst, base_snd : BaseParams multi_fst : MultiParams base_fst multi_snd : MultiParams base_snd base_map : BaseParamsPartialMap base_fst base_snd name_map : MultiParamsNameTotalMap multi_fst multi_snd msg_map : MultiParamsMsgPartialMap multi_fst multi_snd fail_fst : FailureParams multi_fst fail_snd : FailureParams multi_snd f : name -> name -> list msg from, to : name ms : list msg l : list (name * msg) x, x0 : name H : forall f0 g : ?A -> ?B, (forall x1 : ?A, f0 x1 = g x1) -> f0 = g pt_reboot_eq0 : forall d : data, pt_map_data (reboot d) = reboot (pt_map_data d) pt_init_handlers_eq0 : forall n : name, pt_map_data (init_handlers n) = init_handlers (tot_map_name n) pt_net_handlers_some0 : forall (me src : name) (m : msg) (st : data) (m' : msg), pt_map_msg m = Some m' -> pt_mapped_net_handlers me src m st = net_handlers (tot_map_name me) (tot_map_name src) m' (pt_map_data st) pt_net_handlers_none0 : forall (me src : name) (m : msg) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_msg m = None -> net_handlers me src m st = (out, st', ps) -> pt_map_data st' = pt_map_data st /\\\\ filterMap pt_map_name_msg ps = [] /\\\\ filterMap pt_map_output out = [] pt_input_handlers_some0 : forall (me : name) (inp : input) (st : data) (inp' : input), pt_map_input inp = Some inp' -> pt_mapped_input_handlers me inp st = input_handlers (tot_map_name me) inp' (pt_map_data st) tot_map_name_inv_inverse : forall n : name, tot_map_name_inv (tot_map_name n) = n tot_map_name_inverse_inv : forall n : name, tot_map_name (tot_map_name_inv n) = n H1 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_output out = [] H2 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_name_msg ps = [] H0 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> pt_map_data st' = pt_map_data st H3 : forall f0 g : ?A0 -> ?B0, (forall x1 : ?A0, f0 x1 = g x1) -> f0 = g H4 : forall f0 g : ?A1 -> ?B1, (forall x1 : ?A1, f0 x1 = g x1) -> f0 = g H5 : forall f0 g : ?A2 -> ?B2, (forall x1 : ?A2, f0 x1 = g x1) -> f0 = g Unable to unify \"(forall x1 : ?A3, ?B3 x1) = (forall x1 : ?A3, ?C x1)\" with \"filterMap pt_map_msg (collate name_eq_dec to (fun x' y' : name => if sumbool_and (from = x') (from = x' -> False) (to = y') (to = y' -> False) (name_eq_dec from x') (name_eq_dec to y') then ms else f x' y') l (tot_map_name_inv x) (tot_map_name_inv x0)) = collate name_eq_dec (tot_map_name to) (fun x' y' : name => if sumbool_and (tot_map_name from = x') (tot_map_name from = x' -> False) (tot_map_name to = y') (tot_map_name to = y' -> False) (name_eq_dec (tot_map_name from) x') (name_eq_dec (tot_map_name to) y') then filterMap pt_map_msg ms else filterMap pt_map_msg (f (tot_map_name_inv x') (tot_map_name_inv y'))) (filterMap pt_map_name_msg l) x x0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "apply functional_extensionality.", "intros.", "apply functional_extensionality.", "intros.", "qsimpl use: functional_extensionality.", "unfold update2.", "qsimpl use: functional_extensionality.", "qsimpl use: functional_extensionality.", "qsimpl use: functional_extensionality.", "qsimpl use: functional_extensionality."], "tactic": "reflexivity.", "exn": "In environment base_fst, base_snd : BaseParams multi_fst : MultiParams base_fst multi_snd : MultiParams base_snd base_map : BaseParamsPartialMap base_fst base_snd name_map : MultiParamsNameTotalMap multi_fst multi_snd msg_map : MultiParamsMsgPartialMap multi_fst multi_snd fail_fst : FailureParams multi_fst fail_snd : FailureParams multi_snd f : name -> name -> list msg from, to : name ms : list msg l : list (name * msg) x, x0 : name H : forall f0 g : ?A -> ?B, (forall x1 : ?A, f0 x1 = g x1) -> f0 = g pt_reboot_eq0 : forall d : data, pt_map_data (reboot d) = reboot (pt_map_data d) pt_init_handlers_eq0 : forall n : name, pt_map_data (init_handlers n) = init_handlers (tot_map_name n) pt_net_handlers_some0 : forall (me src : name) (m : msg) (st : data) (m' : msg), pt_map_msg m = Some m' -> pt_mapped_net_handlers me src m st = net_handlers (tot_map_name me) (tot_map_name src) m' (pt_map_data st) pt_net_handlers_none0 : forall (me src : name) (m : msg) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_msg m = None -> net_handlers me src m st = (out, st', ps) -> pt_map_data st' = pt_map_data st /\\\\ filterMap pt_map_name_msg ps = [] /\\\\ filterMap pt_map_output out = [] pt_input_handlers_some0 : forall (me : name) (inp : input) (st : data) (inp' : input), pt_map_input inp = Some inp' -> pt_mapped_input_handlers me inp st = input_handlers (tot_map_name me) inp' (pt_map_data st) tot_map_name_inv_inverse : forall n : name, tot_map_name_inv (tot_map_name n) = n tot_map_name_inverse_inv : forall n : name, tot_map_name (tot_map_name_inv n) = n H1 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_output out = [] H2 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> filterMap pt_map_name_msg ps = [] H0 : forall (me : name) (inp : input) (st : data) (out : list output) (st' : data) (ps : list (name * msg)), pt_map_input inp = None -> input_handlers me inp st = (out, st', ps) -> pt_map_data st' = pt_map_data st H3 : forall f0 g : ?A0 -> ?B0, (forall x1 : ?A0, f0 x1 = g x1) -> f0 = g H4 : forall f0 g : ?A1 -> ?B1, (forall x1 : ?A1, f0 x1 = g x1) -> f0 = g H5 : forall f0 g : ?A2 -> ?B2, (forall x1 : ?A2, f0 x1 = g x1) -> f0 = g H6 : forall f0 g : ?A3 -> ?B3, (forall x1 : ?A3, f0 x1 = g x1) -> f0 = g Unable to unify \"collate name_eq_dec (tot_map_name to) (fun x' y' : name => if sumbool_and (tot_map_name from = x') (tot_map_name from = x' -> False) (tot_map_name to = y') (tot_map_name to = y' -> False) (name_eq_dec (tot_map_name from) x') (name_eq_dec (tot_map_name to) y') then filterMap pt_map_msg ms else filterMap pt_map_msg (f (tot_map_name_inv x') (tot_map_name_inv y'))) (filterMap pt_map_name_msg l) x x0\" with \"filterMap pt_map_msg (collate name_eq_dec to (fun x' y' : name => if sumbool_and (from = x') (from = x' -> False) (to = y') (to = y' -> False) (name_eq_dec from x') (name_eq_dec to y') then ms else f x' y') l (tot_map_name_inv x) (tot_map_name_inv x0))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. apply functional_extensionality. intros. apply functional_extensionality. intros. apply functional_extensionality. intros. unfold update2. extensionality src. extensionality dst. unfold update2. extensionality src0. extensionality dst0. simpl. reflexivity.", "hammer_times": 14, "succ": false, "time": 262.14033365249634}]