[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "destruct H, H0, H1, H2, H3, H4, H5, H6.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+"], "tactic": "apply (changement_base_cocyclique _ A B C O1) with (D:=P0); auto.", "exn": "In environment A, B, C, P0, Q, T, O1, O2, I : PO H3 : colineaire (vec P0 B) (vec P0 C) -> False H4 : R (plus (cons (vec P0 C) (vec P0 B)) (plus (cons (vec T B) (vec T A)) (cons (vec Q A) (vec Q C)))) pi H5 : isocele O2 A C H2 : isocele O2 A I H7 : isocele O2 C I H1 : isocele O2 A Q H9 : isocele O2 C Q H8 : isocele O1 A B H0 : isocele O1 A I H11 : isocele O1 B I H : isocele O1 A T H13 : isocele O1 B T The term \"A\" has type \"PO\" while it is expected to have type \"R (double (cons (vec ?C ?A) (vec ?C ?B))) (double (cons (vec ?D ?A) (vec ?D ?B)))\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+", "qsimpl use: changement_base_cocyclique."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+", "qsimpl use: changement_base_cocyclique.", "shelve.", "+", "split.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+", "qsimpl use: changement_base_cocyclique.", "shelve.", "+", "split.", "-", "shelve.", "-"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+", "qsimpl use: changement_base_cocyclique.", "shelve.", "+", "split.", "-", "shelve.", "-"], "tactic": "qsimpl use: changement_base_cocyclique,double,cons,double_orthogonal,vec,pi,auto.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+", "qsimpl use: changement_base_cocyclique.", "shelve.", "+", "split.", "-", "shelve.", "-", "qsimpl use: changement_base_cocyclique,double,cons,double_orthogonal,vec,pi,Ring_theory.ARmul_1_r."], "tactic": "apply (changement_base_cocyclique _ O1 O2 O3 T); auto.", "exn": "The reference O3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl.", "exists O1.", "split.", "+", "qsimpl use: changement_base_cocyclique.", "shelve.", "+", "split.", "-", "shelve.", "-", "qsimpl use: changement_base_cocyclique,double,cons,double_orthogonal,vec,pi,Ring_theory.ARmul_1_r."], "tactic": "apply (changement_base_cocyclique _ O1 O3 O2 P0); auto.", "exn": "The reference O3 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros. destruct H, H0, H1, H2, H3, H4, H5, H6. exists O1. split. + apply (changement_base_cocyclique _ A B C O1) with (D:=P0); auto. + split. - apply (double_orthogonal _ _ _ _ (double (cons (vec T B) (vec T A))) (double (cons (vec Q A) (vec Q C))) pi); auto. - split. * apply (changement_base_cocyclique _ O1 O2 O3 T); auto. * apply (changement_base_cocyclique _ O1 O3 O2 P0); auto.", "succ": false}]