[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "apply chain_ind.", "exn": "Unable to find an instance for the variables A, m, m, p.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-"], "tactic": "apply chain_single.", "exn": "In environment H : forall (A : Set) (P : mEnsemble A -> mRelation A -> prechain A -> Prop), (forall (x : Map A) (T : mEnsemble A) (r : mRelation A), T x -> P T r (single A x)) -> (forall (x y : Map A) (T : mEnsemble A) (r : mRelation A), T x -> T y -> r x y -> P T r (concat A (single A x) y)) -> (forall (x y : Map A) (z : prechain A) (T : mEnsemble A) (r : mRelation A), T y -> r x y -> chain A T r (concat A z x) -> P T r (concat A z x) -> P T r (concat A (concat A z x) y)) -> forall (m : mEnsemble A) (m0 : mRelation A) (p : prechain A), chain A m m0 p -> P m m0 p A : Set x : Map A Unable to unify \"chain ?M2198 ?M2200 ?M2201 (single ?M2198 ?M2199)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) A bool x (map_maxi A x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-", "qsimpl use: chain_ind,chain_single."], "tactic": "apply map_mini_appartient.", "exn": "In environment H1 : forall (A : Set) (x : Map A) (T : mEnsemble A) (r : mRelation A), T x -> chain A T r (single A x) H0 : forall (A : Set) (P : mEnsemble A -> mRelation A -> prechain A -> Prop), (forall (x : Map A) (T : mEnsemble A) (r : mRelation A), T x -> P T r (single A x)) -> (forall (x y : Map A) (T : mEnsemble A) (r : mRelation A), T x -> T y -> r x y -> P T r (concat A (single A x) y)) -> (forall (x y : Map A) (z : prechain A) (T : mEnsemble A) (r : mRelation A), T y -> r x y -> chain A T r (concat A z x) -> P T r (concat A z x) -> P T r (concat A (concat A z x) y)) -> forall (m : mEnsemble A) (m0 : mRelation A) (p : prechain A), chain A m m0 p -> P m m0 p A : Set x : Map A Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) ?M2374 bool ?M2375 (map_mini ?M2374 ?M2375)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) A bool x (map_maxi A x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-", "qsimpl use: chain_ind,chain_single.", "qsimpl use: chain_ind,chain_single,map_mini_appartient."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-", "qsimpl use: chain_ind,chain_single.", "qsimpl use: chain_ind,chain_single,map_mini_appartient.", "shelve.", "-"], "tactic": "apply chain_concat_s; try apply map_mini_appartient.", "exn": "In environment H : forall (A : Set) (P : mEnsemble A -> mRelation A -> prechain A -> Prop), (forall (x : Map A) (T : mEnsemble A) (r : mRelation A), T x -> P T r (single A x)) -> (forall (x y : Map A) (T : mEnsemble A) (r : mRelation A), T x -> T y -> r x y -> P T r (concat A (single A x) y)) -> (forall (x y : Map A) (z : prechain A) (T : mEnsemble A) (r : mRelation A), T y -> r x y -> chain A T r (concat A z x) -> P T r (concat A z x) -> P T r (concat A (concat A z x) y)) -> forall (m : mEnsemble A) (m0 : mRelation A) (p : prechain A), chain A m m0 p -> P m m0 p A : Set x : Map A x0 : Map bool H0 : ensemble_base A x x0 Unable to unify \"chain ?M2582 ?M2585 ?M2586 (concat ?M2582 (single ?M2582 ?M2583) ?M2584)\" with \"(fix lem (m0 m1 : Map bool) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a b => match m1 with | @M1 _ a' b' => if (a =? a')%N then leb b b' else False | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => lem a c /\\\\ lem b d | _ => False end end) x0 (map_maxi A x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-", "qsimpl use: chain_ind,chain_single.", "qsimpl use: chain_ind,chain_single,map_mini_appartient.", "shelve.", "-", "qsimpl use: chain_ind,chain_single,chain_concat_s,map_mini_appartient."], "tactic": "apply lem_reflexive.", "exn": "In environment H4 : forall (A : Set) (x : Map A), ensemble_base A x (map_mini A x) H3 : forall (A : Set) (x y : Map A) (T : mEnsemble A) (r : mRelation A), T x -> T y -> r x y -> chain A T r (concat A (single A x) y) H2 : forall (A : Set) (x : Map A) (T : mEnsemble A) (r : mRelation A), T x -> chain A T r (single A x) H1 : forall (A : Set) (P : mEnsemble A -> mRelation A -> prechain A -> Prop), (forall (x : Map A) (T : mEnsemble A) (r : mRelation A), T x -> P T r (single A x)) -> (forall (x y : Map A) (T : mEnsemble A) (r : mRelation A), T x -> T y -> r x y -> P T r (concat A (single A x) y)) -> (forall (x y : Map A) (z : prechain A) (T : mEnsemble A) (r : mRelation A), T y -> r x y -> chain A T r (concat A z x) -> P T r (concat A z x) -> P T r (concat A (concat A z x) y)) -> forall (m : mEnsemble A) (m0 : mRelation A) (p : prechain A), chain A m m0 p -> P m m0 p A : Set x : Map A x0 : Map bool H0 : ensemble_base A x x0 Unable to unify \"r_reflexive bool lem\" with \"lem x0 (map_maxi A x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-", "qsimpl use: chain_ind,chain_single.", "qsimpl use: chain_ind,chain_single,map_mini_appartient.", "shelve.", "-", "qsimpl use: chain_ind,chain_single,chain_concat_s,map_mini_appartient.", "qsimpl use: chain_ind,chain_concat_s,lem_reflexive,chain_single,map_mini_appartient."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: chain_ind.", "-", "qsimpl use: chain_ind,chain_single.", "qsimpl use: chain_ind,chain_single,map_mini_appartient.", "shelve.", "-", "qsimpl use: chain_ind,chain_single,chain_concat_s,map_mini_appartient.", "qsimpl use: chain_ind,chain_concat_s,lem_reflexive,chain_single,map_mini_appartient.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros. apply chain_ind. - intros. apply chain_single. apply map_mini_appartient. - intros. apply chain_concat_s; try apply map_mini_appartient. simpl. apply lem_reflexive. - intros. apply chain_concat_m; try apply map_mini_appartient; try apply lem_transitive. + apply lazy_power_eg_power_0.", "succ": false}]