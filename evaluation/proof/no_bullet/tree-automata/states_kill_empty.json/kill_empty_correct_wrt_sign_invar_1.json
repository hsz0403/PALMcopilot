[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-"], "tactic": "intros a p.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-"], "tactic": "intros a' p.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+"], "tactic": "apply st_kill_2 in H'.", "exn": "Unable to apply lemma of type \"forall (s : state) (m : Map bool) (a : ad) (p : prec_list), MapGet prec_list (states_kill_aux m s) a = Some p -> exists p' : prec_list, MapGet prec_list s a = Some p' /\\\\ prec_list_kill m p' = Some p\" on hypothesis of type \"MapGet prec_list (M1 prec_list a p0) a' = Some p'\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2."], "tactic": "destruct H' as [p' [Hp Hk]].", "exn": "The reference H' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2."], "tactic": "rewrite Hk.", "exn": "The reference Hk was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2."], "tactic": "apply H'.", "exn": "The reference H' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-"], "tactic": "intros s0 IHs0 s1 IHs1.", "exn": "s1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-"], "tactic": "intros s0 IHs0 s1' IHs1.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'."], "tactic": "destruct (states_kill_aux m s0) eqn:E1.", "exn": "The reference s0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+"], "tactic": "apply IHs0 in H'.", "exn": "The reference IHs0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'."], "tactic": ["destruct H' as [n [H1 H2]].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*"], "tactic": "apply IHs1 in H'.", "exn": "The reference IHs1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'."], "tactic": ["destruct H' as [n [H1 H2]].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros a p.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros a' p.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros a' p'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros H'.", "exn": "H' is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "intros H''.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply st_kill_1 in H'.", "exn": "Unable to find an instance for the variables m, p'.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: st_kill_1,st_kill_2."], "tactic": "destruct H' as [s' [H1 H2]].", "exn": "The reference H' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: st_kill_1,st_kill_2."], "tactic": "exists (states_kill_aux m s').", "exn": "The reference s' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: st_kill_1,st_kill_2."], "tactic": "rewrite H2.", "exn": "The reference H2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "qsimpl use: st_kill_2.", "apply term_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "destruct (states_kill_aux m s2) eqn:E1.", "+", "apply MapPut1 in H'.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "destruct (states_kill_aux m s1) eqn:E2.", "*", "apply MapPut1 in H'.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "apply st_kill_3 in E1.", "--", "shelve.", "--", "shelve.", "*", "qsimpl use: st_kill_1,st_kill_2."], "tactic": "apply H1.", "exn": "In environment H1 : forall (s : state) (m : Map bool) (a : ad) (p : prec_list), MapGet prec_list (states_kill_aux m s) a = Some p -> exists p' : prec_list, MapGet prec_list s a = Some p' /\\\\ prec_list_kill m p' = Some p H0 : forall (s : state) (m : Map bool) (a : ad) (p p' : prec_list), prec_list_kill m p = Some p' -> MapGet prec_list s a = Some p -> exists s' : state, states_kill m s = Some s' /\\\\ MapGet prec_list s' a = Some p' s1, s2 : Map prec_list sigma : signature m : Map bool H : state_correct_wrt_sign (M2 prec_list s1 s2) sigma p : prec_list Heqs : (fix states_kill_aux (m : Map bool) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a p => match prec_list_kill m p with | Some p' => M1 prec_list a p' | None => M0 prec_list end | @M2 _ s0 s1 => match states_kill_aux m s0 with | @M0 _ => match states_kill_aux m s1 with | @M0 _ => M0 prec_list | @M1 _ a p => M1 prec_list (N.succ_double a) p | @M2 _ m0 m1 => M2 prec_list (M0 prec_list) (M2 prec_list m0 m1) end | @M1 _ a p => match states_kill_aux m s1 with | @M0 _ => M1 prec_list (N.double a) p | @M1 _ a0 p0 => M2 prec_list (M1 prec_list a p) (M1 prec_list a0 p0) | @M2 _ m0 m1 => M2 prec_list (M1 prec_list a p) (M2 prec_list m0 m1) end | @M2 _ m0 m1 => M2 prec_list (M2 prec_list m0 m1) (states_kill_aux m s1) end end) m s1 = M0 prec_list a1 : ad Heqs0 : (fix states_kill_aux (m : Map bool) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a p => match prec_list_kill m p with | Some p' => M1 prec_list a p' | None => M0 prec_list end | @M2 _ s0 s1 => match states_kill_aux m s0 with | @M0 _ => match states_kill_aux m s1 with | @M0 _ => M0 prec_list | @M1 _ a p => M1 prec_list (N.succ_double a) p | @M2 _ m0 m1 => M2 prec_list (M0 prec_list) (M2 prec_list m0 m1) end | @M1 _ a p => match states_kill_aux m s1 with | @M0 _ => M1 prec_list (N.double a) p | @M1 _ a0 p0 => M2 prec_list (M1 prec_list a p) (M1 prec_list a0 p0) | @M2 _ m0 m1 => M2 prec_list (M1 prec_list a p) (M2 prec_list m0 m1) end | @M2 _ m0 m1 => M2 prec_list (M2 prec_list m0 m1) (states_kill_aux m s1) end end) m s2 = M1 prec_list a1 p a0 : ad p0 : prec_list E1 : states_kill_aux m s2 = M1 prec_list a0 p0 s3, s4 : Map prec_list E2 : states_kill_aux m s1 = M2 prec_list s3 s4 Unable to unify \"exists p' : prec_list, MapGet prec_list ?M30402 ?M30404 = Some p' /\\\\ prec_list_kill ?M30403 p' = Some ?M30405\" with \"exists n : nat, MapGet nat sigma (N.succ_double a1) = Some n /\\\\ pl_tl_length p n\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s sigma m H. unfold states_kill_aux. destruct s. - intros a p. intros contra. inversion contra. - intros a p. simpl. intros H'. destruct (prec_list_kill m p) eqn:E. + apply st_kill_2 in H'. destruct H' as [p' [Hp Hk]]. rewrite Hk. apply H'. + inversion H'. - intros s0 IHs0 s1 IHs1. intros a p. intros H'. simpl. destruct (states_kill_aux m s0) eqn:E1. + apply IHs0 in H'. destruct H' as [n [H1 H2]]. inversion H'. + destruct (states_kill_aux m s1) eqn:E2. * apply IHs1 in H'. destruct H' as [n [H1 H2]]. inversion H'. * apply st_kill_3 in E1. destruct E1 as [p' [a' [H1 H2]]]. exists p'. exists a'. rewrite H2. apply H1. - intros a p. intros H'. simpl. apply st_kill_1 in H'. destruct H' as [s' [H1 H2]]. exists (states_kill_aux m s'). rewrite H2. apply H1.", "succ": false}]