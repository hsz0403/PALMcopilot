[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+"], "tactic": "destruct (prec_list_kill m p) eqn: eq2.", "exn": "The reference p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+"], "tactic": "destruct (prec_list_kill m p0) eqn: eq3.", "exn": "The reference p0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2."], "tactic": "exists (states_kill m s).", "exn": "In environment s : state m : Map bool a, a0 : ad p1, p2, p' : prec_list b : bool eq1 : MapGet bool m a = Some b p : prec_list eq3 : prec_list_kill m p2 = Some p H0, H3 : match p2 with | prec_cons _ _ _ => match MapGet bool m a0 with | Some true => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) m p1 with | Some la' => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la'0 ls') | None => Some (prec_cons a la'0 prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la'0 => Some (prec_cons a la'0 prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) m p2 with | Some ls' => Some (prec_cons a0 la' ls') | None => Some (prec_cons a0 la' prec_empty) end | None => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) m p2 with | Some ls' => Some ls' | None => None end end | _ => (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) m p2 end | prec_empty => match MapGet bool m a0 with | Some true => match (fix prec_list_kill (m : Map bool) (p : prec_list) {struct p} : option prec_list := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => match prec_list_kill m ls with | Some ls' => Some (prec_cons a la' ls') | None => Some (prec_cons a la' prec_empty) end | None => match prec_list_kill m ls with | Some ls' => Some ls' | None => None end end | _ => prec_list_kill m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some true => match prec_list_kill m la with | Some la' => Some (prec_cons a la' prec_empty) | None => None end | _ => None end | prec_empty => Some prec_empty end) m p1 with | Some la' => Some (prec_cons a0 la' prec_empty) | None => None end | _ => None end end = Some p' H1, H4 : MapGet prec_list s a = Some (prec_cons a0 p1 p2) The term \"states_kill m s\" has type \"option state\" while it is expected to have type \"state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "rewrite eq2.", "exn": "The reference eq2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "rewrite eq3.", "exn": "The reference eq3 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold prec_list_kill in H1.", "destruct p.", "-", "destruct (MapGet bool m a) eqn: eq1.", "+", "destruct (prec_list_kill m p2) eqn: eq3.", "inversion H1.", "inversion H1.", "clear H1.", "inversion H2.", "inversion H1.", "clear H2.", "*", "shelve.", "*", "shelve.", "+", "unfold states_kill.", "destruct (states_kill_aux m s).", "inversion H1.", "inversion H1.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros s m a p p' H1 H2. unfold prec_list_kill in H1. destruct p. - destruct (MapGet bool m a) eqn: eq1. + destruct (prec_list_kill m p) eqn: eq2. * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. subst. clear H1. inversion H2. inversion H1. subst. clear H2. exists (states_kill m s). split. - unfold states_kill. destruct (states_kill_aux m s). inversion H1. inversion H1. + simpl. rewrite eq2. rewrite eq3. reflexivity. + reflexivity. - unfold MapGet. rewrite <- H2. rewrite eq1. reflexivity. } { inversion H1. inversion H1. inversion H1. } * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. inversion H1. } { inversion H1. subst. apply H2. } + discriminate H1. - destruct (MapGet bool m a) eqn: eq1. + destruct (prec_list_kill m p) eqn: eq2. * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. subst. clear H1. inversion H2. inversion H1. subst. clear H2. exists (states_kill m s). split. - unfold states_kill. destruct (states_kill_aux m s). inversion H1. inversion H1. + simpl. rewrite eq2. rewrite eq3. reflexivity. + reflexivity. - unfold MapGet. rewrite <- H2. rewrite eq1. reflexivity. } { inversion H1. inversion H1. inversion H1. } * destruct (prec_list_kill m p0) eqn: eq3. { inversion H1. inversion H1. inversion H1. } { inversion H1. subst. apply H2. } + discriminate H1.", "succ": false}]