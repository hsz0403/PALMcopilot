[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s c pl l H.", "unfold union_mpl_0.", "simpl."], "tactic": "intros H'; rewrite H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s c pl l H.", "unfold union_mpl_0.", "simpl."], "tactic": "reflexivity.", "exn": "In environment s : state c : ad pl, l : prec_list H : MapGet prec_list s c = Some l Unable to unify \"Some (union_pl pl l)\" with \"MapGet prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) c pl s) c\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s c pl l H. unfold union_mpl_0. simpl. intros H'; rewrite H'. reflexivity.", "succ": false}]