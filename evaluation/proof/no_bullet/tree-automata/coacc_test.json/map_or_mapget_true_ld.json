[{"history": {"proof": "intros d m0 m1 a H1 H2 H3. unfold ensemble_base in *. apply (map_or_mapget_true_l _ _ a). - srun best use: domain_equal_symmetric, domain_equal_transitive unfold: preDTA. - sfirstorder depth: 3.", "repairs": ["", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros d m0 m1 a H1 H2 H3.", "unfold ensemble_base in *."], "tactic": "intros H4 H5 H6.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 a H1 H2 H3.", "unfold ensemble_base in *.", "apply (map_or_mapget_true_l _ _ a).", "-", "unfold domain_equal."], "tactic": "intros a0 b0.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 a H1 H2 H3.", "unfold ensemble_base in *.", "apply (map_or_mapget_true_l _ _ a).", "-", "unfold domain_equal.", "destruct m0.", "+", "simpl in H3.", "discriminate.", "+", "destruct m1.", "*", "destruct (N.eqb a0 a)%N eqn:E."], "tactic": "rewrite <- N.eqb_eq in E.", "exn": "Found no subterm matching \"?n = ?n0\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [], "original": "intros d m0 m1 a H1 H2 H3. unfold ensemble_base in *. intros H4 H5 H6. apply (map_or_mapget_true_l _ _ a). - unfold domain_equal. intros a0 b0. destruct m0. + simpl in H3. discriminate. + destruct m1. * destruct (N.eqb a0 a)%N eqn:E. { rewrite <- N.eqb_eq in E. subst a0. simpl. rewrite H3. reflexivity. } { simpl in H3. rewrite E in H3. apply H6 in H3. contradiction. } * simpl in H3. discriminate. + destruct m1. * simpl in H3. discriminate. * simpl in H3. discriminate. - apply H1; auto. - apply H2; auto.", "succ": true}]