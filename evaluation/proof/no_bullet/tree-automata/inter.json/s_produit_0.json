[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s0 s1 c p0 p1 H0 H1.", "unfold s_produit.", "simpl."], "tactic": "rewrite H0, H1.", "exn": "Found no subterm matching \"MapGet prec_list s0 c\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros s0 s1 c p0 p1 H0 H1.", "unfold s_produit.", "simpl."], "tactic": "reflexivity.", "exn": "In environment s0, s1 : state c : ad p0, p1 : prec_list H0 : MapGet prec_list s0 c = Some p0 H1 : MapGet prec_list s1 c = Some p1 Unable to unify \"Some (pl_produit p0 p1)\" with \"MapGet prec_list ((fix s_produit (s0 s1 : state) {struct s1} : state := match s0 with | @M0 _ => match s1 with | @M0 _ | _ => M0 prec_list end | @M1 _ a0 p0 => match s1 with | @M0 _ => M0 prec_list | @M1 _ a1 p1 => if (a0 =? a1)%N then M1 prec_list a0 (pl_produit p0 p1) else M0 prec_list | @M2 _ s10 s11 => match a0 with | 0%N => M2 prec_list (s_produit_l 0%N p0 s10) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p0 s11) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p0 s10) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p0 s11) end end | @M2 _ s00 s01 => match s1 with | @M0 _ => M0 prec_list | @M1 _ 0%N p1 => M2 prec_list (s_produit_r 0%N p1 s00) (M0 prec_list) | @M1 _ (N.pos (q'~1)%positive) p1 => M2 prec_list (M0 prec_list) (s_produit_r (N.pos q') p1 s01) | @M1 _ (N.pos (q'~0)%positive) p1 => M2 prec_list (s_produit_r (N.pos q') p1 s00) (M0 prec_list) | @M1 _ 1%N p1 => M2 prec_list (M0 prec_list) (s_produit_r 0%N p1 s01) | @M2 _ s10 s11 => M2 prec_list (s_produit s00 s10) (s_produit s01 s11) end end) s0 s1) c\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s0 s1 c p0 p1 H0 H1. unfold s_produit. simpl. rewrite H0, H1. reflexivity.", "succ": false}]