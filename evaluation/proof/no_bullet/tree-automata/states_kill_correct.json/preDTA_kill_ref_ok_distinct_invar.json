[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros d sigma H1 H2.", "unfold preDTA_ref_ok_distinct, preDTA_kill in *.", "intros a s H3."], "tactic": "specialize (H1 a s H3) as H4.", "exn": "In environment d : preDTA sigma : signature H1 : forall (a : ad) (s : state), MapGet state d a = Some s -> state_ref_ok s d H2 : predta_correct_wrt_sign d sigma a : ad s : state H3 : MapGet state ((fix preDTA_kill (m : Map bool) (d : preDTA) {struct d} : preDTA := match d with | @M0 _ => M0 state | @M1 _ a s => match states_kill m s with | Some s' => M1 state a s' | None => M0 state end | @M2 _ d0 d1 => match preDTA_kill m d0 with | @M0 _ => match preDTA_kill m d1 with | @M0 _ => M0 state | @M1 _ a s' => M1 state (N.succ_double a) s' | @M2 _ m0 m1 => M2 state (M0 state) (M2 state m0 m1) end | @M1 _ a s' => match preDTA_kill m d1 with | @M0 _ => M1 state (N.double a) s' | @M1 _ a0 s => M2 state (M1 state a s') (M1 state a0 s) | @M2 _ m0 m1 => M2 state (M1 state a s') (M2 state m0 m1) end | @M2 _ m0 m1 => M2 state (M2 state m0 m1) (preDTA_kill m d1) end end) (dta_non_empty_states d) d) a = Some s The term \"H3\" has type \"MapGet state ((fix preDTA_kill (m : Map bool) (d : preDTA) {struct d} : preDTA := match d with | @M0 _ => M0 state | @M1 _ a s => match states_kill m s with | Some s' => M1 state a s' | None => M0 state end | @M2 _ d0 d1 => match preDTA_kill m d0 with | @M0 _ => match preDTA_kill m d1 with | @M0 _ => M0 state | @M1 _ a s' => M1 state (N.succ_double a) s' | @M2 _ m0 m1 => M2 state (M0 state) (M2 state m0 m1) end | @M1 _ a s' => match preDTA_kill m d1 with | @M0 _ => M1 state (N.double a) s' | @M1 _ a0 s => M2 state (M1 state a s') (M1 state a0 s) | @M2 _ m0 m1 => M2 state (M1 state a s') (M2 state m0 m1) end | @M2 _ m0 m1 => M2 state (M2 state m0 m1) (preDTA_kill m d1) end end) (dta_non_empty_states d) d) a = Some s\" while it is expected to have type \"MapGet state d a = Some s\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d sigma H1 H2.", "unfold preDTA_ref_ok_distinct, preDTA_kill in *.", "intros a s H3."], "tactic": "specialize (H2 a s H4) as H5.", "exn": "The reference H4 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma H1 H2.", "unfold preDTA_ref_ok_distinct, preDTA_kill in *.", "intros a s H3."], "tactic": "destruct (dt_non_empty_fix d a H5) as [t H6].", "exn": "The reference H5 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d sigma H1 H2.", "unfold preDTA_ref_ok_distinct, preDTA_kill in *.", "intros a s H3.", "apply (dt_kill_1 d (dta_non_empty_states d) a s) in H3 as [s' [H7 H8]]."], "tactic": "exists t.", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros d sigma H1 H2. unfold preDTA_ref_ok_distinct, preDTA_kill in *. intros a s H3. specialize (H1 a s H3) as H4. specialize (H2 a s H4) as H5. destruct (dt_non_empty_fix d a H5) as [t H6]. apply (dt_kill_1 d (dta_non_empty_states d) a s) in H3 as [s' [H7 H8]]. exists t. auto.", "succ": false}]