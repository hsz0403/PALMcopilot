[{"history": {"proof": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. hauto use: st_kill_2, prec_list_kill_ref_ok_invar.", "repairs": ["", "", "", "", "hammer"], "exceptions": []}, "chat": [], "original": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. unfold states_kill_aux. induction s. - simpl. auto. - destruct p as [a' p']. destruct (prec_list_kill (dta_non_empty_states d) p') eqn:E. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. - destruct s1. + destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. + destruct (states_kill_aux (dta_non_empty_states d) s1) eqn:E2. * destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). * apply IHs1. ++ apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2.", "succ": true}]