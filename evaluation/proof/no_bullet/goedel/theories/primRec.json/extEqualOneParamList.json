[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n m l1 l2 c H.", "unfold extEqualVector in H.", "unfold evalOneParamList.", "unfold extEqualVector."], "tactic": "apply extEqualVectorGeneral with (m' := c).", "exn": "In environment n, m : nat l1, l2 : Vector.t (naryFunc (S n)) m c : nat H : Vector.rect2 (fun (n0 : nat) (_ _ : Vector.t (naryFunc (S n)) n0) => Prop) True (fun (n0 : nat) (_ _ : Vector.t (naryFunc (S n)) n0) (X : Prop) (a b : naryFunc (S n)) => extEqual (S n) a b /\\\\ X) l1 l2 Unable to unify \"Prop\" with \"Vector.rect2 (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) => Prop) True (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) (X : Prop) (a b : naryFunc n) => extEqual n a b /\\\\ X) ((fix evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m) {struct l} : Vector.t (naryFunc n) m := match l in (Vector.t _ m0) return (Vector.t (naryFunc n) m0) with | @Vector.nil _ => Vector.nil (naryFunc n) | @Vector.cons _ f m' l' => Vector.cons ((fix naryFunc (n0 : nat) : Set := match n0 with | 0 => nat | S n1 => nat -> naryFunc n1 end) n) (f a) m' (evalOneParamList n m' a l') end) n m c l1) ((fix evalOneParamList (n m a : nat) (l : Vector.t (naryFunc (S n)) m) {struct l} : Vector.t (naryFunc n) m := match l in (Vector.t _ m0) return (Vector.t (naryFunc n) m0) with | @Vector.nil _ => Vector.nil (naryFunc n) | @Vector.cons _ f m' l' => Vector.cons ((fix naryFunc (n0 : nat) : Set := match n0 with | 0 => nat | S n1 => nat -> naryFunc n1 end) n) (f a) m' (evalOneParamList n m' a l') end) n m c l2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n m l1 l2 c H.", "unfold extEqualVector in H.", "unfold evalOneParamList.", "unfold extEqualVector.", "qsimpl use: extEqualVectorGeneral."], "tactic": "apply evalPrimRecs.", "exn": "In environment X : forall n m : nat, Vector.t (naryFunc n) m -> forall m' : nat, Vector.t (naryFunc n) m' -> Prop n, m : nat l1, l2 : Vector.t (nat -> naryFunc n) m c : nat H : Vector.rect2 (fun (n0 : nat) (_ _ : Vector.t (nat -> naryFunc n) n0) => Prop) True (fun (n0 : nat) (_ _ : Vector.t (nat -> naryFunc n) n0) (X : Prop) (a b : nat -> naryFunc n) => (forall c : nat, extEqual n (a c) (b c)) /\\\\ X) l1 l2 Unable to unify \"Vector.t (naryFunc ?M1548) ?M1549\" with \"(fix rect2_fix (n : nat) (v1 : Vector.t (naryFunc n) n) {struct v1} : forall v2 : Vector.t (naryFunc n) n, (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) => Prop) n v1 v2 := match v1 as v2 in (Vector.t _ n0) return (forall v3 : Vector.t (naryFunc n) n0, (fun (n1 : nat) (_ _ : Vector.t (naryFunc n) n1) => Prop) n0 v2 v3) with | @Vector.nil _ => fun v2 : Vector.t (naryFunc n) 0 => Vector.case0 ((fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) => Prop) 0 (Vector.nil (naryFunc n))) True v2 | @Vector.cons _ h1 n' t1 => fun v2 : Vector.t (naryFunc n) (S n') => Vector.caseS' v2 (fun v2' : Vector.t (naryFunc n) (S n') => (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) => Prop) (S n') (Vector.cons (naryFunc n) h1 n' t1) v2') (fun (h2 : naryFunc n) (t2 : Vector.t (naryFunc n) n') => (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) (X : Prop) (a b : naryFunc n) => extEqual n a b /\\\\ X) n' t1 t2 (rect2_fix n' t1 t2) h1 h2) end) m ((fix evalOneParamList (n m a : nat) (l : Vector.t (nat -> naryFunc n) m) {struct l} : Vector.t (naryFunc n) m := match l in (Vector.t _ m0) return (Vector.t (naryFunc n) m0) with | @Vector.nil _ => Vector.nil (naryFunc n) | @Vector.cons _ f m' l' => Vector.cons ((fix naryFunc (n0 : nat) : Set := match n0 with | 0 => nat | S n1 => nat -> naryFunc n1 end) n) (f a) m' (evalOneParamList n m' a l') end) n m c l1) ((fix evalOneParamList (n m a : nat) (l : Vector.t (nat -> naryFunc n) m) {struct l} : Vector.t (naryFunc n) m := match l in (Vector.t _ m0) return (Vector.t (naryFunc n) m0) with | @Vector.nil _ => Vector.nil (naryFunc n) | @Vector.cons _ f m' l' => Vector.cons ((fix naryFunc (n0 : nat) : Set := match n0 with | 0 => nat | S n1 => nat -> naryFunc n1 end) n) (f a) m' (evalOneParamList n m' a l') end) n m c l2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n m l1 l2 c H.", "unfold extEqualVector in H.", "unfold evalOneParamList.", "unfold extEqualVector.", "qsimpl use: extEqualVectorGeneral.", "qsimpl use: evalPrimRecs,extEqualVectorGeneral."], "tactic": "apply H.", "exn": "In environment X0 : forall n m : nat, Vector.t (naryFunc n) m -> forall m' : nat, Vector.t (naryFunc n) m' -> Prop H0 : forall n m : nat, PrimRecs n m -> Vector.t (naryFunc n) m X : forall n m : nat, Vector.t (naryFunc n) m -> forall m' : nat, Vector.t (naryFunc n) m' -> Prop n, m : nat l1, l2 : Vector.t (nat -> naryFunc n) m c : nat H : Vector.rect2 (fun (n0 : nat) (_ _ : Vector.t (nat -> naryFunc n) n0) => Prop) True (fun (n0 : nat) (_ _ : Vector.t (nat -> naryFunc n) n0) (X : Prop) (a b : nat -> naryFunc n) => (forall c : nat, extEqual n (a c) (b c)) /\\\\ X) l1 l2 Unable to unify \"Vector.rect2 (fun (n0 : nat) (_ _ : Vector.t (nat -> naryFunc n) n0) => Prop) True (fun (n0 : nat) (_ _ : Vector.t (nat -> naryFunc n) n0) (X : Prop) (a b : nat -> naryFunc n) => (forall c : nat, extEqual n (a c) (b c)) /\\\\ X) l1 l2\" with \"Vector.rect2 (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) => Prop) True (fun (n0 : nat) (_ _ : Vector.t (naryFunc n) n0) (X : Prop) (a b : naryFunc n) => extEqual n a b /\\\\ X) ((fix evalOneParamList (n m a : nat) (l : Vector.t (nat -> naryFunc n) m) {struct l} : Vector.t (naryFunc n) m := match l in (Vector.t _ m0) return (Vector.t (naryFunc n) m0) with | @Vector.nil _ => Vector.nil (naryFunc n) | @Vector.cons _ f m' l' => Vector.cons ((fix naryFunc (n0 : nat) : Set := match n0 with | 0 => nat | S n1 => nat -> naryFunc n1 end) n) (f a) m' (evalOneParamList n m' a l') end) n m c l1) ((fix evalOneParamList (n m a : nat) (l : Vector.t (nat -> naryFunc n) m) {struct l} : Vector.t (naryFunc n) m := match l in (Vector.t _ m0) return (Vector.t (naryFunc n) m0) with | @Vector.nil _ => Vector.nil (naryFunc n) | @Vector.cons _ f m' l' => Vector.cons ((fix naryFunc (n0 : nat) : Set := match n0 with | 0 => nat | S n1 => nat -> naryFunc n1 end) n) (f a) m' (evalOneParamList n m' a l') end) n m c l2)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros n m l1 l2 c H. unfold extEqualVector in H. unfold evalOneParamList. unfold extEqualVector. apply extEqualVectorGeneral with (m' := c). - apply evalPrimRecs. - apply H.", "succ": false}]