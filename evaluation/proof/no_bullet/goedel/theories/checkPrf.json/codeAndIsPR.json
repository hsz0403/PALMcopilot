[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold isPR."], "tactic": "destruct n.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold isPR.", "destruct wellFormed.wellFormedFormula."], "tactic": "destruct f.", "exn": "The reference f was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold isPR.", "destruct wellFormed.wellFormedFormula.", "destruct idIsPR.", "intros."], "tactic": ["destruct x.", ""], "exn": "Abstracting over the terms \"n\" and \"x\" leads to a term fun (n0 : nat) (x0 : PrimRec n0) => isPR n0 codeArityF -> isPR n0 codeArityR -> extEqual n0 (evalPrimRec n0 x0) (fun x1 : nat => x1) -> nat which is ill-typed. Reason is: Illegal application: The term \"isPR\" of type \"forall n : nat, naryFunc n -> Set\" cannot be applied to the terms \"n0\" : \"nat\" \"codeArityF\" : \"nat -> nat\" The 2nd term has type \"nat -> nat\" which should be coercible to \"naryFunc n0\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "unfold isPR. intros. destruct n. destruct f. intros. destruct x. destruct x. destruct x0. auto.", "succ": false}]