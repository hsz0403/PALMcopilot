[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros t v s.", "unfold substituteTerm, LNN2LNT_term.", "destruct t.", "-", "simpl."], "tactic": "reflexivity.", "exn": "In environment n, v : nat s : fol.Term LNN Unable to unify \"if Nat.eq_dec v n then (fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) s else fol.var LNT n\" with \"(fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) (if Nat.eq_dec v n then s else fol.var LNN n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros t v s.", "unfold substituteTerm, LNN2LNT_term.", "destruct t.", "-", "simpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros t v s.", "unfold substituteTerm, LNN2LNT_term.", "destruct t.", "-", "simpl.", "shelve.", "-", "simpl."], "tactic": "reflexivity.", "exn": "In environment f : Functions LNN t : fol.Terms LNN (arity LNN (inr f)) v : nat s : fol.Term LNN Unable to unify \"apply LNT f ((fix substituteTerm (s : fol.Term LNT) (x : nat) (t : fol.Term LNT) {struct s} : fol.Term LNT := match s with | @fol.var _ v => if Nat.eq_dec x v then t else fol.var LNT v | @apply _ f ts => apply LNT f (substituteTerms (LNTFunctionArity f) ts x t) end with substituteTerms (n : nat) (ss : fol.Terms LNT n) (x : nat) (t : fol.Term LNT) {struct ss} : fol.Terms LNT n := match ss in (fol.Terms _ n0) return (fol.Terms LNT n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ts => Tcons LNT m (substituteTerm s x t) (substituteTerms m ts x t) end for substituteTerms) (LNTFunctionArity f) ((fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_terms) (LNTFunctionArity f) t) v ((fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_term) s))\" with \"apply LNT f ((fix LNN2LNT_term (t : fol.Term LNN) : Term := match t with | @fol.var _ v => var v | @apply _ f ts => apply LNT f (LNN2LNT_terms (LNTFunctionArity f) ts) end with LNN2LNT_terms (n : nat) (ts : fol.Terms LNN n) {struct ts} : Terms n := match ts in (fol.Terms _ n0) return (Terms n0) with | @Tnil _ => Tnil LNT | @Tcons _ m s ss => Tcons LNT m (LNN2LNT_term s) (LNN2LNT_terms m ss) end for LNN2LNT_terms) (LNTFunctionArity f) ((fix substituteTerm (s : fol.Term LNN) (x : nat) (t : fol.Term LNN) {struct s} : fol.Term LNN := match s with | @fol.var _ v => if Nat.eq_dec x v then t else fol.var LNN v | @apply _ f ts => apply LNN f (substituteTerms (LNTFunctionArity f) ts x t) end with substituteTerms (n : nat) (ss : fol.Terms LNN n) (x : nat) (t : fol.Term LNN) {struct ss} : fol.Terms LNN n := match ss in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ts => Tcons LNN m (substituteTerm s x t) (substituteTerms m ts x t) end for substituteTerms) (LNTFunctionArity f) t v s))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros t v s. unfold substituteTerm, LNN2LNT_term. destruct t. - simpl. reflexivity. - simpl. reflexivity.", "succ": false}]