[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold r_step_coh_t, rc_step."], "tactic": "unfold receive_step_t in rc_step.", "exn": "No such hypothesis: rc_step", "type": "no_hypos", "handled": true}, {"ctx": ["unfold r_step_coh_t, rc_step.", "qsimpl use: receive_step_t,rc_step.", "intros d Hcoh this pt m pf Hin.", "destruct (this == cn) eqn:Heq.", "-", "simpl."], "tactic": ["rewrite (eqP Heq).", ""], "exn": "Dependent type error in rewrite of (fun _pattern_value_ : nid => _pattern_value_ \\\\in dom (dstate d) -> find pt (dsoup d) = Some {| content := Hin; from := Hcoh; to := _pattern_value_; active := true |} -> rc_wf m _pattern_value_ Hcoh Hin -> tag Hin = rc_tag -> tpc_coh {| dstate := upd _pattern_value_ (mkLocal (cstep_recv (getStC m) Hcoh rc_tag Hin (getStL m pf))) (dstate d); dsoup := consume_msg (dsoup d) pt |}) Type error was: Illegal application: The term \"getStL\" of type \"forall (n : nat_eqType) (d : dstatelet), coh d -> n \\\\in nodes -> Log\" cannot be applied to the terms \"_pattern_value_\" : \"nid\" \"d\" : \"dstatelet\" \"m\" : \"coh d\" \"pf\" : \"is_true (this \\\\in (fun x : nat => (x == cn) || mem_seq (pts ++ others) x))\" The 4th term has type \"is_true (this \\\\in (fun x : nat => (x == cn) || mem_seq (pts ++ others) x))\" which should be coercible to \"is_true (_pattern_value_ \\\\in nodes)\".", "type": "term_cannot_apply", "handled": false}, {"ctx": ["unfold r_step_coh_t, rc_step.", "qsimpl use: receive_step_t,rc_step.", "intros d Hcoh this pt m pf Hin.", "destruct (this == cn) eqn:Heq.", "-", "simpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold r_step_coh_t, rc_step.", "qsimpl use: receive_step_t,rc_step.", "intros d Hcoh this pt m pf Hin.", "destruct (this == cn) eqn:Heq.", "-", "simpl.", "shelve.", "-"], "tactic": ["apply Hin.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "unfold r_step_coh_t, rc_step. intros. unfold receive_step_t in rc_step. intros d Hcoh this pt m pf Hin. destruct (this == cn) eqn:Heq. - simpl. rewrite (eqP Heq). unfold getStC, getStL, mkLocal. auto. - apply Hin.", "succ": false}]