[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intros Hs."], "tactic": "apply alwI.", "exn": "In environment this : nid W : world A : Type s : state p : proc A Hs : alwsafe s p Unable to unify \"(always ?M1555 ?M1556 (fun (s' : state) (p' : proc ?M1554) => ?M1557 -> ?M1558 s' p') -> ?M1557 -> always ?M1555 ?M1556 (fun s' : state => [eta ?M1558 s'])) /\\\\ ((?M1557 -> always ?M1555 ?M1556 (fun s' : state => [eta ?M1558 s'])) -> always ?M1555 ?M1556 (fun (s' : state) (p' : proc ?M1554) => ?M1557 -> ?M1558 s' p'))\" with \"forall scs : seq schedule, always_sc s p scs (fun (s2 : state) (p2 : proc A) => forall v : A, p2 = Ret v -> (fun=> xPredT) v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI."], "tactic": "intros s' p' H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI."], "tactic": "intros s' p' H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI."], "tactic": "apply aft_bnd with (P := fun=> True).", "exn": "In environment this : nid W : world A : Type s : state p : proc A Hs : alwsafe s p H : forall (A : Type) (s : state) (p : proc A) (P : Prop) (Q : state -> proc A -> Prop), alwsafe s p -> (P -> always s p (fun s' : state => [eta Q s'])) -> always s p (fun (s' : state) (p' : proc A) => P -> Q s' p') H0 : forall (A : Type) (s : state) (p : proc A) (P : Prop) (Q : state -> proc A -> Prop), alwsafe s p -> always s p (fun (s' : state) (p' : proc A) => P -> Q s' p') -> P -> always s p (fun s' : state => [eta Q s']) The term \"xPredT\" has type \"?T -> Prop\" while it is expected to have type \"?B -> state -> Prop\" (cannot unify \"Prop\" and \"state -> Prop\").", "type": "wrong_type", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True."], "tactic": "intros p Hp.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True."], "tactic": "intros p' Hp.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True."], "tactic": "apply H.", "exn": "In environment this : nid W : world H2 : forall (A B : Type) (p1 : proc A) (p12 : proc B) (pp2 : A -> Pred (proc B)) (s1 : state) (P : B -> state -> Prop), p12 \\\\In pcat p1 pp2 -> after s1 p1 (fun (v : A) (s : state) => forall p : proc B, p \\\\In pp2 v -> after s p P) -> after s1 p12 P A : Type s : state p : proc A Hs : alwsafe s p H : forall (A : Type) (s : state) (p : proc A) (P : Prop) (Q : state -> proc A -> Prop), alwsafe s p -> (P -> always s p (fun s' : state => [eta Q s'])) -> always s p (fun (s' : state) (p' : proc A) => P -> Q s' p') H0 : forall (A : Type) (s : state) (p : proc A) (P : Prop) (Q : state -> proc A -> Prop), alwsafe s p -> always s p (fun (s' : state) (p' : proc A) => P -> Q s' p') -> P -> always s p (fun s' : state => [eta Q s']) scs : seq schedule Unable to unify \"(fix always_sc (A : Type) (s1 : state) (p : proc A) (scs : seq schedule) (P : state -> proc A -> Prop) {struct scs} : Prop := s1 \\\\In coherent /\\\\ match scs with | [::] => forall s2 : state, network_rely W this s1 s2 -> P s2 p | sc :: scs' => forall s2 : state, network_rely W this s1 s2 -> [/\\\\ safe p sc s2, P s2 p & forall (s3 : state) (q : proc A), pstep s2 p sc s3 q -> always_sc A s3 q scs' P] end) ?M2603 ?M2604 ?M2605 scs (fun (s' : state) (p' : proc ?M2603) => ?M2606 -> ?M2607 s' p')\" with \"(fix always_sc (A : Type) (s1 : state) (p : proc A) (scs : seq schedule) (P : state -> proc A -> Prop) {struct scs} : Prop := s1 \\\\In coherent /\\\\ match scs with | [::] => forall s2 : state, network_rely W this s1 s2 -> P s2 p | sc :: scs' => forall s2 : state, network_rely W this s1 s2 -> [/\\\\ safe p sc s2, P s2 p & forall (s3 : state) (q : proc A), pstep s2 p sc s3 q -> always_sc A s3 q scs' P] end) A s p scs (fun (s2 : state) (p2 : proc A) => forall v : A, p2 = Ret v -> (fun=> xPredT) v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True.", "qsimpl use: alwI,aft_bnd,True."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True.", "qsimpl use: alwI,aft_bnd,True.", "shelve.", "-", "intros Hs."], "tactic": "apply alwA.", "exn": "In environment this : nid W : world A : Type s : state p : proc A Hs : after s p (fun=> xPredT) Unable to unify \"(always ?M3224 ?M3225 (fun (s' : state) (p' : proc ?M3222) => forall x : ?M3223, ?M3226 x s' p') -> forall x : ?M3223, always ?M3224 ?M3225 (fun s' : state => [eta ?M3226 x s'])) /\\\\ ((forall x : ?M3223, always ?M3224 ?M3225 (fun s' : state => [eta ?M3226 x s'])) -> always ?M3224 ?M3225 (fun (s' : state) (p' : proc ?M3222) => forall x : ?M3223, ?M3226 x s' p'))\" with \"forall scs : seq schedule, alwsafe_sc s p scs\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True.", "qsimpl use: alwI,aft_bnd,True.", "shelve.", "-", "intros Hs.", "qsimpl use: alwI,aft_bnd,alwA,True."], "tactic": "intros scs' s' p' H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True.", "qsimpl use: alwI,aft_bnd,True.", "shelve.", "-", "intros Hs.", "qsimpl use: alwI,aft_bnd,alwA,True."], "tactic": "intros scs' s' p' H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros Hs.", "qsimpl use: alwI.", "qsimpl use: alwI,aft_bnd,True.", "qsimpl use: alwI,aft_bnd,True.", "shelve.", "-", "intros Hs.", "qsimpl use: alwI,aft_bnd,alwA,True."], "tactic": "apply aftI with (V := mkWorld ProtocolWithIndInv).", "exn": "In environment this : nid W : world H0 : forall (A B : Type) (p1 : proc A) (p12 : proc B) (pp2 : A -> Pred (proc B)) (s1 : state) (P : B -> state -> Prop), p12 \\\\In pcat p1 pp2 -> after s1 p1 (fun (v : A) (s : state) => forall p : proc B, p \\\\In pp2 v -> after s p P) -> after s1 p12 P A : Type s : state p : proc A Hs : after s p (fun=> xPredT) H : forall (A : Type) (s : state) (p : proc A) (P : Prop) (Q : state -> proc A -> Prop), alwsafe s p -> (P -> always s p (fun s' : state => [eta Q s'])) -> always s p (fun (s' : state) (p' : proc A) => P -> Q s' p') H2 : forall (A : Type) (s : state) (p : proc A) (P : Prop) (Q : state -> proc A -> Prop), alwsafe s p -> always s p (fun (s' : state) (p' : proc A) => P -> Q s' p') -> P -> always s p (fun s' : state => [eta Q s']) H1 : forall (A B : Type) (s : state) (p : proc A) (P : B -> state -> proc A -> Prop), alwsafe s p -> (forall x : B, always s p (fun s' : state => [eta P x s'])) -> always s p (fun (s' : state) (p' : proc A) => forall x : B, P x s' p') H3 : forall (A B : Type) (s : state) (p : proc A) (P : B -> state -> proc A -> Prop), alwsafe s p -> always s p (fun (s' : state) (p' : proc A) => forall x : B, P x s' p') -> forall x : B, always s p (fun s' : state => [eta P x s']) The term \"ProtocolWithIndInv\" has type \"forall (p : protocol) (I : dstatelet -> pred nid -> Prop), ProtocolWithInvariant.InductiveInv p I -> Protocols.protocol\" while it is expected to have type \"protocol\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros. split. - intros Hs. apply alwI. auto. intros s' p' H. apply aft_bnd with (P := fun=> True). auto. intros p Hp. apply H. - intros Hs. apply alwA. auto. intros scs' s' p' H. apply aftI with (V := mkWorld ProtocolWithIndInv). reflexivity. apply alw_safe'. auto.", "succ": false}]