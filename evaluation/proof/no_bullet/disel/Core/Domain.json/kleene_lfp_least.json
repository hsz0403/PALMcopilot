[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros D f C x H.", "exn": "D is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros D' f C x H.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros D' f' C x H.", "exn": "C is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros D' f' C' x H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "rewrite <- H."], "tactic": "apply tarski_lfp_least.", "exn": "In environment D : cpo f : D -> D C : continuous f x : D H : f x = x Unable to unify \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class ?M1474) in mx_leq) (tarski_lfp ?M1475) ?M1476\" with \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class D) in mx_leq) kleene_lfp (f x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "rewrite <- H.", "qsimpl use: tarski_lfp_least.", "rewrite <- kleene_lfp_fixed."], "tactic": "apply contE.", "exn": "In environment H0 : forall (T : lattice) (f : T -> T) (x : T), f x = x -> tarski_lfp f <== x D : cpo f : D -> D C : continuous f x : D H : f x = x Unable to unify \"?M1757 (lim ?M1758) = lim [?M1757^^?M1758bycont_mono ?M1759]\" with \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class D) in mx_leq) (f kleene_lfp) (f x)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros D f C x H. rewrite <- H. apply tarski_lfp_least. rewrite <- kleene_lfp_fixed. apply contE. apply C.", "succ": false}]