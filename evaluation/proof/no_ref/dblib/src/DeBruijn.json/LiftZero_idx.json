[{"history": {"proof": "sauto lq: on depth: 3.", "repairs": ["hammer"], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nLiftZero\n\nPremises:\nRecord LiftZero (T : Type) (H : Lift T) : Prop := Build_LiftZero { lift_zero : forall (k : nat) (t : T), lift 0 k t = t } Arguments LiftZero {T}%type_scope {H} Arguments Build_LiftZero [T]%type_scope _ _%function_scope\nBuild_LiftZero : forall (T : Type) (H : Lift T), (forall (k : nat) (t : T), lift 0 k t = t) -> LiftZero\nNat.ones_wd = fun (x y : nat) (H : x = y) => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.Equivalence_Transitive (Nat.pred (Nat.shiftl 1 x)) (Nat.pred (Nat.shiftl 1 y)) (Nat.pred_wd (Nat.shiftl 1 x) (Nat.shiftl 1 y) (Morphisms.Reflexive_partial_app_morphism Nat.shiftl_wd (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive 1) x y H)) (Nat.pred (Nat.shiftl 1 y)) (Nat.pred (Nat.shiftl 1 y)) (Morphisms.eq_proper_proxy (Nat.pred (Nat.shiftl 1 y))) (RelationClasses.reflexivity (Nat.pred (Nat.shiftl 1 y))) : Morphisms.Proper (Morphisms.respectful eq eq) Nat.ones\nInit.Nat.leb = fix leb (n m : nat) {struct n} : bool := match n with | 0 => true | S n' => match m with | 0 => false | S m' => leb n' m' end end : nat -> nat -> bool Arguments Init.Nat.leb (_ _)%nat_scope\noption_map : forall A B : Type, (A -> B) -> option A -> option B\nNat.mul_pos_pos : forall n m : nat, 0 < n -> 0 < m -> 0 < n * m\nNat.lt_le_trans : forall n m p : nat, n < m -> m <= p -> n < p\nBvector.BVeq : forall m n : nat, VectorDef.t bool m -> VectorDef.t bool n -> bool\nNat.max_id : forall n : nat, Nat.max n n = n\nNat.pred_wd = PeanoNat.Nat.pred_wd_obligation_1 : Morphisms.Proper (Morphisms.respectful eq eq) Nat.pred\nlift_var : forall w k x : nat, lift w k (var x) = var (lift w k x)\nNat.le_gt_cases : forall n m : nat, n <= m \\/ m < n\nvar = fun (V : Type) (Var0 : Var V) => let (var) := Var0 in var : forall V : Type, Var V -> nat -> V Arguments var {V}%type_scope {Var} _%nat_scope\nNnat.N2Nat.inj_compare : forall a a' : BinNums.N, BinNat.N.compare a a' = (BinNat.N.to_nat a ?= BinNat.N.to_nat a')\nNat.divide_lcm_r : forall a b : nat, Nat.divide b (Nat.lcm a b)\nZnat.Nat2Z.is_nonneg : forall n : nat, BinInt.Z.le BinNums.Z0 (BinInt.Z.of_nat n)\nNat.max_r : forall n m : nat, n <= m -> Nat.max n m = m\nNnat.N2Nat.inj_max : forall a a' : BinNums.N, BinNat.N.to_nat (BinNat.N.max a a') = Nat.max (BinNat.N.to_nat a) (BinNat.N.to_nat a')\nNat.max_unicity_ext : forall f : nat -> nat -> nat, (forall n m : nat, n < m /\\ f n m = m \\/ m <= n /\\ f n m = n) -> forall n m : nat, f n m = Nat.max n m\nNat.compare_spec : forall x y : nat, CompareSpec (x = y) (x < y) (y < x) (x ?= y)\nNat.lt_lt_succ_r : forall n m : nat, n < m -> n < S m\nBinNatDef.N.odd = fun n : BinNums.N => negb (BinNatDef.N.even n) : BinNums.N -> bool Arguments BinNatDef.N.odd _%N_scope\nInit.Nat.pow = fix pow (n m : nat) {struct m} : nat := match m with | 0 => 1 | S m0 => n * pow n m0 end : nat -> nat -> nat Arguments Init.Nat.pow (_ _)%nat_scope\nnat_ind : forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n\nlt_le_S : forall n m : nat, n < m -> S n <= m\nInductive GFormula (TA TX AA AF : Type) : Type := TT : Tauto.GFormula | FF : Tauto.GFormula | X : TX -> Tauto.GFormula | A : TA -> AA -> Tauto.GFormula | Cj : Tauto.GFormula -> Tauto.GFormula -> Tauto.GFormula | D : Tauto.GFormula -> Tauto.GFormula -> Tauto.GFormula | N : Tauto.GFormula -> Tauto.GFormula | I : Tauto.GFormula -> option AF -> Tauto.GFormula -> Tauto.GFormula Arguments Tauto.GFormula {TA TX AA AF}%type_scope Arguments Tauto.TT {TA TX AA AF}%type_scope Arguments Tauto.FF {TA TX AA AF}%type_scope Arguments Tauto.X {TA TX AA AF}%type_scope Arguments Tauto.A {TA TX AA AF}%type_scope Arguments Tauto.Cj {TA TX AA AF}%type_scope Arguments Tauto.D {TA TX AA AF}%type_scope Arguments Tauto.N {TA TX AA AF}%type_scope Arguments Tauto.I {TA TX AA AF}%type_scope\nDeclConstant.DO = {| |} : DeclConstant.DeclaredConstant 0\nNat.divide_antisym : forall n m : nat, Nat.divide n m -> Nat.divide m n -> n = m\nNat.min_case : forall (n m : nat) (P : nat -> Type), P n -> P m -> P (Nat.min n m)\nInductive ZArithProof : Type := DoneProof : ZMicromega.ZArithProof | RatProof : ZMicromega.ZWitness -> ZMicromega.ZArithProof -> ZMicromega.ZArithProof | CutProof : ZMicromega.ZWitness -> ZMicromega.ZArithProof -> ZMicromega.ZArithProof | EnumProof : ZMicromega.ZWitness -> ZMicromega.ZWitness -> list ZMicromega.ZArithProof -> ZMicromega.ZArithProof | ExProof : BinNums.positive -> ZMicromega.ZArithProof -> ZMicromega.ZArithProof Arguments ZMicromega.EnumProof _ _ _%list_scope Arguments ZMicromega.ExProof _%positive_scope\ngt = fun n m : nat => m < n : nat -> nat -> Prop Arguments gt (_ _)%nat_scope\nNat.div_exact : forall a b : nat, b <> 0 -> a = b * (a / b) < -> a mod b = 0\nlift_idx_recent : forall w k x : nat, k > x -> lift w k x = x\nNat.gcd_eq_0_r : forall n m : nat, Nat.gcd n m = 0 -> m = 0\nString.index = fix index (n : nat) (s1 s2 : String.string) {struct s2} : option nat := match s2 with | String.EmptyString => match n with | 0 => match s1 with | String.EmptyString => Some 0 | String.String _ _ => None end | S _ => None end | String.String _ s2' => match n with | 0 => if String.prefix s1 s2 then Some 0 else match index 0 s1 s2' with | Some n0 => Some (S n0) | None => None end | S n' => match index n' s1 s2' with | Some n0 => Some (S n0) | None => None end end end : nat -> String.string -> String.string -> option nat Arguments String.index _%nat_scope (_ _)%string_scope\nNat.log2_up_eq_succ_iff_pow2 : forall a : nat, 0 < a -> Nat.log2_up (S a) = S (Nat.log2_up a) < -> (exists b : nat, a = 2 ^ b)\nNat.lnot = fun a n : nat => Nat.lxor a (Nat.ones n) : nat -> nat -> nat Arguments Nat.lnot (_ _)%nat_scope\nNat.mul_eq_0_l : forall n m : nat, n * m = 0 -> m <> 0 -> n = 0\nnat_double_ind : forall R : nat -> nat -> Prop, (forall n : nat, R 0 n) -> (forall n : nat, R (S n) 0) -> (forall n m : nat, R n m -> R (S n) (S m)) -> forall n m : nat, R n m\nnegb = fun b : bool => if b then false else true : bool -> bool Arguments negb _%bool_scope"}, {"role": "assistant", "content": "```coq\nexact (Build_LiftZero T H (fun k t => eq_refl _)).\nQed.```"}], "original": "apply (Build_LiftZero T H (fun k t => eq_refl _)).", "succ": true}]