[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold isPR."], "tactic": "intros L codeF codeArityF codeArityFIsPR codeArityFIsCorrect1 codeArityFIsCorrect2 Term Terms var apply.", "exn": "L is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF codeArityF codeArityFIsPR codeArityFIsCorrect1 codeArityFIsCorrect2 Term Terms var apply.", "exn": "codeF is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF codeArityFIsPR codeArityFIsCorrect1 codeArityFIsCorrect2 Term Terms var apply.", "exn": "codeArityF is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR codeArityFIsCorrect1 codeArityFIsCorrect2 Term Terms var apply.", "exn": "codeArityFIsPR is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1 codeArityFIsCorrect2 Term Terms var apply.", "exn": "codeArityFIsCorrect1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1' codeArityFIsCorrect2 Term Terms var apply.", "exn": "codeArityFIsCorrect2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1' codeArityFIsCorrect2' Term Terms var apply.", "exn": "Term is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1' codeArityFIsCorrect2' Term' Terms var apply.", "exn": "Terms is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1' codeArityFIsCorrect2' Term' Terms' var apply.", "exn": "var is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1' codeArityFIsCorrect2' Term' Terms' var' apply.", "exn": "apply is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros L' codeF' codeArityF' codeArityFIsPR' codeArityFIsCorrect1' codeArityFIsCorrect2' Term' Terms' var' apply'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold isPR."], "tactic": "intros isPR1 isPR1CodeF v s.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "unfold isPR in *."], "tactic": "intros n ts.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "unfold isPR in *."], "tactic": "rewrite (freeVarTermApply L) with (f := apply L).", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : {p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) codeArityF} codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L The term \"L\" has type \"Language\" while it is expected to have type \"Functions L\".", "type": "wrong_type", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "unfold isPR in *.", "apply compose1_1IsPR."], "tactic": "apply subTermFunction.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : {p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) codeArityF} codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L Unable to unify \"substituteTerm ?M1479 (fol.apply ?M1479 ?M1480 ?M1481) ?M1482 ?M1483 = fol.apply ?M1479 ?M1480 (substituteTerms ?M1479 (arity ?M1479 (inr ?M1480)) ?M1481 ?M1482 ?M1483)\" with \"{p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) wellFormedTermTerms}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold isPR. intros L codeF codeArityF codeArityFIsPR codeArityFIsCorrect1 codeArityFIsCorrect2 Term Terms var apply. intros isPR1 isPR1CodeF v s. unfold wellFormedTerms. unfold isPR in *. intros n ts. unfold substituteTerm. rewrite (freeVarTermApply L) with (f := apply L). apply compose1_1IsPR. apply subTermFunction.", "succ": false}]