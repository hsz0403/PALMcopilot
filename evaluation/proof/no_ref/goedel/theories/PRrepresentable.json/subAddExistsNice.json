[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n m A v s H H0.", "destruct H.", "-"], "tactic": "apply eq_add_S.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A n, m : nat A : Formula v : nat s : Term H : n + m <= v H0 : forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \\\\/ v < m Unable to unify \"?M1515 = ?M1516\" with \"substituteFormula LNN (addExists m n A) v s = addExists m n (substituteFormula LNN A v s)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-"], "tactic": "apply H.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A n, m : nat A : Formula v : nat s : Term H : n + m <= v H0 : forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \\\\/ v < m Unable to unify \"n + m <= v\" with \"substituteFormula LNN (addExists m n A) v s = addExists m n (substituteFormula LNN A v s)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-", "shelve.", "-", "apply le_lt_or_eq in H.", "destruct H.", "+"], "tactic": "apply le_plus_l in H.", "exn": "Unable to apply lemma of type \"forall n m : nat, n <= n + m\" on hypothesis of type \"S v < m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-", "shelve.", "-", "apply le_lt_or_eq in H.", "destruct H.", "+", "apply Nat.lt_le_incl in H."], "tactic": "apply Nat.lt_le_incl in H0.", "exn": "Unable to apply lemma of type \"forall n m : nat, n < m -> n <= m\" on hypothesis of type \"forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \\\\/ v < m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-", "shelve.", "-", "apply le_lt_or_eq in H.", "destruct H.", "+", "apply Nat.lt_le_incl in H."], "tactic": "apply Nat.lt_le_incl in H1.", "exn": "No such hypothesis: H1", "type": "no_hypos", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-", "shelve.", "-", "apply le_lt_or_eq in H.", "destruct H.", "+", "apply Nat.lt_le_incl in H."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-", "shelve.", "-", "apply le_lt_or_eq in H.", "destruct H.", "+", "apply Nat.lt_le_incl in H.", "shelve.", "+"], "tactic": "apply Nat.lt_le_incl in H0.", "exn": "Unable to apply lemma of type \"forall n m : nat, n < m -> n <= m\" on hypothesis of type \"forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \\\\/ v < m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m A v s H H0.", "destruct H.", "-", "shelve.", "-", "apply le_lt_or_eq in H.", "destruct H.", "+", "apply Nat.lt_le_incl in H.", "shelve.", "+"], "tactic": "apply H0.", "exn": "In environment Representable := expressible.Representable NN : forall n : nat, naryFunc n -> Formula -> Prop RepresentableAlternate := expressible.RepresentableAlternate NN closedNN1 : forall (n : nat) (f : naryFunc n) (A B : Formula), SysPrf NN (iffH A B) -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n f B RepresentableHelp := expressible.RepresentableHelp NN : forall n : nat, naryFunc n -> Formula -> Prop Representable_ext := expressible.Representable_ext NN : forall (n : nat) (f g : naryFunc n) (A : Formula), extEqual n f g -> expressible.RepresentableHelp NN n f A -> expressible.RepresentableHelp NN n g A n, m : nat A : Formula v : nat s : Term H : S v = m H0 : forall v : nat, In v (freeVarTerm LNN s) -> n + m <= v \\\\/ v < m Unable to unify \"n + m <= ?M1527 \\\\/ ?M1527 < m\" with \"substituteFormula LNN (addExists m n A) v s = addExists m n (substituteFormula LNN A v s)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros n m A v s H H0. destruct H. - apply eq_add_S. apply H. - apply le_lt_or_eq in H. destruct H. + apply le_plus_l in H. apply Nat.lt_le_incl in H. apply Nat.lt_le_incl in H0. apply Nat.lt_le_incl in H1. apply (le_trans _ _ _ H H1) in H0. apply plus_lt_reg_l in H0. apply H0. + apply Nat.lt_le_incl in H0. apply H0.", "succ": false}]