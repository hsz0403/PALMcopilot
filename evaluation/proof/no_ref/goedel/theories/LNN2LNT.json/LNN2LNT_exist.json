[{"history": {"proof": "intros v a. unfold LNN2LNT_formula. induction a. - reflexivity. - simpl. sfirstorder depth: 3. - simpl. reflexivity. - sfirstorder depth: 3. - sfirstorder depth: 3.", "repairs": ["", "", "", "", "", "", "", "hammer", "", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros v a.", "unfold LNN2LNT_formula.", "induction a.", "-", "reflexivity.", "-", "simpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros v a.", "unfold LNN2LNT_formula.", "induction a.", "-", "reflexivity.", "-", "simpl.", "shelve.", "-", "simpl."], "tactic": "rewrite IHa1, IHa2.", "exn": "Found no subterm matching \"(fix LNN2LNT_formula (f : fol.Formula LNN) : Formula := match f with | @fol.equal _ t1 t2 => equal (LNN2LNT_term t1) (LNN2LNT_term t2) | @atomic _ r ts => match r as l return (fol.Terms LNN (arity LNN (inl l)) -> Formula) with | LT => fun t0 : fol.Terms LNN (arity LNN (inl LT)) => translateLT t0 end ts | @fol.impH _ A B => impH (LNN2LNT_formula A) (LNN2LNT_formula B) | @fol.notH _ A => notH (LNN2LNT_formula A) | @fol.forallH _ v A => forallH v (LNN2LNT_formula A) end) (fol.existH LNN v a1)\" in the current goal.", "type": "no_subterm", "handled": true}]}, "chat": [], "original": "intros v a. unfold LNN2LNT_formula. induction a. - reflexivity. - simpl. rewrite IHa. reflexivity. - simpl. rewrite IHa1, IHa2. reflexivity.", "succ": true}]