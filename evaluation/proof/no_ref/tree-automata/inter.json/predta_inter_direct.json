[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros d0 d1 a0 a1 t Hcomp Hrec1 Hrec2."], "tactic": "unfold reconnaissance.", "exn": "Cannot coerce reconnaissance to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros d0 d1 a0 a1 t Hcomp Hrec1 Hrec2."], "tactic": "apply rec_dta with (ladj := iad_conv a0 a1).", "exn": "In environment d0, d1 : preDTA a0, a1 : ad t : term Hcomp : predta_compatible d0 d1 Hrec1 : reconnaissance d0 a0 t Hrec2 : reconnaissance d1 a1 t The term \"iad_conv a0 a1\" has type \"N\" while it is expected to have type \"Map prec_list\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d0 d1 a0 a1 t Hcomp Hrec1 Hrec2."], "tactic": "destruct Hcomp as [Hcomp_state _].", "exn": "Unable to find an instance for the variables s0, s1, c, pl0, pl1.", "type": "no_instance_var", "handled": true}]}, "chat": [], "original": "intros d0 d1 a0 a1 t Hcomp Hrec1 Hrec2. unfold reconnaissance. apply rec_dta with (ladj := iad_conv a0 a1). - destruct Hcomp as [Hcomp_state _]. apply Hcomp_state with (s0 := lst_rm_hd (essence t d0)) (s1 := lst_rm_hd (essence t d1)). + apply Hrec1. apply semantic_equiv_0. auto. + apply Hrec2. apply semantic_equiv_0. auto. - simpl. apply rec_st with (l := lst_rm_hd (essence t d0)). + apply Hrec1. apply semantic_equiv_0. auto. + apply Hrec2. apply semantic_equiv_0. auto.", "succ": false}]