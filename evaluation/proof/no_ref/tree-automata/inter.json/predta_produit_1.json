[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a s d a0 a1 s0 s1 H1 H2.", "unfold preDTA_produit_r.", "unfold iad_conv.", "unfold s_produit."], "tactic": "rewrite H1, H2.", "exn": "Found no subterm matching \"MapGet state (M1 state a s) a0\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros a s d a0 a1 s0 s1 H1 H2.", "unfold preDTA_produit_r.", "unfold iad_conv.", "unfold s_produit."], "tactic": "reflexivity.", "exn": "In environment a : ad s : state d : preDTA a0, a1 : ad s0, s1 : state H1 : MapGet state (M1 state a s) a0 = Some s0 H2 : MapGet state d a1 = Some s1 Unable to unify \"Some ((fix s_produit (s0 s1 : state) {struct s1} : state := match s0 with | @M0 _ => match s1 with | @M0 _ | _ => M0 prec_list end | @M1 _ a0 p0 => match s1 with | @M0 _ => M0 prec_list | @M1 _ a1 p1 => s_produit_l a0 p0 (M1 prec_list a1 p1) | @M2 _ s10 s11 => s_produit_l a0 p0 (M2 prec_list s10 s11) end | @M2 _ s00 s01 => match s1 with | @M0 _ => M0 prec_list | @M1 _ a1 p1 => s_produit_r a1 p1 (M2 prec_list s00 s01) | @M2 _ s10 s11 => M2 prec_list (s_produit s00 s10) (s_produit s01 s11) end end) s1 s0)\" with \"MapGet state ((fix preDTA_produit_r (a : ad) (s : state) (d : preDTA) {struct d} : preDTA := match d with | @M0 _ => M0 state | @M1 _ a' s' => M1 state match a' with | 0%N => match a with | 0%N => 0%N | N.pos p1 => N.pos (iad_conv_aux_0 p1) end | N.pos p0 => match a with | 0%N => N.pos (iad_conv_aux_1 p0) | N.pos p1 => N.pos (iad_conv_aux_2 p0 p1) end end ((fix s_produit (s0 s1 : state) {struct s1} : state := match s0 with | @M0 _ => match s1 with | @M0 _ | _ => M0 prec_list end | @M1 _ a0 p0 => match s1 with | @M0 _ => M0 prec_list | @M1 _ a1 p1 => s_produit_l a0 p0 (M1 prec_list a1 p1) | @M2 _ s10 s11 => s_produit_l a0 p0 (M2 prec_list s10 s11) end | @M2 _ s00 s01 => match s1 with | @M0 _ => M0 prec_list | @M1 _ a1 p1 => s_produit_r a1 p1 (M2 prec_list s00 s01) | @M2 _ s10 s11 => M2 prec_list (s_produit s00 s10) (s_produit s01 s11) end end) s' s) | @M2 _ s0 s1 => match a with | 0%N => M2 state (M2 state (preDTA_produit_r 0%N s s0) (M0 state)) (M2 state (preDTA_produit_r 0%N s s1) (M0 state)) | N.pos (p'~1)%positive => M2 state (M2 state (M0 state) (preDTA_produit_r (N.pos p') s s0)) (M2 state (M0 state) (preDTA_produit_r (N.pos p') s s1)) | N.pos (p'~0)%positive => M2 state (M2 state (preDTA_produit_r (N.pos p') s s0) (M0 state)) (M2 state (preDTA_produit_r (N.pos p') s s1) (M0 state)) | 1%N => M2 state (M2 state (M0 state) (preDTA_produit_r 0%N s s0)) (M2 state (M0 state) (preDTA_produit_r 0%N s s1)) end end) a s d) match a1 with | 0%N => match a0 with | 0%N => 0%N | N.pos p1 => N.pos (iad_conv_aux_0 p1) end | N.pos p0 => match a0 with | 0%N => N.pos (iad_conv_aux_1 p0) | N.pos p1 => N.pos (iad_conv_aux_2 p0 p1) end end\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros a s d a0 a1 s0 s1 H1 H2. unfold preDTA_produit_r. unfold iad_conv. unfold s_produit. rewrite H1, H2. reflexivity.", "succ": false}]