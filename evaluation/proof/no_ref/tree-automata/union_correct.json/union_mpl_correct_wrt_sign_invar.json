[{"history": {"proof": "srun best use: st_compat_check_0_correct, union_mpl_correct_wrt_sign_invar_1, st_compat_check_0_complete, st_compat_check_correct, st_compat_check_complete unfold: st_compat_check.", "repairs": ["hammer"], "exceptions": [{"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *."], "tactic": "intros H4.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+"], "tactic": "apply umpl_conv_0_correct_wrt_sign_invar in H1.", "exn": "Unable to apply lemma of type \"forall (s : state) (sigma : signature), state_correct_wrt_sign s sigma -> state_correct_wrt_sign (umpl_conv_0 s) sigma\" on hypothesis of type \"forall (a : ad) (p : prec_list), (if (a0 =? a)%N then Some p0 else None) = Some p -> exists n : nat, MapGet nat sigma a = Some n /\\\\ pl_tl_length p n\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+"], "tactic": "apply H1 in H4.", "exn": "No such hypothesis: H4", "type": "no_hypos", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+", "shelve.", "+", "destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate)."], "tactic": "apply umpl_conv_0_correct_wrt_sign_invar in H2.", "exn": "Unable to apply lemma of type \"forall (s : state) (sigma : signature), state_correct_wrt_sign s sigma -> state_correct_wrt_sign (umpl_conv_0 s) sigma\" on hypothesis of type \"forall (a : ad) (p : prec_list), match a with | 0%N => MapGet prec_list s1_1 0%N | N.pos (p1~1)%positive => MapGet prec_list s1_2 (N.pos p1) | N.pos (p1~0)%positive => MapGet prec_list s1_1 (N.pos p1) | 1%N => MapGet prec_list s1_2 0%N end = Some p -> exists n : nat, MapGet nat sigma a = Some n /\\\\ pl_tl_length p n\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+", "shelve.", "+", "destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate)."], "tactic": "apply H2 in H4.", "exn": "No such hypothesis: H4", "type": "no_hypos", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+", "shelve.", "+", "destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate)."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+", "shelve.", "+", "destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate).", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply umpl_conv_0_correct_wrt_sign_invar in H1.", "exn": "Unable to apply lemma of type \"forall (s : state) (sigma : signature), state_correct_wrt_sign s sigma -> state_correct_wrt_sign (umpl_conv_0 s) sigma\" on hypothesis of type \"forall (a : ad) (p : prec_list), match a with | 0%N => MapGet prec_list s0_1 0%N | N.pos (p1~1)%positive => MapGet prec_list s0_2 (N.pos p1) | N.pos (p1~0)%positive => MapGet prec_list s0_1 (N.pos p1) | 1%N => MapGet prec_list s0_2 0%N end = Some p -> exists n : nat, MapGet nat sigma a = Some n /\\\\ pl_tl_length p n\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s0 s1 sigma H1 H2 a p H3.", "unfold state_correct_wrt_sign in *.", "destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto.", "+", "shelve.", "+", "destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate).", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply H1 in H4.", "exn": "No such hypothesis: H4", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros s0 s1 sigma H1 H2 a p H3. unfold state_correct_wrt_sign in *. intros H4. unfold union_mpl. destruct s0; destruct s1; try (apply H1 in H4); try (apply H2 in H4); simpl in *; auto. + apply umpl_conv_0_correct_wrt_sign_invar in H1. apply H1 in H4. destruct H4 as [n [H5 H6]]. exists n. split; auto. + destruct (MapGet nat sigma a) as [n|] eqn:E; try (apply H1 in H4; discriminate). apply umpl_conv_0_correct_wrt_sign_invar in H2. apply H2 in H4. destruct H4 as [n [H5 H6]]. exists n. split; auto. + apply umpl_conv_0_correct_wrt_sign_invar in H1. apply H1 in H4. destruct H4 as [n [H5 H6]]. apply umpl_conv_0_correct_wrt_sign_invar in H2. apply H2 in H4. destruct H4 as [n' [H7 H8]]. exists (n + n'). split. * rewrite H5, H7. reflexivity. * rewrite H6, H8. apply pl_tl_length_concat.", "succ": true}]