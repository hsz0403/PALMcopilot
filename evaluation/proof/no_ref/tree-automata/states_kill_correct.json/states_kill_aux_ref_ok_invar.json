[{"history": {"proof": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. hauto use: st_kill_2, prec_list_kill_ref_ok_invar.", "repairs": ["", "", "", "", "hammer"], "exceptions": [{"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-"], "tactic": ["destruct p as [a' p'].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d s sigma H1 H2.", "unfold state_ref_ok in H1.", "unfold state_ref_ok.", "intros a p H3.", "induction s.", "-", "shelve.", "-", "shelve.", "-", "destruct s1.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros d s sigma H1 H2. unfold state_ref_ok in H1. unfold state_ref_ok. intros a p H3. unfold states_kill_aux. induction s. - simpl. auto. - destruct p as [a' p']. destruct (prec_list_kill (dta_non_empty_states d) p') eqn:E. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. + simpl. apply IHs. * intros a'' p'' H4. apply H1 with (a:=a''). rewrite <- E in H4. apply prec_list_kill_ref_ok_invar with (sigma:=sigma) in E; auto. * apply H2. auto. - destruct s1. + destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. * apply IHs. ++ intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2. + destruct (states_kill_aux (dta_non_empty_states d) s1) eqn:E2. * destruct (states_kill_aux (dta_non_empty_states d) s) eqn:E1. ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply IHs1. apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). * apply IHs1. ++ apply IHs0. intros a'' p'' H4. apply H1 with (a:=a''). apply H1 with (a:=a). ++ apply H2.", "succ": true}]