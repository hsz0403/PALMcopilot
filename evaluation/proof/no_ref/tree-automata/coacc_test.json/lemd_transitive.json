[{"history": {"proof": "intros d m0 m1 m2 H1 H2. unfold lemd in *. destruct H1 as [H1_1 [H1_2 H1_3]]. destruct H2 as [H2_1 [H2_2 H2_3]]. split. + apply H1_1. + srun best use: lem_transitive unfold: r_transitive.", "repairs": ["", "", "", "", "", "", "", "wrong_bullet", "hammer"], "exceptions": [{"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "apply (borne_1_2 m0 m1).", "exn": "In environment d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_1 : ensemble_base state d m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 The term \"m0\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "intros Hin.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "apply (borne_1_2 m1 m2).", "exn": "In environment d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_1 : ensemble_base state d m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 The term \"m1\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "intros Hin'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "apply (map_or_def_ok_d d m1 m2 H1_2 H2_2).", "exn": "In environment d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_1 : ensemble_base state d m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d (map_or m1 m2)\" with \"ensemble_base state d m0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "intros Hin''.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "apply (borne_1_2 m0 m1).", "exn": "In environment d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_1 : ensemble_base state d m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 The term \"m0\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "apply H1_1."], "tactic": "**", "exn": "Wrong bullet **: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "apply H1_1.", "+"], "tactic": "apply H2_1.", "exn": "In environment d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_1 : ensemble_base state d m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d m1\" with \"ensemble_base state d m2 /\\\\ lem m0 m2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "apply H1_1.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "apply H1_1.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros d m0 m1 m2 H1 H2. unfold lemd in *. destruct H1 as [H1_1 [H1_2 H1_3]]. destruct H2 as [H2_1 [H2_2 H2_3]]. split. + split. - apply (borne_1_2 m0 m1). * intros Hin. apply (borne_1_2 m1 m2). ++ intros Hin'. apply (map_or_def_ok_d d m1 m2 H1_2 H2_2). ++ intros Hin''. apply (borne_1_2 m0 m1). ** apply H1_1. ** apply H2_1. ** apply Hin. * intros Hin'. apply (borne_1_2 m0 m1). ++ apply H1_1. ++ apply H2_1. ++ apply Hin'. - apply (map_or_def_ok m0 m1). apply (lem_domain_equal m0 m1 H1_3). + apply (map_or_def_ok_d d m0 m2). * apply H1_2. * apply H2_2.", "succ": true}]