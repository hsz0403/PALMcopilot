[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s m a p p' H1 H2.", "unfold states_kill_aux.", "destruct s.", "-", "simpl in H2."], "tactic": "rewrite H2.", "exn": "Found no subterm matching \"None\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold states_kill_aux.", "destruct s.", "-", "simpl in H2."], "tactic": "apply H1.", "exn": "In environment m : Map bool a : ad p, p' : prec_list H1 : prec_list_kill m p = Some p' H2 : None = Some p Unable to unify \"prec_list_kill m p = Some p'\" with \"MapGet prec_list (M0 prec_list) a = Some p'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold states_kill_aux.", "destruct s.", "-", "simpl in H2."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold states_kill_aux.", "destruct s.", "-", "simpl in H2.", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold states_kill_aux.", "destruct s.", "-", "simpl in H2.", "shelve.", "-", "shelve.", "-", "destruct (MapGet prec_list (M1 prec_list a p) a).", "+", "destruct (prec_list_kill m p).", "*", "destruct (prec_list_kill m prec_empty).", "**", "inversion H1."], "tactic": "**", "exn": "Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s m a p p' H1 H2.", "unfold states_kill_aux.", "destruct s.", "-", "simpl in H2.", "shelve.", "-", "shelve.", "-", "destruct (MapGet prec_list (M1 prec_list a p) a).", "+", "destruct (prec_list_kill m p).", "*", "destruct (prec_list_kill m prec_empty).", "**", "inversion H1.", "shelve.", "**", "inversion H1."], "tactic": "*", "exn": "Wrong bullet *: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros s m a p p' H1 H2. unfold states_kill_aux. destruct s. - simpl in H2. rewrite H2. apply H1. - destruct (states_kill_aux m s). + destruct (states_kill_aux m s0). * inversion H2. * destruct (MapGet prec_list (M1 prec_list a p0) a). ++ inversion H2. ++ destruct (states_kill_aux m s1). ** inversion H2. ** destruct (prec_list_kill m p). *** destruct (prec_list_kill m prec_empty). **** inversion H1. **** inversion H1. *** destruct (prec_list_kill m s). **** inversion H1. **** apply H1. + destruct (states_kill_aux m s1). * discriminate. * destruct (MapGet prec_list (M1 prec_list a p) a). ++ destruct (states_kill_aux m s1). ** inversion H2. ** destruct (MapGet prec_list s2 (N.succ_double a)). *** inversion H2. *** destruct (states_kill_aux m s3). **** inversion H2. **** apply H1. ++ inversion H2. - destruct (MapGet prec_list (M1 prec_list a p) a). + destruct (prec_list_kill m p). * destruct (prec_list_kill m prec_empty). ** inversion H1. ** inversion H1. * inversion H1. + inversion H2.", "succ": false}]