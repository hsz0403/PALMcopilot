[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-"], "tactic": "intros a p.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-"], "tactic": "intros a' p.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+"], "tactic": "apply st_kill_2 in H'.", "exn": "Unable to apply lemma of type \"forall (s : state) (m : Map bool) (a : ad) (p : prec_list), MapGet prec_list (states_kill_aux m s) a = Some p -> exists p' : prec_list, MapGet prec_list s a = Some p' /\\\\ prec_list_kill m p' = Some p\" on hypothesis of type \"MapGet prec_list (M1 prec_list a p0) a' = Some p'\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+"], "tactic": "destruct H' as [p' [Hp Hk]].", "exn": "p' is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "destruct H' as [p'' [Hp Hk]]."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "destruct H' as [p'' [Hp Hk]].", "shelve.", "+", "inversion H'.", "-"], "tactic": "intros s0 IHs0 s1 IHs1.", "exn": "s1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "destruct H' as [p'' [Hp Hk]].", "shelve.", "+", "inversion H'.", "-"], "tactic": "intros s0 IHs0 s1' IHs1.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "destruct H' as [p'' [Hp Hk]].", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s sigma m H.", "unfold states_kill_aux.", "destruct s.", "-", "intros a p.", "intros contra.", "inversion contra.", "-", "intros a' p'.", "intros H'.", "destruct (prec_list_kill m p) eqn:E.", "+", "destruct H' as [p'' [Hp Hk]].", "shelve.", "+", "inversion H'.", "-", "intros a p.", "intros H'.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros s sigma m H. unfold states_kill_aux. destruct s. - intros a p. intros contra. inversion contra. - intros a p. simpl. intros H'. destruct (prec_list_kill m p) eqn:E. + apply st_kill_2 in H'. destruct H' as [p' [Hp Hk]]. rewrite Hk. apply H'. + inversion H'. - intros s0 IHs0 s1 IHs1. intros a p. intros H'. simpl. destruct (states_kill_aux m s0) eqn:E1. + apply IHs0 in H'. destruct H' as [n [H1 H2]]. inversion H'. + destruct (states_kill_aux m s1) eqn:E2. * apply IHs1 in H'. destruct H' as [n [H1 H2]]. inversion H'. * apply st_kill_3 in E1. destruct E1 as [p' [a' [H1 H2]]]. exists p'. exists a'. rewrite H2. apply H1. - intros a p. intros H'. simpl. apply st_kill_1 in H'. destruct H' as [s' [H1 H2]]. exists (states_kill_aux m s'). rewrite H2. apply H1.", "succ": false}]