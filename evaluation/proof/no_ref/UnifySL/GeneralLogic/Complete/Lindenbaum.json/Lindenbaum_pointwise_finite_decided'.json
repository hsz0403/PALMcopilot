[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-"], "tactic": "destruct H as [n' HL].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-", "shelve.", "-", "destruct H as [n' HL]."], "tactic": "destruct HL as [HL1 | [HL2 HL3]].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-", "shelve.", "-", "destruct H as [n' HL]."], "tactic": "apply Lindenbaum_pointwise_finite_decided with (n:=n') in HL1; auto.", "exn": "No such hypothesis: HL1", "type": "no_hypos", "handled": true}, {"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-", "shelve.", "-", "destruct H as [n' HL]."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-", "shelve.", "-", "destruct H as [n' HL]."], "tactic": "left; apply HL2.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros a n Hca Hproper.", "unfold LindenbaumConstruction, Same_set; split; intros.", "-", "shelve.", "-", "destruct H as [n' HL]."], "tactic": "apply Lindenbaum_pointwise_finite_decided with (n:=n') in HL3; auto.", "exn": "No such hypothesis: HL3", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros a n Hca Hproper. unfold LindenbaumConstruction, Same_set; split; intros. - destruct H as [n' HL]. exists (S n'). unfold LindenbaumChain. right. split. + apply Lindenbaum_pointwise_finite_decided with (n:=n'); auto. + apply Hproper. intros x. split; intros Hx. * destruct Hx as [Hx | Hx]. ++ left. apply HL. left. apply Hx. ++ right. split. -- apply Lindenbaum_pointwise_finite_decided with (n:=n'); auto. -- apply HL. right. apply Hx. * destruct Hx as [Hx1 Hx2]. destruct Hx2 as [Hx2 | Hx2]. ++ left. apply Hx1. ++ right. apply Hx2. - destruct H as [n' HL]. destruct HL as [HL1 | [HL2 HL3]]. + apply Lindenbaum_pointwise_finite_decided with (n:=n') in HL1; auto. + split. * left; apply HL2. * apply Lindenbaum_pointwise_finite_decided with (n:=n') in HL3; auto.", "succ": false}]