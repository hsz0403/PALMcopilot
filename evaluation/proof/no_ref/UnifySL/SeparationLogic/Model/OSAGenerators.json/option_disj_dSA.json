[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold DownwardsClosedSeparationAlgebra."], "tactic": "intros worlds R J SA dSA.", "exn": "worlds is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold DownwardsClosedSeparationAlgebra."], "tactic": "intros worlds' R J SA dSA.", "exn": "R is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold DownwardsClosedSeparationAlgebra."], "tactic": "intros worlds' R' J SA dSA.", "exn": "J is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold DownwardsClosedSeparationAlgebra."], "tactic": "intros worlds' R' J' SA dSA.", "exn": "SA is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold DownwardsClosedSeparationAlgebra."], "tactic": "intros worlds' R' J' SA' dSA.", "exn": "dSA is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold DownwardsClosedSeparationAlgebra.", "intros worlds' R' J' SA' dSA'."], "tactic": "unfold SeparationAlgebra, DownwardsClosedSeparationAlgebra in *.", "exn": "Cannot coerce SeparationAlgebra to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["unfold DownwardsClosedSeparationAlgebra.", "intros worlds' R' J' SA' dSA'.", "unfold Join in J.", "unfold Relation in R."], "tactic": "intros x y Heq Hres.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "unfold DownwardsClosedSeparationAlgebra. intros worlds R J SA dSA. unfold SeparationAlgebra, DownwardsClosedSeparationAlgebra in *. unfold Join in J. unfold Relation in R. intros x y Heq Hres. induction x as [x|]. - induction y as [y|]. + apply incr_split_smaller with (m := Some x) (m1 := Some x) (m2 := Some y); auto. * intros z Hz. apply residual_extensible with (u := x) in Hz as [e [v Hj]]. exists (Some e), (Some v). split; [|split]; auto. + apply incr_split_smaller with (m := Some x) (m1 := Some x) (m2 := None); auto. * intros z Hz. apply residual_extensible with (u := x) in Hz as [e [v Hj]]. exists (Some e), None. split; [|split]; auto. - induction y as [y|]. + apply incr_split_smaller with (m := None) (m1 := None) (m2 := Some y); auto. * intros z Hz. apply residual_extensible with (u := y) in Hz as [e [v Hj]]. exists None, (Some e). split; [|split]; auto. + apply incr_split_smaller with (m := None) (m1 := None) (m2 := None); auto. * intros z Hz. apply residual_extensible with (u := x) in Hz as [e [v Hj]]. exists None, None. split; [|split]; auto.", "succ": false}]