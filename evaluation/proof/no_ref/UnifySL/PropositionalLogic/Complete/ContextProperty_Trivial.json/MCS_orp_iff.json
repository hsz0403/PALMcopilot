[{"history": {"proof": "intros Phi Hmax x y. split. - intros H. apply (MCS_element_derivable Phi Hmax) in H as H1. hauto use: @DCS_orp_iff, maximal_consistent_orp_witnessed, @maximal_consistent_derivable_closed. - intros [Hx | Hy]. + hauto lq: on use: @maximal_consistent_derivable_closed, maximal_consistent_orp_witnessed, @DCS_orp_iff. + hauto lq: on use: @maximal_consistent_derivable_closed, maximal_consistent_orp_witnessed, @DCS_orp_iff.", "repairs": ["", "", "", "", "", "hammer", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "destruct H1 as [Hx Hy].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "apply (MCS_orp_iff Phi Hmax) in Hx.", "exn": "No such hypothesis: Hx", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "apply (MCS_orp_iff Phi Hmax) in Hy.", "exn": "No such hypothesis: Hy", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hx : Phi x The term \"minSC\" has type \"MinimumSequentCalculus L Gamma\" while it is expected to have type \"derivable_closed Phi\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "apply (MCS_nonelement_inconsistent Phi Hmax).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hx : Phi x Unable to unify \"(~ Phi ?M2387 -> Phi |-- ?M2387 --> FF) /\\\\ (Phi |-- ?M2387 --> FF -> ~ Phi ?M2387)\" with \"Phi (x || y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "intros H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+", "shelve.", "+"], "tactic": "apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hy : Phi y The term \"minSC\" has type \"MinimumSequentCalculus L Gamma\" while it is expected to have type \"derivable_closed Phi\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+", "shelve.", "+"], "tactic": "apply (MCS_nonelement_inconsistent Phi Hmax).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hy : Phi y Unable to unify \"(~ Phi ?M2387 -> Phi |-- ?M2387 --> FF) /\\\\ (Phi |-- ?M2387 --> FF -> ~ Phi ?M2387)\" with \"Phi (x || y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "shelve.", "-", "intros [Hx | Hy].", "+", "shelve.", "+"], "tactic": "intros H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros Phi Hmax x y. split. - intros H. apply (MCS_element_derivable Phi Hmax) in H as H1. destruct H1 as [Hx Hy]. apply (MCS_orp_iff Phi Hmax) in Hx. apply (MCS_orp_iff Phi Hmax) in Hy. destruct Hx, Hy. + left. apply H0. + right. apply H. + right. apply H1. - intros [Hx | Hy]. + apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y). * apply (MCS_nonelement_inconsistent Phi Hmax). intros H. apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax). apply H. apply MCS_nonelement_element. apply H0. apply H. * left. apply H0. + apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y). * apply (MCS_nonelement_inconsistent Phi Hmax). intros H. apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax). apply H. apply MCS_nonelement_element. apply H1. apply H. * right. apply H1.", "succ": true}]