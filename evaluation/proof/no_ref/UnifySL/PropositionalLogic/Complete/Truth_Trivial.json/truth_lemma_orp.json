[{"history": {"proof": "intros m Phi H. split. - qauto use: @MCS_orp_iff, @sat_orp unfold: proj1_sig, at_least. - intros H'. qauto use: @sat_orp, @MCS_orp_iff unfold: at_least, proj1_sig.", "repairs": ["", "", "", "hammer", "", "", "hammer"], "exceptions": [{"ctx": ["intros m Phi H.", "split.", "-"], "tactic": "intros [Hx | Hy].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-"], "tactic": "apply IHx in Hx.", "exn": "No such hypothesis: Hx", "type": "no_hypos", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "destruct H' as [Hx | Hy].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "apply IHx.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma MD : Model kMD : KripkeModel MD M : Kmodel SM : Semantics L MD tminSM : TrivialMinimumSemantics L MD SM tpSM : TrivialPropositionalSemantics L MD SM cP : context -> Prop rel : bijection (Kworlds M) {x : context | cP x} AL_MC : at_least (maximal consistent) cP x, y : expr IHx : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= x <-> proj1_sig Phi x IHy : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= y <-> proj1_sig Phi y m : Kworlds M Phi : {x : context | cP x} H : rel m Phi H' : proj1_sig Phi (x || y) Unable to unify \"(KRIPKE: M, ?M2376 |= x -> proj1_sig ?M2377 x) /\\\\ (proj1_sig ?M2377 x -> KRIPKE: M, ?M2376 |= x)\" with \"(let (denotation) := SM in denotation) (x || y) (KRIPKE: M, m)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "rewrite <- IHx in Hx.", "exn": "No such hypothesis: Hx", "type": "no_hypos", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "apply proj1_sig in H.", "exn": "Unable to apply lemma of type \"forall (A : Type) (P : A -> Prop), {x : A | P x} -> A\" on hypothesis of type \"rel m Phi\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma MD : Model kMD : KripkeModel MD M : Kmodel SM : Semantics L MD tminSM : TrivialMinimumSemantics L MD SM tpSM : TrivialPropositionalSemantics L MD SM cP : context -> Prop rel : bijection (Kworlds M) {x : context | cP x} AL_MC : at_least (maximal consistent) cP x, y : expr IHx : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= x <-> proj1_sig Phi x IHy : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= y <-> proj1_sig Phi y m : Kworlds M Phi : {x : context | cP x} H : rel m Phi H' : proj1_sig Phi (x || y) Unable to unify \"rel m Phi\" with \"KRIPKE: M, m |= x || y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "apply IHy.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma MD : Model kMD : KripkeModel MD M : Kmodel SM : Semantics L MD tminSM : TrivialMinimumSemantics L MD SM tpSM : TrivialPropositionalSemantics L MD SM cP : context -> Prop rel : bijection (Kworlds M) {x : context | cP x} AL_MC : at_least (maximal consistent) cP x, y : expr IHx : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= x <-> proj1_sig Phi x IHy : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= y <-> proj1_sig Phi y m : Kworlds M Phi : {x : context | cP x} H : rel m Phi H' : proj1_sig Phi (x || y) Unable to unify \"(KRIPKE: M, ?M2376 |= y -> proj1_sig ?M2377 y) /\\\\ (proj1_sig ?M2377 y -> KRIPKE: M, ?M2376 |= y)\" with \"(let (denotation) := SM in denotation) (x || y) (KRIPKE: M, m)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "rewrite <- IHy in Hy.", "exn": "No such hypothesis: Hy", "type": "no_hypos", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "apply proj1_sig in H.", "exn": "Unable to apply lemma of type \"forall (A : Type) (P : A -> Prop), {x : A | P x} -> A\" on hypothesis of type \"rel m Phi\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m Phi H.", "split.", "-", "shelve.", "-", "intros H'."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma MD : Model kMD : KripkeModel MD M : Kmodel SM : Semantics L MD tminSM : TrivialMinimumSemantics L MD SM tpSM : TrivialPropositionalSemantics L MD SM cP : context -> Prop rel : bijection (Kworlds M) {x : context | cP x} AL_MC : at_least (maximal consistent) cP x, y : expr IHx : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= x <-> proj1_sig Phi x IHy : forall (m : Kworlds M) (Phi : {x : context | cP x}), rel m Phi -> KRIPKE: M, m |= y <-> proj1_sig Phi y m : Kworlds M Phi : {x : context | cP x} H : rel m Phi H' : proj1_sig Phi (x || y) Unable to unify \"rel m Phi\" with \"KRIPKE: M, m |= x || y\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m Phi H. split. - intros [Hx | Hy]. + apply IHx in Hx. rewrite Hx. apply proj1_sig in H. apply H. + apply IHy in Hy. rewrite Hy. apply proj1_sig in H. apply H. - intros H'. destruct H' as [Hx | Hy]. + apply IHx. rewrite <- IHx in Hx. apply proj1_sig in H. apply H. + apply IHy. rewrite <- IHy in Hy. apply proj1_sig in H. apply H.", "succ": true}]