[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p v.", "split.", "-", "intros H."], "tactic": "destruct (le_lt_dec n p) as [H1 | H1].", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : s (rx p) v The term \"p\" has type \"pos n\" while it is expected to have type \"eill_vars\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H."], "tactic": "destruct (le_lt_dec (2 * n) p) as [H2 | H2].", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : s (rx p) v The term \"p\" has type \"pos n\" while it is expected to have type \"eill_vars\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H."], "tactic": "apply H_s_q.", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : s (rx p) v H0 : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v -> P // (i, v) ->> (k, vec_zero) Unable to unify \"exists k0 : eill_vars, P // (?M1469, ?M1470) -[k0]-> (k, vec_zero)\" with \"v = vec_one p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H."], "tactic": "apply H.", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : s (rx p) v Unable to unify \"s (rx p) v\" with \"v = vec_one p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "apply vec_pos_ext.", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : v = vec_one p Unable to unify \"?M1452 = ?M1453\" with \"match le_lt_dec n (rx p) with | left H1 => match le_lt_dec (2 * n) (rx p) with | left _ => P // (rx p - 2 * n, v) ->> (k, vec_zero) | right H2 => vec_pos v (nat2pos (s_subproof H1 H2)) = 0 end | right H1 => v = vec_one (nat2pos H1) end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "intros q.", "exn": "q is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "intros q'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "destruct (le_lt_dec n q) as [H1 | H1].", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : v = vec_one p The term \"q\" has type \"eill_vars -> eill_vars\" while it is expected to have type \"eill_vars\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros p v.", "split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "destruct (le_lt_dec (2 * n) q) as [H2 | H2].", "exn": "In environment n : eill_vars q := fun i : eill_vars => 2 * n + i : eill_vars -> eill_vars rx := fun p : pos n => pos2nat p : pos n -> eill_vars ry := fun p : pos n => n + pos2nat p : pos n -> eill_vars H_rx : forall p q : pos n, rx p = rx q -> p = q P : eill_vars * list (mm_instr (pos n)) k : eill_vars Hk : out_code k P H_s_q : forall (i : eill_vars) (v : vec eill_vars n), s (q i) v <-> P // (i, v) ->> (k, vec_zero) p : pos n v : vec eill_vars n H : v = vec_one p The term \"q\" has type \"eill_vars -> eill_vars\" while it is expected to have type \"eill_vars\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros p v. split. - intros H. destruct (le_lt_dec n p) as [H1 | H1]. + destruct (le_lt_dec (2 * n) p) as [H2 | H2]. * apply H_s_q. apply H. * destruct (nat2pos_not_double n p H1 H2). + apply vec_one_spec_eq. apply nat2pos_injective. apply H1. - intros H. apply vec_pos_ext. intros q. destruct (le_lt_dec n q) as [H1 | H1]. + destruct (le_lt_dec (2 * n) q) as [H2 | H2]. * exfalso. apply (pos2nat_inj n _ _ (s_subproof H1 H2) H). * apply H. + apply vec_one_spec_neq. apply nat2pos_not_injective. apply H1.", "succ": false}]