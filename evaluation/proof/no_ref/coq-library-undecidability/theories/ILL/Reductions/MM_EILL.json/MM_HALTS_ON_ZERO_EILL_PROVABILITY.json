[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros f.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold \"\u2aaf\"."], "tactic": "exists (fun P => exists n s, P = (n, s) /\\ MM_HALTS_ON_ZERO P <-> EILL_PROVABILITY (f P)).", "exn": "In environment f := fun H : MM_PROBLEM => let (n, s) := H in let (P, v) := s in (\u03a3 (1, P) 0, vec_map_list v (fun p : pos n => pos2nat p), 2 * n + 1) : MM_PROBLEM -> EILL_SEQUENT P : ?A * ?B n : ?A0 s : ?A1 The term \"P\" has type \"(?A * ?B)%type\" while it is expected to have type \"MM_PROBLEM\".", "type": "wrong_type", "handled": true}, {"ctx": ["unfold \"\u2aaf\"."], "tactic": "intros P.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold \"\u2aaf\"."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["unfold \"\u2aaf\"."], "tactic": "intros [n [s [HP HMM]]].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold \"\u2aaf\".", "unfold MM_HALTS_ON_ZERO, EILL_PROVABILITY in *."], "tactic": "subst P.", "exn": "No such hypothesis: P", "type": "no_hypos", "handled": true}, {"ctx": ["unfold \"\u2aaf\".", "unfold MM_HALTS_ON_ZERO, EILL_PROVABILITY in *."], "tactic": "split; intros H.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["unfold \"\u2aaf\".", "unfold MM_HALTS_ON_ZERO, EILL_PROVABILITY in *."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros f. unfold \"\u2aaf\". exists (fun P => exists n s, P = (n, s) /\\ MM_HALTS_ON_ZERO P <-> EILL_PROVABILITY (f P)). intros P. split. - intros [n [s [HP HMM]]]. unfold MM_HALTS_ON_ZERO, EILL_PROVABILITY in *. subst P. split; intros H. + left. exists (1, fst s, 0, snd s). apply H. + right. exists (1, fst s, 0, snd s). apply H. - intros [H | H]. + destruct H as [n [s [HP HMS]]]. unfold MM_HALTS_ON_ZERO, EILL_PROVABILITY in *. subst P. split; intros H; inversion H. + destruct H as [n [s [HP H]]]. unfold MM_HALTS_ON_ZERO, EILL_PROVABILITY in *. subst P. split; intros H; inversion H.", "succ": false}]