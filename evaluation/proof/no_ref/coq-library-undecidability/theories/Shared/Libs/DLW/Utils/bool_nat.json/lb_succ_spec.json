[{"history": {"proof": "hauto use: lb_succ_spec_0, lb_nat_fix_0, Nat.add_1_l, lb_succ_spec_1, nat2bool2nat unfold: bool2nat, add inv: bool.", "repairs": ["hammer"], "exceptions": [{"ctx": ["unfold lb_succ.", "simpl."], "tactic": "rewrite lb_succ_spec_1.", "exn": "Found no subterm matching \"\u27e6 lb_succ \u27d9 ?M1514 \u27e7\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold lb_succ.", "simpl."], "tactic": "rewrite lb_nat_fix_3.", "exn": "Found no subterm matching \"\u27e6 ?M1514 :: ?M1515 \u27e7\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold lb_succ.", "simpl."], "tactic": "rewrite <- plus_n_Sm.", "exn": "Found no subterm matching \"?M1514 + S ?M1515\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold lb_succ.", "simpl."], "tactic": "reflexivity.", "exn": "In environment a : bool l : lb Unable to unify \"bool2nat a + \u27e6 l \u27e7\" with \"\u27e6 (fix lb_succ (a : bool) (l : lb) {struct l} : lb := match l with | nil => a :: nil | x :: l0 => let (r, z) := if a then if x then (\u27d9, \u27d8) else (\u27d8, \u27d9) else if x then (\u27d8, \u27d9) else (\u27d8, \u27d8) in z :: lb_succ r l0 end) a l \u27e7\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. unfold lb_succ. simpl. rewrite lb_succ_spec_1. rewrite lb_nat_fix_3. rewrite <- plus_n_Sm. reflexivity.", "succ": true}]