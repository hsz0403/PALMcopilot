[{"history": {"proof": "intros. unfold is_gcd. split. - sfirstorder depth: 3. - split. + strivial use: divides_minus unfold: is_gcd. + intros k Hdivkp Hdivkq. hauto drew: off use: le_plus_minus, divides_plus unfold: is_gcd.", "repairs": ["no_product", "", "", "", "hammer", "", "", "", "hammer", "", "", "hammer"], "exceptions": [{"ctx": [], "tactic": "intros p q Hle Hgcd.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros p' q Hle Hgcd.", "exn": "q is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros p' q' Hle Hgcd.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "unfold is_gcd in Hgcd.", "exn": "No such hypothesis: Hgcd", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold is_gcd.", "split.", "-"], "tactic": "apply Nat.le_trans with (n:=p).", "exn": "In environment p, q, r : nat H : p <= q H0 : is_gcd p q r Unable to unify \"p <= ?M1428\" with \"exists p0 : nat, p = p0 * r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold is_gcd.", "split.", "-"], "tactic": "apply Nat.sub_le_mono_r with (n:=q) (m:=p) (p:=p).", "exn": "In environment p, q, r : nat H : p <= q H0 : is_gcd p q r Unable to unify \"q - p <= p - p\" with \"r div p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold is_gcd.", "split.", "-"], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold is_gcd.", "split.", "-", "shelve.", "-", "split.", "+"], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "unfold is_gcd.", "split.", "-", "shelve.", "-", "split.", "+"], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros p q Hle Hgcd. unfold is_gcd in Hgcd. unfold is_gcd. split. - apply Nat.le_trans with (n:=p). + apply Nat.sub_le_mono_r with (n:=q) (m:=p) (p:=p). apply Hle. + apply Nat.le_sub_le_add_l. * apply Nat.le_trans with (n:=q). -- apply Nat.le_trans with (n:=q-p). ++ apply Nat.le_add_le_sub_r. apply Hle. ++ rewrite Nat.add_sub_assoc. apply Nat.le_sub_le_add_l. apply Nat.le_add_le_sub_r. apply Nat.le_trans with (n:=q). apply Hle. apply Nat.le_refl. -- apply Nat.le_refl. - split. + split. * destruct Hgcd as [Hdivp [Hdivq _]]. rewrite <- Nat.sub_le_mono_r with (n:=p) (m:=q) (p:=p). apply Hle. apply Hdivp. * destruct Hgcd as [Hdivp [Hdivq Hdivr]]. destruct Hdivr as [k Hdivrk]. intros k' Hdivkp Hdivk'q. apply Hdivr. -- apply Nat.le_trans with (n:=q). ++ apply Nat.le_add_le_sub_r. apply Hle. ++ apply Hdivq. -- apply Hdivrk. apply Hdivkp. apply Hdivk'q. + intros k Hdivkp Hdivkq. apply Hgcd. split. * apply Nat.sub_le_mono_r with (n:=p) (m:=q) (p:=p). apply Hle. apply Hdivkp. * apply Hdivkq.", "succ": true}]