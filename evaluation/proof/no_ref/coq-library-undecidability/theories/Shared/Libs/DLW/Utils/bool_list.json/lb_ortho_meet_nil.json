[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros x y.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros x' y.", "exn": "y is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros x' y'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H."], "tactic": "apply lb_ortho_iff in H; destruct H as [_ H].", "exn": "Unable to apply lemma of type \"forall x y : lb, x \u2242 y -> forall x0 y0 : lb, x0 \u2242 y0 -> x \u27c2 x0 <-> y \u27c2 y0\" on hypothesis of type \"x \u27c2 y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "intros H."], "tactic": "apply lb_meet_eq in H.", "exn": "Unable to apply lemma of type \"forall x y : lb, x \u2242 y -> forall x0 y0 : lb, x0 \u2242 y0 -> x \u2193 x0 \u2242 y \u2193 y0\" on hypothesis of type \"x \u27c2 y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "intros H."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "apply lb_meet_eq_Proper.", "exn": "In environment x, y : lb H : x \u2193 y \u2242 nil H0 : forall x y : lb, x \u2242 y -> forall x0 y0 : lb, x0 \u2242 y0 -> x \u2193 x0 \u2aaf y \u2193 y0 Unable to unify \"?M1459 \u2193 ?M1462 \u2aaf ?M1460 \u2193 ?M1463\" with \"x \u27c2 y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "apply lb_ortho_iff_Proper.", "exn": "Unable to find an instance for the variables x, x.", "type": "no_instance_var", "handled": true}, {"ctx": ["split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "apply lb_ortho_anti; auto.", "exn": "Unable to find an instance for the variables b, y.", "type": "no_instance_var", "handled": true}, {"ctx": ["split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "split; auto.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "apply lb_meet_left.", "exn": "In environment x, y : lb H : x \u2193 y \u2242 nil H0 : forall x : lb, x \u2193 nil \u2aaf nil Unable to unify \"?M1441 \u2193 nil \u2aaf nil\" with \"x \u27c2 y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros H.", "shelve.", "-", "intros H."], "tactic": "apply lb_meet_right.", "exn": "In environment x, y : lb H : x \u2193 y \u2242 nil H0 : forall x : lb, nil \u2193 x \u2aaf nil Unable to unify \"nil \u2193 ?M1441 \u2aaf nil\" with \"x \u27c2 y\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros x y. split. - intros H. apply lb_ortho_iff in H; destruct H as [_ H]. apply lb_meet_eq in H. rewrite H. reflexivity. - intros H. apply lb_meet_eq_Proper. apply lb_ortho_iff_Proper. + apply lb_ortho_anti; auto. + split; auto. + apply lb_meet_left. + apply lb_meet_right.", "succ": false}]