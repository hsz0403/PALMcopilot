[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["pose (k := msum nat_join 0 n (fun i : nat => msum nat_join 0 i (fun j : nat => f i))).", "exists k.", "pose (g := (fun i : nat => msum nat_join 0 i (fun j : nat => f i))).", "exists g."], "tactic": "pose (h := (fun i : nat => nat_double_joins_binary_le n (msum nat_join 0 n (fun i0 : nat => f i0)) (fun i => msum nat_join 0 i (fun j : nat => f i)) g i)).", "exn": "In environment m, n : nat f : nat -> nat k := msum nat_join 0 n (fun i : nat => msum nat_join 0 i (fun _ : nat => f i)) : nat H : m \u2272 msum nat_join 0 n f g := fun i : nat => msum nat_join 0 i (fun _ : nat => f i) : nat -> nat i : nat The term \"n\" has type \"nat\" while it is expected to have type \"nat -> nat -> nat\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "pose (k := msum nat_join 0 n (fun i : nat => msum nat_join 0 i (fun j : nat => f i))). exists k. pose (g := (fun i : nat => msum nat_join 0 i (fun j : nat => f i))). exists g. pose (h := (fun i : nat => nat_double_joins_binary_le n (msum nat_join 0 n (fun i0 : nat => f i0)) (fun i => msum nat_join 0 i (fun j : nat => f i)) g i)). exists h. split. * unfold k. unfold g. unfold h. rewrite <- nat_msum_of_unit. reflexivity. * split. ++ apply nat_double_joins_binary_le_right. exists n. split. apply Nat.le_refl. intros i j. apply nat_power_decomp_lt. ++ split. +++ intros i H. apply nat_joins_binary_le_left. apply H. +++ split. ++++ intros i j H. apply nat_power_decomp_is_digit. -- apply H. -- intros. apply nat_power_decomp_lt. ++++ apply nat_power_decomp_unique. reflexivity.", "succ": false}]