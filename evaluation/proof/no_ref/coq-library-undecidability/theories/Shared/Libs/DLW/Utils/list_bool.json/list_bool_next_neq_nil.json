[{"history": {"proof": "intros H. destruct (list_bool_next_def l) as [l' H1]. hfcrush use: list_bool_succ_neq_nil, list_bool_next_spec.", "repairs": ["", "", "hammer"], "exceptions": [{"ctx": ["intros H."], "tactic": "intros H0.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros H."], "tactic": "unfold list_bool_next in H0.", "exn": "No such hypothesis: H0", "type": "no_hypos", "handled": true}, {"ctx": ["intros H.", "destruct (list_bool_next_def l) as [l' H1]."], "tactic": "unfold list_bool_succ in H1.", "exn": "Cannot turn inductive list_bool_succ into an evaluable reference.", "type": "cannot_turn_ind", "handled": true}, {"ctx": ["intros H.", "destruct (list_bool_next_def l) as [l' H1]."], "tactic": "apply list_bool_succ_neq_nil in H1.", "exn": "Unable to apply lemma of type \"forall l : list bool, ~ list_bool_succ l nil\" on hypothesis of type \"list_bool_succ l l'\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros H. unfold not. intros H0. unfold list_bool_next in H0. destruct (list_bool_next_def l) as [l' H1]. unfold list_bool_succ in H1. apply list_bool_succ_neq_nil in H1. apply H0. rewrite H1. reflexivity.", "succ": true}]