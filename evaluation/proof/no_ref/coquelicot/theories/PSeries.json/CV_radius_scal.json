[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros c a not_zero_c.", "exn": "c is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros c' a not_zero_c.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros c' a' not_zero_c.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal."], "tactic": "rewrite PSeries_scal.", "exn": "The LHS of PSeries_scal (PSeries (PS_scal _ _) _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal."], "tactic": "rewrite Series_scal_l.", "exn": "The LHS of Series_scal_l (Series (fun n : nat => _ * _ n)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n)))."], "tactic": "rewrite Rabs_div.", "exn": "The LHS of Rabs_div (Rabs (_ / _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n)))."], "tactic": "rewrite <- Rabs_Ropp.", "exn": "Found no subterm matching \"Rabs ?M2376\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n)))."], "tactic": "rewrite Rabs_Rabsolu.", "exn": "The LHS of Rabs_Rabsolu (Rabs (Rabs _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_radius, Lub_Rbar.", "apply CV_radius_ext.", "intros n.", "unfold PS_scal.", "replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))).", "symmetry."], "tactic": "apply Rmult_integral_contrapositive_currified.", "exn": "In environment c : R a : nat -> R H : c <> 0 n : nat Unable to unify \"?M2380 * ?M2381 = 0 -> False\" with \"a n = scal c (a n)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros c a not_zero_c. unfold CV_radius, Lub_Rbar. apply CV_radius_ext. intros n. unfold PS_scal. rewrite PSeries_scal. rewrite Series_scal_l. unfold Rdiv. replace (/ c * (Series a)) with (Series (fun n => (/ c * a n))). rewrite Rabs_div. rewrite <- Rabs_Ropp. rewrite Rabs_Rabsolu. symmetry. apply Rmult_integral_contrapositive_currified. apply not_zero_c. apply pow_nonzero. apply not_zero_c. apply CV_radius_finite_DAlembert. intros n. apply pow_nonzero. apply not_zero_c. apply is_lim_seq_mult. apply is_lim_seq_const. apply ex_series_lim_0. apply ex_series_le with (b := fun n => Rabs (a n)). intros n. rewrite Rabs_right. - apply Rle_ge. apply Rlt_le. apply Rlt_div_l. + apply Rabs_pos_lt. apply not_zero_c. + apply Rlt_div_r. * apply Rabs_pos_lt. apply not_zero_c. * apply is_lim_seq_const. - apply Rabs_pos_lt. apply not_zero_c.", "succ": false}]