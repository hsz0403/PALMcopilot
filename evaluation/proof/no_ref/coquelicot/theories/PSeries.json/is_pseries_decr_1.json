[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "intros H1 H2.", "unfold is_pseries, PS_decr_1."], "tactic": "intros H3 H4.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "intros H1 H2.", "unfold is_pseries, PS_decr_1."], "tactic": "apply is_pseries_ext.", "exn": "In environment K : AbsRing V : NormedModule K a : nat -> V x, y : K l : V H : mult y x = one H0 : is_pseries a x l H1 : V -> Prop H2 : locally (scal y (plus l (opp (a 0%nat)))) H1 Unable to unify \"forall P : ?V -> Prop, locally ?M2366 P -> filtermap (sum_n (fun k : nat => scal (pow_n ?M2365 k) (?M2364 k))) eventually P\" with \"exists N : nat, forall n : nat, (N <= n)%nat -> (fun x0 : nat => H1 (sum_n (fun k : nat => scal (pow_n x k) (a (S k))) x0)) n\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "intros H1 H2.", "unfold is_pseries, PS_decr_1."], "tactic": "intros n.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros. intros H1 H2. unfold is_pseries, PS_decr_1. intros H3 H4. apply is_pseries_ext. - intros n. unfold PS_decr_1. reflexivity. - apply is_pseries_incr_1 in H4. apply is_pseries_plus with (a0 := PS_incr_1 a) (b := PS_neg_const (a 0%nat)) in H4. apply is_pseries_scal with (c := y) in H4. rewrite <- scal_opp_r in H4. unfold PS_neg_const in H4. rewrite <- H1 in H4. apply H4.", "succ": false}]