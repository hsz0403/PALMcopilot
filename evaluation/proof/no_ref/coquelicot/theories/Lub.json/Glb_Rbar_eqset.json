[{"history": {"proof": "intros H. unfold Glb_Rbar. unfold proj1_sig. assert (E1' := fun y : R => E1 y). qauto use: is_lb_Rbar_subset, Rbar_le_antisym unfold: is_glb_Rbar, is_lb_Rbar inv: sig.", "repairs": ["", "", "", "", "hammer"], "exceptions": [{"ctx": ["intros H.", "unfold Glb_Rbar.", "unfold proj1_sig."], "tactic": "apply PropExtensionalityFacts.PredExt_imp_PropExt.", "exn": "In environment E1, E2 : R -> Prop H : forall x : R, E1 x <-> E2 x Unable to unify \"?M2284 = ?M2285\" with \"(let (a, _) := ex_glb_Rbar E1 in a) = (let (a, _) := ex_glb_Rbar E2 in a)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H.", "unfold Glb_Rbar.", "unfold proj1_sig."], "tactic": "intros x.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros H. unfold Glb_Rbar. unfold proj1_sig. apply PropExtensionalityFacts.PredExt_imp_PropExt. intros x. assert (E1' := fun y : R => E1 y). assert (E2' := fun y : R => E2 y). specialize (H x). apply H. split. - intros H1 y. unfold E1'. apply H1. - intros H1 y. unfold E2'. apply H1.", "succ": true}]