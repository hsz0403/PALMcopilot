[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le."], "tactic": "rewrite foldr_rcons.", "exn": "The LHS of foldr_rcons (foldr _ _ (rcons _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le."], "tactic": "rewrite pairmap_rcons.", "exn": "The LHS of pairmap_rcons (pairmap _ _ (rcons (rcons _ _) _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le."], "tactic": "rewrite Riemann_sum_rcons.", "exn": "The LHS of Riemann_sum_rcons (Riemann_sum _ (SF_rcons _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le."], "tactic": "unfold SF_map_sort.", "exn": "Cannot coerce SF_map_sort to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le.", "unfold SF_map.", "simpl."], "tactic": "rewrite scal_zero_l.", "exn": "The LHS of scal_zero_l (scal zero _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le.", "unfold SF_map.", "simpl."], "tactic": "rewrite plus_zero_r.", "exn": "The LHS of plus_zero_r (plus _ zero) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Riemann_sum.", "unfold SF_compat_le.", "unfold SF_map.", "simpl."], "tactic": "reflexivity.", "exn": "In environment f : R -> R_ModuleSpace s : SF_seq pr : SF_sorted Rle s Unable to unify \"RiemannInt_SF {| fe := SF_fun {| SF_h := SF_h s; SF_t := [seq (fst x, f (snd x)) | x <- SF_t s] |} 0; pre := existT (fun l : Rlist => is_subdivision (SF_fun {| SF_h := SF_h s; SF_t := [seq (fst x, f (snd x)) | x <- SF_t s] |} 0) (SF_h s) (last (SF_h s) (unzip1 [seq (fst x, f (snd x)) | x <- SF_t s])) l) (cons (SF_h s) (seq2Rlist (unzip1 [seq (fst x, f (snd x)) | x <- SF_t s]))) (existT (fun l0 : Rlist => adapted_couple (SF_fun {| SF_h := SF_h s; SF_t := [seq (fst x, f (snd x)) | x <- SF_t s] |} 0) (SF_h s) (last (SF_h s) (unzip1 [seq (fst x, f (snd x)) | x <- SF_t s])) (cons (SF_h s) (seq2Rlist (unzip1 [seq (fst x, f (snd x)) | x <- SF_t s]))) l0) (seq2Rlist (SF_ly {| SF_h := SF_h s; SF_t := [seq (fst x, f (snd x)) | x <- SF_t s] |})) (ad_SF_compat 0 {| SF_h := SF_h s; SF_t := [seq (fst x, f (snd x)) | x <- SF_t s] |} (SF_map_sort f s Rle pr))) |}\" with \"foldr plus zero (pairmap (fun x y : R * R => scal (fst y - fst x) (f (snd y))) (SF_h s, zero) (SF_t s))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold Riemann_sum. unfold SF_compat_le. rewrite foldr_rcons. rewrite pairmap_rcons. rewrite Riemann_sum_rcons. unfold SF_map_sort. unfold SF_map. unfold SF_sorted. unfold sorted. simpl. rewrite scal_zero_l. rewrite plus_zero_r. reflexivity.", "succ": false}]