[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold SF_rev, SF_rcons, SF_cons."], "tactic": "rewrite SF_seq_bij.", "exn": "The LHS of SF_seq_bij (SF_make (SF_lx _) (SF_ly _) (SF_size_lx_ly _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold SF_rev, SF_rcons, SF_cons."], "tactic": ["rewrite SF_lx_cons.", ""], "exn": "Dependent type error in rewrite of (fun _pattern_value_ : seq R => SF_make (rev _pattern_value_) (rev (SF_ly {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})) (SF_rev_0 {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |}) = {| SF_h := SF_h (SF_make (rev (SF_lx s)) (rev (SF_ly s)) (SF_rev_0 s)); SF_t := rcons (SF_t (SF_make (rev (SF_lx s)) (rev (SF_ly s)) (SF_rev_0 s))) h |}) Type error was: Illegal application: The term \"SF_make\" of type \"forall (lx : seq R) (ly : seq T), size lx = S (size ly) -> SF_seq\" cannot be applied to the terms \"rev _pattern_value_\" : \"seq R\" \"rev (SF_ly {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})\" : \"seq T\" \"SF_rev_0 {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |}\" : \"size (rev (SF_lx {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})) = S (size (rev (SF_ly {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})))\" The 3rd term has type \"size (rev (SF_lx {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})) = S (size (rev (SF_ly {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})))\" which should be coercible to \"size (rev _pattern_value_) = S (size (rev (SF_ly {| SF_h := fst h; SF_t := (SF_h s, snd h) :: SF_t s |})))\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "unfold SF_rev, SF_rcons, SF_cons. rewrite SF_seq_bij. rewrite SF_lx_cons. rewrite SF_ly_cons. rewrite SF_size_cons. reflexivity.", "succ": false}]