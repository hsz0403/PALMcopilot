[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros f x b a H.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' x b a H.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' x' b a H.", "exn": "b is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' x' b' a H.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' x' b' a' H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold Rmin, Rmax in H.", "destruct H as [H1 H2]."], "tactic": "apply Rbar_le.", "exn": "In environment f : R -> R a, b, x : R H1 : (if Rle_dec a b then a else b) < x H2 : x < (if Rle_dec a b then b else a) Unable to unify \"Prop\" with \"Rbar_le (f x) (Sup_fct f a b)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Rmin, Rmax in H.", "destruct H as [H1 H2]."], "tactic": "apply completeness.", "exn": "In environment f : R -> R a, b, x : R H1 : (if Rle_dec a b then a else b) < x H2 : x < (if Rle_dec a b then b else a) Unable to unify \"{m : R | is_lub ?M2372 m}\" with \"match Sup_fct f a b with | Finite y => f x <= y | p_infty => True | m_infty => False end\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Rmin, Rmax in H.", "destruct H as [H1 H2]."], "tactic": "exists (Sup_fct f a b).", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "unfold Rmin, Rmax in H.", "destruct H as [H1 H2].", "unfold is_ub_Rbar, Rbar_le."], "tactic": "intros y Hy.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros f x b a H. unfold Rmin, Rmax in H. destruct H as [H1 H2]. apply Rbar_le. apply completeness. - unfold bound. exists (Sup_fct f a b). unfold is_ub_Rbar, Rbar_le. intros y Hy. destruct Hy as [z [Hz1 Hz2]]. exists z. split. + destruct Hz2 as [x0 [Hx Hx']]. exists x0. split. * auto. * split; auto. + intros z' Hz'. apply sup_spec. exists z'. split; auto. - exists x. unfold Rmin, Rmax in H1, H2. split; lra. - exists (f x), (Sup_fct f a b). intros e. specialize (Riemann_integrable_bound f a b). intros [s Hs]. specialize (Hs e). destruct Hs as [s' Hs']. exists s'. intros y Hy. apply Hs'. apply Rabs_bound_between_sup. auto.", "succ": false}]