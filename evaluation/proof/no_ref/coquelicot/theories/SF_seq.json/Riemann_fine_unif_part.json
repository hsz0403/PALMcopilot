[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-"], "tactic": "rewrite seq_step_unif_part.", "exn": "The LHS of seq_step_unif_part (seq_step (unif_part _ _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-"], "tactic": "apply Rabs_pos.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b Unable to unify \"0 < Rabs ?M2367 \\\\/ 0 = Rabs ?M2367\" with \"foldr Rmax 0 (pairmap (fun x y : R => Rabs (y - x)) (head 0 (SF_lx {| SF_h := head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) (behead (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) |})) (behead (SF_lx {| SF_h := head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) (behead (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) |}))) < (b - a) / (INR n + 1) \\\\/ foldr Rmax 0 (pairmap (fun x y : R => Rabs (y - x)) (head 0 (SF_lx {| SF_h := head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) (behead (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) |})) (behead (SF_lx {| SF_h := head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0 (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) (behead (mkseq (fun i : nat => a + INR i * (b - a) / (INR n + 1)) (S (S n)))) |}))) = (b - a) / (INR n + 1)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl."], "tactic": "rewrite size_mkseq in Hi.", "exn": "The LHS of size_mkseq (size (mkseq _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl."], "tactic": "rewrite nth_mkseq.", "exn": "The LHS of nth_mkseq (nth _ (mkseq _ _) _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*"], "tactic": "apply Rle_div_l.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b i : nat Hi : (i < SF_size {| SF_h := head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) (behead (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) |})%nat Unable to unify \"(?M2381 / ?M2383 <= ?M2382 -> ?M2381 <= ?M2382 * ?M2383) /\\\\ (?M2381 <= ?M2382 * ?M2383 -> ?M2381 / ?M2383 <= ?M2382)\" with \"nth 0 (SF_lx {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i <= nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i <= nth 0 (a + 1 * (b - a) / (INR n + 1) :: unzip1 (pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*"], "tactic": "apply pos_INR.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b i : nat Hi : (i < SF_size {| SF_h := head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) (behead (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) |})%nat Unable to unify \"0 < INR ?M2381 \\\\/ 0 = INR ?M2381\" with \"nth 0 (SF_lx {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i <= nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i <= nth 0 (a + 1 * (b - a) / (INR n + 1) :: unzip1 (pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0."], "tactic": "apply tech1.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b i : nat Hi : (i < SF_size {| SF_h := head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) (behead (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) |})%nat Unable to unify \"0 < sum_f_R0 ?M2392 ?M2393\" with \"0 < nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i - nth 0 (SF_lx {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i \\\\/ 0 = nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i - nth 0 (SF_lx {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0."], "tactic": "intros j Hj.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0."], "tactic": "apply pos_INR.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b i : nat Hi : (i < SF_size {| SF_h := head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) (behead (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) |})%nat Unable to unify \"0 < INR ?M2392 \\\\/ 0 = INR ?M2392\" with \"0 < nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i - nth 0 (SF_lx {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i \\\\/ 0 = nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i - nth 0 (SF_lx {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0.", "shelve.", "--", "replace (a + INR i * (b - a) / (INR n + 1) / INR n + 1) with (a + INR i * (b - a) / (INR n + 1) + (b - a) / (INR n + 1)).", "++"], "tactic": "apply Rlt_div_r.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b i : nat Hi : (i < SF_size {| SF_h := head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) (behead (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) |})%nat Unable to unify \"(?M2402 * ?M2404 < ?M2403 -> ?M2402 < ?M2403 / ?M2404) /\\\\ (?M2402 < ?M2403 / ?M2404 -> ?M2402 * ?M2404 < ?M2403)\" with \"nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i < nth 0 (a + 1 * (b - a) / (INR n + 1) :: unzip1 (pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) i \\\\/ nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i = nth 0 (a + 1 * (b - a) / (INR n + 1) :: unzip1 (pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0.", "shelve.", "--", "replace (a + INR i * (b - a) / (INR n + 1) / INR n + 1) with (a + INR i * (b - a) / (INR n + 1) + (b - a) / (INR n + 1)).", "++"], "tactic": "apply pos_INR.", "exn": "In environment f : R -> R -> R a, b : R n : nat Hmonotone : forall a b : R, a <= b -> a <= f a b <= b Hab : a <= b i : nat Hi : (i < SF_size {| SF_h := head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n))); SF_t := pairmap (fun x y : R => (y, f x y)) (head 0%R (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) (behead (mkseq (fun i : nat => (a + INR i * (b - a) / (INR n + 1))%R) (S (S n)))) |})%nat Unable to unify \"0 < INR ?M2402 \\\\/ 0 = INR ?M2402\" with \"nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i < nth 0 (a + 1 * (b - a) / (INR n + 1) :: unzip1 (pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) i \\\\/ nth 0 (SF_ly {| SF_h := a + 0 * (b - a) / (INR n + 1); SF_t := (a + 1 * (b - a) / (INR n + 1), f (a + 0 * (b - a) / (INR n + 1)) (a + 1 * (b - a) / (INR n + 1))) :: pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n] |}) i = nth 0 (a + 1 * (b - a) / (INR n + 1) :: unzip1 (pairmap (fun x y : R => (y, f x y)) (a + 1 * (b - a) / (INR n + 1)) [seq a + INR i * (b - a) / (INR n + 1) | i <- seq.iota 2 n])) i\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b n Hmonotone Hab.", "unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part.", "split.", "-", "shelve.", "-", "split.", "+", "intros i Hi.", "simpl.", "replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)).", "*", "split.", "--", "apply Rminus_le_0.", "shelve.", "--", "replace (a + INR i * (b - a) / (INR n + 1) / INR n + 1) with (a + INR i * (b - a) / (INR n + 1) + (b - a) / (INR n + 1)).", "++"], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros f a b n Hmonotone Hab. unfold seq_step, pointed_subdiv, SF_h, SF_seq_f2, unif_part. split. - rewrite seq_step_unif_part. apply Rabs_pos. - split. + intros i Hi. simpl. rewrite size_mkseq in Hi. rewrite nth_mkseq. replace (nth 0 (mkseq (fun i0 : nat => a + INR i0 * (b - a) / (INR n + 1)) (S (S n))) i) with (a + INR i * (b - a) / (INR n + 1)). * apply Rle_div_l. apply pos_INR. split. -- apply Rminus_le_0. split. apply tech1. intros j Hj. apply pos_INR. -- replace (a + INR i * (b - a) / (INR n + 1) / INR n + 1) with (a + INR i * (b - a) / (INR n + 1) + (b - a) / (INR n + 1)). ++ apply Rlt_div_r. apply pos_INR. split. +++", "succ": false}]