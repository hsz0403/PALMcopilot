[{"history": {"proof": "qauto depth: 4 l: on use: Nat.lt_0_succ, @SF_lx_f2 unfold: SF_lx, unzip1, SF_sorted, pairmap, sorted, map, SF_seq_f2, SF_t, size, behead.", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros T f2 P Ord.", "exn": "T is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2 P Ord.", "exn": "f2 is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2' P Ord.", "exn": "P is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2' P' Ord.", "exn": "Ord is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros T' f2' P' Ord'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted."], "tactic": "destruct H as [H1 H2].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "simpl.", "destruct P.", "*", "trivial.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "simpl.", "destruct P.", "*", "trivial.", "*", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "simpl.", "destruct P.", "*", "trivial.", "*", "shelve.", "-"], "tactic": "inversion Hi.", "exn": "No such hypothesis: Hi", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "simpl.", "destruct P.", "*", "trivial.", "*", "shelve.", "-"], "tactic": "simpl in Hi.", "exn": "No such hypothesis: Hi", "type": "no_hypos", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "simpl.", "destruct P.", "*", "trivial.", "*", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros H.", "unfold SF_sorted, sorted.", "simpl.", "destruct P.", "*", "trivial.", "*", "shelve.", "-", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros T f2 P Ord. split. - intros H. unfold SF_sorted, sorted. destruct H as [H1 H2]. split. + simpl. destruct P. * trivial. * apply H1. + intros i Hi x. apply H2. destruct P as [|h [|h' t]]. * inversion Hi. * simpl in Hi. destruct t. { inversion Hi. } { apply Hi. } * simpl in Hi. apply Hi. - intros H. unfold SF_sorted, sorted in H. destruct H as [H1 H2]. split. + simpl in H1. destruct P. * trivial. * split. { apply H1. } { apply sorted_nth. - apply H2. - intros i Hi x. destruct P as [|h [|h' t]]. + inversion Hi. + simpl in Hi. destruct t. * inversion Hi. * apply Hi. + simpl in Hi. apply Hi. } + intros i Hi x. apply H2. destruct P as [|h [|h' t]]. * inversion Hi. * simpl in Hi. destruct t. { inversion Hi. } { apply Hi. } * simpl in Hi. apply Hi.", "succ": true}]