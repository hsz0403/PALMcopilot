[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply Rge_not_lt in Hnlt.", "exn": "Unable to apply lemma of type \"forall r1 r2 : R, r1 >= r2 -> ~ r1 < r2\" on hypothesis of type \"~ x < y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "destruct i; [apply Hnlt|].", "exn": "In environment x, y : R t : seq R H : sorted Rle [:: x, y & t] IH : sorted Rle (y :: t) -> ordered_Rlist (seq2Rlist (y :: t)) H0 : (0 < Init.Nat.pred (Rlength (cons x (cons y (seq2Rlist t)))))%nat Hnlt : ~ x < y Unable to unify \"~ x < y\" with \"pos_Rl (cons x (cons y (seq2Rlist t))) 0 <= pos_Rl (cons x (cons y (seq2Rlist t))) 1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intro H.", "induction s as [|x [|y t] IH].", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "unfold ordered_Rlist.", "intros.", "inversion H0.", "+", "simpl.", "unfold ordered_Rlist.", "intros.", "destruct (Rlt_dec x y) as [Hlt|Hnlt].", "*", "destruct i; [inversion H0|].", "simpl in H0.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "split. - intro H. induction s as [|x [|y t] IH]. + unfold ordered_Rlist. intros. inversion H0. + unfold ordered_Rlist. intros. inversion H0. + simpl. unfold ordered_Rlist. intros. destruct (Rlt_dec x y) as [Hlt|Hnlt]. * destruct i; [inversion H0|]. simpl in H0. destruct i. { simpl. apply Rlt_le. apply Hlt. } { apply IH with (y::t); auto. } * apply Rge_not_lt in Hnlt. destruct i; [apply Hnlt|]. apply IH with (y :: t); auto. - intro H. induction s as [|x|y t] using sorted. + simpl. reflexivity. + simpl in H. unfold ordered_Rlist in H. split. * apply H. apply Nat.lt_0_succ. * apply IH. intros i Hi. apply H. apply Lt.lt_n_S. apply Hi.", "succ": false}]