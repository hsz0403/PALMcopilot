[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "unfold is_RInt_gen."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold is_RInt_gen.", "intros H'.", "unfold is_RInt_gen in H.", "apply is_RInt_gen_swap in H."], "tactic": "apply is_RInt_gen_ext with (f0 := fun y => opp (f y)) in H.", "exn": "Unable to apply lemma of type \"forall (f0 g : R -> V) (l0 : V), filter_prod ?Fa ?Fb (fun ab : R * R => forall x : R, Rmin (fst ab) (snd ab) < x < Rmax (fst ab) (snd ab) -> f0 x = g x) -> is_RInt_gen f0 ?Fa ?Fb l0 -> is_RInt_gen g ?Fa ?Fb l0\" on hypothesis of type \"is_RInt_gen f Fb Fa (opp l)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros.", "unfold is_RInt_gen.", "intros H'.", "unfold is_RInt_gen in H.", "apply is_RInt_gen_swap in H."], "tactic": ["apply H.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "intros. unfold is_RInt_gen. intros H. unfold is_RInt_gen in H. unfold is_RInt_gen. apply is_RInt_gen_swap in H. apply is_RInt_gen_ext with (f0 := fun y => opp (f y)) in H. apply H. apply filter_forall. intros. rewrite Rmin_comm. rewrite Rmax_comm. apply filter_prod_proper. intros. simpl. apply Ropp_involutive. apply H.", "succ": false}]