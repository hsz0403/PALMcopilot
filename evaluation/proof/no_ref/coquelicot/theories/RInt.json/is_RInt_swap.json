[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *."], "tactic": "unfold is_RInt_point, ex_RInt in *.", "exn": "Cannot coerce is_RInt_point to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *."], "tactic": "unfold ex_RInt_point in *.", "exn": "Cannot coerce ex_RInt_point to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *."], "tactic": "unfold Rminus_le_0, Rle_minus_l in *.", "exn": "Cannot coerce Rminus_le_0 to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp.", "intros eps.", "specialize (H eps)."], "tactic": "intros P [eps_pos P_eps].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros."], "tactic": "specialize (H (eps / 2)).", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a, b : R If : V eps : V -> Prop H : locally If eps -> filtermap (fun ptd : SF_seq => scal (sign (a - b)) (Riemann_sum f ptd)) (Riemann_fine b a) eps H0 : locally (AbelianGroup.opp V (AbelianGroup.class V) If) eps The term \"eps\" has type \"V -> Prop\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold opp.", "intros eps.", "specialize (H eps).", "intros."], "tactic": "assert (Heps2_pos : 0 < eps / 2) by lra.", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a, b : R If : V eps : V -> Prop H : locally If eps -> filtermap (fun ptd : SF_seq => scal (sign (a - b)) (Riemann_sum f ptd)) (Riemann_fine b a) eps H0 : locally (AbelianGroup.opp V (AbelianGroup.class V) If) eps The term \"eps\" has type \"V -> Prop\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros f a b If H. unfold is_RInt in *. unfold filterlim in *. unfold is_RInt_point, ex_RInt in *. unfold ex_RInt_point in *. unfold Rminus_le_0, Rle_minus_l in *. unfold opp. unfold filterlim. intros eps. specialize (H eps). intros P [eps_pos P_eps]. specialize (H (eps / 2)). assert (Heps2_pos : 0 < eps / 2) by lra. specialize (H Heps2_pos). destruct H as [delta [delta_pos H]]. exists delta. split; auto. intros c Hc. apply P_eps. apply H. auto.", "succ": false}]