[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros V f s Hsorted a b.", "exn": "V is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros V' f s Hsorted a b.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros V' f' s Hsorted a b.", "exn": "s is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros V' f' s' Hsorted a b.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_RInt."], "tactic": "apply filterlim_snd.", "exn": "In environment V : NormedModule R_AbsRing f : R -> V s : SF_seq H : SF_sorted Rle s a := SF_h s : R b := last (SF_h s) (unzip1 (SF_t s)) : R P : ?U -> Prop y : ?G P Unable to unify \"filter_prod ?F ?G (fun x : ?T * ?U => P (snd x))\" with \"exists delta : posreal, forall y : SF_seq, (fun ptd : SF_seq => seq_step (SF_lx ptd)) y < delta -> (fun x : SF_seq => (fun ptd : SF_seq => pointed_subdiv ptd /\\\\ SF_h ptd = Rmin a b /\\\\ last (SF_h ptd) (SF_lx ptd) = Rmax a b) x -> (fun x0 : SF_seq => P ((fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum (SF_fun (SF_map f s) zero) ptd)) x0)) x) y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold is_RInt.", "intros eps Heps.", "unfold Rminus."], "tactic": "rewrite Ropp_minus_distr.", "exn": "The LHS of Ropp_minus_distr (- (_ - _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold is_RInt.", "intros eps Heps.", "unfold Rminus."], "tactic": "rewrite Rabs_Ropp.", "exn": "The LHS of Rabs_Ropp (Rabs (- _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold is_RInt.", "intros eps Heps.", "unfold Rminus."], "tactic": "pose proof (Riemann_sum_Chasles_0 f (Rmin a b) (Rmax a b) s eps) as H0.", "exn": "In environment V : NormedModule R_AbsRing f : R -> V s : SF_seq H : SF_sorted Rle s a := SF_h s : R b := last (SF_h s) (unzip1 (SF_t s)) : R eps : V -> Prop Heps : locally (Riemann_sum f s) eps The term \"eps\" has type \"V -> Prop\" while it is expected to have type \"posreal\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "unfold is_RInt.", "intros eps Heps.", "unfold Rminus."], "tactic": "assert (H1: SF_h s <= Rmin a b <= Rmax a b <= last (SF_h s) (unzip1 (SF_t s))).", "exn": "In environment V : NormedModule R_AbsRing f : R -> V s : SF_seq H : SF_sorted Rle s a := SF_h s : R b := last (SF_h s) (unzip1 (SF_t s)) : R eps : V -> Prop Heps : locally (Riemann_sum f s) eps The term \"SF_h s <= Rmin a b <= Rmax a b\" has type \"Prop\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "unfold is_RInt.", "intros eps Heps.", "unfold Rminus."], "tactic": "split; try apply Rmin_l; try apply Rmin_r; try apply Rmax_l; try apply Rmax_r.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}]}, "chat": [], "original": "intros V f s Hsorted a b. unfold is_RInt. apply filterlim_snd. intros eps Heps. unfold Rminus. rewrite Ropp_minus_distr. rewrite Rabs_Ropp. pose proof (Riemann_sum_Chasles_0 f (Rmin a b) (Rmax a b) s eps) as H0. assert (H1: SF_h s <= Rmin a b <= Rmax a b <= last (SF_h s) (unzip1 (SF_t s))). { split; try apply Rmin_l; try apply Rmin_r; try apply Rmax_l; try apply Rmax_r. } apply H0; auto. clear H0. intros x Hx. apply Rabs_def2. apply Rle_trans with (Rabs (scal (sign (b - a)) (Riemann_sum f s))). apply RRle_abs. apply Heps.", "succ": false}]