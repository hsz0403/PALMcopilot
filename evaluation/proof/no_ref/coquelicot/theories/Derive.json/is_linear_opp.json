[{"history": {"proof": "split. - intros x y. srun best use: @opp_plus unfold: AbelianGroup.sort, NormedModule.AbelianGroup. - intros k x. unfold opp. hauto use: @scal_opp_r unfold: AbsRing.Ring, NormedModule.ModuleSpace, ModuleSpace.sort, opp, ModuleSpace.AbelianGroup, NormedModule.sort, ModuleSpace.class, Ring.sort, NormedModule.AbelianGroup, AbelianGroup.sort. - strivial use: Rmult_1_l, Rlt_0_1, @norm_opp unfold: Rle.", "repairs": ["", "", "", "hammer", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": [], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["split.", "-", "intros x y.", "rewrite <- linear_plus.", "unfold opp."], "tactic": "rewrite <- 2!linear_opp.", "exn": "Found no subterm matching \"opp (?M2380 ?M2381)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["split.", "-", "intros x y.", "rewrite <- linear_plus.", "unfold opp."], "tactic": "apply linear_plus.", "exn": "In environment K : AbsRing V : NormedModule K x, y : V Unable to unify \"?M2380 (plus ?M2382 ?M2383) = plus (?M2380 ?M2382) (?M2380 ?M2383)\" with \"AbelianGroup.opp V (AbelianGroup.class V) (plus x y) = AbelianGroup.opp V (AbelianGroup.class V) (plus x y)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros x y.", "rewrite <- linear_plus.", "unfold opp."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["split.", "-", "intros x y.", "rewrite <- linear_plus.", "unfold opp.", "+", "shelve.", "+", "shelve.", "-", "intros k x.", "unfold opp.", "rewrite <- linear_scal."], "tactic": "apply linear_opp.", "exn": "In environment K : AbsRing V : NormedModule K k : K x : V Unable to unify \"?M2390 (opp ?M2391) = opp (?M2390 ?M2391)\" with \"AbelianGroup.opp V (AbelianGroup.class V) (scal k x) = AbelianGroup.opp V (AbelianGroup.class V) (scal k x)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["split.", "-", "intros x y.", "rewrite <- linear_plus.", "unfold opp.", "+", "shelve.", "+", "shelve.", "-", "intros k x.", "unfold opp.", "rewrite <- linear_scal."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "unfold is_linear. intros. split. - intros x y. rewrite <- linear_plus. unfold opp. rewrite <- 2!linear_opp. apply linear_plus. - intros k x. unfold opp. rewrite <- linear_scal. apply linear_opp. - destruct (linear_norm opp) as [M [H1 H2]]. exists M. split. + apply H1. + intros x. rewrite <- linear_norm. apply H2.", "succ": true}]