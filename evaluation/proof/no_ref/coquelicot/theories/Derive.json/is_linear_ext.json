[{"history": {"proof": "intros l_eq l1_linear. split. - intros x y. sauto lq: on depth: 3. - intros k x. sauto lq: on depth: 3. - sauto lq: on depth: 3.", "repairs": ["", "", "", "", "hammer", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros l_eq l1_linear."], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "rewrite <- (linear_plus l1 x y).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x, y : U The term \"x\" has type \"NormedModule.sort K U\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "rewrite -> (linear_plus l2 x y).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x, y : U The term \"x\" has type \"NormedModule.sort K U\" while it is expected to have type \"is_linear l2\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "apply f_equal, l_eq.", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 x, y : U Unable to unify \"plus (l2 x)\" with \"l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "rewrite <- (linear_scal l1 k x).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 k : K x : U The term \"k\" has type \"AbsRing.sort K\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "rewrite -> (linear_scal l2 k x).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 k : K x : U The term \"k\" has type \"AbsRing.sort K\" while it is expected to have type \"is_linear l2\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "apply f_equal, l_eq.", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x l1_linear : is_linear l1 k : K x : U Unable to unify \"scal k\" with \"l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "split.", "-", "intros x y.", "shelve.", "-", "intros k x."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros l_eq l1_linear. unfold is_linear. split. - intros x y. rewrite <- (linear_plus l1 x y). rewrite -> (linear_plus l2 x y). apply f_equal, l_eq. - intros k x. rewrite <- (linear_scal l1 k x). rewrite -> (linear_scal l2 k x). apply f_equal, l_eq. - destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]]. destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]. exists (Rmax M1 M2). split. + apply Rmax_case_strong; auto. + intros x. specialize (norm_bound1 x). specialize (norm_bound2 x). apply Rle_trans with (r2 := M1 * norm x). * apply norm_bound1. * apply Rmult_le_compat_r; [apply Rmax_l | apply norm_bound2].", "succ": true}]