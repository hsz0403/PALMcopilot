[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [], "original": "unfold filterdiff. intros Hd1 Hd2. destruct Hd1 as [l1 H1]. destruct Hd2 as [l2 H2]. exists (fun u => minus (l1 u) (l2 u)). intros eps Heps. specialize (H1 eps Heps). specialize (H2 eps Heps). intros x Hlim. unfold is_domin in *. specialize (H1 x Hlim). specialize (H2 x Hlim). unfold is_linear in *. destruct H1 as [H1l H1f]. destruct H2 as [H2l H2f]. split. - intros x'. assert (Haux1: is_filter_lim F x -> is_domin F (fun y : U => minus y x') (fun y : U => minus (minus (f y) (f x')) (l1 (minus y x)))). { apply H1f. } assert (Haux2: is_filter_lim F x -> is_domin F (fun y : U => minus y x') (fun y : U => minus (minus (g y) (g x')) (l2 (minus y x)))). { apply H2f. } clear -Haux1 Haux2 H1l H2l. intros Hlim'. specialize (Haux1 Hlim'). specialize (Haux2 Hlim'). rewrite minus_zero_r in Haux1. rewrite minus_zero_r in Haux2. rewrite minus_zero_r. enough (H: minus (minus (f x') (f x)) (minus (g x') (g x)) = minus (minus (f x') (g x')) (minus (f x) (g x))). { rewrite <- H. split; auto. } repeat rewrite plus_assoc. repeat rewrite opp_plus. repeat rewrite plus_assoc. repeat rewrite plus_opp_r. repeat rewrite plus_zero_r. reflexivity. - intros y Hy. specialize (H1 x Hy). specialize (H2 x Hy). unfold is_domin in H1, H2. unfold is_domin. intros z Hz. enough (H: minus (l1 z) (l1 y) = minus (l2 z) (l2 y)). { rewrite H; auto. } assert (H3: forall x y, is_filter_lim F x -> is_domin F y (fun a => minus (f a) (f x)) -> minus (f y) (f x) = minus (l1 y) (l1 x)). { intros. apply H1l; auto. } assert (H4: forall x y, is_filter_lim F x -> is_domin F y (fun a => minus (g a) (g x)) -> minus (g y) (g x) = minus (l2 y) (l2 x)). { intros. apply H2l; auto. } specialize (H3 x y Hlim' H1). specialize (H4 x y Hlim' H2). repeat rewrite <- H3. repeat rewrite <- H4. reflexivity.", "succ": false}]