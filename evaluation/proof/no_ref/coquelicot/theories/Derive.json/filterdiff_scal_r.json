[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros K V F FF k Hmult n m.", "exn": "K is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V F FF k Hmult n m.", "exn": "V is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V' F FF k Hmult n m.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-"], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx."], "tactic": "intros eps Heps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve.", "+"], "tactic": "intros x limx.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve.", "+"], "tactic": "intros eps Heps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve.", "+"], "tactic": "unfold filterlim, locally in limx.", "exn": "No such hypothesis: limx", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve.", "+", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros.", "unfold filterdiff.", "split.", "-", "split.", "+", "intros x y.", "unfold scal.", "shelve.", "+", "intros x limx.", "shelve.", "+", "shelve.", "-", "intros y Hy."], "tactic": "apply Hy.", "exn": "In environment K : AbsRing V : NormedModule K F : (V -> Prop) -> Prop FF : Filter F k : K H : forall n m : K, mult n m = mult m n y : V Hy : is_filter_lim F y Unable to unify \"is_filter_lim F y\" with \"is_domin F (fun y0 : V => minus y0 y) (fun y0 : V => minus (minus (scal k y0) (scal k y)) (scal k (minus y0 y)))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros K V F FF k Hmult n m. unfold filterdiff. split. - unfold is_linear. split. + intros x y. unfold scal. rewrite <- module_mult_comm. reflexivity. + intros x limx. unfold is_domin. intros eps Heps. unfold filterlim, locally in limx. specialize (Hmult n m) as Hmult_comm. unfold scal. specialize (limx (ball_norm x (mkposreal _ Heps))) as limx'. destruct limx' as [limx1 limx2]. apply (filter_imp (fun y : V => ball_norm x (mkposreal _ Heps) y) (fun y : V => ball_norm (scal k x) (mkposreal _ Heps) y)). * intros y Hy. rewrite <- Hmult_comm. apply Hy. * apply limx2. - intros x limx. unfold is_domin. intros eps Heps. unfold filterlim, locally in limx. specialize (limx (ball_norm x (mkposreal _ Heps))) as limx'. destruct limx' as [limx1 limx2]. unfold scal. apply (filter_imp (fun y : V => ball_norm x (mkposreal _ Heps) y) (fun y : V => ball_norm (scal k x) (mkposreal _ Heps) y)). + intros y Hy. apply Hy. + apply limx2.", "succ": false}]