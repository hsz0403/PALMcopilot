[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros Hk Hf.", "unfold continuous in *.", "unfold filterlim in *.", "intros P HP.", "unfold scal."], "tactic": "apply Hk in HP as HkP.", "exn": "Unable to apply lemma of type \"filter_le (filtermap k (locally x)) (locally (k x))\" on hypothesis of type \"locally (scal (k x) (f x)) P\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros Hk Hf.", "unfold continuous in *.", "unfold filterlim in *.", "intros P HP.", "unfold scal."], "tactic": "apply Hf in HkP as HfP.", "exn": "No such hypothesis: HkP", "type": "no_hypos", "handled": true}, {"ctx": ["intros Hk Hf.", "unfold continuous in *.", "unfold filterlim in *.", "intros P HP.", "unfold scal."], "tactic": "apply filterlim_scal.", "exn": "In environment U : UniformSpace K : AbsRing V : NormedModule K k : U -> K f : U -> V x : U Hk : filter_le (filtermap k (locally x)) (locally (k x)) Hf : filter_le (filtermap f (locally x)) (locally (f x)) P : V -> Prop HP : locally (scal (k x) (f x)) P Unable to unify \"forall P0 : ?V -> Prop, locally (scal ?M2363 ?M2364) P0 -> filtermap (fun z : ?K * ?V => scal (fst z) (snd z)) (filter_prod (locally ?M2363) (locally ?M2364)) P0\" with \"exists eps : posreal, forall y : U, ball x eps y -> (fun x : U => P ((fun y0 : U => ModuleSpace.scal K (AbelianGroup.Pack V (ModuleSpace.class K V) V) (ModuleSpace.class K V) (k y0) (f y0)) x)) y\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros Hk Hf. unfold continuous in *. unfold filterlim in *. intros P HP. unfold scal. apply Hk in HP as HkP. apply Hf in HkP as HfP. apply filterlim_scal. apply HfP.", "succ": false}]