[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros H1 H2 H3.", "apply is_lim_unique."], "tactic": "apply Lub.Rbar_is_lub_eq with (fun y => f y + g y) (fun z => Rbar_plus (Lim f x) (Lim g x)).", "exn": "In environment f, g : R -> R x : Rbar H1 : ex_lim f x H2 : ex_lim g x H3 : ex_Rbar_plus (Lim f x) (Lim g x) The term \"fun y : R => f y + g y\" has type \"R -> R\" while it is expected to have type \"Rbar -> Prop\" (cannot unify \"R\" and \"Prop\").", "type": "wrong_type", "handled": true}, {"ctx": ["intros H1 H2 H3.", "apply is_lim_unique.", "intros z."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}]}, "chat": [], "original": "intros H1 H2 H3. apply is_lim_unique. apply Lub.Rbar_is_lub_eq with (fun y => f y + g y) (fun z => Rbar_plus (Lim f x) (Lim g x)). - intros z. split. + intros H. unfold Rbar_plus. destruct (ex_Rbar_plus_correct (Lim f x) (Lim g x) H3) as [H4 _]. apply is_Rbar_plus_unique in H4. rewrite H4. apply H. + intros H. unfold Rbar_plus in H. destruct (ex_Rbar_plus_correct (Lim f x) (Lim g x) H3) as [_ H4]. apply is_Rbar_plus_unique in H4. rewrite <- H4. apply H. - apply Lub.Rbar_is_lub_eq with (fun y => Lim f x + Lim g x) (Lim (fun y : R => f y + g y) x). + intros z. split. * intros H. apply H. * intros H. apply H. + apply Lub.Rbar_is_lub_eq with (fun y => Lim f x) (Lim f x). * intros z. split. ++ intros H. apply H. ++ intros H. apply H. * apply Lim_correct. apply ex_lim_plus; apply Lim_correct.", "succ": false}]