[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros f lb la b a y Hlima Hlimb Hcont Hltab Hltylb.", "exn": "f is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' lb la b a y Hlima Hlimb Hcont Hltab Hltylb.", "exn": "lb is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' lb' la b a y Hlima Hlimb Hcont Hltab Hltylb.", "exn": "la is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' lb' la' b a y Hlima Hlimb Hcont Hltab Hltylb.", "exn": "b is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' lb' la' b'' a y Hlima Hlimb Hcont Hltab Hltylb.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' lb' la' b'' a'' y Hlima Hlimb Hcont Hltab Hltylb.", "exn": "y is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros f' lb' la' b'' a'' y' Hlima Hlimb Hcont Hltab Hltylb.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "assert (Hlty: Rbar_lt la lb).", "apply Rbar_lt_trans with (y:=y); auto."], "tactic": "pose (g := fun x => if Rle_dec a x then f x else y).", "exn": "In environment f : R -> R a, b, la, lb : Rbar y : R H : is_lim f a la H0 : is_lim f b lb H1 : forall x : R, Rbar_lt a x -> Rbar_lt x b -> continuity_pt f x H2 : Rbar_lt a b H3 : Rbar_lt la y /\\\\ Rbar_lt y lb x : R The term \"Rle_dec a x\" has type \"{a <= x} + {~ a <= x}\" while it is expected to have type \"bool\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros f lb la b a y Hlima Hlimb Hcont Hltab Hltylb. assert (Hlty: Rbar_lt la lb). { apply Rbar_lt_trans with (y:=y); auto. } pose (g := fun x => if Rle_dec a x then f x else y). assert (Hlimg: is_lim g a la). { unfold is_lim, filterlim, Rbar_locally; simpl. intros P HP. assert (Hdiff: exists delta : posreal, ball a delta y). { apply Rbar_lt_locally with (a:=a) (b:=b) (x:=y); auto. } destruct Hdiff as [delta Hdelta]. exists delta; intros x Hball. apply HP. destruct (Rle_dec a x) as [Hlex|Hnlex]. - exists delta; split; auto. - exfalso; apply Hnlex, Rnot_le_lt in Hnlex. apply Rlt_asym in Hnlex. exfalso; apply Hltab. + apply Rbar_lt_le_trans with (y := x); auto. + apply Rbar_lt_lt_trans with (y := a); auto. } assert (Hlimfg: is_lim (fun x : R => f x - y) a (la - y)). { apply is_lim_minus. - apply Hlima. - apply is_lim_const. } destruct (Rle_lt_or_eq_dec a b) as [Hleab|Heqab]. - pose (c := f_inc (fun x : R => f x - y) a b (la - y) Hlimfg Hlimb). exists c; split. + apply f_inc_correct in Hltab; destruct Hltab; auto. + apply f_inc_correct in Hltab; destruct Hltab; split; auto. - pose (d := f_inc (fun x : R => f x - y) b a (la - y) Hlimfg Hlima). exists d; split. + apply f_inc_correct in Hltab; destruct Hltab; auto. + apply f_inc_correct in Hltab; destruct Hltab; split; auto.", "succ": false}]