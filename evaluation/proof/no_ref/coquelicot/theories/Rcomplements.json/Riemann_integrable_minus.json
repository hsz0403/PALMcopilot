[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]].", "destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]]."], "tactic": "exists (fun x => phi_f x - phi_g x).", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi_f, psi_f : StepFun a b Hf_bound : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi_f t) <= psi_f t Hf_eps : Rabs (RiemannInt_SF psi_f) < eps phi_g, psi_g : StepFun a b Hg_bound : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi_g t) <= psi_g t Hg_eps : Rabs (RiemannInt_SF psi_g) < eps The term \"fun x : R => phi_f x - phi_g x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]].", "destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]]."], "tactic": "exists (fun x => psi_f x + psi_g x).", "exn": "In environment f, g : R -> R a, b : R Hf : Riemann_integrable f a b Hg : Riemann_integrable g a b eps : posreal phi_f, psi_f : StepFun a b Hf_bound : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi_f t) <= psi_f t Hf_eps : Rabs (RiemannInt_SF psi_f) < eps phi_g, psi_g : StepFun a b Hg_bound : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (g t - phi_g t) <= psi_g t Hg_eps : Rabs (RiemannInt_SF psi_g) < eps The term \"fun x : R => psi_f x + psi_g x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]].", "destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]]."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]].", "destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]].", "unfold Rminus."], "tactic": "rewrite Ropp_plus_distr.", "exn": "The LHS of Ropp_plus_distr (- (_ + _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]].", "destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]].", "unfold Rminus."], "tactic": "rewrite Rplus_comm.", "exn": "The LHS of Rplus_comm (_ + _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f g a b Hf Hg.", "intros eps.", "destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]].", "destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]].", "unfold Rminus."], "tactic": "rewrite Rplus_assoc.", "exn": "The LHS of Rplus_assoc (_ + _ + _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}]}, "chat": [], "original": "intros f g a b Hf Hg. intros eps. destruct (Hf eps) as [phi_f [psi_f [Hf_bound Hf_eps]]]. destruct (Hg eps) as [phi_g [psi_g [Hg_bound Hg_eps]]]. exists (fun x => phi_f x - phi_g x). exists (fun x => psi_f x + psi_g x). split. - intros. unfold Rminus. rewrite Ropp_plus_distr. rewrite Rplus_comm. rewrite Rplus_assoc. rewrite (Rplus_comm (- g x)). rewrite <- Rplus_assoc. apply Rle_trans with (Rabs (f x - phi_f x) + Rabs (g x + - phi_g x)). apply Rabs_triang. rewrite Rplus_comm. apply Rplus_le_compat. + apply Hf_bound. apply H. + apply Hg_bound. apply H. - rewrite Rabs_Ropp. rewrite Rabs_Rabsolu. rewrite Ropp_plus_distr. rewrite Rplus_comm. rewrite Rabs_minus_sym. rewrite Rplus_comm. apply Rlt_trans with (Rabs (RiemannInt_SF psi_f + RiemannInt_SF psi_g)). apply Rabs_triang_inv. rewrite Rplus_comm. apply Rle_lt_trans with (Rabs (RiemannInt_SF psi_f) + Rabs (RiemannInt_SF psi_g)). apply Rabs_triang. apply Rplus_lt_compat. apply Hf_eps. apply Hg_eps.", "succ": false}]