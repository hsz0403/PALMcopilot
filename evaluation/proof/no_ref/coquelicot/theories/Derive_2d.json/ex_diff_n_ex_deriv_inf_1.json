[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n p k H f x y H0."], "tactic": "apply ex_diff_n_m with (m := p + k) in H0.", "exn": "In environment n, p, k : nat H : (p + k < n)%nat f : R -> R -> R x, y : R H0 : ex_diff_n f n x y The term \"p\" has type \"nat\" while it is expected to have type \"R\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros n p k H f x y H0.", "apply ex_diff_n_deriv with (n := n) (p := p) (q := k) in H0."], "tactic": "apply ex_diff_n_deriv_aux2 in H0.", "exn": "Unable to apply lemma of type \"forall (f : R -> R -> R) (n : nat) (x y : R), ex_diff_n f (S n) x y -> ex_diff_n (fun u v : R => Derive (fun z : R => f u z) v) n x y\" on hypothesis of type \"ex_diff_n (partial_derive p k f) (n - (p + k)) x y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n p k H f x y H0.", "apply ex_diff_n_deriv with (n := n) (p := p) (q := k) in H0."], "tactic": "apply ex_diff_n_deriv_aux1 in H0.", "exn": "Unable to apply lemma of type \"forall (f : R -> R -> R) (n : nat) (x y : R), ex_diff_n f (S n) x y -> ex_diff_n (fun u v : R => Derive (fun z : R => f z v) u) n x y\" on hypothesis of type \"ex_diff_n (partial_derive p k f) (n - (p + k)) x y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n p k H f x y H0.", "apply ex_diff_n_deriv with (n := n) (p := p) (q := k) in H0."], "tactic": "apply ex_diff_n_ext_loc with (f := f) in H0.", "exn": "Unable to apply lemma of type \"forall (f g : R -> R -> R) (n : nat) (x y : R), locally_2d (fun u v : R => f u v = g u v) x y -> ex_diff_n f n x y -> ex_diff_n g n x y\" on hypothesis of type \"ex_diff_n (partial_derive p k f) (n - (p + k)) x y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n p k H f x y H0.", "apply ex_diff_n_deriv with (n := n) (p := p) (q := k) in H0."], "tactic": "apply Schwarz_aux in H0.", "exn": "Unable to apply lemma of type \"forall (f : R -> R -> R_NormedModule) (x y : R) (eps : posreal), (forall u v : R, Rabs (u - x) < eps -> Rabs (v - y) < eps -> ex_derive (fun z : R => f z v) u /\\\\ ex_derive (fun z : R => Derive (fun t : R => f t z) u) v) -> forall h k : R, Rabs h < eps -> Rabs k < eps -> let phi := fun k0 x0 : R => f x0 (y + k0) - f x0 y in exists u v : R, Rabs (u - x) <= Rabs h /\\\\ Rabs (v - y) <= Rabs k /\\\\ phi k (x + h) - phi k x = h * k * Derive (fun z : R => Derive (fun t : R => f t z) u) v\" on hypothesis of type \"ex_diff_n (partial_derive p k f) (n - (p + k)) x y\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n p k H f x y H0.", "apply ex_diff_n_deriv with (n := n) (p := p) (q := k) in H0."], "tactic": "apply H0.", "exn": "In environment n, p, k : nat H : (p + k < n)%nat f : R -> R -> R x, y : R H0 : ex_diff_n (partial_derive p k f) (n - (p + k)) x y Unable to unify \"ex_diff_n (partial_derive p k f) (n - (p + k)) x y\" with \"ex_derive (fun z : R => partial_derive p k f z y) x\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros n p k H f x y H0. apply ex_diff_n_m with (m := p + k) in H0. apply ex_diff_n_deriv with (n := n) (p := p) (q := k) in H0. apply ex_diff_n_deriv_aux2 in H0. apply ex_diff_n_deriv_aux1 in H0. apply ex_diff_n_ext_loc with (f := f) in H0. apply Schwarz_aux in H0. apply H0. apply Plus.le_plus_minus. apply H.", "succ": false}]