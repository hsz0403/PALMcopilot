[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros u l Hlim.", "exn": "u is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros u' l Hlim.", "exn": "l is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros u' l' Hlim.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq."], "tactic": "intros eps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq.", "destruct l as [l0| |].", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq.", "destruct l as [l0| |].", "-", "shelve.", "-"], "tactic": "destruct (ex_lim_seq u) as [l H].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq.", "destruct l as [l0| |].", "-", "shelve.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq.", "destruct l as [l0| |].", "-", "shelve.", "-", "shelve.", "-"], "tactic": "destruct (ex_lim_seq u) as [l H].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "unfold is_LimSup_seq.", "destruct l as [l0| |].", "-", "shelve.", "-", "shelve.", "-", "exists 0%nat.", "intros n."], "tactic": "split; auto.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}]}, "chat": [], "original": "intros u l Hlim. unfold is_LimSup_seq. intros eps. destruct l as [l0| |]. - destruct (Hlim eps) as [N [HN1 HN2]]. split. + intros n. exists N. destruct (HN1 n) as [n' [Hn' Hn'']]. split. * apply le_trans with N; auto. * apply Rlt_trans with (l0 - eps); auto. + exists N. intro n. destruct (HN2 n) as [Hn1 Hn2]. apply Hn2. apply le_refl. - destruct (ex_lim_seq u) as [l H]. apply is_LimSup_seq_ext_loc with u l. + apply eventually_eq_filterlim with u (eventually_filterlocally (ex_intro _ l H)). + apply H. - destruct (ex_lim_seq u) as [l H]. exists 0%nat. intros n. simpl. split; auto.", "succ": false}]