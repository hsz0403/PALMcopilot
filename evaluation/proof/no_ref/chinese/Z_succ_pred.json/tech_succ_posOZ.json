[{"history": {"proof": "intros n. induction n. - reflexivity. - simpl. qsimpl time: 1.", "repairs": ["", "", "", "", "", "", "no_subterm"], "exceptions": [{"ctx": ["intros n.", "induction n.", "-", "reflexivity.", "-", "simpl."], "tactic": "rewrite IHn.", "exn": "Found no subterm matching \"succZ (posOZ n)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "reflexivity.", "-", "simpl.", "qsimpl time: 1."], "tactic": "reflexivity.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall n : nat, succZ (posOZ n) = pos n\n\nPremises:\nposOZ = fun n : nat => match n with | 0 => OZ | S n' => pos n' end : nat -> Z Arguments posOZ _%nat_scope\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nsuccZ = fun x : Z => match x with | OZ => IZ | pos n => pos (S n) | neg 0 => OZ | neg (S m) => neg m end : Z -> Z\nInductive Z : Set := OZ : Z | pos : nat -> Z | neg : nat -> Z Arguments pos _%nat_scope Arguments neg _%nat_scope\ntech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (Init.Nat.pred n)\ntech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m\nNat.odd_succ : forall n : nat, Nat.odd (S n) = Nat.even n\nNat.succ_pred : forall n : nat, n <> 0 -> S (Nat.pred n) = n\nNat.even_pred : forall n : nat, n <> 0 -> Nat.even (Nat.pred n) = Nat.odd n\nNat.gcd_add_diag_r : forall n m : nat, Nat.gcd n (m + n) = Nat.gcd n m\nNat.setbit_eq : forall a n : nat, Nat.testbit (Nat.setbit a n) n = true\nNat.gcd_sub_diag_r : forall n m : nat, n <= m -> Nat.gcd n (m - n) = Nat.gcd n m\nNat.clearbit_spec' : forall a n : nat, Nat.clearbit a n = Nat.ldiff a (2 ^ n)\nNat.lxor_spec : forall a b n : nat, Nat.testbit (Nat.lxor a b) n = xorb (Nat.testbit a n) (Nat.testbit b n)\nNat.shiftl_land : forall a b n : nat, Nat.shiftl (Nat.land a b) n = Nat.land (Nat.shiftl a n) (Nat.shiftl b n)\nNat.ldiff_ones_r_low : forall a n : nat, Nat.log2 a < n -> Nat.ldiff a (Nat.ones n) = 0\nNat.land_lnot_diag : forall a n : nat, Nat.land a (Nat.lnot a n) = Nat.ldiff a (Nat.ones n)\nNat.shiftl_spec_high' : forall a n m : nat, n <= m -> Nat.testbit (Nat.shiftl a n) m = Nat.testbit a (m - n)\nNat.shiftl_spec_low : forall a n m : nat, m < n -> Nat.testbit (Nat.shiftl a n) m = false\nNat.land_lnot_diag_low : forall a n : nat, Nat.log2 a < n -> Nat.land a (Nat.lnot a n) = 0\nNat.testbit_false : forall a n : nat, Nat.testbit a n = false < -> (a / 2 ^ n) mod 2 = 0\nsucc_predZ : forall x : Z, succZ (predZ x) = x\nNat.Odd_succ : forall n : nat, Nat.Odd (S n) < -> Nat.Even n\nabsZ = fun x : Z => match x with | OZ => OZ | pos n | neg n => pos n end : Z -> Z\nNat.testbit_eqb : forall a n : nat, Nat.testbit a n = ((a / 2 ^ n) mod 2 =? 1)\nNat.lxor_lnot_lnot : forall a b n : nat, Nat.lxor (Nat.lnot a n) (Nat.lnot b n) = Nat.lxor a b\nNat.setbit_iff : forall a n m : nat, Nat.testbit (Nat.setbit a n) m = true < -> n = m \\/ Nat.testbit a m = true\nminus_n_n : forall n : nat, 0 = n - n\nNat.mul_1_l : forall n : nat, 1 * n = n\nNat.sub_0_r : forall n : nat, n - 0 = n\nNat.add_0_r : forall n : nat, n + 0 = n\nNat.sub_diag : forall n : nat, n - n = 0\nNat.lnot_spec_high : forall a n m : nat, n <= m -> Nat.testbit (Nat.lnot a n) m = Nat.testbit a m\nMax.plus_max_distr_l : forall n m p : nat, Nat.max (p + n) (p + m) = p + Nat.max n m\nNat.add_max_distr_l : forall n m p : nat, Nat.max (p + n) (p + m) = p + Nat.max n m\nNat.gcd_mul_mono_l : forall n m p : nat, Nat.gcd (p * n) (p * m) = p * Nat.gcd n m\nNat.pow2_bits_eqb : forall n m : nat, Nat.testbit (2 ^ n) m = (n =? m)\nsucc_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x)\npredZ = fun x : Z => match x with | OZ => neg 0 | pos 0 => OZ | pos (S m) => pos m | neg n => neg (S n) end : Z -> Z\nNat.lnot_spec_low : forall a n m : nat, m < n -> Nat.testbit (Nat.lnot a n) m = negb (Nat.testbit a m)\nNat.gcd_eq_0_l : forall n m : nat, Nat.gcd n m = 0 -> n = 0\nNat.even_spec : forall n : nat, Nat.even n = true < -> Nat.Even n\nNat.divide_0_l : forall n : nat, Nat.divide 0 n -> n = 0\nNat.odd_spec : forall n : nat, Nat.odd n = true < -> Nat.Odd n"}, {"role": "assistant", "content": "```coq\nintros n. induction n.\n- reflexivity.\n- simpl. rewrite IHn. reflexivity.\nQed.```"}], "original": "intros n. induction n. - reflexivity. - simpl. rewrite IHn. reflexivity.", "succ": true}]