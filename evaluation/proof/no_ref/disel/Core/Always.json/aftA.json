[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "split.", "-", "intros."], "tactic": "apply aftI.", "exn": "In environment this : nid W : world A : Type B : Type s : state p : proc A P : B -> A -> state -> Prop H : alwsafe s p H0 : after s p (fun (v : A) (s' : state) => forall x : B, P x v s') x : B Unable to unify \"(after ?M1555 ?M1556 (fun (v : ?M1554) (s' : state) => ?M1557 -> ?M1558 v s') -> ?M1557 -> after ?M1555 ?M1556 (fun v : ?M1554 => [eta ?M1558 v])) /\\\\ ((?M1557 -> after ?M1555 ?M1556 (fun v : ?M1554 => [eta ?M1558 v])) -> after ?M1555 ?M1556 (fun (v : ?M1554) (s' : state) => ?M1557 -> ?M1558 v s'))\" with \"forall scs : seq schedule, always_sc s p scs (fun (s2 : state) (p2 : proc A) => forall v : A, p2 = Ret v -> (fun v0 : A => [eta P x v0]) v s2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "split.", "-", "intros."], "tactic": "apply alwsafe_bnd with (p1:=p) (pp2:=fun (_:B) => fun (_:A) => p) in H.", "exn": "In environment this : nid W : world A : Type B : Type s : state p : proc A P : B -> A -> state -> Prop H : alwsafe s p H0 : after s p (fun (v : A) (s' : state) => forall x : B, P x v s') x : B The term \"fun=> (fun=> p)\" has type \"B -> A -> proc A\" while it is expected to have type \"A -> Pred (proc ?B)\" (cannot unify \"A\" and \"B\").", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "split.", "-", "intros."], "tactic": "destruct H.", "exn": "Unable to find an instance for the variable scs.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "split.", "-", "intros."], "tactic": "intros x.", "exn": "x is already used.", "type": "used_var", "handled": true}]}, "chat": [], "original": "intros. split. - intros. apply aftI. apply alwsafe_bnd with (p1:=p) (pp2:=fun (_:B) => fun (_:A) => p) in H. destruct H. intros x. apply aft_imp with (P1:=fun (_:B)(_:=_) => forall x0:B, P x0 v s') in H0. apply H0. intros.", "succ": false}]