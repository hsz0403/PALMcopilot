[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros W U K H1 H2 H3 H4.", "exn": "W is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros W' U K H1 H2 H3 H4.", "exn": "U is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros W' U' K H1 H2 H3 H4.", "exn": "K is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros W' U' K' H1 H2 H3 H4.", "intros."], "tactic": "apply Injection.injects; auto.", "exn": "In environment U, W : world K : union_mapPCM hook_domain hook_type W' : valid (U \\\\+ W \\\\+ (Unit, K)) U' : hook_complete U K' : hook_complete W H1 : hooks_consistent (U \\\\+ W).1 K H2 : nat_ordType H3, H4 : Label t : nat_ordType H : (H2, H3, (H4, t)) \\\\in dom (U \\\\+ W \\\\+ (Unit, K)) Unable to unify \"Type\" with \"is_true ((H3 \\\\in dom (U \\\\+ W \\\\+ (Unit, K))) && (H4 \\\\in dom (U \\\\+ W \\\\+ (Unit, K))))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros W U K H1 H2 H3 H4. unfold union_mapPCM in H1. unfold union_mapPCM in H4. intros. apply Injection.injects; auto.", "succ": false}]