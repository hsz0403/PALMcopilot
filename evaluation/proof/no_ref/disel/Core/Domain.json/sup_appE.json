[{"history": {"proof": "unfold sup. sfirstorder depth: 3.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["unfold sup."], "tactic": "apply sup_closed.", "exn": "In environment A : Type B : lattice s : Pred (A -> B) x : A Unable to unify \"simpl_fun (Pred ?T) Prop\" with \"Lattice.mx_sup (Lattice.mixin (Lattice.class (funLattice A B))) s x = Lattice.mx_sup (Lattice.mixin (Lattice.class B)) [Pred y | exists f : A -> B, f \\\\In s /\\\\ y = f x]\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold sup."], "tactic": "intros d H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold sup."], "tactic": "apply supM.", "exn": "In environment A : Type B : lattice s : Pred (A -> B) x : A Unable to unify \"(let (mx_leq, _, _, _) := Poset.mixin (Poset.class ?M1464) in mx_leq) (sup ?M1465) ?M1466\" with \"Lattice.mx_sup (Lattice.mixin (Lattice.class (funLattice A B))) s x = Lattice.mx_sup (Lattice.mixin (Lattice.class B)) [Pred y | exists f : A -> B, f \\\\In s /\\\\ y = f x]\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold sup."], "tactic": "intros y H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "unfold sup. apply sup_closed. intros d H. apply supM. intros y H'. exists (fun _ => y). split. - auto. - reflexivity.", "succ": true}]