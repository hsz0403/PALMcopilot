[{"history": {"proof": "srun best use: all_permutations_aux_permutation unfold: all_permutations.", "repairs": ["hammer"], "exceptions": [{"ctx": ["intros l1 l2 H."], "tactic": "induction H.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros l1 l2 H."], "tactic": "apply permutation_nil.", "exn": "In environment A : Type l1, l2 : list A H : In l1 (all_permutations l2) Unable to unify \"permutation [] []\" with \"permutation l1 l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l1 l2 H."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros l1 l2 H."], "tactic": "inversion H'; subst.", "exn": "No such hypothesis: H'", "type": "no_hypos", "handled": true}, {"ctx": ["intros l1 l2 H."], "tactic": "apply permutation_skip.", "exn": "In environment A : Type l1, l2 : list A H : In l1 (all_permutations l2) Unable to unify \"permutation (?M1416 :: ?M1418) (?M1416 :: ?M1417)\" with \"permutation l1 l2\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l1 l2 H. induction H. - apply permutation_nil. - intros H'. inversion H'; subst. apply permutation_skip. apply IHpermutation. auto. - apply permutation_swap. - intros H1 H2. apply permutation_trans with (l2 := l2); auto.", "succ": true}]