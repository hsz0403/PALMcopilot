[{"history": {"proof": "intros l t. induction l as [|hd tl IHl]. - intros H. inversion H. - intros Hin. srun best use: all_cover_aux_cover unfold: all_cover.", "repairs": ["", "", "", "", "", "", "", "hammer"], "exceptions": [{"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "destruct Hin as [Hin | Hin].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "apply cover_one.", "exn": "In environment A : Type empty : A hd : btree A tl : list (btree A) t : btree A IHl : In t (all_cover tl) -> cover tl t Hin : In t (all_cover (hd :: tl)) Unable to unify \"cover [?M1525] ?M1525\" with \"cover (hd :: tl) t\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "apply (cover_sind _ _ cover_one).", "exn": "In environment A : Type empty : A hd : btree A tl : list (btree A) t : btree A IHl : In t (all_cover tl) -> cover tl t Hin : In t (all_cover (hd :: tl)) The term \"cover_one\" has type \"forall t : btree A, cover [t] t\" while it is expected to have type \"forall (l1 l2 : list (btree A)) (t1 t2 t3 : btree A), permutation l1 (t1 :: t2 :: l2) -> cover (node t1 t2 :: l2) t3 -> ?P (node t1 t2 :: l2) t3 -> ?P l1 t3\" (cannot unify \"list (btree A)\" and \"btree A\").", "type": "wrong_type", "handled": true}, {"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "intros l1 l2 t1 t2 t3 Hperm Hcov IH.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "apply (IHl Hin).", "exn": "In environment A : Type empty : A hd : btree A tl : list (btree A) t : btree A IHl : In t (all_cover tl) -> cover tl t Hin : In t (all_cover (hd :: tl)) The term \"Hin\" has type \"In t (all_cover (hd :: tl))\" while it is expected to have type \"In t (all_cover tl)\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "apply (cover_permutation _ (node t1 t2) _ Hcov) in Hperm.", "exn": "No such hypothesis: Hperm", "type": "no_hypos", "handled": true}, {"ctx": ["intros l t.", "induction l as [|hd tl IHl].", "-", "intros H.", "inversion H.", "-", "intros Hin."], "tactic": "apply (cover_inv_app_aux _ _ _ _ _ Hcov eq_refl) in Hperm.", "exn": "No such hypothesis: Hperm", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros l t. induction l as [|hd tl IHl]. - intros H. inversion H. - intros Hin. destruct Hin as [Hin | Hin]. + subst. apply cover_one. + apply (cover_sind _ _ cover_one). intros l1 l2 t1 t2 t3 Hperm Hcov IH. apply (IHl Hin). apply (cover_permutation _ (node t1 t2) _ Hcov) in Hperm. apply (cover_inv_app_aux _ _ _ _ _ Hcov eq_refl) in Hperm. destruct Hperm as [H | [l1 [l2 [[Hcov1 Hcov2] Hperm]]]]. * subst. left. reflexivity. * right. exists l1, l2. split. auto. split. auto. auto.", "succ": true}]