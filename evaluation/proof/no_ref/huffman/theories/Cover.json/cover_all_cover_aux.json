[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n l t.", "generalize dependent l.", "induction n.", "-", "intros l EQ COV.", "simpl.", "inversion EQ."], "tactic": "intros t_cov.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros n l t.", "generalize dependent l.", "induction n.", "-", "intros l EQ COV.", "simpl.", "inversion EQ.", "inversion COV.", "subst."], "tactic": "apply cover_one.", "exn": "In environment A : Type empty : A t : btree A EQ : 0 = length [t] COV : cover [t] t H0 : 0 = length [t] Unable to unify \"cover [?M1577] ?M1577\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n l t.", "generalize dependent l.", "induction n.", "-", "intros l EQ COV.", "simpl.", "inversion EQ.", "inversion COV.", "subst."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n l t.", "generalize dependent l.", "induction n.", "-", "intros l EQ COV.", "simpl.", "inversion EQ.", "inversion COV.", "subst.", "+", "shelve.", "+", "shelve.", "-", "intros l EQ COV.", "destruct l as [|t1 [|t2 l2]].", "+", "discriminate.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n l t.", "generalize dependent l.", "induction n.", "-", "intros l EQ COV.", "simpl.", "inversion EQ.", "inversion COV.", "subst.", "+", "shelve.", "+", "shelve.", "-", "intros l EQ COV.", "destruct l as [|t1 [|t2 l2]].", "+", "discriminate.", "+", "shelve.", "+", "simpl in EQ.", "injection EQ as EQ'."], "tactic": "clear EQ.", "exn": "No such hypothesis: EQ", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros n l t. generalize dependent l. induction n. - intros l EQ COV. simpl. inversion EQ. intros t_cov. inversion COV. subst. apply cover_one. - intros l EQ COV. destruct l as [|t1 [|t2 l2]]. + discriminate. + discriminate. + simpl in EQ. injection EQ as EQ'. clear EQ. apply all_permutations_inb in COV. apply (in_split_permutation t1 t2 l2) in COV. destruct COV as [s1 [s2 PERM]]. subst. apply (cover_inv_app_aux t (node t1 t2) l2). * apply cover_node with (t1:=t1) (t2:=t2); auto. * left. auto.", "succ": false}]