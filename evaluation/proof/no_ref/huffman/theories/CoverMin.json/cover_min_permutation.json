[{"history": {"proof": "intros t l1 l2 H1 H2. induction H1. qauto use: cover_permutation, permutation_sym unfold: cover_min.", "repairs": ["", "", "hammer"], "exceptions": [{"ctx": ["intros t l1 l2 H1 H2.", "induction H1."], "tactic": "apply cover_one.", "exn": "In environment A : Type f : A -> nat t : btree A l1, l2 : list (btree A) H : cover l1 t H0 : forall t2 : btree A, cover l1 t2 -> weight_tree f t <= weight_tree f t2 H2 : permutation l1 l2 Unable to unify \"cover [?M1520] ?M1520\" with \"cover l2 t /\\\\ (forall t2 : btree A, cover l2 t2 -> weight_tree f t <= weight_tree f t2)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros t l1 l2 H1 H2.", "induction H1."], "tactic": ["destruct H as [l1' [t1' [t2' [t3' [Hperm Hcover]]]]].", ""], "exn": "Expects a disjunctive pattern with 2 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros t l1 l2 H1 H2. induction H1. - apply cover_one. - destruct H as [l1' [t1' [t2' [t3' [Hperm Hcover]]]]]. apply (cover_node _ _ _ t3'). + apply (permutation_trans _ _ (t1' :: t2' :: l2)); auto. + apply IHcover_min; auto.", "succ": true}]