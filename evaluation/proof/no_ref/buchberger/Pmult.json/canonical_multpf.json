[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf."], "tactic": "apply canonical_pluspf with (ltM:=ltM) (ltM_dec:=ltM_dec) in os; auto.", "exn": "Unable to find an instance for the variables A, A0, eqA, plusA, eqA_dec, l1, l2.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf."], "tactic": "apply H1l in H1r.", "exn": "Unable to apply lemma of type \"olist (A:=A) ltM l1\" on hypothesis of type \"nZterm A0 eqA (n:=n) l1\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf."], "tactic": "apply H2l in H2r.", "exn": "Unable to apply lemma of type \"olist (A:=A) ltM l2\" on hypothesis of type \"nZterm A0 eqA (n:=n) l2\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf."], "tactic": "split; [apply order_pluspf|apply canonical_mults_inv]; auto.", "exn": "In environment A : Set A0, A1 : A eqA : A -> A -> Prop plusA : A -> A -> A invA : A -> A minusA, multA : A -> A -> A divA : A -> forall b : A, ~ eqA b A0 -> A cs : CoefStructure A A0 A1 eqA plusA invA minusA multA divA eqA_dec : forall a b : A, {eqA a b} + {~ eqA a b} n : nat ltM : mon n -> mon n -> Prop ltM_dec : forall a b : mon n, {ltM a b} + {ltM b a} + {a = b} os : OrderStructure (mon n) (zero_mon n) ltM (mult_mon n) l1, l2 : list (Term A n) H1l : olist (A:=A) ltM l1 H1r : nZterm A0 eqA (n:=n) l1 H2l : olist (A:=A) ltM l2 H2r : nZterm A0 eqA (n:=n) l2 Unable to unify \"olist ?M1872 (pX ?M1877 (pluspf ?M1867 ?M1869 ?M1870 ?M1873 ?M1875 ?M1876)) /\\\\ nZterm ?M1867 ?M1868 (pX ?M1877 (pluspf ?M1867 ?M1869 ?M1870 ?M1873 ?M1875 ?M1876))\" with \"Relation_Operators_compat.Desc (mon n) ltM (fP A n ((fix multpf (p q : list (Term A n)) {struct p} : list (Term A n) := match p with | nil => pO A n | a :: p' => pluspf A0 (eqA:=eqA) plusA eqA_dec (ltM:=ltM) ltM_dec (mults multA (n:=n) a q) (multpf p' q) end) l1 l2))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l1 l2 H1 H2. unfold canonical in H1, H2. destruct H1 as [H1l H1r]. destruct H2 as [H2l H2r]. unfold multpf. simpl. apply canonical_pluspf with (ltM:=ltM) (ltM_dec:=ltM_dec) in os; auto. apply H1l in H1r. apply H2l in H2r. split; [apply order_pluspf|apply canonical_mults_inv]; auto.", "succ": false}]