[{"history": {"proof": "sauto.", "repairs": [], "exceptions": [{"ctx": ["intros l e Hsorted Hin.", "unfold maxIndex.", "induction l as [|e' l' IHl].", "-"], "tactic": "intros _.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros l e Hsorted Hin.", "unfold maxIndex.", "induction l as [|e' l' IHl].", "-", "inversion Hin.", "-"], "tactic": "intros [Heq | Hin'].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros l e Hsorted Hin.", "unfold maxIndex.", "induction l as [|e' l' IHl].", "-", "inversion Hin.", "-"], "tactic": "apply Nat.le_max_l.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry Hsorted : sorted (e' :: l') Hin : In e (e' :: l') IHl : sorted l' -> In e l' -> (fix maxIndex (entries : list entry) : logIndex := match entries with | [] => 0 | e :: _ => eIndex e end) l' >= eIndex e Unable to unify \"?M1642 <= Nat.max ?M1642 ?M1643\" with \"eIndex e <= eIndex e'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e Hsorted Hin.", "unfold maxIndex.", "induction l as [|e' l' IHl].", "-", "inversion Hin.", "-"], "tactic": "apply Nat.max_lub; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry Hsorted : sorted (e' :: l') Hin : In e (e' :: l') IHl : sorted l' -> In e l' -> (fix maxIndex (entries : list entry) : logIndex := match entries with | [] => 0 | e :: _ => eIndex e end) l' >= eIndex e Unable to unify \"Nat.max ?M1642 ?M1643 <= ?M1644\" with \"eIndex e <= eIndex e'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e Hsorted Hin.", "unfold maxIndex.", "induction l as [|e' l' IHl].", "-", "inversion Hin.", "-"], "tactic": "apply IHl; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry Hsorted : sorted (e' :: l') Hin : In e (e' :: l') IHl : sorted l' -> In e l' -> (fix maxIndex (entries : list entry) : logIndex := match entries with | [] => 0 | e :: _ => eIndex e end) l' >= eIndex e Unable to unify \"(fix maxIndex (entries : list entry) : logIndex := match entries with | [] => 0 | e :: _ => eIndex e end) l' >= eIndex e\" with \"eIndex e' >= eIndex e\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l e Hsorted Hin.", "unfold maxIndex.", "induction l as [|e' l' IHl].", "-", "inversion Hin.", "-"], "tactic": "apply sorted_cons; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params e' : entry l' : list entry e : entry Hsorted : sorted (e' :: l') Hin : In e (e' :: l') IHl : sorted l' -> In e l' -> (fix maxIndex (entries : list entry) : logIndex := match entries with | [] => 0 | e :: _ => eIndex e end) l' >= eIndex e Unable to unify \"(forall e' : entry, In e' ?M1642 -> eIndex ?M1643 > eIndex e' /\\\\ eTerm ?M1643 >= eTerm e') /\\\\ (fix sorted (log : list entry) : Prop := match log with | [] => True | e :: es => (forall e' : entry, In e' es -> eIndex e > eIndex e' /\\\\ eTerm e >= eTerm e') /\\\\ sorted es end) ?M1642\" with \"eIndex e <= eIndex e'\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l e Hsorted Hin. unfold maxIndex. induction l as [|e' l' IHl]. - simpl. intros _. inversion Hin. - simpl. intros [Heq | Hin']. + subst. apply Nat.le_max_l. + apply Nat.max_lub; auto. apply IHl; auto. apply sorted_cons; auto.", "succ": true}]