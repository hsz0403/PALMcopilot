[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st h' t r st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "left.", "apply Nat.ltb_lt in H1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "left.", "apply Nat.ltb_lt in H1.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:H2.", "+", "right.", "split; auto.", "apply Nat.ltb_lt in H2."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "left.", "apply Nat.ltb_lt in H1.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:H2.", "+", "right.", "split; auto.", "apply Nat.ltb_lt in H2.", "*", "shelve.", "*", "shelve.", "+", "right.", "split.", "*", "apply Nat.ltb_nlt in H1.", "apply Nat.ltb_nlt in H2."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t r st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:H1.", "-", "left.", "apply Nat.ltb_lt in H1.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:H2.", "+", "right.", "split; auto.", "apply Nat.ltb_lt in H2.", "*", "shelve.", "*", "shelve.", "+", "right.", "split.", "*", "apply Nat.ltb_nlt in H1.", "apply Nat.ltb_nlt in H2.", "shelve.", "*"], "tactic": "split; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output h' : name t : nat r : bool st' : raft_data H1 : (currentTerm st <? t) = false H2 : (t <? currentTerm st) = false H : match type st with | Candidate => {[{[{[{[{[st with votesReceived := (if r then [h'] else []) ++ votesReceived st]} with type := if r && wonElection (dedup name_eq_dec (h' :: votesReceived st)) then Leader else type st]} with matchIndex := assoc_set name_eq_dec [] h (maxIndex (log st))]} with nextIndex := []]} with electoralVictories := (if r && wonElection (dedup name_eq_dec (h' :: votesReceived st)) then [(currentTerm st, h' :: votesReceived st, log st)] else []) ++ electoralVictories st]} | _ => st end = st' Unable to unify \"leaderId st\" with \"leaderId st'\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st h' t r st' H. unfold handleRequestVoteReply in H. destruct (currentTerm st <? t) eqn:H1. - left. apply Nat.ltb_lt in H1. lia. - destruct (t <? currentTerm st) eqn:H2. + right. split; auto. apply Nat.ltb_lt in H2. lia. + right. split. * apply Nat.ltb_nlt in H1. apply Nat.ltb_nlt in H2. lia. * split; auto.", "succ": false}]