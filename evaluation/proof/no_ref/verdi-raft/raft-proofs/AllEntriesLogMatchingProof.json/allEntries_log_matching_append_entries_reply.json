[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold refined_raft_net_invariant_append_entries_reply.", "unfold allEntries_log_matching_inductive.", "intros net H H0 H1 H2 H3 H4.", "unfold allEntries_log_matching.", "intros."], "tactic": "apply H0 in H; apply H1 in H; apply H2 in H; apply H3 in H; apply H4 in H.", "exn": "Unable to apply lemma of type \"list packet\" on hypothesis of type \"packet\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["unfold refined_raft_net_invariant_append_entries_reply.", "unfold allEntries_log_matching_inductive.", "intros net H H0 H1 H2 H3 H4.", "unfold allEntries_log_matching.", "intros."], "tactic": "apply H; auto.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface aelsi : allEntries_leader_sublog_interface lsi : leader_sublog_interface rlmli : refined_log_matching_lemmas_interface net : list packet H : packet H0 : list packet H1 : network H2 : name -> data H3 : list packet H4 : GhostSimulations.ghost_data d : raft_data m : list (name * msg) t : nat es : list entry res : bool H5 : handleAppendEntriesReply (pDst H) (snd (nwState H1 (pDst H))) (pSrc H) t es res = (d, m) H6 : H4 = fst (nwState H1 (pDst H)) H7 : pBody H = AppendEntriesReply t es res H8 : (forall (e e' : entry) (h h' : Net.name), In e (log (snd (nwState H1 h))) -> In e' (map snd (allEntries (fst (nwState H1 h')))) -> eTerm e = eTerm e' -> eIndex e = eIndex e' -> e = e') /\\\\ allEntries_log_matching_nw H1 H9 : refined_raft_intermediate_reachable H1 H10 : nwPackets H1 = net ++ H :: H0 H11 : forall h : name, H2 h = update name_eq_dec (nwState H1) (pDst H) (H4, d) h H12 : forall p' : packet, In p' H3 -> In p' (net ++ H0) \\\\/ In p' (send_packets (pDst H) m) Unable to unify \"packet\" with \"(forall (e e' : entry) (h h' : Net.name), In e (log (snd (nwState {| nwPackets := H3; nwState := H2 |} h))) -> In e' (map snd (allEntries (fst (nwState {| nwPackets := H3; nwState := H2 |} h')))) -> eTerm e = eTerm e' -> eIndex e = eIndex e' -> e = e') /\\\\ allEntries_log_matching_nw {| nwPackets := H3; nwState := H2 |}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold refined_raft_net_invariant_append_entries_reply. unfold allEntries_log_matching_inductive. intros net H H0 H1 H2 H3 H4. unfold allEntries_log_matching. unfold allEntries_leader_sublog. unfold leader_sublog_invariant. unfold leader_sublog_nw_invariant. intros. apply H0 in H; apply H1 in H; apply H2 in H; apply H3 in H; apply H4 in H. unfold allEntries_leader_sublog_invariant, leader_sublog_invariant, leader_sublog_nw_invariant in *. intros. apply H; auto.", "succ": false}]