[{"history": {"proof": "intros h st src t vg st' H. srun best use: @handleRequestVoteReply_same_log unfold: name.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "shelve.", "-", "inversion H."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params tsi : term_sanity_interface h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output src : name t : nat vg : bool st' : raft_data currentTermLt : (currentTerm st <? t) = false H, H0 : (if t <? currentTerm st then st else match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if vg then [src] else []) ++ votesReceived st)) (if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then Leader else type st)) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ((if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then [(currentTerm st, src :: votesReceived st, log st)] else []) ++ electoralVictories st) | _ => st end) = st' Unable to unify \"let (_, _, _, log, _, _, _, _, _, _, _, _, _, _) := st in log\" with \"let (_, _, _, log, _, _, _, _, _, _, _, _, _, _) := if t <? currentTerm st then st else match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if vg then [src] else []) ++ votesReceived st)) (if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then Leader else type st)) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ((if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then [(currentTerm st, src :: votesReceived st, log st)] else []) ++ electoralVictories st) | _ => st end in log\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "shelve.", "-", "inversion H."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params tsi : term_sanity_interface h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output src : name t : nat vg : bool st' : raft_data currentTermLt : (currentTerm st <? t) = false H, H0 : (if t <? currentTerm st then st else match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if vg then [src] else []) ++ votesReceived st)) (if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then Leader else type st)) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ((if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then [(currentTerm st, src :: votesReceived st, log st)] else []) ++ electoralVictories st) | _ => st end) = st' Unable to unify \"let (_, _, _, log, _, _, _, _, _, _, _, _, _, _) := st in log\" with \"let (_, _, _, log, _, _, _, _, _, _, _, _, _, _) := if t <? currentTerm st then st else match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ((if vg then [src] else []) ++ votesReceived st)) (if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then Leader else type st)) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ((if vg && wonElection (dedup name_eq_dec (src :: votesReceived st)) then [(currentTerm st, src :: votesReceived st, log st)] else []) ++ electoralVictories st) | _ => st end in log\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "shelve.", "-", "inversion H."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t vg st' H.", "unfold handleRequestVoteReply in H.", "unfold log.", "destruct (currentTerm st <? t) eqn:currentTermLt.", "-", "destruct (currentTerm st <? t) eqn:currentTermLt'.", "+", "inversion H.", "shelve.", "+", "destruct (t <? currentTerm st) eqn:termLtcurrentTerm.", "*", "inversion H.", "shelve.", "*", "shelve.", "-", "inversion H.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros h st src t vg st' H. unfold handleRequestVoteReply in H. unfold log. destruct (currentTerm st <? t) eqn:currentTermLt. - destruct (currentTerm st <? t) eqn:currentTermLt'. + inversion H. + destruct (t <? currentTerm st) eqn:termLtcurrentTerm. * inversion H. * destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:vote. { inversion H. simpl. reflexivity. } { destruct (type st) eqn:typeSt. + inversion H. + reflexivity. + reflexivity. } - destruct (t <? currentTerm st) eqn:termLtcurrentTerm. + inversion H. + destruct (voteGranted && wonElection (dedup name_eq_dec (src :: votesReceived st))) eqn:vote. * inversion H. simpl. reflexivity. * destruct (type st) eqn:typeSt. ++ inversion H. ++ reflexivity. ++ reflexivity.", "succ": true}]