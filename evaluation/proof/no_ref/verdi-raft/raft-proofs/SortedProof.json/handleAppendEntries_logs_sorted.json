[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros net p t n pli plt es ci st' m H_reachable H_logs_sorted H_handle H_pBody H_In_p.", "unfold handleAppendEntries in H_handle.", "destruct (currentTerm (nwState net (pDst p)) <? t) eqn:term_cond.", "-", "inversion H_handle."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros net p t n pli plt es ci st' m H_reachable H_logs_sorted H_handle H_pBody H_In_p.", "unfold handleAppendEntries in H_handle.", "destruct (currentTerm (nwState net (pDst p)) <? t) eqn:term_cond.", "-", "inversion H_handle.", "shelve.", "-", "destruct (pli =? 0) eqn:pli_cond.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:new_entries_cond.", "*", "inversion H_handle; subst; clear H_handle.", "unfold pBody in H_pBody.", "inversion H_pBody; subst; clear H_pBody."], "tactic": "pose proof handleAppendEntries_logs_sorted as H_sorted.", "exn": "Cannot infer the implicit parameter sorted_interface of handleAppendEntries_logs_sorted whose type is \"sorted_interface\" (no type class instance found) in environment: orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params tsi : term_sanity_interface net : network p : packet t : term n : name pli : logIndex plt : term es : list entry ci : logIndex st' : raft_data m : msg H_reachable : raft_intermediate_reachable net H_logs_sorted : logs_sorted net pli_cond : (pli =? 0) = true new_entries_cond : haveNewEntries (nwState net (pDst p)) es = true H_In_p : In p (nwPackets net) term_cond : (currentTerm (nwState net (pDst p)) <? t) = false H0 : (if t <? currentTerm (nwState net (pDst p)) then (nwState net (pDst p), AppendEntriesReply (currentTerm (nwState net (pDst p))) es false) else (mkRaft_data (currentTerm (advanceCurrentTerm (nwState net (pDst p)) t)) (votedFor (advanceCurrentTerm (nwState net (pDst p)) t)) (Some n) es (Init.Nat.max (commitIndex (nwState net (pDst p))) (Init.Nat.min ci (maxIndex es))) (lastApplied (advanceCurrentTerm (nwState net (pDst p)) t)) (stateMachine (advanceCurrentTerm (nwState net (pDst p)) t)) (nextIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (matchIndex (advanceCurrentTerm (nwState net (pDst p)) t)) (shouldSend (advanceCurrentTerm (nwState net (pDst p)) t)) (votesReceived (advanceCurrentTerm (nwState net (pDst p)) t)) Follower (clientCache (advanceCurrentTerm (nwState net (pDst p)) t)) (electoralVictories (advanceCurrentTerm (nwState net (pDst p)) t)), AppendEntriesReply t es true)) = (st', m) H1 : (let (_, _, pBody) := p in pBody) = AppendEntries t n pli plt es ci", "type": "cannot_infer_para", "handled": true}, {"ctx": ["intros net p t n pli plt es ci st' m H_reachable H_logs_sorted H_handle H_pBody H_In_p.", "unfold handleAppendEntries in H_handle.", "destruct (currentTerm (nwState net (pDst p)) <? t) eqn:term_cond.", "-", "inversion H_handle.", "shelve.", "-", "destruct (pli =? 0) eqn:pli_cond.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:new_entries_cond.", "*", "inversion H_handle; subst; clear H_handle.", "unfold pBody in H_pBody.", "inversion H_pBody; subst; clear H_pBody."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros net p t n pli plt es ci st' m H_reachable H_logs_sorted H_handle H_pBody H_In_p.", "unfold handleAppendEntries in H_handle.", "destruct (currentTerm (nwState net (pDst p)) <? t) eqn:term_cond.", "-", "inversion H_handle.", "shelve.", "-", "destruct (pli =? 0) eqn:pli_cond.", "+", "destruct (haveNewEntries (nwState net (pDst p)) es) eqn:new_entries_cond.", "*", "inversion H_handle; subst; clear H_handle.", "unfold pBody in H_pBody.", "inversion H_pBody; subst; clear H_pBody.", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros net p t n pli plt es ci st' m H_reachable H_logs_sorted H_handle H_pBody H_In_p. unfold handleAppendEntries in H_handle. destruct (currentTerm (nwState net (pDst p)) <? t) eqn:term_cond. - inversion H_handle. - destruct (pli =? 0) eqn:pli_cond. + destruct (haveNewEntries (nwState net (pDst p)) es) eqn:new_entries_cond. * inversion H_handle; subst; clear H_handle. subst. unfold pBody in H_pBody. inversion H_pBody; subst; clear H_pBody. pose proof handleAppendEntries_logs_sorted as H_sorted. specialize (H_sorted net p t n pli plt es ci st' m H_reachable H_logs_sorted H_handle eq_refl H_pBody H_In_p). apply H_sorted. * discriminate. + discriminate.", "succ": false}]