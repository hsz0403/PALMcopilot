[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface si : sorted_interface lmi : log_matching_interface smspi : state_machine_safety'interface rlmli : refined_log_matching_lemmas_interface pllsi : prevLog_leader_sublog_interface ctgt0 : current_term_gt_zero_interface lalcii : lastApplied_le_commitIndex_interface miaei : match_index_all_entries_interface lhlli : leaders_have_leaderLogs_interface lci : leader_completeness_interface lsi : leader_sublog_interface taifoli : terms_and_indices_from_one_log_interface glci : ghost_log_correct_interface lphogli : log_properties_hold_on_ghost_logs_interface glemi : ghost_log_entries_match_interface tci : transitive_commit_interface tsi : term_sanity_interface lhllsi : leaders_have_leaderLogs_strong_interface ollpti : one_leaderLog_per_term_interface rmri : raft_msg_refinement_interface h : name st : raft_data out : list raft_output st' : raft_data ms : list (name * msg) Heq : rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st))) = [] H : ([], RaftState.set_raft_data_lastApplied term name entry logIndex serverType data clientId output st (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st), []) = (out, st', ms) H1 : [] = out H2 : mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st) (stateMachine st) (nextIndex st) (matchIndex st) (shouldSend st) (votesReceived st) (type st) (clientCache st) (electoralVictories st) = st' H3 : [] = ms Unable to unify \"lastApplied st\" with \"lastApplied (mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (if lastApplied st <? commitIndex st then commitIndex st else lastApplied st) (stateMachine st) (nextIndex st) (matchIndex st) (shouldSend st) (votesReceived st) (type st) (clientCache st) (electoralVictories st))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros h st out st' ms H.", "unfold doGenericServer, applyEntries in H.", "destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq.", "-", "inversion H.", "left."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros h st out st' ms H. unfold doGenericServer, applyEntries in H. destruct (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) eqn:Heq. - inversion H. left. reflexivity. - destruct p as [out' st'']. inversion H; subst. right. split. + right. split; [auto |]. symmetry in Heq. apply filter_In in Heq. destruct Heq as [Hin Heq']. apply andb_true_iff in Heq'. destruct Heq' as [H1 H2]. apply Nat.ltb_lt in H1. apply Nat.leb_le in H2. apply findGtIndex_In in Hin. destruct Hin as [Hin _]. exists e. split; auto. + apply Nat.lt_le_incl. apply Nat.ltb_lt. auto.", "succ": false}]