[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros es h st os st' Happly.", "unfold applyEntries in Happly."], "tactic": "remember (rev (filter (fun x : entry => lastApplied st <? eIndex x <=? commitIndex st) (findGtIndex (log st) (lastApplied st)))).", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params aemi : applied_entries_monotonic_interface smci : state_machine_correct_interface si : sorted_interface lacimi : lastApplied_commitIndex_match_interface lmi : log_matching_interface client : clientId id : nat out : output es : list entry h : name st : raft_data os : list raft_output st' : raft_data Happly : (fix applyEntries (h : name) (st : raft_data) (entries : list entry) {struct entries} : list raft_output * raft_data := match entries with | [] => ([], st) | e :: es => let (out, st0) := cacheApplyEntry st e in let (out', state) := applyEntries h st0 es in ((if name_eq_dec (eAt e) h then map (fun o : output => ClientResponse (eClient e) (eId e) o) out else []) ++ out', state) end) h st es = (os, st') x : entry The term \"lastApplied st <? eIndex x\" has type \"bool\" while it is expected to have type \"nat\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros es h st os st' Happly. unfold applyEntries in Happly. remember (rev (filter (fun x : entry => lastApplied st <? eIndex x <=? commitIndex st) (findGtIndex (log st) (lastApplied st)))). destruct p as [out' state']. inversion Happly; subst; clear Happly. split. - reflexivity. - split; reflexivity.", "succ": false}]