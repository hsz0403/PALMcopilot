[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["apply Build_transitive_commit_interface.", "intros net H."], "tactic": "apply CommonTheorems.applyEntries_spec_ind in H.", "exn": "Unable to apply lemma of type \"applyEntries ?h ?st ?es = (?os, ?st') -> forall P : raft_data -> Prop, (forall (d : data) (cc : list (clientId * (nat * output))), P (RaftState.set_raft_data_clientCache term name entry logIndex serverType data clientId output (RaftState.set_raft_data_stateMachine term name entry logIndex serverType data clientId output ?st d) cc)) -> P ?st'\" on hypothesis of type \"refined_raft_intermediate_reachable net\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["apply Build_transitive_commit_interface.", "intros net H.", "intros P H0."], "tactic": "apply H in H0.", "exn": "Unable to apply lemma of type \"refined_raft_intermediate_reachable net\" on hypothesis of type \"entry\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["apply Build_transitive_commit_interface.", "intros net H.", "intros P H0."], "tactic": ["apply H0.", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}]}, "chat": [], "original": "apply Build_transitive_commit_interface. intros net H. apply CommonTheorems.applyEntries_spec_ind in H. intros P H0. apply H in H0. apply H0.", "succ": false}]