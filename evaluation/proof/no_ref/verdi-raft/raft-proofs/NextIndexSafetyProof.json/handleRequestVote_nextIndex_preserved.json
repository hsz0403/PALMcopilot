[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros st h h' t lli llt st' m HhandleRequestVote.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm st) eqn:Heq1.", "-", "inv HhandleRequestVote.", "unfold nextIndex_preserved.", "split; [auto|].", "split; [auto|]."], "tactic": "rewrite Heq1.", "exn": "Found no subterm matching \"t <? currentTerm st'\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros st h h' t lli llt st' m HhandleRequestVote.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm st) eqn:Heq1.", "-", "inv HhandleRequestVote.", "unfold nextIndex_preserved.", "split; [auto|].", "split; [auto|]."], "tactic": "apply le_refl.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params aersi : append_entries_reply_sublog_interface si : sorted_interface h : name h' : fin N t, lli, llt : nat st' : raft_data HhandleRequestVote : (st', RequestVoteReply (currentTerm st') false) = (st', RequestVoteReply (currentTerm st') false) Heq1 : (t <? currentTerm st') = true H : type st' = Leader Unable to unify \"?M1679 <= ?M1679\" with \"nextIndex st' = nextIndex st'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros st h h' t lli llt st' m HhandleRequestVote.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm st) eqn:Heq1.", "-", "inv HhandleRequestVote.", "unfold nextIndex_preserved.", "split; [auto|].", "split; [auto|]."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros st h h' t lli llt st' m HhandleRequestVote.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm st) eqn:Heq1.", "-", "inv HhandleRequestVote.", "unfold nextIndex_preserved.", "split; [auto|].", "split; [auto|].", "shelve.", "-"], "tactic": "destruct (leaderId (advanceCurrentTerm st t) || negb (currentTerm (advanceCurrentTerm st t) <? currentTerm st)) eqn:Heq2.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params aersi : append_entries_reply_sublog_interface si : sorted_interface st : RaftState.raft_data term name entry logIndex serverType data clientId output h : name h' : fin N t, lli, llt : nat st' : raft_data m : msg Heq1 : (t <? currentTerm st) = false HhandleRequestVote : (if (if leaderId (advanceCurrentTerm st t) then false else true) && moreUpToDate llt lli (maxTerm (log (advanceCurrentTerm st t))) (maxIndex (log (advanceCurrentTerm st t))) then match votedFor (advanceCurrentTerm st t) with | Some candidateId' => (advanceCurrentTerm st t, RequestVoteReply (currentTerm (advanceCurrentTerm st t)) (if fin_eq_dec N h' candidateId' then true else false)) | None => (RaftState.set_raft_data_votedFor term name entry logIndex serverType data clientId output (advanceCurrentTerm st t) (Some h'), RequestVoteReply (currentTerm (advanceCurrentTerm st t)) true) end else (advanceCurrentTerm st t, RequestVoteReply (currentTerm (advanceCurrentTerm st t)) false)) = (st', m) The term \"leaderId (advanceCurrentTerm st t)\" has type \"option name\" while it is expected to have type \"bool\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros st h h' t lli llt st' m HhandleRequestVote.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm st) eqn:Heq1.", "-", "inv HhandleRequestVote.", "unfold nextIndex_preserved.", "split; [auto|].", "split; [auto|].", "shelve.", "-"], "tactic": "apply handleRequestVote_type in HhandleRequestVote.", "exn": "Unable to apply lemma of type \"forall (st0 : RaftState.raft_data term name entry logIndex serverType data clientId output) (h0 : name) (h'0 : fin N) (t0 lli0 llt0 : nat) (st'0 : raft_data) (m0 : msg), handleRequestVote h0 st0 t0 h'0 lli0 llt0 = (st'0, m0) -> type st'0 = type st0 /\\\\ currentTerm st'0 = currentTerm st0 \\\\/ type st'0 = Follower\" on hypothesis of type \"(if (if leaderId (advanceCurrentTerm st t) then false else true) && moreUpToDate llt lli (maxTerm (log (advanceCurrentTerm st t))) (maxIndex (log (advanceCurrentTerm st t))) then match votedFor (advanceCurrentTerm st t) with | Some candidateId' => (advanceCurrentTerm st t, RequestVoteReply (currentTerm (advanceCurrentTerm st t)) (if fin_eq_dec N h' candidateId' then true else false)) | None => (RaftState.set_raft_data_votedFor term name entry logIndex serverType data clientId output (advanceCurrentTerm st t) (Some h'), RequestVoteReply (currentTerm (advanceCurrentTerm st t)) true) end else (advanceCurrentTerm st t, RequestVoteReply (currentTerm (advanceCurrentTerm st t)) false)) = (st', m)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros st h h' t lli llt st' m HhandleRequestVote.", "unfold handleRequestVote in HhandleRequestVote.", "destruct (t <? currentTerm st) eqn:Heq1.", "-", "inv HhandleRequestVote.", "unfold nextIndex_preserved.", "split; [auto|].", "split; [auto|].", "shelve.", "-"], "tactic": ["destruct HhandleRequestVote as [Htype | Htype].", ""], "exn": "Expects a disjunctive pattern with 1 branch or a conjunctive pattern made of 0 patterns.", "type": "num_branch_both", "handled": false}]}, "chat": [], "original": "intros st h h' t lli llt st' m HhandleRequestVote. unfold handleRequestVote in HhandleRequestVote. destruct (t <? currentTerm st) eqn:Heq1. - inv HhandleRequestVote. unfold nextIndex_preserved. split; [auto|]. split; [auto|]. rewrite Heq1. apply le_refl. - destruct (leaderId (advanceCurrentTerm st t) || negb (currentTerm (advanceCurrentTerm st t) <? currentTerm st)) eqn:Heq2. + apply handleRequestVote_type in HhandleRequestVote. destruct HhandleRequestVote as [Htype | Htype]. * destruct Htype as [Heq3 Heq4]. rewrite Heq3. rewrite Heq4. rewrite Heq2. split; [auto|]. split; [auto|]. unfold advanceCurrentTerm in Heq3. apply Nat.le_trans with (m:=currentTerm st). ++ apply le_trans with (m:=currentTerm st); [auto|]. apply le_maxTerm. ++ apply le_refl. * destruct Htype as [Heq3 Heq4]. rewrite Heq3. rewrite Heq4. rewrite Heq2. split; [auto|]. split; [auto|]. unfold advanceCurrentTerm in Heq3. rewrite Heq3. rewrite max_l; [auto|]. apply le_refl. + destruct (votedFor (advanceCurrentTerm st t)) eqn: Heq3. * apply handleRequestVote_reply_true in HhandleRequestVote. destruct HhandleRequestVote as [Heq_reply1 Heq_reply2]. destruct Heq_reply2 as [Heq_reply3 Heq_reply4]. apply handleRequestVote_votedFor in HhandleRequestVote. destruct HhandleRequestVote. ++ subst. contradict Heq3. apply andb_prop in Heq2. destruct Heq2; discriminate. ++ assert (currentTerm st = t /\\ votedFor st' = votedFor st) as Heq5 by auto. destruct Heq5 as [Heq5 Heq6]. rewrite Heq5, Heq6. split; [auto|]. split; [auto|]. unfold advanceCurrentTerm in Heq5. rewrite Heq5. rewrite max_l; [auto|]. apply le_refl. * apply handleRequestVote_reply_true' in HhandleRequestVote. destruct HhandleRequestVote as [Heq_reply1 Heq_reply2]. destruct Heq_reply2 as [Heq_reply3 Heq_reply4]. apply handleRequestVote_votedFor in HhandleRequestVote. destruct HhandleRequestVote. ++ subst. rewrite Heq_reply1. contradict Heq3. apply andb_prop in Heq2. destruct Heq2. discriminate. ++ assert (currentTerm st = t /\\ votedFor st' = votedFor st) as Heq5 by auto. destruct Heq5 as [Heq5 Heq6]. rewrite Heq5, Heq6. split; [auto|]. split; [auto|]. unfold advanceCurrentTerm in Heq5. rewrite Heq5. rewrite max_l; [auto|]. apply le_refl.", "succ": false}]