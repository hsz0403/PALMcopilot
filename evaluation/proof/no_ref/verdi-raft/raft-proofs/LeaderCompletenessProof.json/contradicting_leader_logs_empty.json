[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros net nodes t e H_in h H_in_nodes.", "unfold contradicting_leader_logs, contradicting_leader_logs_on_leader in H_in."], "tactic": "apply map_eq_nil in H_in.", "exn": "Unable to apply lemma of type \"forall (A B : Type) (f : A -> B) (l : list A), map f l = [] -> l = []\" on hypothesis of type \"(fix contradicting_leader_logs (net : network) (nodes : list Net.name) (t : nat) (e : entry) {struct nodes} : list (term * name * list entry) := match nodes with | [] => [] | h :: nodes' => map (fun l : nat * list entry => (fst l, h, snd l)) ((fix contradicting_leader_logs_on_leader (l : list (nat * list entry)) (t0 : nat) (e0 : entry) {struct l} : list (nat * list entry) := match l with | [] => [] | (t', log') :: l' => if sumbool_and (t0 < t') (~ t0 < t') (~ In e0 log') (In e0 log') (lt_dec t0 t') (sumbool_not (In e0 log') (~ In e0 log') (in_dec entry_eq_dec e0 log')) then (t', log') :: contradicting_leader_logs_on_leader l' t0 e0 else contradicting_leader_logs_on_leader l' t0 e0 end) (leaderLogs (fst (nwState net h))) t e) ++ contradicting_leader_logs net nodes' t e end) net nodes t e = []\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros net nodes t e H_in h H_in_nodes.", "unfold contradicting_leader_logs, contradicting_leader_logs_on_leader in H_in."], "tactic": "intros t' log' H_in_l H_gt.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros net nodes t e H_in h H_in_nodes. unfold contradicting_leader_logs, contradicting_leader_logs_on_leader in H_in. apply map_eq_nil in H_in. intros t' log' H_in_l H_gt. contradiction.", "succ": false}]