[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "elim expf_dec; intro Heq.", "exn": "Unable to find an instance for the variables m, x, y.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "elim H3; clear H3; intros H3 H3'.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "left; apply between_expf_L0_1; auto.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "right; left; apply between_expf_L0_2 with (i:=1); auto.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "elim H3; clear H3; intros H3 H3'.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "right; right; apply expf_L0_5 with (z:=z) (t:=t); auto.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3.", "unfold expf, inv_hmap, betweenf in *.", "elim H1; clear H1; intros H1 H1'."], "tactic": "left; apply expf_L0_6 with (z:=z) (t:=t); auto.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros m x y z t H1 H2 x0 x_1 y0 y_0_1 H3. unfold expf, inv_hmap, betweenf in *. elim H1; clear H1; intros H1 H1'. elim expf_dec; intro Heq. - elim H3; clear H3; intros H3 H3'. + left; apply between_expf_L0_1; auto. + right; left; apply between_expf_L0_2 with (i:=1); auto. - elim H3; clear H3; intros H3 H3'. + right; right; apply expf_L0_5 with (z:=z) (t:=t); auto. + left; apply expf_L0_6 with (z:=z) (t:=t); auto.", "succ": false}]