[{"history": {"proof": "intros m k x y Hmap Heqc. hfcrush use: cA_cA_1, exd_cA_1, eqc_exd_exd, eqc_symm, eqc_eqc_cA.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros m k x y Hmap Heqc.", "induction m.", "-", "contradiction.", "-", "simpl in Heqc.", "destruct Hmap.", "destruct H0.", "destruct H1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k x y Hmap Heqc.", "induction m.", "-", "contradiction.", "-", "simpl in Heqc.", "destruct Hmap.", "destruct H0.", "destruct H1.", "shelve.", "-", "simpl in Heqc.", "destruct Hmap.", "destruct H0.", "destruct H1.", "destruct H2."], "tactic": "apply (IHm H).", "exn": "In environment m : fmap d : dim d0, d1 : dart k : dim x, y : dart H : inv_hmap m H0 : exd m d0 H1 : exd m d1 H2 : ~ succ m d d0 H3 : ~ pred m d d1 /\\\\ cA m d d0 <> d1 Heqc : eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) y \\\\/ eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) d0 /\\\\ eqc m d1 y \\\\/ eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) d1 /\\\\ eqc m d0 y IHm : inv_hmap m -> eqc m (cA_1 m k x) y -> eqc m x y Unable to unify \"eqc m x y\" with \"eqc (L m d d0 d1) x y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k x y Hmap Heqc.", "induction m.", "-", "contradiction.", "-", "simpl in Heqc.", "destruct Hmap.", "destruct H0.", "destruct H1.", "shelve.", "-", "simpl in Heqc.", "destruct Hmap.", "destruct H0.", "destruct H1.", "destruct H2."], "tactic": "apply Heqc.", "exn": "In environment m : fmap d : dim d0, d1 : dart k : dim x, y : dart H : inv_hmap m H0 : exd m d0 H1 : exd m d1 H2 : ~ succ m d d0 H3 : ~ pred m d d1 /\\\\ cA m d d0 <> d1 Heqc : eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) y \\\\/ eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) d0 /\\\\ eqc m d1 y \\\\/ eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) d1 /\\\\ eqc m d0 y IHm : inv_hmap m -> eqc m (cA_1 m k x) y -> eqc m x y Unable to unify \"eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) y \\\\/ eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) d0 /\\\\ eqc m d1 y \\\\/ eqc m (if eq_dim_dec d k then if eq_dart_dec d1 x then d0 else if eq_dart_dec (cA m k d0) x then cA_1 m k d1 else cA_1 m k x else cA_1 m k x) d1 /\\\\ eqc m d0 y\" with \"eqc (L m d d0 d1) x y\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m k x y Hmap Heqc. induction m. - contradiction. - simpl in Heqc. destruct Hmap. destruct H0. destruct H1. destruct H2. destruct Heqc as [H3 | Heqc']. + inversion H3. apply H5. + apply (IHm H). apply Heqc'. - simpl in Heqc. destruct Hmap. destruct H0. destruct H1. destruct H2. apply (IHm H). apply Heqc.", "succ": true}]