[{"history": {"proof": "intros m k j x z Hmap Hneq. strivial use: cA_cA_1_B_ter.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B."], "tactic": "destruct Hmap.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst."], "tactic": "reflexivity.", "exn": "In environment m : fmap j : dim z : dart Hmap : inv_hmap m Hneq : zero <> j Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero z) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*"], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst."], "tactic": "reflexivity.", "exn": "In environment m : fmap j : dim z : dart Hmap : inv_hmap m n : one <> zero Hneq : one <> j Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m one z) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "shelve.", "+", "destruct (eq_dim_dec k one).", "*", "destruct (eq_dart_dec x z).", "++", "subst.", "shelve.", "++"], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros m k j x z Hmap Hneq. unfold cA, B. destruct Hmap. unfold cA, cA_1 in *. destruct (eq_dim_dec k zero). + destruct (eq_dart_dec x z). * subst. reflexivity. * destruct (eq_dart_dec (cA_1 m0 zero z) z) as [H1 | H1]. ++ rewrite H1. reflexivity. ++ rewrite H1. apply cA_cA_1; auto. + destruct (eq_dim_dec k one). * destruct (eq_dart_dec x z). ++ subst. reflexivity. ++ destruct (eq_dart_dec (cA_1 m0 one z) z) as [H2 | H2]. -- rewrite H2. reflexivity. -- rewrite H2. apply cA_cA_1; auto. * destruct (eq_dim_dec k k0). ++ destruct (eq_dart_dec x0 x). -- reflexivity. -- destruct (eq_dart_dec x0 z). ** subst. reflexivity. ** destruct (eq_dim_dec k0 zero). --- rewrite not_exd_cA; try auto. apply cA_exd; auto. --- reflexivity. ++ destruct (eq_dim_dec k k0). -- destruct (eq_dart_dec x0 x). ** reflexivity. ** destruct (eq_dart_dec x0 z). --- subst. reflexivity. --- destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. +++ rewrite H2. reflexivity. +++ rewrite H2. apply cA_cA_1; auto. -- destruct (eq_dim_dec k k0). ** destruct (eq_dart_dec x0 x). --- reflexivity. --- destruct (eq_dart_dec x0 z). +++ subst. unfold cA. rewrite not_exd_cA; try auto. apply cA_exd; auto. +++ destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. ++++ rewrite H2. reflexivity. ++++ rewrite H2. apply cA_cA_1; auto. ** simpl. destruct (eq_dart_dec x0 x); try reflexivity. destruct (eq_dart_dec x0 z); try reflexivity. destruct (eq_dart_dec (cA_1 (B m0 k0 x) k z) z0); try reflexivity. destruct (eq_dim_dec k0 zero); try reflexivity. destruct (eq_dart_dec x0 z0); try reflexivity. destruct (eq_dart_dec (cA_1 m0 zero z0) z); try reflexivity. apply cA_cA_1; auto.", "succ": true}]