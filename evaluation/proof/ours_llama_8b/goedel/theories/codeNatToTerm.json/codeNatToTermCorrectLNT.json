[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nYour Response:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\nYour Response:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nNone\n\nGoal:\nforall n : nat, codeNatToTerm n = codeTerm LNT codeLNTFunction (natToTermLNT n)\n\nPremises:\nLNT = {| Relations := Empty_set; Functions := LNTFunction; arity := LNTArity |} : Language\nnatToTermLNT = LNT.natToTerm : nat -> LNT.Term Arguments natToTermLNT _%nat_scope\ncodeTerm : forall L : Language, (Functions L -> nat) -> Term L -> nat\ncodeLNTFunction = fun f : LNTFunction => match f with | Plus => 0 | Times => 1 | Succ => 2 | Zero => 3 end : LNTFunction -> nat\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\ncodeNatToTerm = nat_rec (fun _ : nat => nat) (cPair 4 0) (fun _ rec : nat => cPair 3 (S (cPair rec 0))) : nat -> nat Arguments codeNatToTerm _%nat_scope\ncodeNatToTermCorrectLNN : forall n : nat, codeNatToTerm n = codeTerm LNN codeLNTFunction (natToTermLNN n)\ncodeArityLNTFIsCorrect2 : forall n : nat, codeArityLNTF n <> 0 -> exists f : Functions LNT, codeLNTFunction f = n\ncodeArityLNNFIsCorrect2 : forall n : nat, codeArityLNTF n <> 0 -> exists f : Functions LNN, codeLNTFunction f = n\nNat.ones_equiv : forall n : nat, Nat.ones n = Nat.pred (2 ^ n)\nNat.lxor_spec : forall a b n : nat, Nat.testbit (Nat.lxor a b) n = xorb (Nat.testbit a n) (Nat.testbit b n)\nNat.div2_bits : forall a n : nat, Nat.testbit (a / 2) n = Nat.testbit a (S n)\ncodeLNTFunctionInj : forall f g : LNTFunction, codeLNTFunction f = codeLNTFunction g -> f = g\nNat.compare_antisym : forall n m : nat, (m ?= n) = CompOpp (n ?= m)\nNat.lnot_lxor_r : forall a b n : nat, Nat.lnot (Nat.lxor a b) n = Nat.lxor a (Nat.lnot b n)\nNat.lnot_spec_high : forall a n m : nat, n <= m -> Nat.testbit (Nat.lnot a n) m = Nat.testbit a m\nNat.gcd_mul_mono_l : forall n m p : nat, Nat.gcd (p * n) (p * m) = p * Nat.gcd n m\nNat.lnot_spec_low : forall a n m : nat, m < n -> Nat.testbit (Nat.lnot a n) m = negb (Nat.testbit a m)\nNat.shiftl_shiftl : forall a n m : nat, Nat.shiftl (Nat.shiftl a n) m = Nat.shiftl a (n + m)\ncodeTermInj : forall (L : Language) (codeF : Functions L -> nat), (forall f g : Functions L, codeF f = codeF g -> f = g) -> forall t s : Term L, codeTerm L codeF t = codeTerm L codeF s -> t = s\nList.repeat_length : forall (A : Type) (x : A) (n : nat), length (List.repeat x n) = n\neq_add_S : forall n m : nat, S n = S m -> n = m\nNat.min_max_absorption : forall n m : nat, Nat.max n (Nat.min n m) = n\nNat.bits_inj_0 : forall a : nat, (forall n : nat, Nat.testbit a n = false) -> a = 0\nNat.mul_0_l : forall n : nat, 0 * n = 0\nNat.gcd_1_l : forall n : nat, Nat.gcd 1 n = 1\nNat.mul_0_r : forall n : nat, n * 0 = 0\nNat.mul_comm : forall n m : nat, n * m = m * n\nNat.add_comm : forall n m : nat, n + m = m + n\nNat.max_l : forall n m : nat, m <= n -> Nat.max n m = n\nNat.add_cancel_r : forall n m p : nat, n + p = m + p < -> n = m\nNat.compare_eq_iff : forall n m : nat, (n ?= m) = Eq < -> n = m\nNat.eq_dne : forall n m : nat, ~ n <> m < -> n = m\nNat.mul_succ_r : forall n m : nat, n * S m = n * m + n\nNat.shiftl_mul_pow2 : forall a n : nat, Nat.shiftl a n = a * 2 ^ n\nmax_r : forall n m : nat, n <= m -> Init.Nat.max n m = m"}, {"role": "assistant", "content": "```coq\nTheorem goal : forall n : nat, codeNatToTerm n = codeTerm LNT codeLNTFunction (natToTermLNT n).\nProof.\n  intros n.\n  induction n as [|n' IHn'].\n  - simpl. reflexivity.\n  - simpl. rewrite <- IHn'. rewrite codeNatToTermCorrectLNN. auto.\nQed."}], "original": "", "succ": false}]