[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nT: lattice\nf: T -> T\n\nGoal:\nmonotone f -> f (tarski_lfp f) = tarski_lfp f\n\nPremises:\ntarski_lfp : forall T : lattice, (T -> T) -> T\nmonotone : forall T1 T2 : poset, (T1 -> T2) -> Prop\nproj3_sig_eq : forall p : ?u = ?v, eq_rect (sval (Specif.sig_of_sig2 ?u)) [eta ?Q] (proj3_sig ?u) (sval (Specif.sig_of_sig2 ?v)) (proj1_sig_of_sig2_eq p) = proj3_sig ?v where ?A : [T : lattice f : T -> T |- Type] ?P : [T : lattice f : T -> T |- ?A -> Prop] ?Q : [T : lattice f : T -> T |- ?A -> Prop] ?u : [T : lattice f : T -> T |- {a : ?A | ?P a & ?Q a}] ?v : [T : lattice f : T -> T |- {a : ?A | ?P a & ?Q a}]\nprojT2_of_sigT2_eq : forall p : ?u = ?v, eq_rect (projT1 (sigT_of_sigT2 ?u)) [eta ?P] (projT2 (sigT_of_sigT2 ?u)) (projT1 (sigT_of_sigT2 ?v)) (projT1_of_sigT2_eq p) = projT2 (sigT_of_sigT2 ?v) where ?A : [T : lattice f : T -> T |- Type] ?P : [T : lattice f : T -> T |- ?A -> Type] ?Q : [T : lattice f : T -> T |- ?A -> Type] ?u : [T : lattice f : T -> T |- {a : ?A & ?P a & ?Q a}] ?v : [T : lattice f : T -> T |- {a : ?A & ?P a & ?Q a}]\neq_sig_hprop : (forall (x : ?A) (p q : ?P x), p = q) -> forall u v : {a : ?A | ?P a}, sval u = sval v -> u = v where ?A : [T : lattice f : T -> T |- Type] ?P : [T : lattice f : T -> T |- ?A -> Prop]\neq_sig : forall (u v : {a : ?A | ?P a}) (p : sval u = sval v), eq_rect (sval u) [eta ?P] (proj2_sig u) (sval v) p = proj2_sig v -> u = v where ?A : [T : lattice f : T -> T |- Type] ?P : [T : lattice f : T -> T |- ?A -> Prop]\nBinInt.Z.are_bits : forall f : BinNums.Z -> bool, Morphisms.Proper (Morphisms.respectful eq eq) f -> (exists n : BinNums.Z, forall m : BinNums.Z, BinInt.Z.le BinNums.Z0 m -> f m = BinInt.Z.testbit n m) < -> (exists k : BinNums.Z, forall m : BinNums.Z, BinInt.Z.le k m -> f m = f k)\nBinNat.N.eqf = fun f g : BinNums.N -> bool => forall n : BinNums.N, f n = g n : (BinNums.N -> bool) -> (BinNums.N -> bool) -> Prop Arguments BinNat.N.eqf (_ _)%function_scope\nsup_closed = fun T : lattice => [Pred s | forall d : Pred_Class, d <=p s -> sup d \\In s] : forall T : lattice, Simpl_Pred (Pred T) Arguments sup_closed {T}\nLattice.poset = fun cT : lattice => Poset.Pack (Lattice.class cT) cT : lattice -> poset Lattice.poset is a coercion\nLattice.sort = fun t : lattice => let (sort, _, _) := t in sort : lattice -> Type Lattice.sort is a coercion\nlbot = fun T : lattice => sup Pred0 : forall T : lattice, T Arguments lbot {T}\nPred = fun T : Type => T -> Prop : Type -> Type Arguments Pred _%type_scope\nLattice.Pack : forall sort : Type, Lattice.class_of sort -> Type -> lattice\nindex = fun (T : eqType) (x : T) => find (pred1 x) : forall T : eqType, T -> seq T -> nat Arguments index {T} _ _%seq_scope\nLattice.sup = fun cT : lattice => [eta Lattice.mx_sup (Lattice.mixin (Lattice.class cT))] : forall cT : lattice, Pred cT -> cT Arguments Lattice.sup {cT}\nsup_closure = fun (T : lattice) (s : Pred T) => [Pred p | forall t : Pred T, s <=p t -> t \\In sup_closed -> p \\In t] : forall T : lattice, Pred T -> Simpl_Pred T Arguments sup_closure {T}\nLattice.mx_sup : forall T : poset, Lattice.mixin_of T -> Pred T -> T\nInMem : forall T : Type, T -> Mem_Pred T -> Prop\nEqMem : forall T : Type, Mem_Pred T -> Mem_Pred T -> Prop\nSubMem : forall T : Type, Mem_Pred T -> Mem_Pred T -> Prop\ntarski_gfp : forall T : lattice, (T -> T) -> T\nnth = fun (T : Type) (x0 : T) => fix nth (s : seq T) (n : nat) {struct n} : T := match s with | [::] => x0 | x :: s' => match n with | 0 => x | n'.+1 => nth s' n' end end : forall T : Type, T -> seq T -> nat -> T Arguments nth {T}%type_scope _ _%seq_scope _%nat_scope\nshape = fun T : Type => map size : forall T : Type, seq (seq T) -> seq nat Arguments shape {T}%type_scope _%seq_scope\nRecord mixin_of (T : Type) : Type := Mixin { mx_leq : T -> T -> Prop; _ : forall x : T, mx_leq x x; _ : forall x y : T, mx_leq x y -> mx_leq y x -> x = y; _ : forall x y z : T, mx_leq x y -> mx_leq y z -> mx_leq x z } Arguments Poset.mixin_of _%type_scope Arguments Poset.Mixin [T]%type_scope [mx_leq]%function_scope (_ _ _)%function_scope\ninf : forall T : lattice, Pred T -> T\nLattice.clone : forall (T : Type) (cT : lattice) (c : Lattice.class_of T), phant_id (Lattice.class cT) c -> lattice\ndrop = fun T : Type => fix drop (n : nat) (s : seq T) {struct s} : seq T := match s with | [::] => s | _ :: s' => match n with | 0 => s | n'.+1 => drop n' s' end end : forall T : Type, nat -> seq T -> seq T Arguments drop {T}%type_scope _%nat_scope _%seq_scope\nPoset.Class : forall T : Type, Poset.mixin_of T -> Poset.class_of T\nSimplPred : forall T : Type, Pred T -> Simpl_Pred T\nPred_of_Simpl : forall T : Type, Simpl_Pred T -> Pred T\nLattice.base : forall T : Type, Lattice.class_of T -> Poset.class_of T"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]