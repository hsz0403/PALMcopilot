[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nthis: nid\nW: world\nB: Type\nA: Type\ne1: DT this W A\ne2: A -> DT this W B\n\nGoal:\nbnd_prog (code_of e1) (fun x : A => let y := e2 x in code_of y) \\In has_spec this W bind_s\n\nPremises:\nInductive DT (this : nid) (W : world) (A : Type) : Type := with_spec : forall s : spec A, DTbin this W s -> DT this W A Arguments DT _ _ _%type_scope Arguments with_spec [this W] [A]%type_scope [s]\nbnd_prog = fun (T : prog W A this) (K : A -> prog W B this) => Prog (or_introl (erefl Unfinished)) : prog W A this -> (A -> prog W B this) -> prog W B this Arguments bnd_prog _ _%function_scope\ncode_of : forall (this : nid) (W : world) (A : Type) (e : DT this W A), DTbin this W (spec_of e)\nhas_spec : forall (this : nid) (W : world) (A : Type), spec A -> Simpl_Pred (prog W A this)\nList.In : forall A : Type, A -> seq A -> Prop\nsnd = fun (A B : Type) (p : A * B) => let (_, y) := p in y : forall A B : Type, A * B -> B Arguments snd {A B}%type_scope\nbnd_set = fun (T : prog W A this) (K : A -> prog W B this) (t : proc this W B) => t = Unfinished \\/ (exists t' : proc this W A, t \\In pcat t' (fun x : A => K x) /\\ t' \\In T) : prog W A this -> (A -> prog W B this) -> proc this W B -> Prop Arguments bnd_set _ _%function_scope\nInE : forall T : Type, (forall x y : T, x \\In [:: y] <-> x = y) * (forall (y : T) (s : seq T) (x : T), x \\In y :: s <-> x = y \\/ x \\In s) * (forall (T0 : Type) (x : T0) (p : Simpl_Pred T0), (x \\In p) = p x)\nret_has_spec : forall (this : nid) (W : world) (A : Type) (x : A), ret_prog this W x \\In has_spec this W (ret_s this W x)\nact : forall (this : nid) (W : world) (A : Type), action W A this -> DT this W A\nbind_s = (fun i : state => s1.1 i /\\ (forall (x : A) (s : state), s1.2 i x s -> (s2 x).1 s), fun (i : state) (y : B) (m : state) => exists (x : A) (s : state), s1.2 i x s /\\ (s2 x).2 s y m) : spec B\nret : forall (this : nid) (W : world) (A : Type), A -> DT this W A\nDT_sind : forall (this : nid) (W : world) (A : Type) (P : DT this W A -> SProp), (forall (s : spec A) (d : DTbin this W s), P (with_spec d)) -> forall d : DT this W A, P d\nDT_rec : forall (this : nid) (W : world) (A : Type) (P : DT this W A -> Set), (forall (s : spec A) (d : DTbin this W s), P (with_spec d)) -> forall d : DT this W A, P d\nDT_ind : forall (this : nid) (W : world) (A : Type) (P : DT this W A -> Prop), (forall (s : spec A) (d : DTbin this W s), P (with_spec d)) -> forall d : DT this W A, P d\nDT_rect : forall (this : nid) (W : world) (A : Type) (P : DT this W A -> Type), (forall (s : spec A) (d : DTbin this W s), P (with_spec d)) -> forall d : DT this W A, P d\nspec_of : forall (this : nid) (W : world) (A : Type), DT this W A -> spec A\npost_of : forall (this : nid) (W : world) (A : Type), DT this W A -> post A\nfst = fun (A B : Type) (p : A * B) => let (x, _) := p in x : forall A B : Type, A * B -> A Arguments fst {A B}%type_scope\nwith_spec : forall (this : nid) (W : world) (A : Type) (s : spec A), DTbin this W s -> DT this W A\npre_of : forall (this : nid) (W : world) (A : Type), DT this W A -> pre\npredC_morph : forall (T : Type) (x y : Pred_Class), x <~> y -> PredC x <~> PredC y\nIn_cons : forall (T : Type) (y : T) (s : seq T) (x : T), x \\In y :: s < -> x = y \\/ x \\In s\nMem_Seq1 : forall (T : Type) (x y : T), x \\In [:: y] < -> x = y\nverify : forall (this : nid) (W : world) (A : Type), state -> DT this W A -> (A -> state -> Prop) -> Prop\npredI_morph : forall (T : Type) (x y : Pred_Class), x <~> y -> forall x0 y0 : Pred_Class, x0 <~> y0 -> PredI x x0 <~> PredI y y0\nDTbin_make : forall (this : nid) (W : world) (A : Type) (s : spec A) (prog_of : prog W A this), prog_of \\In has_spec this W s -> DTbin this W s\nDTLattice.bot_spec : forall (this : nid) (W : world) (A : Type) (s : spec A), DTLattice.bot_prg this W A \\In has_spec this W s\nalw_bnd : forall (this : nid) (W : world) (A B : Type) (p1 : proc this W A) (p12 : proc this W B) (pp2 : A -> Pred (proc this W B)) (s1 : state) (P : state -> B -> Prop), p12 \\In pcat p1 pp2 -> always s1 p1 (fun (s2 : state) (p2 : proc this W A) => forall (p : proc this W B) (v : A), p2 = Ret v -> p \\In pp2 v -> always s2 p (fun (s : state) (q : proc this W B) => forall v0 : B, q = Ret v0 -> P s v0)) -> always s1 p12 (fun (s : state) (p : proc this W B) => forall v : B, p = Ret v -> P s v)\nalwsafe_bnd : forall (this : nid) (W : world) (A B : Type) (p1 : proc this W A) (p12 : proc this W B) (s1 : state) (pp2 : A -> Pred (proc this W B)), p12 \\In pcat p1 pp2 -> always s1 p1 (fun (s2 : state) (p2 : proc this W A) => forall (p : proc this W B) (v : A), p2 = Ret v -> p \\In pp2 v -> alwsafe s2 p) -> alwsafe s1 p12\nact_has_spec : forall (this : nid) (W : world) (A : Type) (a : action W A this), act_prog a \\In has_spec this W (act_s a)\naft_bnd : forall (this : nid) (W : world) (A B : Type) (p1 : proc this W A) (p12 : proc this W B) (pp2 : A -> Pred (proc this W B)) (s1 : state) (P : B -> state -> Prop), p12 \\In pcat p1 pp2 -> after s1 p1 (fun (v : A) (s : state) => forall p : proc this W B, p \\In pp2 v -> after s p P) -> after s1 p12 P\nstsepE : forall (this : nid) (W : world) (A : Type) (s : spec A) (e1 e2 : DTbin this W s), e1 = e2 < -> e1 = e2\nImage_mem : forall (A B : Type) (f : A -> B) (P : Pred A) (x : A), x \\In P -> f x \\In [Image f i | i <- P]\nInductive proc (this : nid) (W : world) (A : Type) : Type := Unfinished : proc this W A | Ret : A -> proc this W A | Act : action W A this -> proc this W A | Seq : forall B : Type, proc this W B -> (B -> proc this W A) -> proc this W A | Inject : forall (V : world) (K : hooks), injects V W K -> proc this V A ->...-> proc this W A Arguments proc _ _ _%type_scope Arguments Unfinished {this W} {A}%type_scope Arguments Ret [this W] [A]%type_scope Arguments Act [this W] [A]%type_scope Arguments Seq [this W] [A B]%type_scope _ _%function_scope Arguments Inject [this W] [A]%type_scope [V K] Arguments WithInv [this W] [A]%type_scope _ _%function_scope"}, {"role": "assistant", "content": "```coq\nRequire Import List.\n\nImport nid_world_type_type_pred_class_pred_spec_state_action_proc_hooks_world_list_seq_seq_pred_prop_pred_class_pred_class_pred_spec_type_set_prop_type.\n\nLemma goal :\n  bnd_prog (code_of e1) (fun x : A => let y := e2 x in code_of y) \\In has_spec this W bind_s.\nProof.\n  unfold bnd_prog, has_spec, bind_s.\n  intros.\n  destruct e1 as [s1 [s2]].\n  destruct e2 as [s3 [s4]].\n  simpl.\n  constructor.\n  - eapply ret_has_spec.\n  - eapply act_has_spec.\n  - eapply DT_sind.\n    + intros.\n      eauto.\n  - eauto.\nQed."}], "original": "Require Import List.", "succ": false}]