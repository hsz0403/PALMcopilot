[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nYour Response:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\nYour Response:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nNone\n\nGoal:\nprop_extensionality\n\nPremises:\next_prop_dep_proof_irrel_cic = fun pe : prop_extensionality => ext_prop_dep_proof_irrel_gen boolP trueP falseP boolP_ind boolP_elim_redl boolP_elim_redr pe boolP_indd : prop_extensionality -> proof_irrelevance\nprovable_prop_ext = PropExtensionalityFacts.PropExt_imp_ProvPropExt : prop_extensionality -> provable_prop_extensionality\next_prop_fixpoint : prop_extensionality -> forall A : Prop, A -> has_fixpoint A\nprop_ext_A_eq_A_imp_A : prop_extensionality -> forall A : Prop, A -> (A -> A) = A\nprop_ext_retract_A_A_imp_A : prop_extensionality -> forall A : Prop, A -> retract A (A -> A)\next_prop_dep_proof_irrel_cc = ext_prop_dep_proof_irrel_gen BoolP TrueP FalseP BoolP_elim BoolP_elim_redl BoolP_elim_redr : prop_extensionality -> BoolP_dep_induction -> proof_irrelevance\nprop_extensionality = forall A B : Prop, A < -> B -> A = B : Prop\nprop_ext_em_degen = fun (Ext : prop_extensionality) (EM : excluded_middle) (A : Prop) => let o : A \\/ ~ A := EM A in match o with | or_introl H => or_introl (Ext A True (conj (fun _ : A => I) (fun _ : True => H))) | or_intror H => or_intror (Ext A False (conj H (False_ind A))) end : prop_extensionality -> excluded_middle -> prop_degeneracy\next_prop_dep_proof_irrel_gen : forall (bool : Prop) (true false : bool) (bool_elim : forall C : Prop, C -> C -> bool -> C), (forall (C : Prop) (c1 c2 : C), c1 = bool_elim C c1 c2 true) -> (forall (C : Prop) (c1 c2 : C), c2 = bool_elim C c1 c2 false) -> prop_extensionality -> (forall P : bool -> Prop, P true -> P false -> forall b : bool, P b) -> proof_irrelevance\naux : forall (bool : Prop) (true false : bool) (bool_elim : forall C : Prop, C -> C -> bool -> C), (forall (C : Prop) (c1 c2 : C), c1 = bool_elim C c1 c2 true) -> (forall (C : Prop) (c1 c2 : C), c2 = bool_elim C c1 c2 false) -> prop_extensionality -> (forall P : bool -> Prop, P true -> P false -> forall b : bool, P b) -> true = false\nprop_degen_ext = fun (H : prop_degeneracy) (A B : Prop) (H0 : A <-> B) => match H0 with | conj Hab Hba => let o : A = True \\/ A = False := H A in match o with | or_introl H1 => let o0 : B = True \\/ B = False := H B in match o0 with | or_introl H2 => eq_ind_r (fun B0 : Prop => A = B0) H1 H2 | or_intror H2 => False_ind (A = B) (eq_ind_r (fun B0 : Prop => ~ B0) (fun H3 : False => H3) H2 (Hab (eq_ind_r (fun A0 : Prop => A0) I H1))) end | or_intror H1 => let o0 : B = True \\/ B = False := H B in match o0 with | or_introl H2 => False_ind (A = B) (eq_ind_r (fun A0 : Prop => ~ A0)...\nZ.add_le_mono_r : forall n m p : Z, (n <= m)%Z < -> (n + p <= m + p)%Z\nField_theory.NPEpow : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> bool) -> Ring_polynom.PExpr C -> N -> Ring_polynom.PExpr C\nZ.compare_spec : forall x y : Z, CompareSpec (x = y) (x < y)%Z (y < x)%Z (x ?= y)%Z\nPos.lt_succ_r : forall p q : positive, (p < Pos.succ q)%positive < -> (p <= q)%positive\nFSetPositive.PositiveSet.In = fun (i : FSetPositive.PositiveSet.elt) (t : FSetPositive.PositiveSet.t) => FSetPositive.PositiveSet.mem i t = true : FSetPositive.PositiveSet.elt -> FSetPositive.PositiveSet.t -> Prop\nN.log2_succ_le : forall a : N, (N.log2 (N.succ a) <= N.succ (N.log2 a))%N\nInductive prod (A B : Type) : Type := pair : A -> B -> A * B For pair: Arguments A, B are implicit and maximally inserted For prod: Argument scopes are [type_scope type_scope] For pair: Argument scopes are [type_scope type_scope _ _]\nsum_rect : forall (A B : Type) (P : A + B -> Type), (forall a : A, P (inl a)) -> (forall b : B, P (inr b)) -> forall s : A + B, P s\nBinPosDef.Pos.mul = fix mul (x y : positive) {struct x} : positive := match x with | (p~1)%positive => (y + (mul p y)~0)%positive | (p~0)%positive => ((mul p y)~0)%positive | 1%positive => y end : positive -> positive -> positive Argument scopes are [positive_scope positive_scope]\nBool.eqb = fun b1 b2 : bool => if b1 then if b2 then true else false else if b2 then false else true : bool -> bool -> bool Argument scopes are [bool_scope bool_scope]\nssrbool.idP = fun b1 : bool => if b1 as b return (Bool.reflect (is_true b) b) then Bool.ReflectT (is_true true) ssrbool.is_true_true else Bool.ReflectF (is_true false) ssrbool.not_false_is_true : forall b1 : bool, Bool.reflect (is_true b1) b1 Argument b1 is implicit and maximally inserted Argument scope is [bool_scope]\nBinIntDef.Z.of_N = fun n : N => match n with | 0%N => 0%Z | N.pos p => Z.pos p end : N -> Z Argument scope is [N_scope]\nInductive bool : Set := true : bool | false : bool\nZ.mul_0_l : forall n : Z, (0 * n)%Z = 0%Z\nZ.mul_wd = Morphisms.reflexive_proper Z.mul : Morphisms.Proper (Morphisms.respectful Z.eq (Morphisms.respectful Z.eq Z.eq)) Z.mul\nZ.add_le_mono_l : forall n m p : Z, (n <= m)%Z < -> (p + n <= p + m)%Z\nOrderedRing.sor_setoid : forall (R : Type) (rO rI : R) (rplus rtimes rminus : R -> R -> R) (ropp : R -> R) (req rle rlt : R -> R -> Prop), OrderedRing.SOR rO rI rplus rtimes rminus ropp req rle rlt -> RelationClasses.Equivalence req\nOrderedRing.sor_setoid_Reflexive : forall (R : Type) (rO rI : R) (rplus rtimes rminus : R -> R -> R) (ropp : R -> R) (req rle rlt : R -> R -> Prop), OrderedRing.SOR rO rI rplus rtimes rminus ropp req rle rlt -> RelationClasses.Reflexive req\nInductive byte : Set := x00 : Byte.byte | x01 : Byte.byte | x02 : Byte.byte | x03 : Byte.byte | x04 : Byte.byte | x05 : Byte.byte | x06 : Byte.byte | x07 : Byte.byte | x08 : Byte.byte | x09 : Byte.byte | x0a : Byte.byte | x0b : Byte.byte | x0c : Byte.byte | x0d : Byte.byte | x0e : Byte.byte | x0f : Byte.byte | x10 : Byte.byte | x11 : Byte.byte | x12 : Byte.byte | x13 : Byte.byte | x14 : Byte.byte | x15 : Byte.byte | x16 : Byte.byte | x17 : Byte.byte | x18 : Byte.byte | x19 : Byte.byte | x1a : Byte.byte | x1b : Byte.byte | x1c : Byte.byte | x1d : Byte.byte | x1e : Byte.byte | x1f : Byte.byte | x20 : Byte.byte | x21 : Byte.byte | x22 : Byte.byte..."}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]