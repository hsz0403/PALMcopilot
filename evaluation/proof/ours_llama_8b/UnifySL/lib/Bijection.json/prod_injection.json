[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nYour Response:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\nYour Response:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nA1: Type\nB1: Type\nA2: Type\nB2: Type\nR1: injection A1 B1\nR2: injection A2 B2\n\nGoal:\ninjection (A1 * A2) (B1 * B2)\n\nPremises:\nRecord injection (A B : Type) : Type := Build_injection { inj_R : A -> B -> Prop; im_inj : image_defined inj_R; pf_inj : partial_functional inj_R; in_inj : injective inj_R } For injection: Argument scopes are [type_scope type_scope] For Build_injection: Argument scopes are [type_scope type_scope function_scope _ _ _]\nssrfun.tagged2 : forall w : {x : ?I & ?T_ x & ?U_ x}, ?T_ (ssrfun.tag2 w) where ?I : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- Type] ?T_ : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- ?I -> Type] ?U_ : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- ?I -> Type]\nssrfun.tagged2' : forall w : {x : ?I & ?T_ x & ?U_ x}, ?U_ (ssrfun.tag2 w) where ?I : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- Type] ?T_ : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- ?I -> Type] ?U_ : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- ?I -> Type]\nssrfun.Tagged : forall T_ : ?I -> Type, T_ ?i -> {x0 : ?I & T_ x0} where ?I : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- Type] ?i : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- ?I]\nVectorSpec.uncons_cons : forall (a : ?A) (v : VectorDef.t ?A ?n), VectorDef.uncons (VectorDef.cons ?A a ?n v) = (a, v) where ?A : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- Type] ?n : [A1 : Type B1 : Type A2 : Type B2 : Type R1 : injection A1 B1 R2 : injection A2 B2 |- nat]\nim_inj : forall (A B : Type) (i : injection A B), image_defined i\npf_inj : forall (A B : Type) (i : injection A B), partial_functional i\nin_inj : forall (A B : Type) (i : injection A B), injective i\ninj_R : forall A B : Type, injection A B -> A -> B -> Prop\nsum_injection = fun (A1 B1 A2 B2 : Type) (R1 : injection A1 B1) (R2 : injection A2 B2) => {| inj_R := fun (a : A1 + A2) (b : B1 + B2) => match a with | inl a0 => match b with | inl b0 => R1 a0 b0 | inr _ => False end | inr a0 => match b with | inl _ => False | inr b0 => R2 a0 b0 end end; im_inj := fun a : A1 + A2 => match a as s return (exists b : B1 + B2, match s with | inl a0 => match b with | inl b0 => R1 a0 b0 | inr _ => False end | inr a0 => match b with | inl _ => False | inr b0 => R2 a0 b0 end end) with | inl a0 => let e :...\nFBuild_injection : forall (A B : Type) (f : A -> B), function_injective f -> injection A B\nBuild_injection : forall (A B : Type) (inj_R : A -> B -> Prop), image_defined inj_R -> partial_functional inj_R -> injective inj_R -> injection A B\ninjection_trans = fun (A B C : Type) (R1 : injection A B) (R2 : injection B C) => {| inj_R := fun (a : A) (c : C) => exists b : B, R1 a b /\\ R2 b c; im_inj := fun a : A => let e : exists b : B, R1 a b := im_inj A B R1 a in match e with | ex_intro _ b H => let e0 : exists b0 : C, R2 b b0 := im_inj B C R2 b in match e0 with | ex_intro _ c H0 => ex_intro (fun b0 : C => exists b1 : B, R1 a b1 /\\ R2 b1 b0) c (ex_intro (fun b0 : B => R1 a b0 /\\ R2 b0 c) b (conj H H0)) end end; pf_inj := fun (a : A) (c1 c2 : C) (H : exists b...\nList.split : forall A B : Type, list (A * B) -> list A * list B\nRing_polynom.add_pow_list : forall R : Type, R -> N -> list (R * positive) -> list (R * positive)\nRing_polynom.mk_monpol_list : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> C) -> (C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> list (Ring_polynom.PExpr C * Ring_polynom.PExpr C) -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C)\nswapprod_ind : forall (A : Type) (R : A -> A -> Prop) (P : A * A -> A * A -> Prop), (forall (x y : A) (p : A * A), symprod A A R R (x, y) p -> P (x, y) p) -> (forall (x y : A) (p : A * A), symprod A A R R (x, y) p -> P (y, x) p) -> forall p p0 : A * A, swapprod A R p p0 -> P p p0\nswapprod_sind : forall (A : Type) (R : A -> A -> Prop) (P : A * A -> A * A -> SProp), (forall (x y : A) (p : A * A), symprod A A R R (x, y) p -> P (x, y) p) -> (forall (x y : A) (p : A * A), symprod A A R R (x, y) p -> P (y, x) p) -> forall p p0 : A * A, swapprod A R p p0 -> P p p0\nRing_polynom.PSubstL1 : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> nat -> Ring_polynom.Pol C\nRing_polynom.PSubstL : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> nat -> option (Ring_polynom.Pol C)\nRefl.make_impl_map : forall (A B : Type) (eval : A -> Prop) (eval' : A * B -> Prop) (l : list (A * B)) (r : Prop), (forall x : A * B, eval' x <-> eval (fst x)) -> Refl.make_impl eval' l r < -> Refl.make_impl eval (List.map fst l) r\nRing_polynom.PNSubstL : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> nat -> nat -> Ring_polynom.Pol C\nRing_polynom.CFactor : forall C : Type, C -> (C -> C -> bool) -> (C -> C -> C * C) -> Ring_polynom.Pol C -> C -> Ring_polynom.Pol C * Ring_polynom.Pol C\nprod_rec : forall (A B : Type) (P : A * B -> Set), (forall (a : A) (b : B), P (a, b)) -> forall p : A * B, P p\nprod_sind : forall (A B : Type) (P : A * B -> SProp), (forall (a : A) (b : B), P (a, b)) -> forall p : A * B, P p\nprod_rect : forall (A B : Type) (P : A * B -> Type), (forall (a : A) (b : B), P (a, b)) -> forall p : A * B, P p\nprod_ind : forall (A B : Type) (P : A * B -> Prop), (forall (a : A) (b : B), P (a, b)) -> forall p : A * B, P p\nRing_polynom.norm_subst : forall C : Type, C -> C -> (C -> C -> C) -> (C -> C -> C) -> (C -> C -> C) -> (C -> C) -> (C -> C -> bool) -> (C -> C -> C * C) -> nat -> list (C * Ring_polynom.Mon * Ring_polynom.Pol C) -> Ring_polynom.PExpr C -> Ring_polynom.Pol C\nTauto.ror_cnf : forall Term' Annot : Type, (Term' -> bool) -> (Term' -> Term' -> option Term') -> list (list (Term' * Annot)) -> list (Tauto.clause Term' Annot) -> Tauto.cnf Term' Annot * list Annot\nTauto.ror_clause_cnf : forall Term' Annot : Type, (Term' -> bool) -> (Term' -> Term' -> option Term') -> list (Term' * Annot) -> list (Tauto.clause Term' Annot) -> list (Tauto.clause Term' Annot) * list Annot\nssrfun.all_pair : forall (I : Type) (T U : I -> Type), (forall i : I, T i * U i) -> (forall x : I, T x) * (forall x : I, U x)"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]