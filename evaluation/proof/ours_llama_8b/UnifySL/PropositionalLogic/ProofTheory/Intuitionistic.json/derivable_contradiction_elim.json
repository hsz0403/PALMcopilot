[{"history": {"proof": "", "repairs": [], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nYour Response:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\nYour Response:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nL: Language\nminL: MinimumLanguage L\npL: PropositionalLanguage L\nGamma: Derivable L\nbSC: BasicSequentCalculus L Gamma\nminSC: MinimumSequentCalculus L Gamma\nipSC: IntuitionisticPropositionalSequentCalculus L Gamma\n\nGoal:\nforall (Phi : context) (x y : expr), Phi |-- x --> ~~ x --> y\n\nPremises:\ncontext = fun L : Language => expr -> Prop : Language -> Type Argument L is implicit and maximally inserted\nRecord Derivable (L : Language) : Type := Build_Derivable { derivable : context -> expr -> Prop } For Build_Derivable: Argument scopes are [_ function_scope]\nRecord PropositionalLanguage (L : Language) : Type := Build_PropositionalLanguage { andp : expr -> expr -> expr; orp : expr -> expr -> expr; falsep : expr } For Build_PropositionalLanguage: Argument scopes are [_ function_scope function_scope _]\nBasicSequentCalculus : forall L : Language, Derivable L -> Prop\nIntuitionisticPropositionalSequentCalculus : forall L : Language, PropositionalLanguage L -> Derivable L -> Prop\nMinimumSequentCalculus : forall L : Language, MinimumLanguage L -> Derivable L -> Prop\nexpr = fun Language0 : Language => let (expr) := Language0 in expr : Language -> Type Argument Language is implicit and maximally inserted\nRecord MinimumLanguage (L : Language) : Type := Build_MinimumLanguage { impp : expr -> expr -> expr } For Build_MinimumLanguage: Argument scopes are [_ function_scope]\nderivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\ (fun x : expr => In x xs) |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Derivable ?L] ?FiniteWitnessedSequentCalculus : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus...\ncontextual_derivable_finite_witnessed : forall (Phi Psi : context) (y : expr), Union expr Phi Psi |-- y -> exists xs : list expr, Forall Psi xs /\\ Union expr Phi (fun x : expr => In x xs) |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Derivable ?L] ?bSC : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : Basic...\nBuild_MinimumSequentCalculus : forall (L : Language) (minL : MinimumLanguage L) (Gamma : Derivable L), (forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y) -> (forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y) -> MinimumSequentCalculus L Gamma\nBuild_IntuitionisticPropositionalSequentCalculus : forall (L : Language) (pL : PropositionalLanguage L) (Gamma : Derivable L), (forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y) -> (forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x) -> (forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y) -> (forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y) -> (forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y) -> (forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z) ->...-> IntuitionisticPropositionalSequentCalculus L Gamma\nderivable_double_negp_intros : forall (Phi : context) (x : expr), Phi |-- x - -> ~~ (~~ x)\ndeduction_double_negp_intros : forall (Phi : context) (x : expr), Phi |-- x -> Phi |-- ~~ (~~ x)\nderivable_provable : forall (Phi : context) (y : expr), Phi |-- y <-> (exists xs : list expr, Forall (fun x : expr => Phi x) xs /\\ |-- multi_imp xs y) where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?GammaP : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC...\nprovable_multi_imp_weaken : forall (xs : list expr) (x y : expr), |-- x --> y -> |-- multi_imp xs x --> multi_imp xs y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : Int...\naux_minimun_theorem04 : forall x y : expr, |-- (x --> x --> y) --> x --> y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus...\naux_minimun_rule02 : forall x y z : expr, |-- x --> y -> |-- y --> z -> |-- x --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequent...\naxiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSe...\nmodus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Pro...\nTestInAxiomatization.Unnamed_thm0 : forall (Phi : context) (x1 y1 x2 y2 : expr), |-- x2 --> x1 -> |-- y1 --> y2 -> Phi |-- x1 --> y1 -> Phi |-- x2 --> y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?GammaP : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable...\nBuild_BasicSequentCalculus : forall (L : Language) (Gamma : Derivable L), (forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x) -> (forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x) -> (forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y) -> BasicSequentCalculus L Gamma\nprovable_impp_arg_switch : forall x y z : expr, |-- (x --> y --> z) --> y --> x --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequent...\naux_minimun_theorem03 : forall x y z : expr, |-- y --> (x --> y --> z) --> x --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSe...\naux_minimun_rule00 : forall x y : expr, |-- x -> |-- y --> x where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Provable ?...\naux_minimun_theorem02 : forall x y : expr, |-- x --> (x --> y) --> y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma...\nprovable_multi_imp_arg_switch2 : forall (xs : list expr) (x y : expr), |-- multi_imp xs (x --> y) --> x --> multi_imp xs y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC...\nTestInSequentCalculus.Unnamed_thm0 : forall (Phi : context) (x1 y1 x2 y2 : expr), |-- x2 --> x1 -> |-- y1 --> y2 -> Phi |-- x1 --> y1 -> Phi |-- x2 --> y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?GammaP : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable...\naux_minimun_theorem01 : forall x y z : expr, |-- (x --> z) --> x --> y --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCal...\nprovable_impp_trans : forall x y z : expr, |-- (x --> y) --> (y --> z) --> x --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSe...\naux_minimun_theorem00 : forall x y z : expr, |-- (y --> z) --> (x --> y) --> x --> z where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticProposition...\nTestInAxiomatization.Unnamed_thm : forall (Phi : context) (y1 y2 : expr), |-- y1 --> y2 -> Phi |-- y1 -> Phi |-- y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?GammaP : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCal...\naxiom1 : forall x y : expr, |-- x --> y --> x where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Provable ?L] ?Minimum...\nadjoint_iter : forall (x : expr) (xs : list expr) (y : expr), |-- fold_left ?prodp xs x - -> y < -> |-- x - ->...-> expr] ?Adj : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Adjointness ?L ?Gamma ?prodp ?funcp]\naux_minimun_rule01 : forall x y z : expr, |-- x --> y -> |-- (z --> x) --> z --> y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSe...\ndeduction_weaken0 : forall (Phi : context) (y : expr), |-- y -> Phi |-- y where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Derivable ?L] ?bSC : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |-...\nTestInSequentCalculus.Unnamed_thm : forall (Phi : context) (y1 y2 : expr), |-- y1 --> y2 -> Phi |-- y1 -> Phi |-- y2 where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?GammaP : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCal...\nprovable_impp_refl : forall x : expr, |-- x --> x where ?L : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Language] ?minL : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- MinimumLanguage ?L] ?Gamma : [L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma |- Provable ?L] ?minAX..."}, {"role": "assistant", "content": "```coq\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nInductive context : Type :=\n| var : expr -> context\n| app : context -> expr -> context.\n\nDefinition Phi := context.\n\nDefinition x := expr.\n\nDefinition y := expr.\n\nDefinition z := expr.\n\nHint Resolve modus_ponens axiom2 axiom1.\n\nLemma TestInAxiomatization_Unnamed_thm : forall (Phi : context) (x1 y1 x2 y2 : expr),\n  |-- x2 --> x1 -> |-- y1 --> y2 -> Phi |-- x1 --> y1 -> Phi |-- x2 --> y2.\nProof.\n  intros Phi x1 y1 x2 y2 H1 H2.\n  apply TestInAxiomatization.Unnamed_thm0 with (Phi := Phi) (x1 := x1) (y1 := y1) (x2 := x2) (y2 := y2).\n  - auto.\n  - auto.\n  - apply modus_ponens.\n    + auto.\n    + apply axiom2.\nQed.\n\nLemma TestInSequentCalculus_Unnamed_thm : forall (Phi : context) (y1 y2 : expr),\n  |-- y1 --> y2 -> Phi |-- y1 -> Phi |-- y2.\nProof.\n  intros Phi y1 y2 H.\n  apply TestInSequentCalculus.Unnamed_thm0 with (Phi := Phi) (y1 := y1) (y2 := y2).\n  - auto.\n  - apply modus_ponens.\n    + auto.\n    + apply axiom2.\nQed.\n\nLemma adjoint_iter : forall (x : expr) (xs : list expr) (y : expr),\n  |-- fold_left?prodp xs x -> y < -> |-- x ->... -> y.\nProof.\n  intros x xs y H.\n  induction xs.\n  - simpl. auto.\n  - simpl. apply IHxs.\n    + apply modus_ponens.\n      * auto.\n      * apply axiom2.\nQed.\n\nLemma provable_multi_imp_arg_switch2 : forall (xs : list expr) (x y : expr),\n  |-- multi_imp xs (x --> y) --> x --> multi_imp xs y.\nProof.\n  intros xs x y H.\n  apply provable_multi_imp_arg_switch.\n  - auto.\n  - apply IHxs.\n    + apply modus_ponens.\n      * auto.\n      * apply axiom2.\nQed.\n\nLemma provable_impp_trans : forall x y z : expr,\n  |-- (x --> y) --> (y --> z) --> x --> z.\nProof.\n  intros x y z H1 H2.\n  apply modus_ponens.\n  - apply modus_ponens.\n    + apply axiom2.\n    + apply H1.\n  - apply H2.\nQed.\n\nLemma TestInAxiomatization_Unnamed_thm0 : forall (Phi : context) (y1 y2 : expr),\n  |-- y1 --> y2 -> Phi |-- y1 -> Phi |-- y2.\nProof.\n  intros Phi y1 y2 H.\n  apply TestInAxiomatization.Unnamed_thm0 with (Phi := Phi) (y1 := y1) (y2 := y2).\n  - auto.\n  - apply modus_ponens.\n    + auto.\n    + apply axiom2.\nQed.\n\nLemma aux_minimun_theorem04 : forall x y : expr,\n  |-- (x --> y --> z) --> x --> z.\nProof.\n  intros x y H.\n  apply modus_ponens.\n  - apply modus_ponens.\n    + apply axiom2.\n    + apply H.\n  - apply H.\nQed.\n\nLemma provable_impp_refl : forall x : expr,\n  |-- x --> x.\nProof.\n  intros x.\n  apply axiom1.\nQed.\n\nTheorem TestInSequentCalculus_Unnamed_thm0 : forall (Phi : context) (x1 y1 x2 y2 : expr),\n  |-- x2 --> x1 -> |-- y1 --> y2 -> Phi |-- x1 --> y1 -> Phi |-- x2 --> y2.\nProof.\n  intros Phi x1 y1 x2 y2 H1 H2.\n  apply TestInSequentCalculus.Unnamed_thm0 with (Phi := Phi) (x1 := x1) (y1 := y1) (x2 := x2) (y2 := y2).\n  - auto.\n  - apply modus_ponens.\n    + auto.\n    + apply axiom2.\nQed.\n\nTheorem TestInAxiomatization_Unnamed_thm1 : forall (Phi : context) (y1 y2 : expr),\n  |-- y"}], "original": "Require Import Coq.Lists.List. Import ListNotations. Inductive context : Type := | var : expr -> context | app : context -> expr -> context. Definition Phi := context. Definition x := expr. Definition y := expr. Definition z := expr. Hint Resolve modus_ponens axiom2 axiom1.", "succ": false}]