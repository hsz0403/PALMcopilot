[{"history": {"proof": "unfold discrete. qsimpl time: 1 use: discrete_iff. apply discrete_iff. hauto l: on depth: 3.", "repairs": ["", "no_subterm", "ref_not_found", "hammer"], "exceptions": [{"ctx": ["unfold discrete."], "tactic": "rewrite discrete_iff.", "exn": "Found no subterm matching \"discrete ?T\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold discrete.", "qsimpl time: 1 use: discrete_iff."], "tactic": "apply inhabited_intro.", "exn": "The reference inhabited_intro was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\ndiscrete bool\n\nPremises:\ndiscrete = fun X : Type => decidable (fun '(x, y) => x = y) : Type -> Prop Arguments discrete _%type_scope\ndiscrete_iff : forall X : Type, discrete X < -> inhabited (eq_dec X)\nInductive ascii : Set := Ascii : bool -> bool -> bool -> bool -> bool -> bool -> bool -> bool -> Ascii.ascii Arguments Ascii.Ascii (_ _ _ _ _ _ _ _)%bool_scope\nInductive bool : Set := true : bool | false : bool\nandb = fun b1 b2 : bool => if b1 then b2 else false : bool -> bool -> bool Arguments andb (_ _)%bool_scope\nimplb = fun b1 b2 : bool => if b1 then b2 else true : bool -> bool -> bool Arguments implb (_ _)%bool_scope\norb = fun b1 b2 : bool => if b1 then true else b2 : bool -> bool -> bool Arguments orb (_ _)%bool_scope\nnegb = fun b : bool => if b then false else true : bool -> bool Arguments negb _%bool_scope\nBool.lt = fun b1 b2 : bool => if b1 then False else b2 = true : bool -> bool -> Prop Arguments Bool.lt (_ _)%bool_scope\nBvector.BshiftL : forall n : nat, Bvector.Bvector (S n) -> bool -> Vector.t bool (S n)\nDatatypes.is_true = fun b : bool => b = true : bool -> Prop Arguments Datatypes.is_true _%bool_scope\nPeanoNat.Nat.b2n = fun b : bool => if b then 1 else 0 : bool -> nat Arguments PeanoNat.Nat.b2n _%bool_scope\nBinInt.Z.b2z = fun b : bool => if b then BinNums.Zpos BinNums.xH else BinNums.Z0 : bool -> BinNums.Z Arguments BinInt.Z.b2z _%bool_scope\nBinNat.N.b2n = fun b : bool => if b then BinNums.Npos BinNums.xH else BinNums.N0 : bool -> BinNums.N Arguments BinNat.N.b2n _%bool_scope\nssrbool.orbAC = fun __top_assumption_ : bool => (fun (_evar_0_ : (fun b : bool => forall y z : bool, (b || y || z)%bool = (b || z || y)%bool) true) (_evar_0_0 : (fun b : bool => forall y z : bool, (b || y || z)%bool = (b || z || y)%bool) false) => if __top_assumption_ as b return ((fun b0 : bool => forall y z : bool, (b0 || y || z)%bool = (b0 || z || y)%bool) b) then _evar_0_ else _evar_0_0) (fun __top_assumption_0 : bool => (fun (_evar_0_ : (fun b : bool => forall z : bool, (true || b || z)%bool = (true || z || b)%bool) true) (_evar_0_0 : (fun b : bool => forall z :...\nInitialRing.NotConstant = false : bool\nNat.even = fix even (n : nat) : bool := match n with | 0 => true | 1 => false | S (S n') => even n' end : nat -> bool Arguments Nat.even _%nat_scope\nNat.testbit = fix testbit (a n : nat) {struct n} : bool := match n with | 0 => Nat.odd a | S n0 => testbit (Nat.div2 a) n0 end : nat -> nat -> bool Arguments Nat.testbit (_ _)%nat_scope\nBvector.Bvector = Vector.t bool : nat -> Set Arguments Bvector.Bvector _%nat_scope\nList.existsb : forall A : Type, (A -> bool) -> list A -> bool\nNat.leb = fix leb (n m : nat) {struct n} : bool := match n with | 0 => true | S n' => match m with | 0 => false | S m' => leb n' m' end end : nat -> nat -> bool Arguments Nat.leb (_ _)%nat_scope\nssrbool.pred = fun T : Type => T -> bool : Type -> Type Arguments ssrbool.pred _%type_scope\nssrbool.simpl_pred = fun T : Type => ssrfun.simpl_fun T bool : Type -> Type Arguments ssrbool.simpl_pred _%type_scope\nRingMicromega.cneqb : forall C : Type, (C -> C -> bool) -> C -> C -> bool\nssreflect.not_locked_false_eq_true = (fun _evar_0_ : (fun u : unit => (let 'tt := u in fun x : bool => x) false <> true) tt => match ssreflect.master_key as u return ((fun u0 : unit => (let 'tt := u0 in fun x : bool => x) false <> true) u) with | tt => _evar_0_ end) (fun H : false = true => let H0 : False := eq_ind false (fun e : bool => if e then False else True) I true H in False_ind False H0) : ssreflect.locked false <> true\nbool_sind : forall P : bool -> SProp, P true -> P false -> forall b : bool, P b\nNat.eqb = fix eqb (n m : nat) {struct n} : bool := match n with | 0 => match m with | 0 => true | S _ => false end | S n' => match m with | 0 => false | S m' => eqb n' m' end end : nat -> nat -> bool Arguments Nat.eqb (_ _)%nat_scope\nRingMicromega.check_inconsistent : forall C : Type, C -> (C -> C -> bool) -> (C -> C -> bool) -> RingMicromega.NFormula C -> bool\nByte.to_bits_of_bits : forall b : bool * (bool * (bool * (bool * (bool * (bool * (bool * bool)))))), Byte.to_bits (Byte.of_bits b) = b\nSumbool.bool_eq_rec : forall (b : bool) (P : bool -> Set), (b = true -> P true) -> (b = false -> P false) -> P b\nBinPosDef.Pos.ltb = fun x y : BinNums.positive => match BinPosDef.Pos.compare x y with | Lt => true | _ => false end : BinNums.positive -> BinNums.positive -> bool Arguments BinPosDef.Pos.ltb (_ _)%positive_scope"}, {"role": "assistant", "content": "```coq\nunfold discrete. rewrite discrete_iff. apply inhabited_intro. exists (fun _ _ => orb true). intros x y Hxy. simpl in Hxy. destruct x; destruct y; auto. Qed."}], "original": "unfold discrete. rewrite discrete_iff. apply inhabited_intro. exists (fun _ _ => orb true). intros x y Hxy. simpl in Hxy. destruct x; destruct y; auto.", "succ": true}]