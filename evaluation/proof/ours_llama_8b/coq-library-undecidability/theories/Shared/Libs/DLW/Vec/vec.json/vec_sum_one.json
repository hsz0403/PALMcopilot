[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nn: nat\np: pos n\n\nGoal:\nvec_sum (vec_one p) = 1\n\nPremises:\nNotation pos := Fin.t\nvec_one = fun (n : nat) (p : pos n) => vec_set_pos (fun q : pos n => if pos_eq_dec p q then 1 else 0) : forall n : nat, pos n -> vec nat n Arguments vec_one {n}%nat_scope\nvec_sum : forall n : nat, vec nat n -> nat\nvec_change_succ : forall (n : nat) (v : vec nat n) (p : pos n), v[(S (v#>p))/p] = vec_plus (vec_one p) v\nvec_sum_plus : forall (n : nat) (v w : vec nat n), vec_sum (vec_plus v w) = vec_sum v + vec_sum w\nvec_change_pred : forall (n : nat) (v : vec nat n) (p : pos n) (u : nat), v#>p = S u -> v = vec_plus (vec_one p) (v[u/p])\nvec_sum_zero : forall n : nat, vec_sum vec_zero = 0\npos2nat_nxt : forall (n : nat) (p : pos n), pos2nat (pos_nxt p) = S (pos2nat p)\npm_lift_nxt : forall (m n : nat) (r : pos_map m n) (p : pos m), pm_lift r (pos_nxt p) = pos_nxt (r p)\nvec_one_nxt : forall (n : nat) (p : pos n), vec_one (pos_nxt p) = 0 ## vec_one p\npos2nat_left : forall (n m : nat) (p : pos n), pos2nat (pos_left m p) = pos2nat p\npos_both_lr : forall (n m : nat) (p : pos n + pos m), pos_both n m (pos_lr p) = p\npos_both_right : forall (n m : nat) (p : pos m), pos_both n m (pos_right n p) = inr p\npos_both_left : forall (n m : nat) (p : pos n), pos_both n m (pos_left m p) = inl p\npos2nat_right : forall (n m : nat) (p : pos m), pos2nat (pos_right n p) = n + pos2nat p\nNat.add_assoc : forall n m p : nat, n + (m + p) = n + m + p\nVectorSpec.replace_id : forall (A : Type) (n : nat) (p : pos n) (v : vec A n), VectorDef.replace v p (VectorDef.nth v p) = v\nNat.divide_wd = fun (x x' : nat) (Hx : x = x') (y y' : nat) (Hy : y = y') => Morphisms.trans_co_eq_inv_impl_morphism RelationClasses.iff_Transitive (exists p : nat, y = p * x) (exists p : nat, y = p * x') (Morphisms_Prop.ex_iff_morphism (fun p : nat => y = p * x) (fun p : nat => y = p * x') (fun p : nat => Morphisms.per_partial_app_morphism (RelationClasses.Equivalence_PER Nat.eq_equiv) (p * x) (p * x') (Morphisms.Reflexive_partial_app_morphism Nat.mul_wd (Morphisms.reflexive_proper_proxy RelationClasses.Equivalence_Reflexive p) x x' Hx))) (exists p : nat, y' = p * x') (exists p : nat, y' = p * x') (Morphisms.eq_proper_proxy (exists p : nat,...\npos_map = fun m n : nat => pos m -> pos n : nat -> nat -> Set Arguments pos_map (_ _)%nat_scope\nNat.divide = fun x y : nat => exists z : nat, y = z * x : nat -> nat -> Prop Arguments Nat.divide (_ _)%nat_scope\nNat.Bezout = fun n m p : nat => exists a b : nat, a * n = p + b * m : nat -> nat -> nat -> Prop Arguments Nat.Bezout (_ _ _)%nat_scope\nInit.Nat.log2 = fun n : nat => Init.Nat.log2_iter (Init.Nat.pred n) 0 1 0 : nat -> nat Arguments Init.Nat.log2 _%nat_scope\nlt = fun n m : nat => S n <= m : nat -> nat -> Prop Arguments lt (_ _)%nat_scope\nNat.gcd_unique : forall n m p : nat, 0 <= p -> Nat.divide p n -> Nat.divide p m -> (forall q : nat, Nat.divide q n -> Nat.divide q m -> Nat.divide q p) -> Nat.gcd n m = p\nNat.divide_mul_r : forall n m p : nat, Nat.divide n p -> Nat.divide n (m * p)\nvec_zero = fun n : nat => vec_set_pos (fun _ : pos n => 0) : forall n : nat, vec nat n Arguments vec_zero {n}%nat_scope\nFin.FS_inj : forall x y : pos ?n, pos_nxt x = pos_nxt y -> x = y where ?n : [n : nat p : pos n |- nat]\nInit.Nat.pred = fun n : nat => match n with | 0 => n | S u => u end : nat -> nat Arguments Init.Nat.pred _%nat_scope\nvec_plus = fun (n : nat) (v w : vec nat n) => vec_set_pos (fun p : pos n => (v#>p) + (w#>p)) : forall n : nat, vec nat n -> vec nat n -> vec nat n Arguments vec_plus {n}%nat_scope\nFin.to_nat_inj : forall p0 q : pos ?n, proj1_sig (Fin.to_nat p0) = proj1_sig (Fin.to_nat q) -> p0 = q where ?n : [n : nat p : pos n |- nat]\nFinFun.bInjective = fun (n : nat) (f : nat -> nat) => forall x y : nat, x < n -> y < n -> f x = f y -> x = y : nat -> (nat -> nat) -> Prop Arguments FinFun.bInjective _%nat_scope _%function_scope\npos_S_inv : forall p0 : pos (S ?n), (p0 = pos0) + {q : pos ?n | p0 = pos_nxt q} where ?n : [n : nat p : pos n |- nat]\nNat.divide_add_cancel_r : forall n m p : nat, Nat.divide n m -> Nat.divide n (m + p) -> Nat.divide n p"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]