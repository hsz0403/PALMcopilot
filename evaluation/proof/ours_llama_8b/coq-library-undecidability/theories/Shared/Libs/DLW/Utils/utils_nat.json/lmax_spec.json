[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nl: list nat\nx: nat\n\nGoal:\nlmax l <= x <-> Forall (fun y : nat => y <= x) l\n\nPremises:\nInductive list (A : Type) : Type := nil : list A | cons : A -> list A -> list A Arguments list _%type_scope Arguments nil {A}%type_scope Arguments cons {A}%type_scope a l%list_scope : rename\nForall : forall A : Type, (A -> Prop) -> list A -> Prop\nInductive nat : Set := O : nat | S : nat -> nat Arguments S _%nat_scope\nlmax = fold_right Nat.max 0 : list nat -> nat Arguments lmax _%list_scope\nPermutation.Permutation_list_max = fun (l1 l2 : list nat) (HP : l1 ~p l2) => Permutation.Permutation_ind (fun l3 l4 : list nat => list_max l3 = list_max l4) eq_refl (fun (x : nat) (l l' : list nat) (_ : l ~p l') (IHHP : list_max l = list_max l') => f_equal_nat nat (Init.Nat.max x) (list_max l) (list_max l') IHHP) (fun (x y : nat) (l : list nat) => eq_ind_r (fun n : nat => Init.Nat.max y n = Init.Nat.max x (Init.Nat.max y (list_max l))) (eq_ind_r (fun n : nat => Init.Nat.max y (Nat.max (list_max l) x) = n) (Nat.max_assoc y (list_max l) x) (Nat.max_comm x (Init.Nat.max y (list_max l)))) (Nat.max...\nPermutation.Permutation_list_sum = fun (l1 l2 : list nat) (HP : l1 ~p l2) => Permutation.Permutation_ind (fun l3 l4 : list nat => list_sum l3 = list_sum l4) eq_refl (fun (x : nat) (l l' : list nat) (_ : l ~p l') (IHHP : list_sum l = list_sum l') => f_equal_nat nat (Init.Nat.add x) (list_sum l) (list_sum l') IHHP) (fun (x y : nat) (l : list nat) => eq_ind_r (fun n : nat => y + n = x + (y + list_sum l)) (eq_ind_r (fun n : nat => y + (list_sum l + x) = n) (Nat.add_assoc y (list_sum l) x) (Nat.add_comm x (y + list_sum l))) (Nat.add_comm x (list_sum l))) (fun (l l' l'' : list nat) (_...\nInit.Nat.div = fun x y : nat => match y with | 0 => y | S y' => fst (Init.Nat.divmod x y' 0 y') end : nat -> nat -> nat Arguments Init.Nat.div (_ _)%nat_scope\nForall_image : forall (A B : Type) (f : A -> B) (l : list B), Forall (fun y : B => exists x : A, y = f x) l < -> (exists l' : list A, l = map f l')\nlist_max_le : forall (l : list nat) (n : nat), list_max l <= n < -> Forall (fun k : nat => k <= n) l\nf_equal_nat : forall (B : Type) (f : nat -> B) (x y : nat), x = y -> f x = f y\nnotin_flat_map_Forall : forall (A B : Type) (f : A -> list B) (x : B) (l : list A), ~ In x (flat_map f l) < -> Forall (fun y : A => ~ In x (f y)) l\nExists_Forall_neg : forall (A : Type) (P : A -> Prop) (l : list A), (forall x : A, P x \\/ ~ P x) -> Exists (fun x : A => ~ P x) l < -> ~ Forall P l\nin_flat_map_Exists : forall (A B : Type) (f : A -> list B) (x : B) (l : list A), In x (flat_map f l) < -> Exists (fun y : A => In x (f y)) l\nForall_Exists_neg : forall (A : Type) (P : A -> Prop) (l : list A), Forall (fun x : A => ~ P x) l < -> ~ Exists P l\nlist_max_lt : forall (l : list nat) (n : nat), l <> nil -> list_max l < n < -> Forall (fun k : nat => k < n) l\nlist_an_duplicate_inv : forall (a n : nat) (l : list nat) (x : nat) (m : list nat) (y : nat) (r : list nat), list_an a n = l ++ x :: m ++ y :: r -> a <= x /\\ x < y < a + n\nForall_and : forall (A : Type) (P Q : A -> Prop) (l : list A), Forall P l -> Forall Q l -> Forall (fun x : A => P x /\\ Q x) l\nForall_and_inv : forall (A : Type) (P Q : A -> Prop) (l : list A), Forall (fun x : A => P x /\\ Q x) l -> Forall P l /\\ Forall Q l\nBinInt.Z.le = fun x y : BinNums.Z => BinInt.Z.compare x y <> Gt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.le (_ _)%Z_scope\nBinInt.Z.lt = fun x y : BinNums.Z => BinInt.Z.compare x y = Lt : BinNums.Z -> BinNums.Z -> Prop Arguments BinInt.Z.lt (_ _)%Z_scope\nForall2_Forall : forall (X : Type) (R : X -> X -> Prop) (ll : list X), Forall2 R ll ll < -> Forall (fun x : X => R x x) ll\nnth_nth_nth_map : forall (A : Type) (l : list A) (n : nat) (d : A) (ln : list nat) (dn : nat), n < length ln \\/ length l <= dn -> nth (nth n ln dn) l d = nth n (map (fun x : nat => nth x l d) ln) d\nin_map_iff : forall (A B : Type) (f : A -> B) (l : list A) (y : B), In y (map f l) < -> (exists x : A, f x = y /\\ In x l)\nincl_Forall_in_iff : forall (A : Type) (l l' : list A), incl l l' < -> Forall (fun x : A => In x l') l\nlt = fun n m : nat => S n <= m : nat -> nat -> Prop Arguments lt (_ _)%nat_scope\nconcat_nil_Forall : forall (A : Type) (l : list (list A)), concat l = nil < -> Forall (fun x : list A => x = nil) l\nmap_ext_Forall : forall (A B : Type) (f g : A -> B) (l : list A), Forall (fun x : A => f x = g x) l -> map f l = map g l\nBinIntDef.Z.add = fun x y : BinNums.Z => match x with | BinNums.Z0 => y | BinNums.Zpos x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinNums.Zpos (BinPos.Pos.add x' y') | BinNums.Zneg y' => BinIntDef.Z.pos_sub x' y' end | BinNums.Zneg x' => match y with | BinNums.Z0 => x | BinNums.Zpos y' => BinIntDef.Z.pos_sub y' x' | BinNums.Zneg y' => BinNums.Zneg (BinPos.Pos.add x' y') end end : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.add (_ _)%Z_scope\nnat_morph_N = {| Smorph0 := eq_refl; Smorph1 := eq_refl; Smorph_add := Nnat.N2Nat.inj_add; Smorph_mul := Nnat.N2Nat.inj_mul; Smorph_eq := fun (x y : BinNums.N) (H : BinNat.N.eqb x y = true) => let H0 : forall n m : BinNums.N, BinNat.N.eqb n m = true -> n = m := fun n m : BinNums.N => match BinNat.N.eqb_eq n m with | conj x0 _ => x0 end in let H1 : x = y := H0 x y H in eq_ind_r (fun x0 : BinNums.N => BinNat.N.to_nat x0 = BinNat.N.to_nat y) eq_refl H1 |} : semi_morph 0 1 Init.Nat.add Init.Nat.mul eq BinNums.N0 (BinNums.Npos BinNums.xH) BinNat.N.add BinNat.N.mul BinNat...\nneg_Forall_Exists_neg : forall (A : Type) (P : A -> Prop) (l : list A), (forall x : A, {P x} + {~ P x}) -> ~ Forall P l -> Exists (fun x : A => ~ P x) l\nexists_Forall : forall (A B : Type) (P : A -> B -> Prop) (l : list B), (exists k : A, Forall (P k) l) -> Forall (fun x : B => exists k : A, P k x) l\nForall_fold_right : forall (A : Type) (P : A -> Prop) (l : list A), Forall P l < -> fold_right (fun x : A => and (P x)) True l\nForall_forall : forall (A : Type) (P : A -> Prop) (l : list A), Forall P l < -> (forall x : A, In x l -> P x)\nlist_max = fun l : list nat => fold_right Init.Nat.max 0 l : list nat -> nat Arguments list_max _%list_scope"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]