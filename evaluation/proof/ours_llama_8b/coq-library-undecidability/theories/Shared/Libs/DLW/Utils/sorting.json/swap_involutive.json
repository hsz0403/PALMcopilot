[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nn: nat\nj: nat\ni: nat\n\nGoal:\nswap (swap n) = n\n\nPremises:\nswap = fun n : nat => if Nat.eq_dec n i then j else if Nat.eq_dec n j then i else n : nat -> nat Arguments swap _%nat_scope\nswap_spec : forall n : nat, n <> i -> n <> j -> swap n = n\nNat.ones = fun n : nat => Nat.pred (Nat.shiftl 1 n) : nat -> nat Arguments Nat.ones _%nat_scope\nInit.Nat.log2 = fun n : nat => Init.Nat.log2_iter (Init.Nat.pred n) 0 1 0 : nat -> nat Arguments Init.Nat.log2 _%nat_scope\nZnat.Nat2Z.inj_succ : forall n : nat, BinInt.Z.of_nat (S n) = BinInt.Z.succ (BinInt.Z.of_nat n)\nNat.lxor_spec : forall a b n : nat, Nat.testbit (Nat.lxor a b) n = xorb (Nat.testbit a n) (Nat.testbit b n)\nNat.compare_antisym : forall n m : nat, (m ?= n) = CompOpp (n ?= m)\nInductive t : nat -> Set := F1 : forall n : nat, Fin.t (S n) | FS : forall n : nat, Fin.t n -> Fin.t (S n) Arguments Fin.t _%nat_scope Arguments Fin.F1 {n}%nat_scope Arguments Fin.FS {n}%nat_scope\nZnat.Nat2Z.inj_mul : forall n m : nat, BinInt.Z.of_nat (n * m) = BinInt.Z.mul (BinInt.Z.of_nat n) (BinInt.Z.of_nat m)\nNat.land_ones : forall a n : nat, Nat.land a (Nat.ones n) = a mod 2 ^ n\nZnat.Nat2Z.inj_add : forall n m : nat, BinInt.Z.of_nat (n + m) = BinInt.Z.add (BinInt.Z.of_nat n) (BinInt.Z.of_nat m)\nNat.land_ones_low : forall a n : nat, Nat.log2 a < n -> Nat.land a (Nat.ones n) = a\nZnat.Nat2Z.inj_sub_max : forall n m : nat, BinInt.Z.of_nat (n - m) = BinInt.Z.max BinNums.Z0 (BinInt.Z.sub (BinInt.Z.of_nat n) (BinInt.Z.of_nat m))\nBinIntDef.Z.sub = fun m n : BinNums.Z => BinIntDef.Z.add m (BinIntDef.Z.opp n) : BinNums.Z -> BinNums.Z -> BinNums.Z Arguments BinIntDef.Z.sub (_ _)%Z_scope\nswap_spec_j = let s := Nat.eq_dec j i in match s as s0 return ((if s0 then j else if Nat.eq_dec j j then i else j) = i) with | left e => e | right n => let s0 := Nat.eq_dec j j in match s0 as s1 return ((if s1 then i else j) = i) with | left _ => eq_refl | right n0 => (fun lemma : j = i <-> BinInt.Z.of_nat j = BinInt.Z.of_nat i => Morphisms.iff_flip_impl_subrelation (j = i) (BinInt.Z.of_nat j = BinInt.Z.of_nat i) lemma) (ZifyClasses.mkrel nat BinNums.Z eq BinInt.Z.of_nat eq (fun x y : nat => iff_sym (Znat.Nat2Z.inj_iff x y)) j (BinInt.Z.of_nat j) eq_refl i (BinInt.Z.of_nat i) eq_refl) (let n1 : BinInt.Z.of_nat j <> BinInt.Z.of_nat j := Z...\ngcd.divides = fun n k : nat => exists p : nat, k = p * n : nat -> nat -> Prop Arguments gcd.divides (_ _)%nat_scope\nNat.divide = fun x y : nat => exists z : nat, y = z * x : nat -> nat -> Prop Arguments Nat.divide (_ _)%nat_scope\ngcd.arem = fun n d q j : nat => j <= d /\\ (n = 2 * q * d + j \\/ q <> 0 /\\ n = 2 * q * d - j) : nat -> nat -> nat -> nat -> Prop Arguments gcd.arem (_ _ _ _)%nat_scope\ngcd.div = fun q p : nat => projT1 (gcd.div_full q p) : nat -> nat -> nat Arguments gcd.div (_ _)%nat_scope\nInit.Nat.land = fun a b : nat => Init.Nat.bitwise andb a a b : nat -> nat -> nat Arguments Init.Nat.land (_ _)%nat_scope\ngcd.rem = fun q p : nat => proj1_sig (projT2 (gcd.div_full q p)) : nat -> nat -> nat Arguments gcd.rem (_ _)%nat_scope\nswap_spec_i = let s := Nat.eq_dec i i in match s as s0 return ((if s0 then j else if Nat.eq_dec i j then i else i) = j) with | left _ => eq_refl | right n => (fun lemma : (if Nat.eq_dec i j then i else i) = j <-> BinInt.Z.of_nat (if Nat.eq_dec i j then i else i) = BinInt.Z.of_nat j => Morphisms.iff_flip_impl_subrelation ((if Nat.eq_dec i j then i else i) = j) (BinInt.Z.of_nat (if Nat.eq_dec i j then i else i) = BinInt.Z.of_nat j) lemma) (ZifyClasses.mkrel nat BinNums.Z eq BinInt.Z.of_nat eq (fun x y : nat => iff_sym (Znat.Nat2Z.inj_iff x y)) (if Nat.eq_dec i j then i else i) (BinInt.Z.of_nat (if Nat.eq_dec i j then i else i)) eq_refl j (BinInt.Z.of_nat j...\nInit.Nat.sqrt = fun n : nat => Init.Nat.sqrt_iter n 0 0 0 : nat -> nat Arguments Init.Nat.sqrt _%nat_scope\nZifyClasses.mkapp : forall (S1 S2 T : Type) (OP : S1 -> S2) (I1 : S1 -> T) (I2 : S2 -> T) (TUOP : T -> T), (forall n : S1, I2 (OP n) = TUOP (I1 n)) -> forall (s1 : S1) (t1 : T), I1 s1 = t1 -> I2 (OP s1) = TUOP t1\nNat.lcm = fun a b : nat => a * (b / Nat.gcd a b) : nat -> nat -> nat Arguments Nat.lcm (_ _)%nat_scope\nInit.Nat.lxor = fun a b : nat => Init.Nat.bitwise xorb (Init.Nat.max a b) a b : nat -> nat -> nat Arguments Init.Nat.lxor (_ _)%nat_scope\nlt = fun n m : nat => S n <= m : nat -> nat -> Prop Arguments lt (_ _)%nat_scope\nPeanoNat.Nat.div_wd_obligation_1 = fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => eq_ind_r (fun x1 : nat => x / x1 = y / y0) (eq_ind_r (fun x1 : nat => x1 / y0 = y / y0) eq_refl H) H0 : Morphisms.respectful eq (Morphisms.respectful eq eq) Nat.div Nat.div\nPeanoNat.Nat.sub_wd_obligation_1 = fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => eq_ind_r (fun x1 : nat => x - x1 = y - y0) (eq_ind_r (fun x1 : nat => x1 - y0 = y - y0) eq_refl H) H0 : Morphisms.respectful eq (Morphisms.respectful eq eq) Init.Nat.sub Init.Nat.sub\nPeanoNat.Nat.mul_wd_obligation_1 = fun (x y : nat) (H : x = y) (x0 y0 : nat) (H0 : x0 = y0) => eq_ind_r (fun x1 : nat => x * x1 = y * y0) (eq_ind_r (fun x1 : nat => x1 * y0 = y * y0) eq_refl H) H0 : Morphisms.respectful eq (Morphisms.respectful eq eq) Init.Nat.mul Init.Nat.mul\nInit.Nat.ldiff = fun a b : nat => Init.Nat.bitwise (fun b0 b' : bool => (b0 && negb b')%bool) a a b : nat -> nat -> nat Arguments Init.Nat.ldiff (_ _)%nat_scope"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]