[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nYour Response:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\nYour Response:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\np: nat\nHp: p <> 0%nat\n\nGoal:\nring_morphism 0%Z 1%Z Z.add Z.mul Z.opp (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (Zp_opp Hp) (Z2Zp Hp)\n\nPremises:\nDecimal.opp = fun d : Decimal.int => match d with | Decimal.Pos d0 => Decimal.Neg d0 | Decimal.Neg d0 => Decimal.Pos d0 end : Decimal.int -> Decimal.int Arguments Decimal.opp _%dec_int_scope\nN.add = fun n m : N => match n with | 0%N => m | N.pos p => match m with | 0%N => n | N.pos q => N.pos (p + q) end end : N -> N -> N Arguments N.add (_ _)%N_scope\nZp_zero : forall p : nat, p <> 0 -> Z_Zp p\nZp_mult : forall p : nat, p <> 0 -> Z_Zp p -> Z_Zp p -> Z_Zp p\nZp_one : forall p : nat, p <> 0 -> Z_Zp p\nring_morphism : forall X : Type, X -> X -> (X -> X -> X) -> (X -> X -> X) -> (X -> X) -> forall Y : Type, Y -> Y -> (Y -> Y -> Y) -> (Y -> Y -> Y) -> (Y -> Y) -> (X -> Y) -> Prop\nZp_plus : forall p : nat, p <> 0 -> Z_Zp p -> Z_Zp p -> Z_Zp p\nZ2Zp : forall p : nat, p <> 0 -> Z -> Z_Zp p\nZp_opp : forall p : nat, p <> 0 -> Z_Zp p -> Z_Zp p\nInductive Z : Set := Z0 : Z | Zpos : positive -> Z | Zneg : positive -> Z Arguments Zpos _%positive_scope Arguments Zneg _%positive_scope\nN.mul = fun n m : N => match n with | 0%N => 0%N | N.pos p => match m with | 0%N => 0%N | N.pos q => N.pos (p * q) end end : N -> N -> N Arguments N.mul (_ _)%N_scope\nZp_ring_ring_lemma1 : forall (p : nat) (Hp : p <> 0) (n : nat) (l : list (Z_Zp p)) (lpe : list (Ring_polynom.PExpr Z * Ring_polynom.PExpr Z)) (pe1 pe2 : Ring_polynom.PExpr Z), Ring_polynom.interp_PElist (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (fun x y : Z_Zp p => Zp_plus Hp x (Zp_opp Hp y)) (Zp_opp Hp) eq (gen_phiZ (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (Zp_opp Hp)) id_phi_N (pow_N (Zp_one Hp) (Zp_mult Hp)) l lpe -> (let lmp := Ring_polynom.mk_monpol_list 0%Z 1%Z Z...\nZp_ring_ring_lemma2 : forall (p : nat) (Hp : p <> 0) (n : nat) (lH : list (Ring_polynom.PExpr Z * Ring_polynom.PExpr Z)) (l : list (Z_Zp p)), Ring_polynom.interp_PElist (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (fun x y : Z_Zp p => Zp_plus Hp x (Zp_opp Hp y)) (Zp_opp Hp) eq (gen_phiZ (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (Zp_opp Hp)) id_phi_N (pow_N (Zp_one Hp) (Zp_mult Hp)) l lH -> forall lmp : list (Z * Ring_polynom.Mon * Ring_polynom.Pol Z), Ring_polynom.mk_monpol_list 0%Z 1%...\nZp_is_ring : forall (p : nat) (Hp : p <> 0), ring_theory (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (fun x y : Z_Zp p => Zp_plus Hp x (Zp_opp Hp y)) (Zp_opp Hp) eq\nZp_plus_monoid : forall (p : nat) (Hp : p <> 0), monoid_theory (Zp_plus Hp) (Zp_zero Hp)\nZp_mult_monoid : forall (p : nat) (Hp : p <> 0), monoid_theory (Zp_mult Hp) (Zp_one Hp)\nZp_expo_invertible : forall (p : nat) (Hp : p <> 0) (n : nat) (x : Z_Zp p), Zp_invertible Hp x -> Zp_invertible Hp (mscal (Zp_mult Hp) (Zp_one Hp) n x)\nnat2Zp_expo : forall (p : nat) (Hp : p <> 0) (n u : nat), nat2Zp Hp (mscal Init.Nat.mul 1 n u) = mscal (Zp_mult Hp) (Zp_one Hp) n (nat2Zp Hp u)\nZr_ring_lemma1 : forall (n : nat) (l : list Z) (lpe : list (Ring_polynom.PExpr Z * Ring_polynom.PExpr Z)) (pe1 pe2 : Ring_polynom.PExpr Z), Ring_polynom.interp_PElist 0%Z 1%Z Z.add Z.mul Z.sub Z.opp eq (IDphi (R:=Z)) Z.of_N Z.pow l lpe ->...-> Ring_polynom.PEeval 0%Z 1%Z Z.add Z.mul Z.sub Z.opp (IDphi (R:=Z)) Z.of_N Z.pow l pe1 = Ring_polynom.PEeval 0%Z 1%Z Z.add Z.mul Z.sub Z.opp (IDphi (R:=Z)) Z.of_N Z.pow l pe2\nZr_ring_lemma2 : forall (n : nat) (lH : list (Ring_polynom.PExpr Z * Ring_polynom.PExpr Z)) (l : list Z), Ring_polynom.interp_PElist 0%Z 1%Z Z.add Z.mul Z.sub Z.opp eq (IDphi (R:=Z)) Z.of_N Z.pow l lH ->...-> Ring_polynom.PEeval 0%Z 1%Z Z.add Z.mul Z.sub Z.opp (IDphi (R:=Z)) Z.of_N Z.pow l pe = Ring_polynom.Pphi_pow 0%Z 1%Z Z.add Z.mul Z.sub Z.opp 0%Z 1%Z Zeq_bool (IDphi (R:=Z)) Z.of_N Z.pow get_signZ l npe\nZp_invert_minus_one : forall (p : nat) (Hp : p <> 0) (Hp' : prime p), Zp_invert Hp Hp' (Zp_opp Hp (Zp_one Hp)) = Zp_opp Hp (Zp_one Hp)\nZp_one_invertible : forall (p : nat) (Hp : p <> 0), Zp_invertible Hp (Zp_one Hp)\nZp_opp_zero : forall (p : nat) (Hp : p <> 0), Zp_opp Hp (Zp_zero Hp) = Zp_zero Hp\nZp_plus_zero : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), Zp_plus Hp (Zp_zero Hp) x = x\nZp_plus_zero_r : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), Zp_plus Hp x (Zp_zero Hp) = x\nZp_mult_zero : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), Zp_mult Hp (Zp_zero Hp) x = Zp_zero Hp\nZp_invert_spec1 : forall (p : nat) (Hp : p <> 0) (Hp' : prime p), Zp_invert Hp Hp' (Zp_zero Hp) = Zp_zero Hp\nnat2Zp_minus_one : forall (p : nat) (Hp : p <> 0), nat2Zp Hp (p - 1) = Zp_opp Hp (Zp_one Hp)\nZp_mult_one : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), Zp_mult Hp (Zp_one Hp) x = x\nZp_mult_one_r : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), Zp_mult Hp x (Zp_one Hp) = x\nZp_invert_one : forall (p : nat) (Hp : p <> 0) (Hp' : prime p), Zp_invert Hp Hp' (Zp_one Hp) = Zp_one Hp\nWilson_thm_1 : forall (p : nat) (Hp : p <> 0), prime p -> nat2Zp Hp (fact (p - 1)) = Zp_opp Hp (Zp_one Hp)\nZp_prime_square_one : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), prime p -> Zp_mult Hp x x = Zp_one Hp < -> x = Zp_one Hp \\/ x = Zp_opp Hp (Zp_one Hp)\nZp_invert_fix : forall (p : nat) (Hp : p <> 0) (Hp' : prime p) (x : Z_Zp p), Zp_invert Hp Hp' x = x < -> x = Zp_zero Hp \\/ x = Zp_one Hp \\/ x = Zp_opp Hp (Zp_one Hp)\nZp_lprod_fact : forall (p : nat) (Hp : p <> 0), prime p -> forall n : nat, nat2Zp Hp (fact (S n)) = Zp_lprod Hp (map (nat2Zp Hp) (list_an 2 n))\nnat2Zp_choose : forall (p : nat) (Hp : p <> 0) (x : Z_Zp p), x = Zp_zero Hp \\/ x = Zp_one Hp \\/ x = Zp_opp Hp (Zp_one Hp) \\/ (exists m : nat, 1 < m < p - 1 /\\ nat2Zp Hp m = x)\ngen_phiZ_morph : forall (R : Type) (rO rI : R) (radd rmul rsub : R -> R -> R) (ropp : R -> R) (req : R -> R -> Prop), Setoid.Setoid_Theory R req -> ring_eq_ext radd rmul ropp req -> ring_theory rO rI radd rmul rsub ropp req -> ring_morph rO rI radd rmul rsub ropp req 0%Z 1%Z Z.add Z.mul Z.sub Z.opp Zeq_bool (gen_phiZ rO rI radd rmul ropp)\nZ2Zp_minus : forall (p : nat) (Hp : p <> 0) (u v : Z), Z2Zp Hp (u - v) = Zp_plus Hp (Z2Zp Hp u) (Zp_opp Hp (Z2Zp Hp v))\nZp_opp_plus : forall (p : nat) (Hp : p <> 0) (x y : Z_Zp p), Zp_opp Hp (Zp_plus Hp x y) = Zp_plus Hp (Zp_opp Hp x) (Zp_opp Hp y)\nZp_mult_plus_distr_l : forall (p : nat) (Hp : p <> 0) (x y z : Z_Zp p), Zp_mult Hp x (Zp_plus Hp y z) = Zp_plus Hp (Zp_mult Hp x y) (Zp_mult Hp x z)\nZp_mult_plus_distr_r : forall (p : nat) (Hp : p <> 0) (x y z : Z_Zp p), Zp_mult Hp (Zp_plus Hp y z) x = Zp_plus Hp (Zp_mult Hp y x) (Zp_mult Hp z x)"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]