[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nYour Response:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\nYour Response:\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nT: Type\n\nGoal:\nforall WO : partial_WO, premaximal partial_WO_ord WO -> pwo_S WO = Full_set\n\nPremises:\npremaximal = fun (T : Type) (R : relation T) (x : T) => forall y : T, R x y -> R y x : forall T : Type, relation T -> T -> Prop Arguments premaximal {T}%type_scope\nRecord partial_WO_ord (WO1 WO2 : partial_WO) : Prop := Build_partial_WO_ord { pwo_S_incl : Included (pwo_S WO1) (pwo_S WO2); pwo_restriction : forall x y : T, In (pwo_S WO1) x -> In (pwo_S WO1) y -> pwo_R WO1 x y <-> pwo_R WO2 x y; pwo_downward_closed : forall x y : T, In (pwo_S WO1) y -> In (pwo_S WO2) x -> pwo_R WO2 x y -> In (pwo_S WO1) x } Arguments Build_partial_WO_ord _ _ _ (_ _)%function_scope\npwo_S = fun p : partial_WO => let (pwo_S, pwo_R, _, _) := p in pwo_S : partial_WO -> Ensemble T\nRecord partial_WO : Type := Build_partial_WO { pwo_S : Ensemble T; pwo_R : relation T; pwo_R_lives_on_S : forall x y : T, pwo_R x y -> In pwo_S x /\\ In pwo_S y; pwo_wo : well_order (restriction_relation pwo_R pwo_S) } Arguments Build_partial_WO _ _ _%function_scope\npartial_WO_chain_ub_correct : forall (C : Ensemble partial_WO) (c : chain partial_WO_ord C) (WO : partial_WO), In C WO -> partial_WO_ord WO (partial_WO_chain_ub C c)\nextend_strictly_partial_WO_correct : forall (WO : partial_WO) (x : T) (ni : ~ In (pwo_S WO) x), partial_WO_ord WO (extend_strictly_partial_WO WO x ni)\npartial_WO_chain_ub : forall C : Ensemble partial_WO, chain partial_WO_ord C -> partial_WO\npwo_S_incl : forall WO1 WO2 : partial_WO, partial_WO_ord WO1 WO2 -> Included (pwo_S WO1) (pwo_S WO2)\npwo_downward_closed : forall WO1 WO2 : partial_WO, partial_WO_ord WO1 WO2 -> forall x y : T, In (pwo_S WO1) y -> In (pwo_S WO2) x -> pwo_R WO2 x y -> In (pwo_S WO1) x\npwo_restriction : forall WO1 WO2 : partial_WO, partial_WO_ord WO1 WO2 -> forall x y : T, In (pwo_S WO1) x -> In (pwo_S WO1) y -> pwo_R WO1 x y < -> pwo_R WO2 x y\nBuild_partial_WO : forall (pwo_S : Ensemble T) (pwo_R : relation T), (forall x y : T, pwo_R x y -> In pwo_S x /\\ In pwo_S y) -> well_order (restriction_relation pwo_R pwo_S) -> partial_WO\npartial_WO_preord = {| preord_refl := fun x : partial_WO => match x as p return (partial_WO_ord p p) with | {| pwo_S := pwo_S0; pwo_R := pwo_R0; pwo_R_lives_on_S := pwo_R_lives_on_S0; pwo_wo := pwo_wo0 |} => {| pwo_S_incl := fun (x0 : T) (H : In pwo_S0 x0) => H; pwo_restriction := fun (x0 y : T) (_ : In pwo_S0 x0) (_ : In pwo_S0 y) => conj (fun H1 : pwo_R0 x0 y => H1) (fun H1 : pwo_R0 x0 y => H1); pwo_downward_closed := fun (x0 y : T) (_ : In pwo_S0 y) (H0 : In pwo_S0 x0) (_ : pwo_R0...\nZornsLemmaForPreorders : forall (T : Type) (R : relation T), preorder R -> (forall S : Ensemble T, chain R S -> exists x : T, forall y : T, In S y -> R y x) -> exists x : T, premaximal R x\nBuild_partial_WO_ord : forall WO1 WO2 : partial_WO, Included (pwo_S WO1) (pwo_S WO2) -> (forall x y : T, In (pwo_S WO1) x -> In (pwo_S WO1) y -> pwo_R WO1 x y <-> pwo_R WO2 x y) -> (forall x y : T, In (pwo_S WO1) y -> In (pwo_S WO2) x -> pwo_R WO2 x y -> In (pwo_S WO1) x) -> partial_WO_ord WO1 WO2\npwo_wo : forall p : partial_WO, well_order (restriction_relation (pwo_R p) (pwo_S p))\nQuotients.quotient : forall A : Type, relation A -> Type\nInverseImage.inverse_image_id : (forall y : ?Y, ?f (?g y) = y) -> forall S : Ensemble ?Y, InverseImage.inverse_image ?g (InverseImage.inverse_image ?f S) = S where ?X : [T : Type |- Type] ?Y : [T : Type |- Type] ?f : [T : Type |- ?X -> ?Y] ?g : [T : Type |- ?Y -> ?X]\nInverseImage.inverse_image_full : forall f : ?X -> ?Y, InverseImage.inverse_image f Full_set = Full_set where ?X : [T : Type |- Type] ?Y : [T : Type |- Type]\nImage.image_empty : forall f : ?U -> ?V, Image.Im Empty_set f = Empty_set where ?U : [T : Type |- Type] ?V : [T : Type |- Type]\nInverseImage.inverse_image_full_set : forall f : ?X -> ?Y, InverseImage.inverse_image f Full_set = Full_set where ?X : [T : Type |- Type] ?Y : [T : Type |- Type]\nInverseImage.inverse_image_empty : forall f : ?X -> ?Y, InverseImage.inverse_image f Empty_set = Empty_set where ?X : [T : Type |- Type] ?Y : [T : Type |- Type]\nInverseImage.inverse_image_empty_set : forall f : ?X -> ?Y, InverseImage.inverse_image f Empty_set = Empty_set where ?X : [T : Type |- Type] ?Y : [T : Type |- Type]\nInverseImage.inverse_image_family_union : forall F : Families.Family ?Y, (forall x : ?X, ?g (?f x) = x) -> (forall y : ?Y, ?f (?g y) = y) -> InverseImage.inverse_image ?f (Families.FamilyUnion F) = Families.FamilyUnion (InverseImage.inverse_image (InverseImage.inverse_image ?g) F) where ?X : [T : Type |- Type] ?Y : [T : Type |- Type] ?f : [T : Type |- ?X -> ?Y] ?g : [T : Type |- ?Y -> ?X]\nInverseImage.inverse_image_image_surjective : forall (f : ?X -> ?Y) (T0 : Ensemble ?Y), FunctionProperties.surjective f -> Image.Im (InverseImage.inverse_image f T0) f = T0 where ?X : [T : Type |- Type] ?Y : [T : Type |- Type]\nIndexedFamilies.IndexedFamily = fun A T : Type => A -> Ensemble T : Type -> Type -> Type Arguments IndexedFamilies.IndexedFamily (_ _)%type_scope\nrelation = fun A : Type => A -> A -> Prop : Type -> Type Arguments relation _%type_scope\nRelations_1.Relation = fun U : Type => U -> U -> Prop : Type -> Type Arguments Relations_1.Relation _%type_scope\nBuild_order : forall R : relation ?A, reflexive R -> transitive R -> antisymmetric R -> order R where ?A : [T : Type |- Type]\nBuild_preorder : forall R : relation ?A, reflexive R -> transitive R -> preorder R where ?A : [T : Type |- Type]\nEnsemble = fun U : Type => U -> Prop : Type -> Type Arguments Ensemble _%type_scope\nImage.Im_def : forall (X : Ensemble ?U) (f : ?U -> ?V) (x : ?U), In X x -> In (Image.Im X f) (f x) where ?U : [T : Type |- Type] ?V : [T : Type |- Type]\nintro_characteristic_sat : forall (P : ?X -> Prop) (x : ?X), P x -> In (characteristic_function_abstraction P) x where ?X : [T : Type |- Type]\nInverseImage.inverse_image_composition : forall (f : ?Y -> ?Z) (g : ?X -> ?Y) (U : Ensemble ?Z), InverseImage.inverse_image (fun x : ?X => f (g x)) U = InverseImage.inverse_image g (InverseImage.inverse_image f U) where ?X : [T : Type |- Type] ?Y : [T : Type |- Type] ?Z : [T : Type |- Type]\nFiniteTypes.FiniteT_ind : forall P : Type -> Prop, P False -> (forall T : Type, FiniteTypes.FiniteT T -> P T -> P (option T)) -> (forall (X Y : Type) (f1 : X -> Y), FiniteTypes.FiniteT X -> P X -> FunctionProperties.invertible f1 -> P Y) -> forall T : Type, FiniteTypes.FiniteT T -> P T"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]