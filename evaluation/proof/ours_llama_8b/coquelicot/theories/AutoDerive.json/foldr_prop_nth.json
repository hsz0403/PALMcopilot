[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\n\n\nGoal:\nforall (T : Type) (P : T -> Prop) (d : T) (l : seq T) (n : nat), foldr (fun (d0 : T) (acc : Prop) => P d0 /\\ acc) True l -> P d -> P (nth d l n)\n\nPremises:\nNotation seq := list\nInductive True : Prop := I : True\nInductive nat : Set := O : nat | S : nat -> nat For S: Argument scope is [nat_scope]\nfoldr = fun (T R : Type) (f : T -> R -> R) (z0 : R) => fix foldr (s : seq T) : R := match s with | [::] => z0 | x :: s' => f x (foldr s') end : forall T R : Type, (T -> R -> R) -> R -> seq T -> R Arguments T, R are implicit and maximally inserted Argument scopes are [type_scope type_scope function_scope _ list_scope]\nnth = fun (T : Type) (x0 : T) => fix nth (s : seq T) (n : nat) {struct n} : T := match s with | [::] => x0 | x :: s' => match n with | 0%nat => x | S n' => nth s' n' end end : forall T : Type, T -> seq T -> nat -> T Argument T is implicit and maximally inserted Argument scopes are [type_scope _ list_scope nat_scope]\ndomain_ind' : forall P : domain -> Prop, P Never -> P Always -> (forall (p : R -> Prop) (e : expr), P (Partial p e)) -> (forall (n k : nat) (f : Rn k R) (le : seq expr), P (Derivable n k f le)) -> (forall (m n k : nat) (f : Rn k R) (le : seq expr), P (Derivable2 m n k f le)) -> (forall (n : nat) (e : expr), P (Continuous n e)) -> (forall (m n : nat) (e : expr), P (Continuous2 m n e)) -> (forall f e1 e2 : expr, P (Integrable f e1 e2)) -> (forall (n : nat) (f e1 e2 : expr), P (ParamIntegrable n f e1 e2)) ->...-> forall d : domain, P d\nlist_rec : forall (A : Type) (P : seq A -> Set), P [::] -> (forall (a : A) (l : seq A), P l -> P (a :: l)) -> forall l : seq A, P l\nlist_ind : forall (A : Type) (P : seq A -> Prop), P [::] -> (forall (a : A) (l : seq A), P l -> P (a :: l)) -> forall l : seq A, P l\nexpr_ind' : forall P : expr -> Prop, (forall n : nat, P (Var n)) -> (forall (k : nat) (f : Rn k R) (le : seq expr), foldr (fun (e : expr) (acc : Prop) => P e /\\ acc) True le -> P (AppExt k f le)) -> (forall (k : nat) (f : Rn k R) (n : nat) (le : seq expr), foldr (fun (e : expr) (acc : Prop) => P e /\\ acc) True le -> P (AppExtD k f n le)) -> (forall e1 e2 : expr, P e1 -> P e2 -> P (App e1 e2)) -> (forall e1 e2 : expr, P e1 -> P e2 -> P (Subst e1 e2)) -> (forall r : R, P (Cst r)) ->...-> forall e : expr, P e\nlast_ind : forall (T : Type) (P : seq T -> Type), P [::] -> (forall (s : seq T) (x : T), P s -> P (rcons s x)) -> forall s : seq T, P s\nelimT : forall (P : Prop) (b : bool), reflect P b -> b -> P\nexist : forall (A : Type) (P : A -> Prop) (x : A), P x -> {x : A | P x}\nelimTF : forall (P : Prop) (b c : bool), reflect P b -> b = c -> if c then P else ~ P\niffP : forall (P Q : Prop) (b : bool), reflect P b -> (P -> Q) -> (Q -> P) -> reflect Q b\nintroTFn : forall (P : Prop) (b c : bool), reflect P (~~ b) -> (if c then ~ P else P) -> b = c\nSF_seq.nth_le_seq_step : forall (x0 : R) (l : seq R) (i : nat), (S i < size l)%nat -> Rabs (nth x0 l (S i) - nth x0 l i) <= SF_seq.seq_step l\nSF_seq.sorted = fix sorted (T : Type) (Ord : T -> T -> Prop) (s : seq T) {struct s} : Prop := match s with | [::] => True | [:: h0] => True | h0 :: (h1 :: _) as t0 => Ord h0 h1 /\\ sorted T Ord t0 end : forall T : Type, (T -> T -> Prop) -> seq T -> Prop Argument T is implicit and maximally inserted Argument scopes are [type_scope function_scope list_scope]\nInductive reflect (P : Prop) : bool -> Set := ReflectT : P -> reflect P true | ReflectF : ~ P -> reflect P false For reflect: Argument scopes are [type_scope bool_scope] For ReflectT: Argument scopes are [type_scope _] For ReflectF: Argument scopes are [type_scope _]\nall_iff = fun (P0 : Prop) (Ps : seq Prop) => let fix loop (P : Prop) (Qs : seq Prop) {struct Qs} : Prop := match Qs with | [::] => P -> P0 | Q :: Qs0 => all_iff_and (P -> Q) (loop Q Qs0) end in loop P0 Ps : Prop -> seq Prop -> Prop Argument scopes are [type_scope list_scope]\nnat_ind : forall P : nat -> Prop, P 0%nat -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n\nInductive sig (A : Type) (P : A -> Prop) : Type := exist : forall x : A, P x -> {x : A | P x} For sig: Argument A is implicit For exist: Argument A is implicit For sig: Argument scopes are [type_scope type_scope] For exist: Argument scopes are [type_scope function_scope _ _]\nAllIffConj : forall P Q : Prop, P -> Q -> all_iff_and P Q\nReflectT : forall P : Prop, P -> reflect P true\nInductive all_iff_and (P Q : Prop) : Prop := AllIffConj : P -> Q -> all_iff_and P Q For AllIffConj: Arguments P, Q are implicit For all_iff_and: Argument scopes are [type_scope type_scope] For AllIffConj: Argument scopes are [type_scope type_scope _ _]\nReflectF : forall P : Prop, ~ P -> reflect P false\nprop_in1 : forall T1 : Type, mem_pred T1 -> forall P : T1 -> Prop, phantom Prop (forall x : T1, P x) -> Prop\nsize_mkseq : forall (T : Type) (f : nat -> T) (n : nat), size (mkseq f n) = n\nprop_in2 : forall T1 : Type, mem_pred T1 -> forall P : T1 -> T1 -> Prop, phantom Prop (forall x y : T1, P x y) -> Prop\nfoldl_rev : forall (T R : Type) (f : R -> T -> R) (z : R) (s : seq T), foldl f z (rev s) = foldr (fun (x : T) (z0 : R) => f z0 x) z s\nnth_mkseq : forall (T : Type) (x0 : T) (f : nat -> T) (n i : nat), ssrnat.leq (S i) n -> nth x0 (mkseq f n) i = f i\nnth_reshape : forall (T : Type) (sh : seq nat) (l : seq T) (n : nat), nth [::] (reshape sh l) n = take (nth 0%nat sh n) (drop (sumn (take n sh)) l)\nset_nth_default : forall (T : Type) (s : seq T) (y0 x0 : T) (n : nat), ssrnat.leq (S n) (size s) -> nth x0 s n = nth y0 s n\ntake_nth : forall (T : Type) (x0 : T) (n : nat) (s : seq T), ssrnat.leq (S n) (size s) -> take (S n) s = rcons (take n s) (nth x0 s n)\nbefore_find : forall (T : Type) (x0 : T) (a : pred T) (s : seq T) (i : nat), ssrnat.leq (S i) (find a s) -> a (nth x0 s i) = false\nnth_default : forall (T : Type) (x0 : T) (s : seq T) (n : nat), ssrnat.leq (size s) n -> nth x0 s n = x0"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]