[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nK: AbsRing\nV: NormedModule K\n\nGoal:\nis_linear opp\n\nPremises:\nRecord is_linear (K : AbsRing) (U V : NormedModule K) (l : U -> V) : Prop := Build_is_linear { linear_plus : forall x y : U, l (plus x y) = plus (l x) (l y); linear_scal : forall (k : K) (x : U), l (scal k x) = scal k (l x); linear_norm : exists M : R, 0 < M /\\ (forall x : U, norm (l x) <= M * norm x) } For is_linear: Arguments K, U, V are implicit and maximally inserted For Build_is_linear: Arguments K, U, V are implicit and maximally inserted For is_linear: Argument scopes are [_ _ _ function_scope] For Build_is_linear: Argument scopes are [_ _ _ function_scope function_scope function_scope _]\nNotation NormedModule := NormedModule.type\nlinear_opp : forall (l : ?U -> ?V) (x : ?U), is_linear l -> l (opp x) = opp (l x) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nis_linear_comp : forall (l1 : ?U -> ?V) (l2 : ?V -> ?W), is_linear l1 -> is_linear l2 -> is_linear (fun x : ?U => l2 (l1 x)) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?W : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nis_linear_ext : forall l1 l2 : ?U -> ?V, (forall x : ?U, l1 x = l2 x) -> is_linear l1 -> is_linear l2 where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nopp_opp : forall x : ?G, opp (opp x) = x where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nopp_mult_m1 : forall x : ?K, opp x = mult (opp one) x where ?K : [K : AbsRing V : NormedModule K |- Ring]\nfilterlim_opp : forall x : ?V, filterlim opp (locally x) (locally (opp x)) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nopp_plus : forall x y : ?G, opp (plus x y) = plus (opp x) (opp y) where ?G : [K : AbsRing V : NormedModule K |- AbelianGroup]\nscal_opp_one : forall u : ?V, scal (opp one) u = opp u where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nscal_opp_l : forall (x : ?K) (u : ?V), scal (opp x) u = opp (scal x u) where ?K : [K : AbsRing V : NormedModule K |- Ring] ?V : [K : AbsRing V : NormedModule K |- ModuleSpace ?K]\nlinear_zero : forall l : ?U -> ?V, is_linear l -> l zero = zero where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nlinear_cont : forall (l : ?U -> ?V) (x : ?U), is_linear l -> continuous l x where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\ncontinuous_opp : forall (f : ?U -> ?V) (x : ?U), continuous f x -> continuous (fun x0 : ?U => opp (f x0)) x where ?U : [K : AbsRing V : NormedModule K |- UniformSpace] ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nlinear_plus : forall l : ?U -> ?V, is_linear l -> forall x y : ?U, l (plus x y) = plus (l x) (l y) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nlinear_scal : forall l : ?U -> ?V, is_linear l -> forall (k : ?K) (x : ?U), l (scal k x) = scal k (l x) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nopp = fun G : AbelianGroup => AbelianGroup.opp G (AbelianGroup.class G) : forall G : AbelianGroup, G -> G Argument G is implicit and maximally inserted\nlinear_norm : forall l : ?U -> ?V, is_linear l -> exists M : R, 0 < M /\\ (forall x : ?U, norm (l x) <= M * norm x) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nBuild_is_linear : forall l : ?U -> ?V, (forall x y : ?U, l (plus x y) = plus (l x) (l y)) -> (forall (k : ?K) (x : ?U), l (scal k x) = scal k (l x)) -> (exists M : R, 0 < M /\\ (forall x : ?U, norm (l x) <= M * norm x)) -> is_linear l where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nMopp = fun (G : AbelianGroup) (m n : nat) (A : matrix m n) => mk_matrix m n (fun i j : nat => opp (coeff_mat zero A i j)) : forall (G : AbelianGroup) (m n : nat), matrix m n -> matrix m n Arguments G, m, n are implicit and maximally inserted Argument scopes are [_ nat_scope nat_scope _]\nis_linear_id = {| linear_plus := fun x y : V => eq_refl; linear_scal := fun (k : K) (x : V) => eq_refl; linear_norm := ex_intro (fun M : R => 0 < M /\\ (forall x : V, norm x <= M * norm x)) 1 (conj Rlt_0_1 (fun x : V => (fun _evar_0_ : norm x <= norm x => eq_ind_r (fun _pattern_value_ : R => norm x <= _pattern_value_) _evar_0_ (Rmult_1_l (norm x))) (Rle_refl (norm x)))) |} : is_linear (fun x : V => x)\nis_linear_zero = fun (K : AbsRing) (U V : NormedModule K) => {| linear_plus := fun _ _ : U => (fun _evar_0_ : zero = zero => eq_ind_r (fun _pattern_value_ : V => zero = _pattern_value_) _evar_0_ (plus_zero_l zero)) eq_refl; linear_scal := fun (k : K) (_ : U) => (fun _evar_0_ : zero = zero => eq_ind_r (fun _pattern_value_ : V => zero = _pattern_value_) _evar_0_ (scal_zero_r k)) eq_refl; linear_norm := ex_intro (fun M : R => 0 < M /\\ (forall x : U, norm zero <= M * norm x)) 1 (conj Rlt_0_1 (fun x : U => (fun _evar_0_ : norm zero <= norm x => eq_ind_r (fun _pattern_value_ : R => norm zero <= _pattern_value_) _evar_...\nprod_norm_eq_zero : forall x : ?U * ?V, prod_norm x = 0 -> x = zero where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nprod_norm_triangle : forall x y : ?U * ?V, prod_norm (plus x y) <= prod_norm x + prod_norm y where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\ndomin_rw_l : forall (f1 f2 : ?T -> ?U) (g : ?T -> ?V), is_equiv ?F f1 f2 -> is_domin ?F f1 g -> is_domin ?F f2 g where ?T : [K : AbsRing V : NormedModule K |- Type] ?Ku : [K : AbsRing V : NormedModule K |- AbsRing] ?Kv : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?Ku] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?Kv] ?F : [K : AbsRing V : NormedModule K |- (?T -> Prop) -> Prop] ?FF : [K : AbsRing V : NormedModule K |- Filter ?F]\nprod_norm_compat1 : forall (x y : ?U * ?V) (eps : R), prod_norm (minus y x) < eps -> ball x eps y where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nprod_norm_compat2 : forall (x y : ?U * ?V) (eps : posreal), ball x eps y -> prod_norm (minus y x) < prod_norm_factor * eps where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\ndomin_plus : forall (f : ?T -> ?U) (g1 g2 : ?T -> ?V), is_domin ?F f g1 -> is_domin ?F f g2 -> is_domin ?F f (fun x : ?T => plus (g1 x) (g2 x)) where ?T : [K : AbsRing V : NormedModule K |- Type] ?Ku : [K : AbsRing V : NormedModule K |- AbsRing] ?Kv : [K : AbsRing V : NormedModule K |- AbsRing] ?U : [K : AbsRing V : NormedModule K |- NormedModule ?Ku] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?Kv] ?F : [K : AbsRing V : NormedModule K |- (?T -> Prop) -> Prop] ?FF : [K : AbsRing V : NormedModule K |- Filter ?F]\nequiv_sym : forall f g : ?T -> ?V, is_equiv ?F f g -> is_equiv ?F g f where ?T : [K : AbsRing V : NormedModule K |- Type] ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K] ?F : [K : AbsRing V : NormedModule K |- (?T -> Prop) -> Prop] ?FF : [K : AbsRing V : NormedModule K |- Filter ?F]\nnorm_ge_0 : forall x : ?V, 0 <= norm x where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nlocally_norm_le_locally : forall x : ?V, filter_le (locally_norm x) (locally x) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]\nlocally_le_locally_norm : forall x : ?V, filter_le (locally x) (locally_norm x) where ?K : [K : AbsRing V : NormedModule K |- AbsRing] ?V : [K : AbsRing V : NormedModule K |- NormedModule ?K]"}, {"role": "assistant", "content": "```coq\nTheorem: is_linear opp.\nProof.\n  intros K U V l Hl.\n  assert (Hl': is_linear l).\n  { apply Build_is_linear with (M:=1); auto. }\n  apply Build_is_linear with (linear_plus:=fun x y => eq_refl) (linear_scal:=fun (k : K) (x : U) => eq_refl) (linear_norm:=ex_intro (fun M : R => 0 < M /\\ (forall x : U, norm (l x) <= M * norm x)) 1 (conj Rlt_0_1 (fun x : U => (fun _evar_0_ : norm (l x) <= norm x => eq_ind_r (fun _pattern_value_ : R => norm (l x) <= _pattern_value_) _evar_0_ (Rmult_1_l (norm x))) (Rle_refl (norm x))))).\n  { auto. }\n  assert (Hl'' : is_linear (fun x : U => l (opp x))).\n  { apply Build_is_linear with (linear_plus:=fun x y => eq_refl) (linear_scal:=fun (k : K) (x : U) => eq_refl) (linear_norm:=ex_intro (fun M : R => 0 < M /\\ (forall x : U, norm (l (opp x)) <= M * norm x)) 1 (conj Rlt_0_1 (fun x : U => (fun _evar_0_ : norm (l (opp x)) <= norm x => eq_ind_r (fun _pattern_value_ : R => norm (l (opp x)) <= _pattern_value_) _evar_0_ (Rmult_1_l (norm x))) (Rle_refl (norm x))))).\n    { auto. }\n  apply Build_is_linear with (linear_plus:=fun x y => eq_refl) (linear_scal:=fun (k : K) (x : U) => eq_refl) (linear_norm:=ex_intro (fun M : R => 0 < M /\\ (forall x : U, norm (opp (l x)) <= M * norm x)) 1 (conj Rlt_0_1 (fun x : U => (fun _evar_0_ : norm (opp (l x)) <= norm x => eq_ind_r (fun _pattern_value_ : R => norm (opp (l x)) <= _pattern_value_) _evar_0_ (Rmult_1_l (norm x))) (Rle_refl (norm x))))).\n  { auto. }\n  auto.\nQed."}], "original": "", "succ": false}]