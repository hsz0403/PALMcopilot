[{"history": {"proof": "shelve.", "repairs": [""], "exceptions": []}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nK: AbsRing\n\nGoal:\nforall x : K, 0 <= abs x\n\nPremises:\nabs = AbsRing.abs (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : K -> R\nabs_triangle : forall x y : K, abs (plus x y) <= abs x + abs y\nabs_mult : forall x y : K, abs (mult x y) <= abs x * abs y\nabs_opp : forall x : K, abs (opp x) = abs x\nabs_eq_zero : forall x : K, abs x = 0 -> x = zero\nabs_minus : forall x y : K, abs (minus x y) = abs (minus y x)\nsin_ge_0 : forall x : R, 0 <= x -> x <= PI -> 0 <= sin x\nsign_le_0 : forall x : R, x <= 0 -> sign x <= 0\nFourier_util.Rle_zero_pos_plus1 : forall x : R, 0 <= x -> 0 <= 1 + x\nRle_mult_inv_pos : forall x y : R, 0 <= x -> 0 < y -> 0 <= x * / y\nRatan_seq_converging : forall x : R, 0 <= x <= 1 -> Un_cv (Ratan_seq x) 0\npow2_ge_0 : forall x : R, 0 <= x ^ 2\nnfloor : forall x : R, 0 <= x -> nat\ncos_ge_0 : forall x : R, - (PI / 2) <= x -> x <= PI / 2 -> 0 <= cos x\nRatan_seq_decreasing : forall x : R, 0 <= x <= 1 -> Un_decreasing (Ratan_seq x)\ncos_le_0 : forall x : R, PI / 2 <= x -> x <= 3 * (PI / 2) -> cos x <= 0\nnfloor_ex : forall x : R, 0 <= x -> {n : nat | INR n <= x < INR n + 1}\npow_lt_1_compat : forall (x : R) (n : nat), 0 <= x < 1 -> (0 < n)%nat -> 0 <= x ^ n < 1\nsign_le : forall x y : R, x <= y -> sign x <= sign y\nnonneg_derivative_0 : forall (f : R -> R) (pr : derivable f), increasing f -> forall x : R, 0 <= derive_pt f x (pr x)\nnonpos_derivative_0 : forall (f : R -> R) (pr : derivable f), decreasing f -> forall x : R, derive_pt f x (pr x) <= 0\nps_atan_exists_01 : forall x : R, 0 <= x <= 1 -> {l : R | Un_cv (fun N : nat => sum_f_R0 (tg_alt (Ratan_seq x)) N) l}\nIVT_cor : forall (f : R -> R) (x y : R), continuity f -> x <= y -> f x * f y <= 0 -> {z : R | x <= z <= y /\\ f z = 0}\nsin_gt_0 : forall x : R, 0 < x -> x < PI -> 0 < sin x\nRlt_mult_inv_pos : forall x y : R, 0 < x -> 0 < y -> 0 < x * / y\ndecreasing = fun f : R -> R => forall x y : R, x <= y -> f y <= f x : (R -> R) -> Prop Argument scope is [function_scope]\nincreasing = fun f : R -> R => forall x y : R, x <= y -> f x <= f y : (R -> R) -> Prop Argument scope is [function_scope]\nAbsRing.ax5 : forall (K : Ring) (m : AbsRing.mixin_of K) (x : K), AbsRing.abs K m x = 0 -> x = zero\nAbsRing.ax4 : forall (K : Ring) (m : AbsRing.mixin_of K) (x y : K), AbsRing.abs K m (mult x y) <= AbsRing.abs K m x * AbsRing.abs K m y\nAbsRing.ax3 : forall (K : Ring) (m : AbsRing.mixin_of K) (x y : K), AbsRing.abs K m (plus x y) <= AbsRing.abs K m x + AbsRing.abs K m y\nopp_mult_m1 : forall x : ?K, opp x = mult (opp one) x where ?K : [K : AbsRing |- Ring]"}, {"role": "assistant", "content": "```coq\n```"}], "original": "", "succ": false}]