[{"history": {"proof": "qsimpl time: 1 use: mult_one_l,AbsRing.", "repairs": ["no_match_term"], "exceptions": [{"ctx": ["unfold abs."], "tactic": "rewrite AbsRing.ax1.", "exn": "The LHS of AbsRing.ax1 (AbsRing.abs _ _ zero) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold abs."], "tactic": "rewrite mult_one_l.", "exn": "The LHS of mult_one_l (mult one _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold abs.", "qsimpl time: 1 use: mult_one_l,AbsRing."], "tactic": "rewrite mult_one_r.", "exn": "The LHS of mult_one_r (mult _ one) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold abs.", "qsimpl time: 1 use: mult_one_l,AbsRing.", "qsimpl time: 1 use: mult_one_r,mult_one_l,AbsRing."], "tactic": "reflexivity.", "exn": "In environment K : AbsRing H : forall x : ?K, mult one x = x H1 : forall x : ?K1, mult one x = x H0 : forall x : ?K0, mult x one = x Unable to unify \"1\" with \"AbsRing.abs (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) one\".", "type": "cannot_unify", "handled": true}]}, "chat": [{"role": "user", "content": "I will give you a Coq proof state, including both hypotheses and a specific goal and your need to prove it. Your response should be a singular code block of Coq proof starting with \"```coq\n\", ending with \"Qed.```\", without any additional explanation or commentary. Follow to these guidelines:\nIntroduce variables using unique names to avoid any conflicts.\nKeep each command distinct and separated, avoid concatenations like ';' or '[cmd|cmd]'.\nOrganize your proof with bullets like '-', '+', and '*' instead of braces ({, }). Shift to their double symbols like '--' and '++', when necessary.\nEffectively use given premises, follow the syntax and structure demonstrated in the examples provided.\n\nExample 1:\n\nHypotheses:\nn, m: nat\nIHn: m + n = n + m\n\nGoal:\nm + S n = S n + m\n\nProof:\n```coq\nsimpl. rewrite <- IHn. auto.\nQed.```\n\nExample 2:\nHypotheses:\n\nGoal:\nforall n m : nat, m + n = n + m\n\n```coq\nintros n m. induction n.\n- simpl. auto.\n- simpl. rewrite <- IHn. auto.\nQed.```\n\nSolve This Proof State:\n\nHypotheses:\nK: AbsRing\n\nGoal:\nabs one = 1\n\nPremises:\nabs = AbsRing.abs (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : K -> R\none = fun K : Ring => Ring.one (AbelianGroup.Pack K (Ring.class K) K) (Ring.class K) : forall K : Ring, K Argument K is implicit and maximally inserted\nmult_one_l : forall x : ?K, mult one x = x where ?K : [K : AbsRing |- Ring]\nmult_one_r : forall x : ?K, mult x one = x where ?K : [K : AbsRing |- Ring]\nAbsRing.Mixin : forall (K : Ring) (abs : K -> R), abs zero = 0 -> abs (opp one) = 1 -> (forall x y : K, abs (plus x y) <= abs x + abs y) -> (forall x y : K, abs (mult x y) <= abs x * abs y) -> (forall x : K, abs x = 0 -> x = zero) -> AbsRing.mixin_of K\nRecord mixin_of (K : Ring) : Type := Mixin { abs : K -> R; ax1 : abs zero = 0; ax2 : abs (opp one) = 1; ax3 : forall x y : K, abs (plus x y) <= abs x + abs y; ax4 : forall x y : K, abs (mult x y) <= abs x * abs y; ax5 : forall x : K, abs x = 0 -> x = zero } For Mixin: Argument scopes are [_ function_scope _ _ function_scope function_scope function_scope]\nabs_opp : forall x : K, abs (opp x) = abs x\nabs_minus : forall x y : K, abs (minus x y) = abs (minus y x)\nabs_opp_one = AbsRing.ax2 K (AbsRing.class K) : abs (opp one) = 1\nabs_eq_zero : forall x : K, abs x = 0 -> x = zero\nabs_zero = AbsRing.ax1 (Ring.Pack K (AbsRing.class K) K) (AbsRing.class K) : abs zero = 0\nabs_mult : forall x y : K, abs (mult x y) <= abs x * abs y\nabs_triangle : forall x y : K, abs (plus x y) <= abs x + abs y\nAbsRing.sort = fun t : AbsRing => let (sort, _, _) := t in sort : AbsRing -> Type AbsRing.sort is a coercion\nAbsRing.AbelianGroup = fun cT : AbsRing => let xT := let '{| AbsRing.sort := T |} := cT in T in AbelianGroup.Pack cT (AbsRing.class cT : AbsRing.class_of xT) xT : AbsRing -> AbelianGroup AbsRing.AbelianGroup is a coercion\nAbsRing.Ring = fun cT : AbsRing => let xT := let '{| AbsRing.sort := T |} := cT in T in Ring.Pack cT (AbsRing.class cT : AbsRing.class_of xT) xT : AbsRing -> Ring AbsRing.Ring is a coercion\nopp_opp : forall x : ?G, opp (opp x) = x where ?G : [K : AbsRing |- AbelianGroup]\nopp_mult_m1 : forall x : ?K, opp x = mult (opp one) x where ?K : [K : AbsRing |- Ring]\nplus_comm : forall x y : ?G, plus x y = plus y x where ?G : [K : AbsRing |- AbelianGroup]\nopp_mult_l : forall x y : ?K, opp (mult x y) = mult (opp x) y where ?K : [K : AbsRing |- Ring]\nopp_mult_r : forall x y : ?K, opp (mult x y) = mult x (opp y) where ?K : [K : AbsRing |- Ring]\nopp_plus : forall x y : ?G, opp (plus x y) = plus (opp x) (opp y) where ?G : [K : AbsRing |- AbelianGroup]\npow_n = fun K : Ring => fix pow_n (x : K) (N : nat) {struct N} : K := match N with | 0%nat => one | S i => mult x (pow_n x i) end : forall K : Ring, K -> nat -> K Argument K is implicit and maximally inserted Argument scopes are [_ _ nat_scope]\nAbsRing.Pack : forall sort : Type, AbsRing.class_of sort -> Type -> AbsRing\nRsqr_0 = Rmult_0_l 0 : 0\u00b2 = 0\nln_1 = eq_ind (exp 0) (fun r : R => ln r = 0) (eq_ind_r (fun r : R => r = 0) eq_refl (ln_exp 0)) 1 exp_0 : ln 1 = 0\npow_R1 : forall (r : R) (n : nat), r ^ n = 1 -> Rabs r = 1 \\/ n = 0%nat\ncos_pi2 = let (x, a) as s return (cos (proj1_sig s) = 0) := PI_2_aux in match a with | conj _ q => eq_ind (- - cos x) (fun r : R => r = 0) (eq_ind_r (fun r : R => - r = 0) Ropp_0 q) (cos x) (Ropp_involutive (cos x)) end : cos PI2 = 0\nRsqr_eq_abs_0 : forall x y : R, x\u00b2 = y\u00b2 -> Rabs x = Rabs y\nRabs_R0 = match Rcase_abs 0 as s return ((if s then - 0 else 0) = 0) with | left r => (fun H : ~ 0 < 0 => False_ind (- 0 = 0) (H r)) (Rlt_irrefl 0) | right _ => eq_refl end : Rabs 0 = 0\ncosh_0 = eq_ind_r (fun r : R => (exp 0 + exp r) / 2 = 1) (eq_ind_r (fun r : R => (r + r) / 2 = 1) (eq_ind 1 (fun r : R => r = 1) eq_refl (2 * / 2) (Rinv_r_sym 2 (IZR_neq 2 0 (fun H : 2%Z = 0%Z => let H0 : False := eq_ind 2%Z (fun e : Z => match e with | Z.pos _ => True | _ => False end) I 0%Z H in False_ind False H0)))) exp_0) Ropp_0 : cosh 0 = 1\nAbsRing.ax5 : forall (K : Ring) (m : AbsRing.mixin_of K) (x : K), AbsRing.abs K m x = 0 -> x = zero"}, {"role": "assistant", "content": "```coq\nunfold abs. rewrite AbsRing.ax1. rewrite mult_one_l. rewrite mult_one_r. reflexivity.\nQed.```"}], "original": "unfold abs. rewrite AbsRing.ax1. rewrite mult_one_l. rewrite mult_one_r. reflexivity.", "succ": false}]