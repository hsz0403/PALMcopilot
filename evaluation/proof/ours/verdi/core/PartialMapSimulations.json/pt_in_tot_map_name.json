[{"history": {"proof": "intros m m' l n H_pt_map_msg H_snd_eq_m H_in_filterMap. apply In_filterMap in H_in_filterMap. qauto use: @tot_map_name_inv_inverse unfold: snd, pt_map_name_msg, name, msg, fst inv: prod.", "repairs": ["", "ref_not_found", "hammer"], "exceptions": [{"ctx": ["intros m m' l n H_pt_map_msg H_snd_eq_m H_in_filterMap."], "tactic": "apply in_filterMap_In in H_in_filterMap.", "exn": "The reference in_filterMap_In was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m m' l n H_pt_map_msg H_snd_eq_m H_in_filterMap.", "apply In_filterMap in H_in_filterMap."], "tactic": "apply in_map_exists in H_in_filterMap.", "exn": "The reference in_map_exists was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m m' l n H_pt_map_msg H_snd_eq_m H_in_filterMap.", "apply In_filterMap in H_in_filterMap.", "apply RingMicromega.psubC in H_in_filterMap."], "tactic": ["destruct H_in_filterMap as [nm [H_in_l H_pt_map_name_msg]].", ""], "exn": "Expects a disjunctive pattern with 3 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros m m' l n H_pt_map_msg H_snd_eq_m H_in_filterMap. apply in_filterMap_In in H_in_filterMap. apply in_map_exists in H_in_filterMap. destruct H_in_filterMap as [nm [H_in_l H_pt_map_name_msg]]. rewrite <- H_pt_map_name_msg. apply H_snd_eq_m. apply H_in_l.", "hammer_times": 4, "succ": true, "time": 53.86703824996948}]