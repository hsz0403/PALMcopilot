[{"history": {"proof": "intros Phi Hmax x y. split. - intros H. apply (MCS_element_derivable Phi Hmax) in H as H1. srun best use: maximal_consistent_orp_witnessed unfold: orp_witnessed. - intros [Hx | Hy]. + hcrush use: @derivable_closed_element_derivable, @maximal_consistent_derivable_closed unfold: derivable_closed inv: IntuitionisticPropositionalSequentCalculus. + hauto lq: on use: @maximal_consistent_derivable_closed, maximal_consistent_orp_witnessed, @DCS_orp_iff.", "repairs": ["", "", "", "", "", "hammer", "", "", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1."], "tactic": "destruct H1 as [Hx Hy].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2."], "tactic": "apply (MCS_orp_iff Phi Hmax) in Hx.", "exn": "No such hypothesis: Hx", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2."], "tactic": "apply (MCS_orp_iff Phi Hmax) in Hy.", "exn": "No such hypothesis: Hy", "type": "no_hypos", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2."], "tactic": "destruct Hx, Hy.", "exn": "The reference Hx was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left."], "tactic": "apply H0.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty."], "tactic": "apply H.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L Phi : context x, y : expr H : Phi (x || y) H1 : Phi |-- x || y H2 : forall Psi : context, consistent Psi -> Included expr Phi Psi -> Included expr Psi Phi x0 : expr H3 : Phi |-- x0 -> False derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y Unable to unify \"Phi (x || y)\" with \"Ensembles.In expr (Empty_set expr) x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty."], "tactic": "apply H1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L Phi : context x, y : expr H : Phi (x || y) H1 : Phi |-- x || y H2 : forall Psi : context, consistent Psi -> Included expr Phi Psi -> Included expr Psi Phi x0 : expr H3 : Phi |-- x0 -> False derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y Unable to unify \"Phi |-- x || y\" with \"Ensembles.In expr (Empty_set expr) x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+"], "tactic": "apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y).", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L Gamma : Derivable L bSC : BasicSequentCalculus L Gamma minSC : MinimumSequentCalculus L Gamma ipSC : IntuitionisticPropositionalSequentCalculus L Gamma cpSC : ClassicalPropositionalSequentCalculus L Gamma Phi : context Hmax : maximal consistent Phi x, y : expr Hx : Phi x The term \"minSC\" has type \"MinimumSequentCalculus L Gamma\" while it is expected to have type \"derivable_closed Phi\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "apply (MCS_nonelement_inconsistent Phi Hmax).", "exn": "The reference Hmax was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax).", "exn": "The reference CP_rule_of_contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H."], "tactic": "apply MCS_nonelement_element.", "exn": "The reference MCS_nonelement_element was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2."], "tactic": "apply H0.", "exn": "In environment L : Language pL : PropositionalLanguage L Gamma : Derivable L minL : MinimumLanguage L Phi : context x, y : expr Hx : Phi x X0 : Prop H : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi x \\\\/ Phi y0 -> Phi (x || y0) H0 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi (x || y0) -> Phi x \\\\/ Phi y0 H2 : forall Psi : context, consistent Psi -> Included expr Phi Psi -> Included expr Psi Phi x0 : expr H3 : Phi |-- x0 -> False derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y Unable to unify \"?M6000 ?M6003 \\\\/ ?M6000 ?M6004\" with \"exists x : expr, ~ (let (derivable) := Gamma in derivable) (fun e : expr => Phi e) |-- x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "apply H.", "exn": "Found no subterm matching \"?M10298 || ?M10299\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*"], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "apply H0.", "exn": "In environment L : Language pL : PropositionalLanguage L Gamma : Derivable L minL : MinimumLanguage L Phi : context x, y : expr Hx : Phi x X0 : Prop H : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi x \\\\/ Phi y0 -> Phi (x || y0) H0 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi (x || y0) -> Phi x \\\\/ Phi y0 H2 : forall Psi : context, consistent Psi -> Included expr Phi Psi -> Included expr Psi Phi x0 : expr H3 : Phi |-- x0 -> False derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H1 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y : expr, (Phi (x || y) -> Phi x \\\\/ Phi y) /\\\\ (Phi x \\\\/ Phi y -> Phi (x || y)) X1, X2 : Prop H5 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y : expr, (Phi (x || y) -> Phi x \\\\/ Phi y) /\\\\ (Phi x \\\\/ Phi y -> Phi (x || y)) X3 : Prop Unable to unify \"?M19796 ?M19799 \\\\/ ?M19796 ?M19800\" with \"exists x : expr, ~ (let (derivable) := Gamma in derivable) (fun e : expr => Phi e) |-- x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*"], "tactic": "apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y).", "exn": "The reference minSC was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*"], "tactic": "apply (MCS_nonelement_inconsistent Phi Hmax).", "exn": "The reference Hmax was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*"], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'."], "tactic": "apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax).", "exn": "The reference CP_rule_of_contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'."], "tactic": "apply H.", "exn": "In environment L : Language pL : PropositionalLanguage L Gamma : Derivable L minL : MinimumLanguage L Phi : context x, y : expr Hx : Phi x X0 : Prop H : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi x \\\\/ Phi y0 -> Phi (x || y0) H0 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi (x || y0) -> Phi x \\\\/ Phi y0 H2 : forall Psi : context, consistent Psi -> Included expr Phi Psi -> Included expr Psi Phi x0 : expr H3 : Phi |-- x0 -> False derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H' : expr y0 : expr Unable to unify \"?M24627 ?M24630 \\\\/ ?M24627 y0\" with \"Phi (H' || y0)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "apply MCS_nonelement_element.", "exn": "The reference MCS_nonelement_element was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply NNPP."], "tactic": "apply H1.", "exn": "In environment L : Language pL : PropositionalLanguage L Gamma : Derivable L minL : MinimumLanguage L Phi : context x, y : expr Hx : Phi x X0 : Prop H : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi x \\\\/ Phi y0 -> Phi (x || y0) H0 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y0 : expr, Phi (x || y0) -> Phi x \\\\/ Phi y0 H2 : forall Psi : context, consistent Psi -> Included expr Phi Psi -> Included expr Psi Phi x0 : expr H3 : Phi |-- x0 -> False derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H' : expr H1 : forall Phi : context, derivable_closed Phi -> orp_witnessed Phi -> forall x y : expr, (Phi (x || y) -> Phi x \\\\/ Phi y) /\\\\ (Phi x \\\\/ Phi y -> Phi (x || y)) y0 : expr H4 : Phi (H' || y0) X1 : Prop Unable to unify \"(?M28926 (?M28929 || ?M28930) -> ?M28926 ?M28929 \\\\/ ?M28926 ?M28930) /\\\\ (?M28926 ?M28929 \\\\/ ?M28926 ?M28930 -> ?M28926 (?M28929 || ?M28930))\" with \"~ (Phi H' \\\\/ Phi y0) -> False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply NNPP.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "apply H.", "exn": "Found no subterm matching \"?M33189 || ?M33190\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply NNPP.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros Phi Hmax x y.", "split.", "-", "intros H.", "apply (MCS_element_derivable Phi Hmax) in H as H1.", "qsimpl time: 2.", "left.", "apply Constructive_sets.Included_Empty.", "shelve.", "-", "intros [Hx | Hy].", "+", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply H.", "apply H2.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "*", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "shelve.", "*", "intros H'.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "apply NNPP.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "qsimpl time: 2 use: DCS_orp_iff,orp_witnessed.", "shelve.", "*", "right."], "tactic": "apply H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros Phi Hmax x y. split. - intros H. apply (MCS_element_derivable Phi Hmax) in H as H1. destruct H1 as [Hx Hy]. apply (MCS_orp_iff Phi Hmax) in Hx. apply (MCS_orp_iff Phi Hmax) in Hy. destruct Hx, Hy. + left. apply H0. + right. apply H. + right. apply H1. - intros [Hx | Hy]. + apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y). * apply (MCS_nonelement_inconsistent Phi Hmax). intros H. apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax). apply H. apply MCS_nonelement_element. apply H0. apply H. * left. apply H0. + apply (DCS_orp_iff Phi minSC (orp_witnessed L pL Phi) x y). * apply (MCS_nonelement_inconsistent Phi Hmax). intros H. apply (CP_rule_of_contradiction (SequentCalculus2Axiomatization_ipAX L minL pL Gamma ipSC minSC) Hmax). apply H. apply MCS_nonelement_element. apply H1. apply H. * right. apply H1.", "succ": true}]