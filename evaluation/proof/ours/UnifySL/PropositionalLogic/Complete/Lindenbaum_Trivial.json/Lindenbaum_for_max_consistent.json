[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros P H1 H2 H3 H4."], "tactic": "intros CA init Hinit.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-"], "tactic": "intros Phi HPhi.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-"], "tactic": "apply H4.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Unable to unify \"Countable expr\" with \"consistent (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2."], "tactic": "unfold maximal.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi."], "tactic": "apply H1.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L SC : NormalSequentCalculus L GammaP GammaD bSC : BasicSequentCalculus L GammaD fwSC : FiniteWitnessedSequentCalculus L GammaD minSC : MinimumSequentCalculus L GammaD ipSC : IntuitionisticPropositionalSequentCalculus L GammaD cpSC : ClassicalPropositionalSequentCalculus L GammaD minAX : MinimumAxiomatization L GammaP ipAX : IntuitionisticPropositionalLogic L GammaP P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Hmax : context Phi : consistent Hmax HPhi : Included expr (LindenbaumConstruction H4 init P) Hmax Unable to unify \"Lindenbaum_ensures P derivable_closed\" with \"Included expr Hmax (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Hmax : context HPhi : Included expr (LindenbaumConstruction H4 init P) Hmax x : expr H0 : Hmax |-- x -> False andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y derivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H5 : forall x : expr, empty_context |-- x -> |-- x H6 : forall x : expr, |-- x -> empty_context |-- x Unable to unify \"Lindenbaum_ensures P orp_witnessed\" with \"Included expr Hmax (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "intros x y Hxy.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "intros x' y Hxy.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "apply HPhi.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Hmax : context HPhi : Included expr (LindenbaumConstruction H4 init P) Hmax x : expr H0 : Hmax |-- x -> False andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y derivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H5 : forall x : expr, empty_context |-- x -> |-- x H6 : forall x : expr, |-- x -> empty_context |-- x Unable to unify \"Included expr (LindenbaumConstruction H4 init P) Hmax\" with \"Included expr Hmax (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Hmax : context HPhi : Included expr (LindenbaumConstruction H4 init P) Hmax x : expr H0 : Hmax |-- x -> False andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y derivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H5 : forall x : expr, empty_context |-- x -> |-- x H6 : forall x : expr, |-- x -> empty_context |-- x Unable to unify \"Lindenbaum_ensures P orp_witnessed\" with \"Included expr Hmax (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "intros x y Hxy.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "intros x' y Hxy.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "apply HPhi.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Hmax : context HPhi : Included expr (LindenbaumConstruction H4 init P) Hmax x : expr H0 : Hmax |-- x -> False andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y derivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H5 : forall x : expr, empty_context |-- x -> |-- x H6 : forall x : expr, |-- x -> empty_context |-- x Unable to unify \"Included expr (LindenbaumConstruction H4 init P) Hmax\" with \"Included expr Hmax (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L pL : PropositionalLanguage L GammaP : Provable L GammaD : Derivable L P : Ensemble expr -> Prop H1 : Lindenbaum_ensures P derivable_closed H2 : Lindenbaum_ensures P orp_witnessed H3 : Lindenbaum_ensures P consistent H4 : Countable expr init : Ensemble expr H : P init Hmax : context HPhi : Included expr (LindenbaumConstruction H4 init P) Hmax x : expr H0 : Hmax |-- x -> False andp_intros : forall x y : expr, |-- x --> y --> x && y andp_elim1 : forall x y : expr, |-- x && y --> x andp_elim2 : forall x y : expr, |-- x && y --> y orp_intros1 : forall x y : expr, |-- x --> x || y orp_intros2 : forall x y : expr, |-- y --> x || y orp_elim : forall x y z : expr, |-- (x --> z) --> (y --> z) --> x || y --> z falsep_elim : forall x : expr, |-- FF --> x modus_ponens : forall x y : expr, |-- x --> y -> |-- x -> |-- y axiom1 : forall x y : expr, |-- x --> y --> x axiom2 : forall x y z : expr, |-- (x --> y --> z) --> (x --> y) --> x --> z derivable_excluded_middle : forall (Phi : context) (x : expr), Phi |-- x || ~~ x deduction_andp_intros : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- y -> Phi |-- x && y deduction_andp_elim1 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- x deduction_andp_elim2 : forall (Phi : context) (x y : expr), Phi |-- x && y -> Phi |-- y deduction_orp_intros1 : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x || y deduction_orp_intros2 : forall (Phi : context) (x y : expr), Phi |-- y -> Phi |-- x || y deduction_orp_elim : forall (Phi : Ensemble expr) (x y z : expr), Phi;; x |-- z -> Phi;; y |-- z -> Phi;; x || y |-- z deduction_falsep_elim : forall (Phi : context) (x : expr), Phi |-- FF -> Phi |-- x deduction_modus_ponens : forall (Phi : context) (x y : expr), Phi |-- x -> Phi |-- x --> y -> Phi |-- y deduction_impp_intros : forall (Phi : Ensemble expr) (x y : expr), Phi;; x |-- y -> Phi |-- x --> y derivable_finite_witnessed : forall (Phi : context) (y : expr), Phi |-- y -> exists xs : list expr, Forall Phi xs /\\\\ (fun x : expr => In x xs) |-- y deduction_weaken : forall (Phi Psi : Ensemble expr) (x : expr), Included expr Phi Psi -> Phi |-- x -> Psi |-- x derivable_assum : forall (Phi : Ensemble expr) (x : expr), Ensembles.In expr Phi x -> Phi |-- x deduction_subst : forall (Phi Psi : context) (y : expr), (forall x : expr, Psi x -> Phi |-- x) -> Union expr Phi Psi |-- y -> Phi |-- y H5 : forall x : expr, empty_context |-- x -> |-- x H6 : forall x : expr, |-- x -> empty_context |-- x Unable to unify \"Lindenbaum_ensures P orp_witnessed\" with \"Included expr Hmax (LindenbaumConstruction H4 init P)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros P H1 H2 H3 H4.", "intros.", "split.", "-", "qsimpl time: 2.", "-", "intros Hmax Phi HPhi.", "qsimpl time: 2."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros P H1 H2 H3 H4. unfold Lindenbaum_ensures. intros CA init Hinit. split. - intros Phi HPhi. apply H4. unfold maximal. split. + apply H3. intros Psi HPsi. apply HPhi. apply Ensembles_ext.left_Included_Union. auto. + intros Psi Hmax Psi_incl. apply Ensembles_ext.Included_trans with (Union expr Phi Psi). * apply Ensembles_ext.Union_Included. split. ++ apply Hmax. apply Ensembles_ext.left_Included_Union. ++ apply Hmax. apply Ensembles_ext.right_Included_Union. * auto. - intros Hmax Phi HPhi. apply H1. apply H2. + intros x y Hxy. apply HPhi. apply H2. left. auto. + intros x y Hxy. apply HPhi. apply H2. right. auto.", "succ": false}]