[{"history": {"proof": "qsimpl time: 2 use: multi_imp. qsimpl time: 2 use: fold_right_app,multi_imp. qsimpl time: 2 use: fold_right_app,multi_imp. qsimpl time: 2 use: fold_right_app,multi_imp. qsimpl time: 2 use: fold_right_app,multi_imp. qsimpl time: 2 use: fold_right_app,multi_imp.", "repairs": ["no_hypos", "no_hypos", "no_hypos", "no_hypos", "no_hypos", "no_hypos"], "exceptions": [{"ctx": ["intros xs1 xs2 y."], "tactic": "intros H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp."], "tactic": "unfold multi_imp in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app."], "tactic": "rewrite fold_right_app in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp."], "tactic": "apply provable_multi_imp_split in H'.", "exn": "No such hypothesis: H'", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp."], "tactic": "destruct H' as [xs1' [xs2' [H1 [H2 H3]]]].", "exn": "The reference H' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "destruct L as [xs1' [xs2' [H1 [H2 H3]]]]."], "tactic": "apply provable_multi_imp_shrink in H3.", "exn": "No such hypothesis: H3", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "destruct L as [xs1' [xs2' [H1 [H2 H3]]]].", "qsimpl time: 2 use: fold_right_app,multi_imp."], "tactic": "apply provable_multi_imp_weaken with (xs := xs1 ++ xs2') in H3.", "exn": "No such hypothesis: H3", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "destruct L as [xs1' [xs2' [H1 [H2 H3]]]].", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp."], "tactic": "apply provable_multi_imp_arg_switch2 in H3.", "exn": "No such hypothesis: H3", "type": "no_hypos", "handled": true}, {"ctx": ["intros xs1 xs2 y.", "unfold multi_imp.", "qsimpl time: 2 use: multi_imp.", "rewrite fold_right_app.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "destruct L as [xs1' [xs2' [H1 [H2 H3]]]].", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp.", "qsimpl time: 2 use: fold_right_app,multi_imp."], "tactic": "apply H3.", "exn": "The reference H3 was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros xs1 xs2 y. intros H. unfold multi_imp. unfold multi_imp in H. rewrite fold_right_app. unfold multi_imp. rewrite fold_right_app in H. unfold multi_imp in H. intros H'. apply provable_multi_imp_split in H'. destruct H' as [xs1' [xs2' [H1 [H2 H3]]]]. apply provable_multi_imp_shrink in H3. apply provable_multi_imp_weaken with (xs := xs1 ++ xs2') in H3. apply provable_multi_imp_arg_switch2 in H3. apply H3. apply provable_multi_imp_arg_switch1. apply H.", "succ": false}]