[{"history": {"proof": "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel. qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "repairs": ["not_evaluable", "no_instance_var"], "exceptions": [{"ctx": [], "tactic": "unfold BranchJoinKripkeIntuitionisticModel in *.", "exn": "Cannot coerce BranchJoinKripkeIntuitionisticModel to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "intros [Ha Hb].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "intros m1 m2 n H1 H2.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "intros m1 m2 n H1' H2.", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "intros m1 m2 n H1' H2'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "specialize (Ha m1 m2 n H1 H2) as [m [Hm1 Hm2]].", "exn": "The reference Ha was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "exists (a m).", "exn": "The reference a was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel."], "tactic": "apply Hm1.", "exn": "The reference Hm1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--"], "tactic": "apply Korder_identity, Hm2.", "exn": "In environment A : Type B : Type RA : Relation A RB : Relation B Korder_branch_join0 : forall m1 m2 n : B, n <= m1 -> n <= m2 -> exists m : B, m1 <= m /\\\\ m2 <= m Korder_branch_join1 : forall m1 m2 n : A, n <= m1 -> n <= m2 -> exists m : A, m1 <= m /\\\\ m2 <= m a0 : A a1 : B b0 : A b1 : B n0 : A n1 : B H1 : (RA @@1)%signature (n0, n1) (b0, b1) H2 : (RB @@2)%signature (n0, n1) (b0, b1) H0 : (RA @@1)%signature (n0, n1) (a0, a1) H3 : (RB @@2)%signature (n0, n1) (a0, a1) Unable to unify \"?M3961 = ?M3962\" with \"exists m : A * B, (a0, a1) <= m /\\\\ (b0, b1) <= m\".", "type": "cannot_unify", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*"], "tactic": "intros m1 m2 n H1 H2.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*"], "tactic": "intros m1 m2 n H1' H2.", "exn": "H2 is already used.", "type": "used_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*"], "tactic": "intros m1 m2 n H1' H2'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*"], "tactic": "specialize (Hb m1 m2 n H1 H2) as [m [Hm1 Hm2]].", "exn": "The reference Hb was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*"], "tactic": "exists (b m).", "exn": "The reference b was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*"], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel."], "tactic": "--", "exn": "Wrong bullet --: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve."], "tactic": "--", "exn": "Wrong bullet --: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*"], "tactic": "apply Hm1.", "exn": "The reference Hm1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd."], "tactic": "--", "exn": "Wrong bullet --: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--"], "tactic": "apply Korder_identity, Hm2.", "exn": "In environment A : Type B : Type RA : Relation A RB : Relation B Korder_branch_join0 : forall m1 m2 n : B, n <= m1 -> n <= m2 -> exists m : B, m1 <= m /\\\\ m2 <= m Korder_branch_join1 : forall m1 m2 n : A, n <= m1 -> n <= m2 -> exists m : A, m1 <= m /\\\\ m2 <= m a0 : A a1 : B b0 : A b1 : B n0 : A n1 : B H1 : (RA @@1)%signature (n0, n1) (b0, b1) H2 : (RB @@2)%signature (n0, n1) (b0, b1) H0 : (RA @@1)%signature (n0, n1) (a0, a1) H3 : (RB @@2)%signature (n0, n1) (a0, a1) Unable to unify \"?M5545 = ?M5546\" with \"list (exists m : A * B, (a0, a1) <= m /\\\\ (b0, b1) <= m)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel."], "tactic": "intros [m [Hm1 Hm2]].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "split.", "intros n Hn1 Hn2."], "tactic": "destruct (Hm1 n Hn1 Hn2) as [m' [Hm'1 Hm'2]].", "exn": "The reference Hm1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "split.", "intros n Hn1 Hn2."], "tactic": "exists m'.", "exn": "The reference m' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "split.", "intros n Hn1 Hn2."], "tactic": "split.", "exn": "In environment A : Type B : Type RA : Relation A RB : Relation B Korder_branch_join0 : forall m1 m2 n : B, n <= m1 -> n <= m2 -> exists m : B, m1 <= m /\\\\ m2 <= m Korder_branch_join1 : forall m1 m2 n : A, n <= m1 -> n <= m2 -> exists m : A, m1 <= m /\\\\ m2 <= m a0 : A a1 : B b0 : A b1 : B n0 : A n1 : B H1 : (RA @@1)%signature (n0, n1) (b0, b1) H2 : (RB @@2)%signature (n0, n1) (b0, b1) H0 : (RA @@1)%signature (n0, n1) (a0, a1) H3 : (RB @@2)%signature (n0, n1) (a0, a1) n, Hn1 : B Hn2 : n <= Hn1 Unable to unify \"Hn1\" with \"n\".", "type": "cannot_unify", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "split.", "intros n Hn1 Hn2.", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel."], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "split.", "intros a b.", "qsimpl time: 2 use: BranchJoinKripkeIntuitionisticModel.", "apply hd.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "*", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "shelve.", "*", "apply hd.", "++", "shelve.", "++", "shelve.", "--", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "split.", "intros n Hn1 Hn2.", "qsimpl time: 2 use: Korder_identity,BranchJoinKripkeIntuitionisticModel.", "++", "shelve.", "++", "shelve."], "tactic": "--", "exn": "Wrong bullet --: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "unfold BranchJoinKripkeIntuitionisticModel in *. split. - intros a b. split. + intros [Ha Hb]. split. * intros m1 m2 n H1 H2. specialize (Ha m1 m2 n H1 H2) as [m [Hm1 Hm2]]. exists (a m). split. -- apply Hm1. -- apply Korder_identity, Hm2. * intros m1 m2 n H1 H2. specialize (Hb m1 m2 n H1 H2) as [m [Hm1 Hm2]]. exists (b m). split. -- apply Hm1. -- apply Korder_identity, Hm2. + intros [m [Hm1 Hm2]]. split. * intros n Hn1 Hn2. destruct (Hm1 n Hn1 Hn2) as [m' [Hm'1 Hm'2]]. exists m'. split. -- apply Hm'1. -- apply Korder_identity, Hm'2. * intros n Hn1 Hn2. destruct (Hm2 n Hn1 Hn2) as [m' [Hm'1 Hm'2]]. exists m'. split. -- apply Hm'1. -- apply Korder_identity, Hm'2. - intros a b [Ha Hb]. split. + intros m1 m2 n H1 H2. destruct (Ha (fst m1) (fst m2) (fst n)) as [m [Hm1 Hm2]]. * apply H1. * apply H2. exists (a m). split. * apply Korder_no_branch, Hm1. * intros H. apply Hm2. apply Korder_identity, H. + intros m1 m2 n H1 H2. destruct (Hb (snd m1) (snd m2) (snd n)) as [m [Hm1 Hm2]]. * apply H1. * apply H2. exists (b m). split. * apply Korder_no_branch, Hm1. * intros H. apply Hm2. apply Korder_identity, H.", "succ": false}]