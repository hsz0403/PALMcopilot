[{"history": {"proof": "qsimpl time: 2 use: sat_impp. qsimpl time: 2 use: sat_impp. qsimpl time: 2 use: sat_impp. qsimpl time: 2 use: denote_sepcon,sat_impp.", "repairs": ["no_hypos", "no_instance_var", "cannot_unify", "cannot_apply_in"], "exceptions": [{"ctx": [], "tactic": "intros x y m HM.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "apply sound_wand_sepcon_adjoint."], "tactic": "intros m' H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "apply sound_wand_sepcon_adjoint.", "intros."], "tactic": "apply sat_impp in H.", "exn": "No such hypothesis: H", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "apply sound_wand_sepcon_adjoint.", "intros.", "qsimpl time: 2 use: sat_impp."], "tactic": "destruct H as [H1 H2].", "exn": "Unable to find an instance for the variables m, x, y.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "apply sound_wand_sepcon_adjoint.", "intros.", "qsimpl time: 2 use: sat_impp.", "qsimpl time: 2 use: sat_impp."], "tactic": "apply H2.", "exn": "In environment L : Language minL : MinimumLanguage L MD : Model kMD : KripkeModel MD M : Kmodel R : Relation (Kworlds M) SM : Semantics L MD pL : PropositionalLanguage L sepconL : SepconLanguage L wandL : WandLanguage L J : Join (Kworlds M) dSA : DownwardsClosedSeparationAlgebra (Kworlds M) dsepconSM : SepconSemantics L MD M SM dwandSM : WandSemantics L MD M SM x, y : expr m, m0 : Kworlds M H : forall (m : Kworlds M) (x y : expr), (forall n : Kworlds M, m <= n -> KRIPKE: M, n |= x -> KRIPKE: M, n |= y) -> KRIPKE: M, m |= x --> y H0 : forall (m : Kworlds M) (x y : expr), KRIPKE: M, m |= x --> y -> forall n : Kworlds M, m <= n -> KRIPKE: M, n |= x -> KRIPKE: M, n |= y all_increasing : forall x : Kworlds M, increasing x denote_andp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x && y)) (Semantics.andp (Kdenotation M x) (Kdenotation M y)) denote_orp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x || y)) (Semantics.orp (Kdenotation M x) (Kdenotation M y)) H1 : Included (Kworlds M) (Kdenotation M FF) Semantics.falsep H2 : Included (Kworlds M) Semantics.falsep (Kdenotation M FF) denote_impp : forall x y : expr, Same_set (Kworlds M) (Kdenotation M (x --> y)) (Semantics.impp (Kdenotation M x) (Kdenotation M y)) denote_closed : forall x : expr, upwards_closed_Kdenote (Kdenotation M x) join_comm : forall m1 m2 m : Kworlds M, join m1 m2 m -> join m2 m1 m join_assoc : forall mx my mz mxy mxyz : Kworlds M, join mx my mxy -> join mxy mz mxyz -> exists myz : Kworlds M, join my mz myz /\\\\ join mx myz mxyz PreOrder_Reflexive : Reflexive Krelation PreOrder_Transitive : Transitive Krelation H3 : forall (m : Kworlds M) (x y : expr), (KRIPKE: M, m |= x --> y -> forall n : Kworlds M, m <= n -> KRIPKE: M, n |= x -> KRIPKE: M, n |= y) /\\\\ ((forall n : Kworlds M, m <= n -> KRIPKE: M, n |= x -> KRIPKE: M, n |= y) -> KRIPKE: M, m |= x --> y) Unable to unify \"Included (Kworlds M) Semantics.falsep (Kdenotation M FF)\" with \"KRIPKE: M, m0 |= x --> y -* x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "apply sound_wand_sepcon_adjoint.", "intros.", "qsimpl time: 2 use: sat_impp.", "qsimpl time: 2 use: sat_impp.", "qsimpl time: 2 use: sat_impp."], "tactic": "apply HM.", "exn": "The reference HM was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "apply sound_wand_sepcon_adjoint.", "intros.", "qsimpl time: 2 use: sat_impp.", "qsimpl time: 2 use: sat_impp.", "qsimpl time: 2 use: sat_impp.", "apply denote_impp."], "tactic": "apply denote_sepcon in H1.", "exn": "Unable to apply lemma of type \"forall x0 y0 : expr, Same_set (Kworlds ?M) (Kdenotation ?M (x0 * y0)) (StrongSemantics.StrongSemantics.sepcon (Kdenotation ?M x0) (Kdenotation ?M y0))\" on hypothesis of type \"Included (Kworlds M) (Kdenotation M FF) Semantics.falsep\".", "type": "cannot_apply_in", "handled": true}]}, "chat": [], "original": "intros x y m HM. apply sound_wand_sepcon_adjoint. intros m' H. apply sat_impp in H. destruct H as [H1 H2]. apply H2. apply HM. apply denote_sepcon in H1. auto.", "succ": false}]