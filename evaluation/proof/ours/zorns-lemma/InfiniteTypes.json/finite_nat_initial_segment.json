[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n.", "induction n.", "-"], "tactic": "apply empty_finite.", "exn": "Unable to unify \"FiniteT False\" with \"FiniteT {m : nat | m < 0}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+"], "tactic": "apply finite_exp.", "exn": "In environment n : nat IHn : FiniteT {m : nat | m < n} Unable to unify \"FiniteT (?M1799 -> ?M1800)\" with \"FiniteT nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp."], "tactic": "apply finite_exp.", "exn": "In environment H0 : forall X Y : Type, FiniteT X -> FiniteT Y -> FiniteT (X -> Y) H : FiniteT False n : nat IHn : FiniteT {m : nat | m < n} Unable to unify \"FiniteT (?M2129 -> ?M2130)\" with \"FiniteT nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp."], "tactic": "apply finite_exp.", "exn": "In environment H2 : forall X Y : Type, FiniteT X -> FiniteT Y -> FiniteT (X -> Y) H1 : FiniteT False n : nat IHn : FiniteT {m : nat | m < n} Unable to unify \"FiniteT (?M2459 -> ?M2460)\" with \"FiniteT nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "shelve.", "+"], "tactic": "apply finite_nat_cardinal.", "exn": "The reference finite_nat_cardinal was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "shelve.", "+", "apply Nat.induction."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros n.", "induction n.", "-", "qsimpl use: empty_finite.", "shelve.", "-", "apply finite_subtype with (P := fun (m:nat) => m < S n).", "+", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "qsimpl use: empty_finite,finite_exp.", "shelve.", "+", "apply Nat.induction.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros n. induction n. - apply empty_finite. - apply finite_subtype with (P := fun (m:nat) => m < S n). + apply finite_exp. * apply finite_exp. { apply finite_exp. - apply finite_nat_cardinal. - apply finite_prod. + apply FiniteT_has_nat_cardinal. + apply FiniteT_has_nat_cardinal. } { apply finite_prod. - apply FiniteT_has_nat_cardinal. - apply FiniteT_has_nat_cardinal. } * apply finite_prod. { apply FiniteT_nat_cardinal. apply add_finite. apply FiniteT_has_nat_cardinal. } { apply add_finite. apply finite_nat_cardinal. } + intros m. destruct (lt_dec m (S n)). * exists m. split. { apply cardinal_unicity with (n := S n). - apply FiniteT_has_nat_cardinal. - apply card_add. + apply finite_nat_cardinal. + apply card_empty. } { intros p H. apply Fin.to_nat_of_nat. } * intros [p Hp]. apply (False_rect _ (nlt_0_r m Hp)).", "succ": false}]