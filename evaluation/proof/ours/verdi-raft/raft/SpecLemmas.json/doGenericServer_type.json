[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "unfold doGenericServer in H."], "tactic": "destruct (applyEntries h st (rev (filter (fun x : entry => lastApplied st <? eIndex x && eIndex x <=? commitIndex st) (findGtIndex (log st) (lastApplied st))))).", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params h : name st : raft_data os : list raft_output st' : raft_data ms : list (name * msg) H : (let (out, state) := applyEntries h st (rev (filter (fun x : entry => (lastApplied st <? eIndex x) && (eIndex x <=? commitIndex st)) (findGtIndex (log st) (lastApplied st)))) in (out, {[state with lastApplied := if lastApplied state <? commitIndex state then commitIndex state else lastApplied state]}, [])) = (os, st', ms) x : entry The term \"eIndex x\" has type \"logIndex\" while it is expected to have type \"bool\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "unfold doGenericServer in H.", "qsimpl use: entry,applyEntries,filter,commitIndex,log,lastApplied,rev,findGtIndex,eIndex."], "tactic": ["inversion H.", ""], "exn": "Illegal application: The term \"RaftState.type\" of type \"forall term name entry logIndex serverType stateMachineData clientId output : Type, RaftState.raft_data term name entry logIndex serverType stateMachineData clientId output -> serverType\" cannot be applied to the terms \"term\" : \"Set\" \"name\" : \"Type\" \"T\" : \"Type\" \"logIndex\" : \"Set\" \"serverType\" : \"Set\" \"data\" : \"Type\" \"clientId\" : \"Type\" \"output\" : \"Type\" \"st'\" : \"raft_data\" The 9th term has type \"raft_data\" which should be coercible to \"RaftState.raft_data term name T logIndex serverType data clientId output\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. intros. unfold doGenericServer in H. destruct (applyEntries h st (rev (filter (fun x : entry => lastApplied st <? eIndex x && eIndex x <=? commitIndex st) (findGtIndex (log st) (lastApplied st))))). inversion H. subst. simpl. split; reflexivity.", "succ": false}]