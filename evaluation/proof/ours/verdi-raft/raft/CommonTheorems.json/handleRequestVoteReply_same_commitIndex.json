[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n st src t v.", "unfold handleRequestVoteReply.", "simpl."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params n : name st : RaftState.raft_data term name entry logIndex serverType data clientId output src : name t : nat v : bool Unable to unify \"commitIndex st\" with \"commitIndex (if currentTerm st <? t then mkRaft_data (currentTerm (advanceCurrentTerm st t)) (votedFor (advanceCurrentTerm st t)) (leaderId (advanceCurrentTerm st t)) (log (advanceCurrentTerm st t)) (commitIndex (advanceCurrentTerm st t)) (lastApplied (advanceCurrentTerm st t)) (stateMachine (advanceCurrentTerm st t)) (nextIndex (advanceCurrentTerm st t)) (matchIndex (advanceCurrentTerm st t)) (shouldSend (advanceCurrentTerm st t)) (votesReceived (advanceCurrentTerm st t)) Follower (clientCache (advanceCurrentTerm st t)) (electoralVictories (advanceCurrentTerm st t)) else if t <? currentTerm st then st else match type st with | Candidate => mkRaft_data (currentTerm st) (votedFor st) (leaderId st) (log st) (commitIndex st) (lastApplied st) (stateMachine st) [] [ (n, maxIndex (log st))] (shouldSend st) ((if v then [src] else []) ++ votesReceived st) (if v && wonElection (if in_dec name_eq_dec src (votesReceived st) then dedup name_eq_dec (votesReceived st) else src :: dedup name_eq_dec (votesReceived st)) then Leader else type st) (clientCache st) ((if v && wonElection (if in_dec name_eq_dec src (votesReceived st) then dedup name_eq_dec (votesReceived st) else src :: dedup name_eq_dec (votesReceived st)) then [(currentTerm st, src :: votesReceived st, log st)] else []) ++ electoralVictories st) | _ => st end)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros n st src t v. unfold handleRequestVoteReply. simpl. reflexivity.", "succ": false}]