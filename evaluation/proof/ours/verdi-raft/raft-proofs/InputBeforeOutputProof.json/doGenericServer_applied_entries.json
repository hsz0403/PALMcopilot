[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-"], "tactic": "rewrite applied_entries_update with (st := r) by lia.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-"], "tactic": "rewrite H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1."], "tactic": "apply applied_entries_update.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params oiai : output_implies_applied_interface aiii : applied_implies_input_interface si : sorted_interface lacimi : lastApplied_commitIndex_match_interface lmi : log_matching_interface smsi : state_machine_safety_interface misi : max_index_sanity_interface uii : unique_indices_interface client : clientId id : nat ps : list packet h : name sigma : Net.name -> data os : list raft_output st' : raft_data ms : list (name * msg) H_reach : raft_intermediate_reachable {| nwPackets := ps; nwState := sigma |} l : list raft_output r : raft_data H0 : l = os H1 : mkRaft_data (currentTerm r) (votedFor r) (leaderId r) (log r) (commitIndex r) (if lastApplied r <? commitIndex r then commitIndex r else lastApplied r) (stateMachine r) (nextIndex r) (matchIndex r) (shouldSend r) (votesReceived r) (type r) (clientCache r) (electoralVictories r) = st' H2 : [] = ms Unable to unify \"applied_entries (update name_eq_dec ?M2111 ?M2112 ?M2113) = applied_entries ?M2111 /\\\\ (exists h' : name, argmax (fun h0 : name => lastApplied (?M2111 h0)) (all_fin N) = Some h' /\\\\ lastApplied (?M2111 h') >= lastApplied ?M2113) \\\\/ argmax (fun h' : name => lastApplied (update name_eq_dec ?M2111 ?M2112 ?M2113 h')) (all_fin N) = Some ?M2112 /\\\\ applied_entries (update name_eq_dec ?M2111 ?M2112 ?M2113) = rev (removeAfterIndex (log ?M2113) (lastApplied ?M2113))\" with \"applied_entries (update name_eq_dec sigma h st') = applied_entries sigma ++ rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update."], "tactic": "lia.", "exn": "The reference lia was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update.", "+", "shelve.", "+", "shelve.", "-", "intros e H_in."], "tactic": "apply in_app_iff in H_in.", "exn": "Unable to apply lemma of type \"forall (A : Type) (l l' : list A) (a : A), In a (l ++ l') <-> In a l \\\\/ In a l'\" on hypothesis of type \"In e (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h))))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update.", "+", "shelve.", "+", "shelve.", "-", "intros e H_in.", "qsimpl use: in_app_iff,applied_entries_update."], "tactic": "destruct H_in.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update.", "+", "shelve.", "+", "shelve.", "-", "intros e H_in.", "qsimpl use: in_app_iff,applied_entries_update.", "qsimpl use: in_app_iff,applied_entries_update."], "tactic": "eapply log_matching_nw with (p:=mkPacket h h (AppendEntries t h pli plt es ci)) in H_reach; try auto.", "exn": "The reference ci was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update.", "+", "shelve.", "+", "shelve.", "-", "intros e H_in.", "qsimpl use: in_app_iff,applied_entries_update.", "qsimpl use: in_app_iff,applied_entries_update."], "tactic": "specialize (H_reach (mkPacket h h (AppendEntries t h pli plt es ci)) t h pli plt es ci).", "exn": "The reference ci was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update.", "+", "shelve.", "+", "shelve.", "-", "intros e H_in.", "qsimpl use: in_app_iff,applied_entries_update.", "qsimpl use: in_app_iff,applied_entries_update."], "tactic": "apply H_reach.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params H2 : forall (sigma : name -> RaftState.raft_data term name entry logIndex serverType data clientId output) (h : name) (st : RaftState.raft_data term name entry logIndex serverType data clientId output), Raft.lastApplied st >= Raft.lastApplied (sigma h) -> applied_entries (update name_eq_dec sigma h st) = applied_entries sigma /\\\\ (exists h' : name, argmax (fun h0 : name => Raft.lastApplied (sigma h0)) (all_fin N) = Some h' /\\\\ Raft.lastApplied (sigma h') >= Raft.lastApplied st) \\\\/ argmax (fun h' : name => Raft.lastApplied (update name_eq_dec sigma h st h')) (all_fin N) = Some h /\\\\ applied_entries (update name_eq_dec sigma h st) = rev (removeAfterIndex (Raft.log st) (Raft.lastApplied st)) one_node_params : OneNodeParams orig_base_params client : clientId id : nat ps : list packet h : name sigma : name -> raft_data os : list raft_output H_reach : raft_intermediate_reachable {| nwPackets := ps; nwState := sigma |} e : entry H_in : In e (rev (removeAfterIndex (Raft.log (sigma h)) (Raft.lastApplied (sigma h)))) H4 : forall (A : Type) (l l' : list A) (a : A), In a (l ++ l') -> In a l \\\\/ In a l' H : forall (A : Type) (l l' : list A) (a : A), In a l' -> In a (l ++ l') H0 : forall (A : Type) (l l' : list A) (a : A), In a l -> In a (l ++ l') currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) UniqueIndices_invariant : forall net : network, raft_intermediate_reachable net -> UniqueIndices net max_index_sanity_invariant : forall net : network, raft_intermediate_reachable net -> maxIndex_sanity net state_machine_safety_invariant : forall net : network, raft_intermediate_reachable net -> state_machine_safety net log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net lastApplied_commitIndex_match_invariant : forall net : network, raft_intermediate_reachable net -> lastApplied_commitIndex_match net commitIndex_lastApplied_match_invariant : forall net : network, raft_intermediate_reachable net -> commitIndex_lastApplied_match net lastApplied_lastApplied_match_invariant : forall net : network, raft_intermediate_reachable net -> lastApplied_lastApplied_match net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (Raft.log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (Raft.log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net applied_implies_input : forall (client : clientId) (id : nat) (failed : list name) (net : network) (tr : list (name * (raft_input + list raft_output))) (e : entry), step_failure_star step_failure_init (failed, net) tr -> eClient e = client -> eId e = id -> applied_implies_input_state client id (eInput e) net -> in_input_trace client id (eInput e) tr output_implies_applied : forall (client : clientId) (id : nat) (failed : list name) (net : network) (tr : list (name * (raft_input + list raft_output))), step_failure_star step_failure_init (failed, net) tr -> key_in_output_trace client id tr -> in_applied_entries client id net Unable to unify \"raft_intermediate_reachable {| nwPackets := ps; nwState := sigma |}\" with \"exists h : name, In e (Raft.log (sigma h)) /\\\\ eIndex e <= Raft.commitIndex (sigma h)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros ps h sigma os st' ms H_reach H_doGenericServer.", "unfold doGenericServer in H_doGenericServer.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))).", "inversion H_doGenericServer.", "clear H_doGenericServer.", "exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))).", "split.", "-", "rewrite H1.", "qsimpl use: applied_entries_update.", "+", "shelve.", "+", "shelve.", "-", "intros e H_in.", "qsimpl use: in_app_iff,applied_entries_update.", "qsimpl use: in_app_iff,applied_entries_update.", "qsimpl use: in_app_iff,applied_entries_update."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros ps h sigma os st' ms H_reach H_doGenericServer. unfold doGenericServer in H_doGenericServer. destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h)))))). inversion H_doGenericServer. clear H_doGenericServer. exists (rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h)))). split. - rewrite applied_entries_update with (st := r) by lia. rewrite H. apply applied_entries_update. lia. - intros e H_in. apply in_app_iff in H_in. destruct H_in. + eapply log_matching_nw with (p:=mkPacket h h (AppendEntries t h pli plt es ci)) in H_reach; try auto. unfold log_matching_nw in H_reach. specialize (H_reach (mkPacket h h (AppendEntries t h pli plt es ci)) t h pli plt es ci). apply H_reach. * unfold nwPackets. simpl. left. reflexivity. * unfold nwPackets. simpl. left. reflexivity. + apply send_packets_app in H. apply in_app_iff in H. destruct H. * exfalso. apply in_map_iff in H. destruct H as [p [_ H_in]]. inversion H_in. * auto.", "succ": false}]