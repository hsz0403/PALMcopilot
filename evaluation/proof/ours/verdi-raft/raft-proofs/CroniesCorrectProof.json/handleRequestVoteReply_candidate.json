[{"history": {"proof": "intros h st src t v st' Hhandle Htype. unfold handleRequestVoteReply in Hhandle. destruct (currentTerm st <? t) eqn:Hlt. - inversion Hhandle. scongruence depth: 3. - destruct (t <? currentTerm st) eqn:Hgt. + inversion Hhandle. hauto lq: on depth: 3. + destruct v. destruct Hhandle as [H1 H2]. qsimpl. inversion Hhandle. hauto lq: on depth: 3.", "repairs": ["", "", "", "", "", "hammer", "", "", "", "", "hammer", "", "", "transform_curly", "cannot_unify", "", "hammer"], "exceptions": [{"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:Hgt.", "+", "inversion Hhandle."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:Hgt.", "+", "inversion Hhandle.", "shelve.", "+"], "tactic": "destruct (votes_correct_invariant net rri).", "exn": "The reference net was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:Hgt.", "+", "inversion Hhandle.", "shelve.", "+"], "tactic": "apply (H net H1).", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:Hgt.", "+", "inversion Hhandle.", "shelve.", "+"], "tactic": "apply (refined_raft_net_invariant_request_vote_reply' xs p ys net st' ps' gd d t v Hhandle eq_refl H4).", "exn": "The reference H4 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:Hgt.", "+", "inversion Hhandle.", "shelve.", "+", "destruct v."], "tactic": "apply handleRequestVoteReply_true_votedFor in Hhandle.", "exn": "The reference handleRequestVoteReply_true_votedFor was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st src t v st' Hhandle Htype.", "unfold handleRequestVoteReply in Hhandle.", "destruct (currentTerm st <? t) eqn:Hlt.", "-", "inversion Hhandle.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:Hgt.", "+", "inversion Hhandle.", "shelve.", "+", "destruct v.", "destruct Hhandle as [H1 H2]."], "tactic": "split; reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params rri : raft_refinement_interface vci : votes_correct_interface cvfsi : candidates_vote_for_selves_interface h : name st : RaftState.raft_data term name entry logIndex serverType data clientId output src : name t : nat Hlt : (currentTerm st <? t) = false Hgt : (t <? currentTerm st) = false Htype : type match type st with | Candidate => RaftState.set_raft_data_electoralVictories term name entry logIndex serverType data clientId output (RaftState.set_raft_data_nextIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_matchIndex term name entry logIndex serverType data clientId output (RaftState.set_raft_data_type term name entry logIndex serverType data clientId output (RaftState.set_raft_data_votesReceived term name entry logIndex serverType data clientId output st ([src] ++ votesReceived st)) (if true && wonElection (dedup name_eq_dec (src :: votesReceived st)) then Leader else type st)) (assoc_set name_eq_dec [] h (maxIndex (log st)))) []) ((if true && wonElection (dedup name_eq_dec (src :: votesReceived st)) then [(currentTerm st, src :: votesReceived st, log st)] else []) ++ electoralVictories st) | _ => st end = Candidate Unable to unify \"Candidate\" with \"type st\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros h st src t v st' Hhandle Htype. unfold handleRequestVoteReply in Hhandle. destruct (currentTerm st <? t) eqn:Hlt. - inversion Hhandle. - destruct (t <? currentTerm st) eqn:Hgt. + inversion Hhandle. + destruct (votes_correct_invariant net rri). apply (H net H1). * apply (refined_raft_net_invariant_request_vote_reply' xs p ys net st' ps' gd d t v Hhandle eq_refl H4). * auto. * unfold handleRequestVoteReply in Hhandle. destruct v. { apply handleRequestVoteReply_true_votedFor in Hhandle. destruct Hhandle as [H1 H2]. subst. split; reflexivity. } { inversion Hhandle. }", "succ": true}]