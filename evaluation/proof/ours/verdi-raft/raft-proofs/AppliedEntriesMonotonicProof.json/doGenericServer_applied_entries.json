[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros ps h sigma os st' ms H1 H2.", "unfold doGenericServer in H2.", "destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied st' <? eIndex x) && (eIndex x <=? commitIndex st')) (findGtIndex (log (sigma h)) (lastApplied st'))))) as [out state0] eqn:Heq_applyEntries.", "inversion H2.", "clear H2.", "unfold applied_entries.", "exists (rev (removeAfterIndex (log (update name_eq_dec sigma h state0 h)) (lastApplied (update name_eq_dec sigma h state0 h))))."], "tactic": "reflexivity.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params si : sorted_interface lmi : log_matching_interface uii : unique_indices_interface smsi : state_machine_safety_interface misi : max_index_sanity_interface crci : commit_recorded_committed_interface lci : leader_completeness_interface lacimi : lastApplied_commitIndex_match_interface ps : list packet h : name sigma : Net.name -> data os : list raft_output st' : raft_data ms : list (name * msg) H1 : raft_intermediate_reachable {| nwPackets := ps; nwState := sigma |} out : list raft_output state0 : raft_data Heq_applyEntries : applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied st' <? eIndex x) && (eIndex x <=? commitIndex st')) (findGtIndex (log (sigma h)) (lastApplied st')))) = (out, state0) H0 : (let (out, state) := applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied (sigma h) <? eIndex x) && (eIndex x <=? commitIndex (sigma h))) (findGtIndex (log (sigma h)) (lastApplied (sigma h))))) in (out, mkRaft_data (currentTerm state) (votedFor state) (leaderId state) (log state) (commitIndex state) (if lastApplied state <? commitIndex state then commitIndex state else lastApplied state) (stateMachine state) (nextIndex state) (matchIndex state) (shouldSend state) (votesReceived state) (type state) (clientCache state) (electoralVictories state), [])) = (os, st', ms) Unable to unify \"match argmax (fun h : name => lastApplied (sigma h)) (all_fin N) with | Some h => rev (removeAfterIndex (log (sigma h)) (lastApplied (sigma h))) | None => [] end ++ rev (removeAfterIndex (log (update name_eq_dec sigma h state0 h)) (lastApplied (update name_eq_dec sigma h state0 h)))\" with \"match argmax (fun h0 : name => lastApplied (update name_eq_dec sigma h st' h0)) (all_fin N) with | Some h0 => rev (removeAfterIndex (log (update name_eq_dec sigma h st' h0)) (lastApplied (update name_eq_dec sigma h st' h0))) | None => [] end\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros ps h sigma os st' ms H1 H2. unfold doGenericServer in H2. destruct (applyEntries h (sigma h) (rev (filter (fun x : entry => (lastApplied st' <? eIndex x) && (eIndex x <=? commitIndex st')) (findGtIndex (log (sigma h)) (lastApplied st'))))) as [out state0] eqn:Heq_applyEntries. inversion H2. subst. clear H2. unfold applied_entries. exists (rev (removeAfterIndex (log (update name_eq_dec sigma h state0 h)) (lastApplied (update name_eq_dec sigma h state0 h)))). reflexivity.", "succ": false}]