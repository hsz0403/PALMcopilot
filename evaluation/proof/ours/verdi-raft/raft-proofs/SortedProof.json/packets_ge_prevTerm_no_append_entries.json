[{"history": {"proof": "intros net ps' l st' H1 H2 H3. unfold packets_ge_prevTerm in *. intros p t n pli plt entries c e H4 H5 H6. qsimpl. destruct eId as [eId | eId]. qsimpl. - hauto l: on depth: 3. - hauto l: on depth: 3.", "repairs": ["", "", "", "no_instance_var", "ref_not_found", "not_inductive_goal", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros net ps' l st' H1 H2 H3.", "unfold packets_ge_prevTerm in *.", "intros p t n pli plt entries c e H4 H5 H6."], "tactic": "apply H1.", "exn": "Unable to find an instance for the variables p, t, n, pli, entries, c.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros net ps' l st' H1 H2 H3.", "unfold packets_ge_prevTerm in *.", "intros p t n pli plt entries c e H4 H5 H6.", "qsimpl."], "tactic": "apply H3.", "exn": "In environment orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params net : network ps', l : list packet H1 : forall (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (entries : list entry) (c : logIndex) (e : entry), In p (nwPackets net) -> pBody p = AppendEntries t n pli plt entries c -> In e entries -> eTerm e >= plt H2 : forall p : packet, In p ps' -> In p (nwPackets net) \\\\/ In p l H3 : forall p : packet, In p l -> is_append_entries (pBody p) -> False p : packet t : term n : name pli : logIndex plt : term entries : list entry c : logIndex e : entry H4 : In p ps' H5 : pBody p = AppendEntries t n pli plt entries c H6 : In e entries currentTerm : term votedFor, leaderId : option name log : list entry commitIndex, lastApplied : logIndex stateMachine : data nextIndex, matchIndex : list (name * logIndex) shouldSend : bool votesReceived : list name type : serverType clientCache : list (clientId * (nat * output)) electoralVictories : list (term * list name * list entry) no_entries_past_current_term_invariant : forall net : network, raft_intermediate_reachable net -> no_entries_past_current_term net Unable to unify \"False\" with \"eTerm e >= plt\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros net ps' l st' H1 H2 H3.", "unfold packets_ge_prevTerm in *.", "intros p t n pli plt entries c e H4 H5 H6.", "qsimpl."], "tactic": "intros p' H7.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros net ps' l st' H1 H2 H3.", "unfold packets_ge_prevTerm in *.", "intros p t n pli plt entries c e H4 H5 H6.", "qsimpl."], "tactic": "apply H2 in H7.", "exn": "No such hypothesis: H7", "type": "no_hypos", "handled": true}, {"ctx": ["intros net ps' l st' H1 H2 H3.", "unfold packets_ge_prevTerm in *.", "intros p t n pli plt entries c e H4 H5 H6.", "qsimpl."], "tactic": "destruct H7 as [H7 | H7].", "exn": "The reference H7 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros net ps' l st' H1 H2 H3.", "unfold packets_ge_prevTerm in *.", "intros p t n pli plt entries c e H4 H5 H6.", "qsimpl.", "destruct eId as [eId | eId]."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros net ps' l st' H1 H2 H3. unfold packets_ge_prevTerm in *. intros p t n pli plt entries c e H4 H5 H6. apply H1. apply H3. auto. intros p' H7. apply H2 in H7. destruct H7 as [H7 | H7]. left. auto. contradiction.", "succ": true}]