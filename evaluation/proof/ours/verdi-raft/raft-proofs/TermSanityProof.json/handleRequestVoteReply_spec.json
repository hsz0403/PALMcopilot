[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:current_term_lt_t.", "-", "inversion H."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:current_term_lt_t.", "-", "inversion H.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:t_lt_current_term.", "+", "inversion H."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:current_term_lt_t.", "-", "inversion H.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:t_lt_current_term.", "+", "inversion H.", "shelve.", "+"], "tactic": "destruct (voteGranted && wonElection (dedup name_eq_dec (h' :: votesReceived st))) eqn:vg.", "exn": "The reference voteGranted was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:current_term_lt_t.", "-", "inversion H.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:t_lt_current_term.", "+", "inversion H.", "shelve.", "+", "inversion H.", "destruct (type st) eqn:st_type."], "tactic": "apply handleRequestVote_reply_spec in H.", "exn": "The reference handleRequestVote_reply_spec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:current_term_lt_t.", "-", "inversion H.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:t_lt_current_term.", "+", "inversion H.", "shelve.", "+", "inversion H.", "destruct (type st) eqn:st_type.", "destruct H as [H1 [H2 H3]].", "split."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros h st h' t v st' H.", "unfold handleRequestVoteReply in H.", "destruct (currentTerm st <? t) eqn:current_term_lt_t.", "-", "inversion H.", "shelve.", "-", "destruct (t <? currentTerm st) eqn:t_lt_current_term.", "+", "inversion H.", "shelve.", "+", "inversion H.", "destruct (type st) eqn:st_type.", "destruct H as [H1 [H2 H3]].", "split.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros h st h' t v st' H. unfold handleRequestVoteReply in H. destruct (currentTerm st <? t) eqn:current_term_lt_t. - inversion H. - destruct (t <? currentTerm st) eqn:t_lt_current_term. + inversion H. + destruct (voteGranted && wonElection (dedup name_eq_dec (h' :: votesReceived st))) eqn:vg. * inversion H. * destruct (type st) eqn:st_type. { apply handleRequestVote_reply_spec in H. destruct H as [H1 [H2 H3]]. split. + split; auto. + auto. } { apply handleRequestVote_same_log with (n := h) in H. rewrite H. auto. }", "succ": false}]