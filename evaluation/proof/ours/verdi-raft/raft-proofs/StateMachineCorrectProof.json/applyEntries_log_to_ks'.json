[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "intros l h st o st' H.", "exn": "l is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros l' h st o st' H.", "exn": "h is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros l' h' st o st' H.", "exn": "st is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros l' h' st'' o st' H.", "exn": "o is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros l' h' st'' o' st' H.", "exn": "st' is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros l' h' st'' o' st''' H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros l' h' st'' o' st''' H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks."], "tactic": "rewrite H.", "exn": "Found no subterm matching \"applyEntries h st l\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl."], "tactic": "rewrite map_map.", "exn": "Found no subterm matching \"map ?M3962 (map ?M3961 ?M3963)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-"], "tactic": "pose proof lmi as [_ Hlog_matching_invariant].", "exn": "The reference lmi was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity)."], "tactic": "apply Hlog_matching_invariant in H_cache_apply.", "exn": "The reference Hlog_matching_invariant was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity)."], "tactic": "specialize (IHl st'' h st'').", "exn": "In environment H0 : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params a : entry l : list entry h : name st : raft_data o : list raft_output st' : raft_data H : applyEntries h st (a :: l) = (o, st') log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net state_machine_safety_invariant : forall net : network, raft_intermediate_reachable net -> state_machine_safety net max_index_sanity_invariant : forall net : network, raft_intermediate_reachable net -> maxIndex_sanity net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net IHl : applyEntries h st l = (o, st') -> a_equiv clientId_eq_dec ((fix log_to_ks' (l : list entry) (ks : list (clientId * nat)) {struct l} : list (clientId * nat) := match l with | [] => ks | e :: l' => if assoc_default clientId_eq_dec ks (eClient e) 0 <=? eId e then log_to_ks' l' (assoc_set clientId_eq_dec ks (eClient e) (eId e)) else log_to_ks' l' ks end) l (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st))) (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st')) out : list output st'' : RaftState.raft_data term name entry logIndex serverType data clientId output Heq_cacheRes : (out, st'') = cacheApplyEntry st a H_cache_apply : cacheApplyEntry st a = (out, st'') The term \"st''\" has type \"RaftState.raft_data term name entry logIndex serverType data clientId output\" while it is expected to have type \"applyEntries h st l = (o, st')\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map."], "tactic": "rewrite H_cache_apply.", "exn": "The reference H_cache_apply was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map."], "tactic": "pose proof handleAppendEntries_logs_sorted as [H1 _].", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map."], "tactic": "apply H1 with (net:=_)(p:=_)(t:=_)(n:=_)(pli:=_)(plt:=_)(es:=_)(ci:=_)(m:=_) in H_cache_apply.", "exn": "No such hypothesis: H_cache_apply", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map."], "tactic": "apply a_equiv_trans with (l':=log_to_ks' [a] (clientCache_to_ks (clientCache st))) in H_cache_apply.", "exn": "No such hypothesis: H_cache_apply", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks'.", "+"], "tactic": "apply H_cache_apply.", "exn": "The reference H_cache_apply was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks'.", "+"], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks'.", "+", "shelve.", "+"], "tactic": "apply log_to_ks'_a_equiv.", "exn": "In environment H1 : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params a : entry l : list entry h : name st : raft_data o : list raft_output st' : raft_data l0 : list output r : RaftState.raft_data term name entry logIndex serverType data clientId output Heqp : cacheApplyEntry st a = (l0, r) Heqp0 : applyEntries h r l = (o, st') n : eAt a = h -> False Heqs : name_eq_dec (eAt a) h = right n log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net state_machine_safety_invariant : forall net : network, raft_intermediate_reachable net -> state_machine_safety net max_index_sanity_invariant : forall net : network, raft_intermediate_reachable net -> maxIndex_sanity net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net IHl : applyEntries h st l = (o, st') -> a_equiv clientId_eq_dec ((fix log_to_ks' (l : list entry) (ks : list (clientId * nat)) {struct l} : list (clientId * nat) := match l with | [] => ks | e :: l' => if assoc_default clientId_eq_dec ks (eClient e) 0 <=? eId e then log_to_ks' l' (assoc_set clientId_eq_dec ks (eClient e) (eId e)) else log_to_ks' l' ks end) l (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st))) (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st')) Unable to unify \"forall k : clientId, assoc clientId_eq_dec (log_to_ks' ?M10132 ?M10133) k = assoc clientId_eq_dec (log_to_ks' ?M10132 ?M10134) k\" with \"let (_, _, _, clientId, _) := raft_params in clientId\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks'.", "+", "shelve.", "+", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks',log_to_ks'_a_equiv."], "tactic": "apply IHl.", "exn": "In environment orig_base_params : BaseParams raft_params : RaftParams orig_base_params l1 : list entry -> list (clientId * nat) -> list (clientId * nat) H2 : forall (l : list entry) (ks ks' : list (clientId * nat)), a_equiv clientId_eq_dec ks ks' -> a_equiv clientId_eq_dec (l1 l ks) (l1 l ks') H0 : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l H : forall (K V : Type) (K_eq_dec : forall k k' : K, {k = k'} + {k = k' -> False}) (l l' l'' : list (K * V)), a_equiv K_eq_dec l l' -> a_equiv K_eq_dec l' l'' -> a_equiv K_eq_dec l l'' one_node_params : OneNodeParams orig_base_params a : entry l : list entry h : name st : raft_data o : list raft_output st' : raft_data l0 : list output r : RaftState.raft_data term name entry logIndex serverType data clientId output Heqp : cacheApplyEntry st a = (l0, r) Heqp0 : applyEntries h r l = (o, st') n : eAt a = h -> False Heqs : name_eq_dec (eAt a) h = right n log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net state_machine_safety_invariant : forall net : network, raft_intermediate_reachable net -> state_machine_safety net max_index_sanity_invariant : forall net : network, raft_intermediate_reachable net -> maxIndex_sanity net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net IHl : applyEntries h st l = (o, st') -> a_equiv clientId_eq_dec ((fix log_to_ks' (l : list entry) (ks : list (clientId * nat)) {struct l} : list (clientId * nat) := match l with | [] => ks | e :: l' => if assoc_default clientId_eq_dec ks (eClient e) 0 <=? eId e then log_to_ks' l' (assoc_set clientId_eq_dec ks (eClient e) (eId e)) else log_to_ks' l' ks end) l (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st))) (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st')) X1 : list (clientId * (nat * output)) X0 : list (clientId * nat) Unable to unify \"a_equiv clientId_eq_dec ((fix log_to_ks' (l : list entry) (ks : list (clientId * nat)) {struct l} : list (clientId * nat) := match l with | [] => ks | e :: l' => if assoc_default clientId_eq_dec ks (eClient e) 0 <=? eId e then log_to_ks' l' (assoc_set clientId_eq_dec ks (eClient e) (eId e)) else log_to_ks' l' ks end) l (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st))) (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st'))\" with \"clientId\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks'.", "+", "shelve.", "+", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks',log_to_ks'_a_equiv.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks',log_to_ks'_a_equiv."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold log_to_ks'.", "unfold clientCache_to_ks.", "qsimpl.", "qsimpl use: map_map.", "apply a_equiv_sym.", "induction l.", "-", "shelve.", "-", "pose proof mkEntry as [_ Hlog_matching_invariant].", "remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes.", "destruct cacheRes as [out st''].", "assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity).", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: map_map.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks'.", "+", "shelve.", "+", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks',log_to_ks'_a_equiv.", "qsimpl use: clientCache_to_ks,a_equiv_trans,clientCache,map_map,log_to_ks',log_to_ks'_a_equiv.", "shelve.", "+"], "tactic": "apply in_eq.", "exn": "In environment H0 : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l orig_base_params : BaseParams one_node_params : OneNodeParams orig_base_params raft_params : RaftParams orig_base_params a : entry l : list entry h : name st : raft_data o : list raft_output st' : raft_data H : applyEntries h st (a :: l) = (o, st') log_matching_invariant : forall net : network, raft_intermediate_reachable net -> log_matching net state_machine_safety_invariant : forall net : network, raft_intermediate_reachable net -> state_machine_safety net max_index_sanity_invariant : forall net : network, raft_intermediate_reachable net -> maxIndex_sanity net handleAppendEntries_logs_sorted : forall (net : network) (p : packet) (t : term) (n : name) (pli : logIndex) (plt : term) (es : list entry) (ci : logIndex) (st' : raft_data) (m : msg), raft_intermediate_reachable net -> logs_sorted net -> handleAppendEntries (pDst p) (nwState net (pDst p)) t n pli plt es ci = (st', m) -> pBody p = AppendEntries t n pli plt es ci -> In p (nwPackets net) -> sorted (log st') handleClientRequest_logs_sorted : forall (h : name) (client : clientId) (id : nat) (c : input) (out : list raft_output) (st : raft_data) (l : list (name * msg)) (net : network), handleClientRequest h (nwState net h) client id c = (out, st, l) -> raft_intermediate_reachable net -> logs_sorted_host net -> sorted (log st) logs_sorted_invariant : forall net : network, raft_intermediate_reachable net -> logs_sorted net IHl : applyEntries h st l = (o, st') -> a_equiv clientId_eq_dec ((fix log_to_ks' (l : list entry) (ks : list (clientId * nat)) {struct l} : list (clientId * nat) := match l with | [] => ks | e :: l' => if assoc_default clientId_eq_dec ks (eClient e) 0 <=? eId e then log_to_ks' l' (assoc_set clientId_eq_dec ks (eClient e) (eId e)) else log_to_ks' l' ks end) l (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st))) (map (fun e : clientId * (nat * output) => (fst e, fst (snd e))) (clientCache st')) Unable to unify \"?M12987 = ?M12987 \\\\/ (fix In (a : ?M12986) (l : list ?M12986) {struct l} : Prop := match l with | [] => False | b :: m => b = a \\\\/ In a m end) ?M12987 ?M12988\" with \"nat\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. intros l h st o st' H. unfold log_to_ks'. unfold clientCache_to_ks. unfold clientCache_to_ks in H. rewrite H. unfold clientCache_to_ks. rewrite map_map. simpl. apply a_equiv_sym. induction l. - simpl. auto. - simpl. pose proof lmi as [_ Hlog_matching_invariant]. remember (cacheApplyEntry st a) as cacheRes eqn: Heq_cacheRes. destruct cacheRes as [out st'']. assert (H_cache_apply: cacheApplyEntry st a = (out,st'')) by (rewrite Heq_cacheRes; reflexivity). apply Hlog_matching_invariant in H_cache_apply. specialize (IHl st'' h st''). rewrite H_cache_apply. pose proof handleAppendEntries_logs_sorted as [H1 _]. apply H1 with (net:=_)(p:=_)(t:=_)(n:=_)(pli:=_)(plt:=_)(es:=_)(ci:=_)(m:=_) in H_cache_apply. apply a_equiv_trans with (l':=log_to_ks' [a] (clientCache_to_ks (clientCache st))) in H_cache_apply. + apply H_cache_apply. + apply log_to_ks'_a_equiv. apply IHl. + apply in_eq.", "succ": false}]