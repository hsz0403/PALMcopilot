[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros n x y."], "tactic": "pose proof Fin.eq_dec n as Fin_eq_dec.", "exn": "In environment L : Language language_dec : language_decideable nilTermsHelp := fun (n : nat) (H : n = 0) => nat_rec (fun n0 : nat => n0 = 0 -> Terms n0) (fun _ : 0 = 0 => Tnil) (fun (n0 : nat) (_ : n0 = 0 -> Terms n0) (H0 : S n0 = 0) => let H1 : False := eq_ind (S n0) (fun e : nat => match e with | 0 => False | S _ => True end) I 0 H0 in False_rec (Terms (S n0)) H1) n H : forall n : nat, n = 0 -> Terms n consTermsHelp := fun (n : nat) (H : Terms n) => match n with | 0 => forall p : 0 = n, {_ : unit | eq_rec 0 (fun z : nat => Terms z) Tnil n p = H} | S n0 => forall p : S n0 = n, {t : Term * Terms n0 | eq_rec (S n0) (fun z : nat => Terms z) (Tcons n0 (fst t) (snd t)) n p = H} end : forall n : nat, Terms n -> Set n : nat x, y : Terms n The term \"n\" has type \"nat\" while it is expected to have type \"Fin.t ?n\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros n x y.", "qsimpl."], "tactic": ["destruct x, y.", ""], "exn": "Abstracting over the terms \"n\" and \"y\" leads to a term fun (n0 : nat) (y0 : Terms n0) => {Tnil = y0} + {Tnil = y0 -> False} which is ill-typed. Reason is: Illegal application: The term \"@eq\" of type \"forall A : Type, A -> A -> Prop\" cannot be applied to the terms \"Terms n0\" : \"Set\" \"Tnil\" : \"Terms 0\" \"y0\" : \"Terms n0\" The 2nd term has type \"Terms 0\" which should be coercible to \"Terms n0\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "intros n x y. pose proof Fin.eq_dec n as Fin_eq_dec. destruct x, y. - left. reflexivity. - right. intros contra. inversion contra. - right. intros contra. inversion contra. - destruct (Fin_eq_dec n0 n1) as [eq | neq]. + subst. destruct (H t t0). * left. reflexivity. * right. intros contra. inversion contra. contradiction. + right. intros contra. inversion contra. contradiction.", "succ": false}]