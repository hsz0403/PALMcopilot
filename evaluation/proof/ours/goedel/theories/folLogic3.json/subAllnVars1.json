[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a ts ss.", "unfold subAllTerms.", "induction ts.", "-", "reflexivity.", "-", "simpl."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a ts ss.", "unfold subAllTerms.", "induction ts.", "-", "reflexivity.", "-", "simpl."], "tactic": "intros m.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros a ts ss.", "unfold subAllTerms.", "induction ts.", "-", "reflexivity.", "-", "simpl."], "tactic": "specialize (ss m).", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a ts ss.", "unfold subAllTerms.", "induction ts.", "-", "reflexivity.", "-", "simpl."], "tactic": "apply ss.", "exn": "In environment L : Language var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L equal := fol.equal L : fol.Term L -> fol.Term L -> fol.Formula L atomic := fol.atomic L : forall r : Relations L, fol.Terms L (arity L (inl r)) -> fol.Formula L impH := fol.impH L : fol.Formula L -> fol.Formula L -> fol.Formula L notH := fol.notH L : fol.Formula L -> fol.Formula L forallH := fol.forallH L : nat -> fol.Formula L -> fol.Formula L orH := fol.orH L : fol.Formula L -> fol.Formula L -> fol.Formula L andH := fol.andH L : fol.Formula L -> fol.Formula L -> fol.Formula L existH := fol.existH L : nat -> fol.Formula L -> fol.Formula L iffH := fol.iffH L : fol.Formula L -> fol.Formula L -> fol.Formula L ifThenElseH := fol.ifThenElseH L : fol.Formula L -> fol.Formula L -> fol.Formula L -> fol.Formula L Prf := folProof.Prf L : fol.Formulas L -> fol.Formula L -> Set SysPrf := folProof.SysPrf L : fol.System L -> fol.Formula L -> Prop termsMap := fun (m : nat) (ts ss : fol.Terms L m) => nat_rec (fun m0 : nat => fol.Terms L m0 -> fol.Terms L m0 -> nat -> fol.Term L) (fun (_ _ : fol.Terms L 0) (n : nat) => var n) (fun (m0 : nat) (Hrecm : fol.Terms L m0 -> fol.Terms L m0 -> nat -> fol.Term L) (ts0 ss0 : fol.Terms L (S m0)) => let s := consTerms L m0 ts0 in sig_rec (fun _ : {t : fol.Term L * fol.Terms L m0 | Tcons L m0 (fst t) (snd t) = ts0} => nat -> fol.Term L) (fun (x : fol.Term L * fol.Terms L m0) (p : Tcons L m0 (fst x) (snd x) = ts0) => prod_rec (fun x0 : fol.Term L * fol.Terms L m0 => Tcons L m0 (fst x0) (snd x0) = ts0 -> nat -> fol.Term L) (fun (a : fol.Term L) (b : fol.Terms L m0) (_ : Tcons L m0 (fst (a, b)) (snd (a, b)) = ts0) => let s0 := consTerms L m0 ss0 in sig_rec (fun _ : {t : fol.Term L * fol.Terms L m0 | Tcons L m0 (fst t) (snd t) = ss0} => nat -> fol.Term L) (fun (x0 : fol.Term L * fol.Terms L m0) (p1 : Tcons L m0 (fst x0) (snd x0) = ss0) => prod_rec (fun x1 : fol.Term L * fol.Terms L m0 => Tcons L m0 (fst x1) (snd x1) = ss0 -> nat -> fol.Term L) (fun (a0 : fol.Term L) (b0 : fol.Terms L m0) (_ : Tcons L m0 (fst (a0, b0)) (snd (a0, b0)) = ss0) (n : nat) => if Nat.eq_dec n (m0 + m0) then a else if Nat.eq_dec n (S (m0 + m0)) then a0 else Hrecm b b0 n) x0 p1) s0) x p) s) m ts ss : forall m : nat, fol.Terms L m -> fol.Terms L m -> nat -> fol.Term L n : nat t : fol.Term L ts : fol.Terms L n ss : fol.Terms L (S n) IHts : forall ss : fol.Terms L n, ts = (fix subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L := match t with | @fol.var _ x => fun m : nat -> fol.Term L => m x | @fol.apply _ f ts => fun m : nat -> fol.Term L => fol.apply L f (subAllTerms (arity L (inr f)) ts m) end with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} : (nat -> fol.Term L) -> fol.Terms L n := match ts in (fol.Terms _ n0) return ((nat -> fol.Term L) -> fol.Terms L n0) with | @Tnil _ => fun _ : nat -> fol.Term L => Tnil L | @Tcons _ n' t ss0 => fun m : nat -> fol.Term L => Tcons L n' (subAllTerm t m) (subAllTerms n' ss0 m) end for subAllTerms) n (fst (nVars L n)) (termsMap n ts ss) Unable to unify \"fol.Terms L (S n)\" with \"Tcons L n t ts = (fix subAllTerm (t : fol.Term L) : (nat -> fol.Term L) -> fol.Term L := match t with | @fol.var _ x => fun m : nat -> fol.Term L => m x | @fol.apply _ f ts => fun m : nat -> fol.Term L => fol.apply L f (subAllTerms (arity L (inr f)) ts m) end with subAllTerms (n : nat) (ts : fol.Terms L n) {struct ts} : (nat -> fol.Term L) -> fol.Terms L n := match ts in (fol.Terms _ n0) return ((nat -> fol.Term L) -> fol.Terms L n0) with | @Tnil _ => fun _ : nat -> fol.Term L => Tnil L | @Tcons _ n' t ss => fun m : nat -> fol.Term L => Tcons L n' (subAllTerm t m) (subAllTerms n' ss m) end for subAllTerms) (S n) (fst (prod_rec (fun _ : fol.Terms L n * fol.Terms L n => (fol.Terms L (S n) * fol.Terms L (S n))%type) (fun a b : fol.Terms L n => (Tcons L n (fol.var L (n + n)) a, Tcons L n (fol.var L (S (n + n))) b)) (nVars L n))) (sig_rec (fun _ : {t0 : fol.Term L * fol.Terms L n | Tcons L n (fst t0) (snd t0) = Tcons L n t ts} => nat -> fol.Term L) (fun (x : fol.Term L * fol.Terms L n) (p : Tcons L n (fst x) (snd x) = Tcons L n t ts) => prod_rec (fun x0 : fol.Term L * fol.Terms L n => Tcons L n (fst x0) (snd x0) = Tcons L n t ts -> nat -> fol.Term L) (fun (a : fol.Term L) (b : fol.Terms L n) (_ : Tcons L n a b = Tcons L n t ts) => sig_rec (fun _ : {t : fol.Term L * fol.Terms L n | Tcons L n (fst t) (snd t) = ss} => nat -> fol.Term L) (fun (x0 : fol.Term L * fol.Terms L n) (p1 : Tcons L n (fst x0) (snd x0) = ss) => prod_rec (fun x1 : fol.Term L * fol.Terms L n => Tcons L n (fst x1) (snd x1) = ss -> nat -> fol.Term L) (fun (a0 : fol.Term L) (b0 : fol.Terms L n) (_ : Tcons L n a0 b0 = ss) (n0 : nat) => if Nat.eq_dec n0 (n + n) then a else if Nat.eq_dec n0 (S (n + n)) then a0 else termsMap n b b0 n0) x0 p1) (consTerms L n ss)) x p) (consTerms L n (Tcons L n t ts)))\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros a ts ss. unfold subAllTerms. induction ts. - reflexivity. - simpl. f_equal. apply H. intros m. specialize (ss m). apply ss.", "succ": false}]