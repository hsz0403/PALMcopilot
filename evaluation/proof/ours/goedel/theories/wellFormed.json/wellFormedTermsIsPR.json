[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold isPR.", "unfold wellFormedTerms."], "tactic": "induction x.", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-"], "tactic": "unfold termRel.", "exn": "The reference termRel was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*"], "tactic": "apply indIsPR.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : isPR 1 codeArityF codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L Unable to unify \"{p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) (fun a : nat => nat_rec (fun _ : nat => nat) ?M1494 (fun x y : nat => ?M1492 x y) a)}\" with \"{p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) (fun x : nat => x)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR."], "tactic": "apply_.", "exn": "The reference apply_ was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*"], "tactic": "apply codeArityFIsPR.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : isPR 1 codeArityF codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L Unable to unify \"isPR 1 codeArityF\" with \"isPR 1 cPairPi2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+"], "tactic": "apply codeTermInj.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : isPR 1 codeArityF codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L Unable to unify \"?M2623 = ?M2624\" with \"{p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) wellFormedTermTerms}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR.", "shelve.", "-"], "tactic": "apply ind1ParamIsPR.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : isPR 1 codeArityF codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L n : nat IHn : {p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) (fun ts : nat => cPairPi2 (wellFormedTermTerms ts))} Unable to unify \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun a b : nat => nat_rec (fun _ : nat => nat) (?M3390 b) (fun x y : nat => ?M3388 x y b) a)}\" with \"{p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) (fun ts : nat => cPairPi2 (wellFormedTermTerms ts))}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR.", "shelve.", "-", "qsimpl use: ind1ParamIsPR,codeTermInj,indIsPR."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR.", "shelve.", "-", "qsimpl use: ind1ParamIsPR,codeTermInj,indIsPR.", "-"], "tactic": "apply compose1_2IsPR.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : isPR 1 codeArityF codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L Unable to unify \"{p : PrimRec 1 | extEqual 1 (evalPrimRec 1 p) (fun x : nat => ?M3518 (?M3514 x) (?M3516 x))}\" with \"nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR.", "shelve.", "-", "qsimpl use: ind1ParamIsPR,codeTermInj,indIsPR.", "-", "qsimpl use: ind1ParamIsPR,compose1_2IsPR,codeTermInj,indIsPR."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR.", "shelve.", "-", "qsimpl use: ind1ParamIsPR,codeTermInj,indIsPR.", "-", "qsimpl use: ind1ParamIsPR,compose1_2IsPR,codeTermInj,indIsPR.", "-"], "tactic": "apply compose2_1IsPR.", "exn": "In environment L : Language codeF : Functions L -> nat codeArityF : nat -> nat codeArityFIsPR : isPR 1 codeArityF codeArityFIsCorrect1 : forall f : Functions L, codeArityF (codeF f) = S (arity L (inr f)) codeArityFIsCorrect2 : forall n : nat, codeArityF n <> 0 -> exists f : Functions L, codeF f = n Term := fol.Term L : Set Terms := fol.Terms L : nat -> Set var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L Unable to unify \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun x y : nat => ?M3660 (?M3658 x y))}\" with \"nat\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold wellFormedTerms.", "induction cPair.", "-", "apply compose1_NIsPR.", "+", "apply compose1_1IsPR.", "*", "qsimpl use: indIsPR.", "shelve.", "*", "qsimpl use: indIsPR.", "shelve.", "+", "qsimpl use: codeTermInj,indIsPR.", "shelve.", "-", "qsimpl use: ind1ParamIsPR,codeTermInj,indIsPR.", "-", "qsimpl use: ind1ParamIsPR,compose1_2IsPR,codeTermInj,indIsPR.", "-", "qsimpl use: compose2_1IsPR,compose1_2IsPR,indIsPR,ind1ParamIsPR,codeTermInj."], "tactic": "++", "exn": "Wrong bullet ++: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "unfold isPR. intros. unfold wellFormedTerms. induction x. - unfold naryFunc. unfold termRel. intros. apply compose1_NIsPR. + apply compose1_1IsPR. * apply indIsPR. apply_. * apply codeArityFIsPR. + apply codeTermInj. - unfold naryFunc. intros. apply ind1ParamIsPR. + apply compose1_2IsPR. * apply compose2_1IsPR. ++ apply compose1_1IsPR. ** apply indIsPR. apply_. ** apply codeArityFIsPR. ++ apply codeArityFIsPR. * apply compose1_1IsPR. ++ apply indIsPR. apply_. ++ apply codeArityFIsPR. + apply codeTermInj.", "succ": false}]