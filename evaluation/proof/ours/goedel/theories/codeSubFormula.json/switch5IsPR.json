[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f1 f2 f3 f4 f5 g H1 H2 H3 H4 H5 H6.", "unfold isPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR.", "apply swapIsPR."], "tactic": "apply compose2_4IsPR; auto.", "exn": "In environment L : Language codeF : Functions L -> nat codeR : Relations L -> nat var := fol.var L : nat -> fol.Term L apply := fol.apply L : forall f : Functions L, fol.Terms L (arity L (inr f)) -> fol.Term L codeFormula := code.codeFormula L codeF codeR : fol.Formula L -> nat codeTerm := code.codeTerm L codeF : fol.Term L -> nat f1, f2, f3, f4, f5 : nat -> nat -> nat g : nat -> nat H1 : isPR 2 f1 H2 : isPR 2 f2 H3 : isPR 2 f3 H4 : isPR 2 f4 H5 : isPR 2 f5 H6 : isPR 1 g Unable to unify \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun x y : nat => ?M1495 (?M1487 x y) (?M1489 x y) (?M1491 x y) (?M1493 x y))}\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun y x : nat => switchPR (g y) (switchPR (Init.Nat.pred (g y)) (switchPR (Init.Nat.pred (Init.Nat.pred (g y))) (switchPR (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (g y)))) (f1 y x) (f2 y x)) (f3 y x)) (f4 y x)) (f5 y x))}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros f1 f2 f3 f4 f5 g H1 H2 H3 H4 H5 H6. unfold isPR. intros. apply swapIsPR. apply swapIsPR. apply swapIsPR. apply swapIsPR. apply swapIsPR. apply swapIsPR. apply compose2_4IsPR; auto.", "succ": false}]