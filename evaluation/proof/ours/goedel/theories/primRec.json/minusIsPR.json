[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold isPR.", "unfold Init.Nat.sub."], "tactic": "induction n.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold isPR.", "unfold Init.Nat.sub."], "tactic": "apply pi1_2IsPR.", "exn": "Unable to unify \"isPR 2 (fun a _ : nat => a)\" with \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fix sub (n m : nat) {struct n} : nat := match n with | 0 => n | S k => match m with | 0 => n | S l => sub k l end end)}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold Init.Nat.sub.", "qsimpl use: pi1_2IsPR."], "tactic": "apply compose2_1IsPR.", "exn": "In environment x : PrimRec 2 H0 : forall c c0 : nat, evalPrimRec 2 x c c0 = c Unable to unify \"{p : PrimRec 2 | extEqual 2 (evalPrimRec 2 p) (fun x y : nat => ?M1773 (?M1771 x y))}\" with \"{p : PrimRec 2 | forall c c0 : nat, evalPrimRec 2 p c c0 = (fix sub (n m : nat) {struct n} : nat := match n with | 0 => n | S k => match m with | 0 => n | S l => sub k l end end) c c0}\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold isPR.", "unfold Init.Nat.sub.", "qsimpl use: pi1_2IsPR.", "qsimpl use: compose2_1IsPR,pi1_2IsPR."], "tactic": "apply IHn.", "exn": "The reference IHn was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "unfold isPR. intros. unfold Init.Nat.sub. induction n. - apply pi1_2IsPR. - apply compose2_1IsPR. + apply IHn. + apply swapIsPR.", "succ": false}]