[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros x y.", "unfold Plus.", "unfold freeVarTerm."], "tactic": "reflexivity.", "exn": "In environment x, y : Term Unable to unify \"(fix freeVarTerm (s : fol.Term LNN) : list nat := match s with | @fol.var _ v => v :: nil | @apply _ f ts => freeVarTerms (arity LNN (inr f)) ts end with freeVarTerms (n : nat) (ss : fol.Terms LNN n) {struct ss} : list nat := match ss with | @Tnil _ => nil | @Tcons _ m t ts => freeVarTerm t ++ freeVarTerms m ts end for freeVarTerm) x ++ (fix freeVarTerm (s : fol.Term LNN) : list nat := match s with | @fol.var _ v => v :: nil | @apply _ f ts => freeVarTerms (arity LNN (inr f)) ts end with freeVarTerms (n : nat) (ss : fol.Terms LNN n) {struct ss} : list nat := match ss with | @Tnil _ => nil | @Tcons _ m t ts => freeVarTerm t ++ freeVarTerms m ts end for freeVarTerm) y\" with \"(fix freeVarTerm (s : fol.Term LNN) : list nat := match s with | @fol.var _ v => v :: nil | @apply _ f ts => freeVarTerms (arity LNN (inr f)) ts end with freeVarTerms (n : nat) (ss : fol.Terms LNN n) {struct ss} : list nat := match ss with | @Tnil _ => nil | @Tcons _ m t ts => freeVarTerm t ++ freeVarTerms m ts end for freeVarTerm) x ++ (fix freeVarTerm (s : fol.Term LNN) : list nat := match s with | @fol.var _ v => v :: nil | @apply _ f ts => freeVarTerms (arity LNN (inr f)) ts end with freeVarTerms (n : nat) (ss : fol.Terms LNN n) {struct ss} : list nat := match ss with | @Tnil _ => nil | @Tcons _ m t ts => freeVarTerm t ++ freeVarTerms m ts end for freeVarTerm) y ++ nil\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros x y. unfold Plus. simpl. unfold freeVarTerm. reflexivity.", "succ": false}]