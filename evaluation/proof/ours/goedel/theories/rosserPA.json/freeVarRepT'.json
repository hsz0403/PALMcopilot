[{"history": {"proof": "intros v H. hauto use: LNT2LNN_freeVarFormula.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *."], "tactic": "intros Hv.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *."], "tactic": "apply (reduceSub LNN) in Hv.", "exn": "No such hypothesis: Hv", "type": "no_hypos", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN."], "tactic": "apply (LNN2LNT_freeVarFormula1 f) in Hv.", "exn": "No such hypothesis: Hv", "type": "no_hypos", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1."], "tactic": "apply (freeVarRepT) in Hv.", "exn": "No such hypothesis: Hv", "type": "no_hypos", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1."], "tactic": "apply Hv.", "exn": "The reference Hv was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "apply LNNRelation_ind.", "-"], "tactic": "intros x Hx.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "apply LNNRelation_ind.", "-"], "tactic": "apply (contradiction T _ _) in H.", "exn": "Unable to apply lemma of type \"SysPrf T ?f -> SysPrf T (notH ?f) -> SysPrf T ?g\" on hypothesis of type \"In v ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) ((fix LNT2LNN_formula (f : Formula) : fol.Formula LNN := match f with | @fol.equal _ t1 t2 => fol.equal LNN ((fix LNT2LNN_term (t : Term) : fol.Term LNN := match t with | @fol.var _ v => fol.var LNN v | @apply _ f0 ts => apply LNN f0 (LNT2LNN_terms (LNTFunctionArity f0) ts) end with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : fol.Terms LNN n := match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss) end for LNT2LNN_term) t1) ((fix LNT2LNN_term (t : Term) : fol.Term LNN := match t with | @fol.var _ v => fol.var LNN v | @apply _ f0 ts => apply LNN f0 (LNT2LNN_terms (LNTFunctionArity f0) ts) end with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : fol.Terms LNN n := match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss) end for LNT2LNN_term) t2) | @atomic _ r _ => match r return (fol.Formula LNN) with end | @fol.impH _ A B => fol.impH LNN (LNT2LNN_formula A) (LNT2LNN_formula B) | @fol.notH _ A => fol.notH LNN (LNT2LNN_formula A) | @fol.forallH _ v A => fol.forallH LNN v (LNT2LNN_formula A) end) repT))\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "apply LNNRelation_ind.", "-", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1,contradiction."], "tactic": "apply H.", "exn": "In environment H7 : forall (T : System) (f g : Formula), SysPrf T f -> SysPrf T (notH f) -> SysPrf T g l1 : Language H6 : forall (f : fol.Formula l1) (v : nat), In v (freeVarFormula LNT (LNN2LNT_formula f)) -> In v (freeVarFormula l1 f) H3 : forall (L : Language) (T : fol.System L) (v : nat) (s : fol.Term L) (f g : fol.Formula L), (In_freeVarSys L v T -> False) -> folProof.SysPrf L T (fol.iffH L f g) -> folProof.SysPrf L T (fol.iffH L (substituteFormula L f v s) (substituteFormula L g v s)) l0 : Language H5 : forall (f : fol.Formula l0) (v : nat), In v (freeVarFormula LNT (LNN2LNT_formula f)) -> In v (freeVarFormula l0 f) l : Language H4 : forall (f : fol.Formula l) (v : nat), In v (freeVarFormula LNT (LNN2LNT_formula f)) -> In v (freeVarFormula l f) T : System extendsPA : Included Formula PA T repT : Formula v0 : nat freeVarRepT : forall v : nat, In v ((fix freeVarFormula (A : fol.Formula LNT) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNT t ++ freeVarTerm LNT s | @atomic _ r ts => freeVarTerms LNT (Datatypes.Empty_set_rec (fun _ : Datatypes.Empty_set => nat) r) ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v0 A0 => list_remove nat Nat.eq_dec v0 (freeVarFormula A0) end) repT) -> v = v0 expressT1 : forall f : Formula, mem (fol.Formula LNT) T f -> SysPrf T (substituteFormula LNT repT v0 (natToTerm (codeFormula f))) expressT2 : forall f : Formula, (mem (fol.Formula LNT) T f -> False) -> SysPrf T (notH (substituteFormula LNT repT v0 (natToTerm (codeFormula f)))) v : nat H : In v ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) ((fix LNT2LNN_formula (f : Formula) : fol.Formula LNN := match f with | @fol.equal _ t1 t2 => fol.equal LNN ((fix LNT2LNN_term (t : Term) : fol.Term LNN := match t with | @fol.var _ v => fol.var LNN v | @apply _ f0 ts => apply LNN f0 (LNT2LNN_terms (LNTFunctionArity f0) ts) end with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : fol.Terms LNN n := match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss) end for LNT2LNN_term) t1) ((fix LNT2LNN_term (t : Term) : fol.Term LNN := match t with | @fol.var _ v => fol.var LNN v | @apply _ f0 ts => apply LNN f0 (LNT2LNN_terms (LNTFunctionArity f0) ts) end with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : fol.Terms LNN n := match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss) end for LNT2LNN_term) t2) | @atomic _ r _ => match r return (fol.Formula LNN) with end | @fol.impH _ A B => fol.impH LNN (LNT2LNN_formula A) (LNT2LNN_formula B) | @fol.notH _ A => fol.notH LNN (LNT2LNN_formula A) | @fol.forallH _ v A => fol.forallH LNN v (LNT2LNN_formula A) end) repT)) Relations, Functions : Set H1 : Relations -> nat H2 : Functions -> nat Unable to unify \"In v ((fix freeVarFormula (A : fol.Formula LNN) : list nat := match A with | @fol.equal _ t s => freeVarTerm LNN t ++ freeVarTerm LNN s | @atomic _ r ts => freeVarTerms LNN match r with | LT => 2 end ts | @fol.impH _ A0 B => freeVarFormula A0 ++ freeVarFormula B | @fol.notH _ A0 => freeVarFormula A0 | @fol.forallH _ v A0 => list_remove nat Nat.eq_dec v (freeVarFormula A0) end) ((fix LNT2LNN_formula (f : Formula) : fol.Formula LNN := match f with | @fol.equal _ t1 t2 => fol.equal LNN ((fix LNT2LNN_term (t : Term) : fol.Term LNN := match t with | @fol.var _ v => fol.var LNN v | @apply _ f0 ts => apply LNN f0 (LNT2LNN_terms (LNTFunctionArity f0) ts) end with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : fol.Terms LNN n := match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss) end for LNT2LNN_term) t1) ((fix LNT2LNN_term (t : Term) : fol.Term LNN := match t with | @fol.var _ v => fol.var LNN v | @apply _ f0 ts => apply LNN f0 (LNT2LNN_terms (LNTFunctionArity f0) ts) end with LNT2LNN_terms (n : nat) (ts : Terms n) {struct ts} : fol.Terms LNN n := match ts in (fol.Terms _ n0) return (fol.Terms LNN n0) with | @Tnil _ => Tnil LNN | @Tcons _ m s ss => Tcons LNN m (LNT2LNN_term s) (LNT2LNN_terms m ss) end for LNT2LNN_term) t2) | @atomic _ r _ => match r return (fol.Formula LNN) with end | @fol.impH _ A B => fol.impH LNN (LNT2LNN_formula A) (LNT2LNN_formula B) | @fol.notH _ A => fol.notH LNN (LNT2LNN_formula A) | @fol.forallH _ v A => fol.forallH LNN v (LNT2LNN_formula A) end) repT))\" with \"v = v0\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "apply LNNRelation_ind.", "-", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1,contradiction.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1,contradiction."], "tactic": "apply (closedNN x).", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros v H.", "unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *.", "qsimpl use: reduceSub,LNN.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1.", "apply LNNRelation_ind.", "-", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1,contradiction.", "qsimpl use: reduceSub,LNN,LNN2LNT_freeVarFormula1,contradiction."], "tactic": "apply Hv.", "exn": "The reference Hv was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros v H. unfold LNT2LNN_formula, freeVarFormula, LNT2LNN_term in *. intros Hv. apply (reduceSub LNN) in Hv. - apply (LNN2LNT_freeVarFormula1 f) in Hv. apply (freeVarRepT) in Hv. apply Hv. - intros x Hx. apply (contradiction T _ _) in H. + apply H. + apply (closedNN x). apply Hv.", "succ": true}]