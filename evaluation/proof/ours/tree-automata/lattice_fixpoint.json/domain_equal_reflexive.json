[{"history": {"proof": "intros A m. induction m. + unfold domain_equal. destruct N0. - qsimpl use: eqmap_refl. - qsimpl use: eqmap_refl,mapcanon_exists_1. + qsimpl use: eqmap_refl,mapcanon_exists_1. + qsimpl use: eqmap_refl,eqmap_sym,mapcanon_exists_1.", "repairs": ["", "", "", "", "ref_not_found", "", "cannot_unify", "", "cannot_unify", "wrong_bullet", "cannot_unify", "wrong_bullet", "cannot_unify"], "exceptions": [{"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal."], "tactic": "destruct m.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-"], "tactic": "apply eqmap_refl.", "exn": "In environment A : Set Unable to unify \"forall a : ad, MapGet ?M1861 ?M1862 a = MapGet ?M1861 ?M1862 a\" with \"True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-"], "tactic": "apply mapcanon_unique with (m:=m1) (m':=M1 a a0).", "exn": "The reference m1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-"], "tactic": "apply mapcanon_exists_1.", "exn": "In environment A : Set p : positive Unable to unify \"forall a : ad, MapGet ?M1861 ?M1862 a = MapGet ?M1861 (MapCanonicalize ?M1861 ?M1862) a\" with \"True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-", "qsimpl use: eqmap_refl,mapcanon_exists_1."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-", "qsimpl use: eqmap_refl,mapcanon_exists_1.", "+"], "tactic": "apply mapcanon_exists_1.", "exn": "In environment A : Set a : ad a0 : A Unable to unify \"forall a : ad, MapGet ?M1861 ?M1862 a = MapGet ?M1861 (MapCanonicalize ?M1861 ?M1862) a\" with \"a = a\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-", "qsimpl use: eqmap_refl,mapcanon_exists_1.", "+", "qsimpl use: eqmap_refl,mapcanon_exists_1."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-", "qsimpl use: eqmap_refl,mapcanon_exists_1.", "+", "qsimpl use: eqmap_refl,mapcanon_exists_1.", "+"], "tactic": "apply eqmap_sym.", "exn": "In environment A : Set m1, m2 : Map A IHm1 : domain_equal A A m1 m1 IHm2 : domain_equal A A m2 m2 Unable to unify \"forall a : ad, MapGet ?M1863 ?M1865 a = MapGet ?M1863 ?M1864 a\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) A A m1 m1 /\\\\ (fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) A A m2 m2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A m.", "induction m.", "+", "unfold domain_equal.", "destruct N0.", "-", "qsimpl use: eqmap_refl.", "-", "qsimpl use: eqmap_refl,mapcanon_exists_1.", "+", "qsimpl use: eqmap_refl,mapcanon_exists_1.", "+", "qsimpl use: eqmap_refl,eqmap_sym,mapcanon_exists_1."], "tactic": "apply Map_of_alist_of_Map_c.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros A m. induction m. + unfold domain_equal. destruct m. - apply eqmap_refl. - apply mapcanon_unique with (m:=m1) (m':=M1 a a0). * apply mapcanon_exists_1. * apply mapcanon_exists_1. * apply eqmap_sym. apply Map_of_alist_of_Map_c. apply makeM2_canon. apply mapcanon_exists_1. apply mapcanon_exists_1. - apply eqmap_refl. + unfold domain_equal. destruct m. - apply eqmap_refl. - apply mapcanon_unique with (m:=m) (m':=m). * apply eqmap_refl. * apply eqmap_refl. * apply eqmap_refl.", "succ": true}]