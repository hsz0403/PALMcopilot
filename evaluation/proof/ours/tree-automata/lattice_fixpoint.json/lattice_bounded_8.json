[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros A m H1 m0 H2.", "unfold lattice_bounded_def_2 in *."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros A m H1 m0 H2.", "unfold lattice_bounded_def_2 in *.", "qsimpl."], "tactic": "apply lattice_bounded_6.", "exn": "In environment A : Set m : Map A H1 : forall p : prechain bool, sas_chain bool (ensemble_base A m) lem p -> chain_length bool p <= S (MapCard A m) m0 : Map A H2 : forall p : prechain bool, sas_chain bool (ensemble_base A m0) lem p -> chain_length bool p <= S (MapCard A m0) p : prechain bool H0 : chain bool (ensemble_base A (M2 A m m0)) lem p H3 : dist_chain bool p Unable to unify \"forall p : prechain bool, sas_chain bool (ensemble_base ?M2791 (M0 ?M2791)) lem p -> chain_length bool p <= S (MapCard ?M2791 (M0 ?M2791))\" with \"chain_length bool p <= S (MapCard A m + MapCard A m0)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros A m H1 m0 H2.", "unfold lattice_bounded_def_2 in *.", "qsimpl.", "qsimpl use: lattice_bounded_6."], "tactic": "apply lattice_bounded_6.", "exn": "In environment H : forall A : Set, lattice_bounded_def_2 A (M0 A) A : Set m : Map A H1 : forall p : prechain bool, sas_chain bool (ensemble_base A m) lem p -> chain_length bool p <= S (MapCard A m) m0 : Map A H2 : forall p : prechain bool, sas_chain bool (ensemble_base A m0) lem p -> chain_length bool p <= S (MapCard A m0) p : prechain bool H0 : chain bool (ensemble_base A (M2 A m m0)) lem p H3 : dist_chain bool p Unable to unify \"forall p : prechain bool, sas_chain bool (ensemble_base ?M3387 (M0 ?M3387)) lem p -> chain_length bool p <= S (MapCard ?M3387 (M0 ?M3387))\" with \"chain_length bool p <= S (MapCard A m + MapCard A m0)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros A m H1 m0 H2. unfold lattice_bounded_def_2 in *. split. - apply lattice_bounded_6. - apply lattice_bounded_6.", "succ": false}]