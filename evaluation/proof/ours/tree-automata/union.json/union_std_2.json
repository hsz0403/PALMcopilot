[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-"], "tactic": "apply H in H1.", "exn": "Unable to apply lemma of type \"mpl_compat (M2 prec_list m m0) s1\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "qsimpl."], "tactic": "apply H0 in H1.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "qsimpl.", "apply MapPut1 in H1."], "tactic": "apply H1.", "exn": "In environment m, m0 : state p : prec_list d : preDTA tl : term_list H : mpl_compat (M2 prec_list m m0) (M1 prec_list 0%N p) H2 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl s1 m0) (app c tl) H3 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) H1 : Map (forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl s1 m) (app c tl)) H4 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) l : prec_list H9 : MapGet prec_list m 0%N = Some l H10 : liste_reconnait d l tl Unable to unify \"Map (forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl s1 m) (app c tl))\" with \"state_reconnait d (M2 prec_list (union_mpl_0 0%N p m) m0) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "qsimpl.", "apply MapPut1 in H1."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "qsimpl.", "apply MapPut1 in H1.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "apply H0 in H2.", "exn": "Unable to apply lemma of type \"state_reconnait d (M2 prec_list m m0) (app c tl)\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) /\\\\ state_reconnait d (union_mpl s1 m0) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "qsimpl.", "apply MapPut1 in H1.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl."], "tactic": "apply H in H2.", "exn": "Unable to apply lemma of type \"mpl_compat (M2 prec_list m m0) s1\" on hypothesis of type \"forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl s1 m0) (app c tl)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros m H1 m0 H2.", "unfold union_std_def in *.", "intros.", "split.", "-", "qsimpl.", "apply MapPut1 in H1.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl."], "tactic": "apply H2.", "exn": "In environment m, m0, s1 : state d : preDTA tl : term_list H : mpl_compat (M2 prec_list m m0) s1 H2 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl s1 m0) (app c tl) H3 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m0 s1 -> state_reconnait d m0 (app c tl) -> state_reconnait d (union_mpl m0 s1) (app c tl) H1 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl s1 m) (app c tl) H4 : forall (s1 : state) (d : preDTA) (c : ad) (tl : term_list), mpl_compat m s1 -> state_reconnait d m (app c tl) -> state_reconnait d (union_mpl m s1) (app c tl) l : prec_list H9 : MapGet prec_list m 0%N = Some l H10 : liste_reconnait d l tl Unable to unify \"state_reconnait ?M30513 (union_mpl ?M30512 m0) (app ?M30514 ?M30515)\" with \"state_reconnait d (union_mpl s1 (M2 prec_list m m0)) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros m H1 m0 H2. unfold union_std_def in *. intros. split. - apply H in H1. apply H0 in H1. apply H1. - apply H0 in H2. apply H in H2. apply H2.", "succ": false}]