[{"history": {"proof": "intros s d a pl c tl H1 H2. srun best use: union_s_rpl_3 unfold: union_s_rpl_def.", "repairs": ["", "hammer"], "exceptions": [{"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left."], "tactic": "eapply union_s0d_0.", "exn": "In environment d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M0 prec_list) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (M1 prec_list a pl) (app c tl) Unable to unify \"c\" with \"a\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0."], "tactic": "apply H1.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-"], "tactic": "destruct (ad =? c)%N eqn:Adc.", "exn": "In environment a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M1 prec_list a0 p) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d (if (a =? a0)%N then M1 prec_list a (union_pl pl p) else MapMerge prec_list (M1 prec_list a pl) (M1 prec_list a0 p)) (app c tl) The term \"ad\" has type \"Set\" while it is expected to have type \"N\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left."], "tactic": "eapply union_s0d_1_0.", "exn": "In environment X : Set H : forall (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) p : prec_list d : preDTA pl : prec_list c : ad tl : term_list H1 : forall (c0 : ad) (p0 p1 : prec_list), (if (c =? c0)%N then Some pl else None) = Some p0 -> (if (c =? c0)%N then Some p else None) = Some p1 -> pl_compat p0 p1 H7 : liste_reconnait d (union_pl pl p) tl Unable to unify \"state_reconnait ?M7779 (union_mpl_0 ?M7780 ?M7781 (M1 prec_list ?M7780 ?M7782)) (app ?M7780 ?M7783)\" with \"state_reconnait d (M1 prec_list c pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad."], "tactic": "apply H1.", "exn": "In environment X0 : Set H2 : forall (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H0 : forall (d : preDTA) (c : ad) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) X : Set p : prec_list d : preDTA pl : prec_list c : ad tl : term_list H1 : forall (c0 : ad) (p0 p1 : prec_list), (if (c =? c0)%N then Some pl else None) = Some p0 -> (if (c =? c0)%N then Some p else None) = Some p1 -> pl_compat p0 p1 H7 : liste_reconnait d (union_pl pl p) tl Unable to unify \"?M8546 = prec_empty /\\\\ ?M8547 = prec_empty \\\\/ ?M8546 <> prec_empty /\\\\ ?M8547 <> prec_empty\" with \"state_reconnait d (M1 prec_list c pl) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad."], "tactic": "apply H2.", "exn": "The reference H2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right."], "tactic": "eapply union_s0d_1_1.", "exn": "In environment X : Set H : forall (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), (if (a =? c)%N then Some pl else None) = Some p0 -> (if (a0 =? c)%N then Some p else None) = Some p1 -> pl_compat p0 p1 p0 : positive Heqn : N.lxor a0 a = N.pos p0 H0 : a = a0 -> False l : prec_list H7 : MapGet prec_list (MapPut1 prec_list a0 p a pl p0) c = Some l H8 : liste_reconnait d l tl Unable to unify \"state_reconnait ?M9318 (union_mpl_0 ?M9319 ?M9320 (M1 prec_list ?M9321 ?M9322)) (app ?M9319 ?M9323)\" with \"state_reconnait d (M1 prec_list a0 p) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "apply H1.", "exn": "In environment S : Set H4 : forall (d : preDTA) (c : S) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H3 : forall (d : preDTA) (c : S) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) H2 : forall (d : preDTA) (c : ad) (pl : prec_list) (c0 : ad) (pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c0 pl0) -> (c = c0 -> False) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end) (app c tl) X : Set H : forall (d : preDTA) (c : ad) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) a0 : ad p : prec_list d : preDTA a : ad pl : prec_list c : ad tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), (if (a =? c)%N then Some pl else None) = Some p0 -> (if (a0 =? c)%N then Some p else None) = Some p1 -> pl_compat p0 p1 p0 : positive Heqn : N.lxor a0 a = N.pos p0 H0 : a = a0 -> False l : prec_list H7 : MapGet prec_list (MapPut1 prec_list a0 p a pl p0) c = Some l H8 : liste_reconnait d l tl Unable to unify \"?M10567 = prec_empty /\\\\ ?M10568 = prec_empty \\\\/ ?M10567 <> prec_empty /\\\\ ?M10568 <> prec_empty\" with \"state_reconnait d (M1 prec_list a0 p) (app c tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "apply n.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind."], "tactic": "apply H2.", "exn": "The reference H2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left."], "tactic": "eapply union_s0d_2_0.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app 0%N tl) Unable to unify \"state_reconnait ?M12089 (union_mpl_0 0%N ?M12090 (M2 prec_list ?M12091 ?M12092)) (app 0%N ?M12093)\" with \"state_reconnait d (M1 prec_list a pl) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "apply H1.", "exn": "In environment S : Set H4 : forall (d : preDTA) (c : S) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H3 : forall (d : preDTA) (c : S) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) H0 : forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list), mpl_compat (M1 prec_list 0%N pl) (M2 prec_list s0 s1) -> state_reconnait d (M1 prec_list 0%N pl) (app 0%N tl) -> state_reconnait d (M2 prec_list (union_mpl_0 0%N pl s0) s1) (app 0%N tl) H : forall (d : preDTA) (c : ad) (pl : prec_list) (c0 : ad) (pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c0 pl0) -> (c = c0 -> False) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end) (app c tl) s1, s2 : Map prec_list d : preDTA pl : prec_list tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), (if match c with | 0%N => true | N.pos _ => false end then Some pl else None) = Some p0 -> match c with | 0%N => MapGet prec_list s1 0%N | N.pos (p~1)%positive => MapGet prec_list s2 (N.pos p) | N.pos (p~0)%positive => MapGet prec_list s1 (N.pos p) | 1%N => MapGet prec_list s2 0%N end = Some p1 -> pl_compat p0 p1 l : prec_list H9 : MapGet prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) 0%N = Some l H10 : liste_reconnait d l tl Unable to unify \"?M21119 = prec_empty /\\\\ ?M21120 = prec_empty \\\\/ ?M21119 <> prec_empty /\\\\ ?M21120 <> prec_empty\" with \"state_reconnait d (M1 prec_list 0%N pl) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "apply H2.", "exn": "In environment S0 : Set H7 : forall (d : preDTA) (c : S0) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H6 : forall (d : preDTA) (c : S0) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) H5 : forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list), mpl_compat (M1 prec_list 0%N pl) (M2 prec_list s0 s1) -> state_reconnait d (M1 prec_list 0%N pl) (app 0%N tl) -> state_reconnait d (M2 prec_list (union_mpl_0 0%N pl s0) s1) (app 0%N tl) H2 : forall (d : preDTA) (c : ad) (pl : prec_list) (c0 : ad) (pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c0 pl0) -> (c = c0 -> False) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end) (app c tl) S : Set H4 : forall (d : preDTA) (c : S) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H3 : forall (d : preDTA) (c : S) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) s1, s2 : Map prec_list d : preDTA pl : prec_list tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), (if match c with | 0%N => true | N.pos _ => false end then Some pl else None) = Some p0 -> match c with | 0%N => MapGet prec_list s1 0%N | N.pos (p~1)%positive => MapGet prec_list s2 (N.pos p) | N.pos (p~0)%positive => MapGet prec_list s1 (N.pos p) | 1%N => MapGet prec_list s2 0%N end = Some p1 -> pl_compat p0 p1 l : prec_list H9 : MapGet prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) 0%N = Some l H10 : liste_reconnait d l tl Unable to unify \"state_reconnait ?M22752 (if (?M22753 =? ?M22755)%N then M1 prec_list ?M22753 (union_pl ?M22754 ?M22756) else match N.lxor ?M22755 ?M22753 with | 0%N => M1 prec_list ?M22755 ?M22756 | N.pos p => MapPut1 prec_list ?M22755 ?M22756 ?M22753 ?M22754 p end) (app ?M22753 ?M22757)\" with \"state_reconnait d (M1 prec_list 0%N pl) (app 0%N tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right."], "tactic": "eapply union_s0d_2_1.", "exn": "In environment s1, s2 : Map prec_list d : preDTA a : ad pl : prec_list p : positive tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), MapGet prec_list (M1 prec_list a pl) c = Some p0 -> MapGet prec_list (M2 prec_list s1 s2) c = Some p1 -> pl_compat p0 p1 H2 : state_reconnait d match a with | 0%N => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) s2 | N.pos (p'~1)%positive => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s2) | N.pos (p'~0)%positive => M2 prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'0~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p'0) pl s1) | N.pos (p'0~0)%positive => M2 prec_list (union_mpl_0 (N.pos p'0) pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) (N.pos p') pl s1) s2 | 1%N => M2 prec_list s1 ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else MapMerge prec_list (M1 prec_list c pl) (M1 prec_list c0 pl0) | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s2) end (app (N.pos p) tl) Unable to unify \"state_reconnait ?M24701 (union_mpl_0 1%N ?M24702 (M2 prec_list ?M24703 ?M24704)) (app 1%N ?M24705)\" with \"state_reconnait d (M2 prec_list s1 s2) (app (N.pos p) tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_2_1,union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "apply H1.", "exn": "In environment S : Set H5 : forall (d : preDTA) (c : S) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H4 : forall (d : preDTA) (c : S) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) H3 : forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list), mpl_compat (M1 prec_list 0%N pl) (M2 prec_list s0 s1) -> state_reconnait d (M1 prec_list 0%N pl) (app 0%N tl) -> state_reconnait d (M2 prec_list (union_mpl_0 0%N pl s0) s1) (app 0%N tl) H0 : forall (d : preDTA) (c : ad) (pl : prec_list) (c0 : ad) (pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c0 pl0) -> (c = c0 -> False) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end) (app c tl) H : forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list), mpl_compat (M1 prec_list 1%N pl) (M2 prec_list s0 s1) -> state_reconnait d (M1 prec_list 1%N pl) (app 1%N tl) -> state_reconnait d (M2 prec_list s0 (union_mpl_0 0%N pl s1)) (app 1%N tl) s1, s2 : Map prec_list d : preDTA pl : prec_list p : positive tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), (if match c with | 0%N => true | N.pos _ => false end then Some pl else None) = Some p0 -> match c with | 0%N => MapGet prec_list s1 0%N | N.pos (p~1)%positive => MapGet prec_list s2 (N.pos p) | N.pos (p~0)%positive => MapGet prec_list s1 (N.pos p) | 1%N => MapGet prec_list s2 0%N end = Some p1 -> pl_compat p0 p1 l : prec_list H10 : MapGet prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) (N.pos p) = Some l H11 : liste_reconnait d l tl Unable to unify \"?M42724 = prec_empty /\\\\ ?M42725 = prec_empty \\\\/ ?M42724 <> prec_empty /\\\\ ?M42725 <> prec_empty\" with \"state_reconnait d (M2 prec_list s1 s2) (app (N.pos p~0) tl)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s d a pl c tl H1 H2.", "unfold mpl_compat in H1.", "unfold union_mpl_0 in H2.", "destruct s.", "-", "left.", "qsimpl use: union_s0d_0.", "-", "qsimpl use: union_s0d_0,N,ad.", "+", "left.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "qsimpl use: union_s0d_1_0,union_s0d_0,N,ad.", "apply N_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,N,ad,union_s0d_1_0,union_s0d_0.", "apply prec_list_ind.", "apply prec_list_ind.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct c as [|p].", "+", "left.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "right.", "qsimpl use: union_s0d_2_1,union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0.", "qsimpl use: union_s0d_2_1,union_s0d_1_1,union_s0d_2_0,N,ad,union_s0d_1_0,union_s0d_0."], "tactic": "apply H2.", "exn": "In environment S0 : Set H9 : forall (d : preDTA) (c : S0) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H8 : forall (d : preDTA) (c : S0) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) H7 : forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list), mpl_compat (M1 prec_list 0%N pl) (M2 prec_list s0 s1) -> state_reconnait d (M1 prec_list 0%N pl) (app 0%N tl) -> state_reconnait d (M2 prec_list (union_mpl_0 0%N pl s0) s1) (app 0%N tl) H6 : forall (d : preDTA) (c : ad) (pl : prec_list) (c0 : ad) (pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c0 pl0) -> (c = c0 -> False) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end) (app c tl) H2 : forall (d : preDTA) (pl : prec_list) (s0 s1 : state) (tl : term_list), mpl_compat (M1 prec_list 1%N pl) (M2 prec_list s0 s1) -> state_reconnait d (M1 prec_list 1%N pl) (app 1%N tl) -> state_reconnait d (M2 prec_list s0 (union_mpl_0 0%N pl s1)) (app 1%N tl) S : Set H5 : forall (d : preDTA) (c : S) (pl : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M0 prec_list) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (M1 prec_list c pl) (app c tl) H4 : forall (d : preDTA) (c : S) (pl pl0 : prec_list) (tl : term_list), mpl_compat (M1 prec_list c pl) (M1 prec_list c pl0) -> state_reconnait d (M1 prec_list c pl) (app c tl) -> state_reconnait d (if (c =? c)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c c with | 0%N => M1 prec_list c pl0 | N.pos p => MapPut1 prec_list c pl0 c pl p end) (app c tl) s1, s2 : Map prec_list d : preDTA pl : prec_list p : positive tl : term_list H1 : forall (c : ad) (p0 p1 : prec_list), (if match c with | 0%N => true | N.pos _ => false end then Some pl else None) = Some p0 -> match c with | 0%N => MapGet prec_list s1 0%N | N.pos (p~1)%positive => MapGet prec_list s2 (N.pos p) | N.pos (p~0)%positive => MapGet prec_list s1 (N.pos p) | 1%N => MapGet prec_list s2 0%N end = Some p1 -> pl_compat p0 p1 l : prec_list H10 : MapGet prec_list ((fix union_mpl_0 (c : ad) (pl : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M1 prec_list c pl | @M1 _ c0 pl0 => if (c =? c0)%N then M1 prec_list c (union_pl pl pl0) else match N.lxor c0 c with | 0%N => M1 prec_list c0 pl0 | N.pos p => MapPut1 prec_list c0 pl0 c pl p end | @M2 _ s0 s1 => match c with | 0%N => M2 prec_list (union_mpl_0 0%N pl s0) s1 | N.pos (p'~1)%positive => M2 prec_list s0 (union_mpl_0 (N.pos p') pl s1) | N.pos (p'~0)%positive => M2 prec_list (union_mpl_0 (N.pos p') pl s0) s1 | 1%N => M2 prec_list s0 (union_mpl_0 0%N pl s1) end end) 0%N pl s1) (N.pos p) = Some l H11 : liste_reconnait d l tl Unable to unify \"state_reconnait ?M44301 (M2 prec_list ?M44303 (union_mpl_0 0%N ?M44302 ?M44304)) (app 1%N ?M44305)\" with \"state_reconnait d (M2 prec_list s1 s2) (app (N.pos p~0) tl)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros s d a pl c tl H1 H2. unfold mpl_compat in H1. unfold union_mpl_0 in H2. destruct s. - left. eapply union_s0d_0. apply H1. apply H2. - destruct (ad =? c)%N eqn:Adc. + left. eapply union_s0d_1_0. apply H1. apply H2. + right. eapply union_s0d_1_1. apply H1. apply n. apply H2. - destruct c as [|p]. + left. eapply union_s0d_2_0. apply H1. apply H2. + right. eapply union_s0d_2_1. apply H1. apply H2.", "succ": true}]