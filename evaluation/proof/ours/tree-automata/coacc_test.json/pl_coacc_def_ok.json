[{"history": {"proof": "intros d pl. unfold ensemble_base. induction pl. - simpl. qsimpl use: map_mini_appartient. srun best use: map_or_def_ok_d, map_replace_def_ok_d unfold: ensemble_base. - simpl. qsimpl use: map_mini_appartient,map_or_def_ok_d. apply H.", "repairs": ["", "", "", "", "", "cannot_unify", "hammer", "", "", "cannot_unify", "ref_not_found"], "exceptions": [{"ctx": ["intros d pl.", "unfold ensemble_base.", "induction pl.", "-", "simpl."], "tactic": "apply map_mini_appartient.", "exn": "In environment d : preDTA a : ad pl1, pl2 : prec_list IHpl1 : domain_equal state bool d (pl_coacc d pl1) IHpl2 : domain_equal state bool d (pl_coacc d pl2) Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) ?M1855 bool ?M1856 (map_mini ?M1855 ?M1856)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d (map_replace bool (map_or (pl_coacc d pl1) (pl_coacc d pl2)) a true)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d pl.", "unfold ensemble_base.", "induction pl.", "-", "simpl.", "qsimpl use: map_mini_appartient."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d pl.", "unfold ensemble_base.", "induction pl.", "-", "simpl.", "qsimpl use: map_mini_appartient.", "shelve.", "-", "simpl."], "tactic": "apply map_or_def_ok_d.", "exn": "In environment d : preDTA Unable to unify \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool ?M1959 (map_or ?M1960 ?M1961)\" with \"(fix domain_equal (A B : Set) (m0 : Map A) (m1 : Map B) {struct m1} : Prop := match m0 with | @M0 _ => match m1 with | @M0 _ => True | _ => False end | @M1 _ a _ => match m1 with | @M1 _ b _ => a = b | _ => False end | @M2 _ a b => match m1 with | @M2 _ c d => domain_equal A B a c /\\\\ domain_equal A B b d | _ => False end end) state bool d (map_mini state d)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d pl.", "unfold ensemble_base.", "induction pl.", "-", "simpl.", "qsimpl use: map_mini_appartient.", "shelve.", "-", "simpl.", "qsimpl use: map_mini_appartient,map_or_def_ok_d."], "tactic": "apply IHpl1.", "exn": "The reference IHpl1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d pl.", "unfold ensemble_base.", "induction pl.", "-", "simpl.", "qsimpl use: map_mini_appartient.", "shelve.", "-", "simpl.", "qsimpl use: map_mini_appartient,map_or_def_ok_d.", "apply H."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros d pl. unfold ensemble_base. induction pl. - simpl. apply map_mini_appartient. - simpl. apply map_or_def_ok_d. + apply IHpl1. + apply IHpl2.", "succ": true}]