[{"history": {"proof": "intros d m0 m1 m2 H1 H2. unfold lemd in *. destruct H1 as [H1_1 [H1_2 H1_3]]. destruct H2 as [H2_1 [H2_2 H2_3]]. split. + qsimpl. + qsimpl use: borne_1_2. qsimpl use: borne_1_2. qsimpl use: borne_1_2,map_or_def_ok_d. qsimpl use: borne_1_2,map_or_def_ok_d. qsimpl use: borne_1_2,map_or_def_ok_d. apply prec_list_ind. * intros Hin'. qsimpl use: borne_1_2,map_or_def_ok_d. * qsimpl use: borne_1_2,map_or_def_ok_d. apply prec_list_ind. - sfirstorder depth: 3. - qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok. srun best use: lem_transitive unfold: r_transitive. - qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok. * qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok.", "repairs": ["", "", "", "", "", "", "not_inductive_product", "wrong_bullet", "wrong_type", "wrong_type", "cannot_unify", "wrong_type", "cannot_unify", "ref_not_found", "", "", "wrong_type", "wrong_bullet", "cannot_unify", "ref_not_found", "", "hammer", "wrong_bullet", "cannot_unify", "hammer", "wrong_bullet", "cannot_unify", "", "cannot_unify"], "exceptions": [{"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+"], "tactic": "apply (borne_1_2 m0 m1).", "exn": "In environment d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_1 : ensemble_base state d m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 The term \"m0\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2."], "tactic": "intros Hin.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2."], "tactic": "apply (borne_1_2 m1 m2).", "exn": "In environment H : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 The term \"m1\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2."], "tactic": "intros Hin'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2."], "tactic": "apply (map_or_def_ok_d d m1 m2 H1_2 H2_2).", "exn": "In environment H0 : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d (map_or m1 m2)\" with \"lem m0 m2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "intros Hin''.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "apply (borne_1_2 m0 m1).", "exn": "In environment H1 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 The term \"m0\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "apply H1_1.", "exn": "In environment H2 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H0 : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d m0\" with \"lem m0 m2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "apply H2_1.", "exn": "The reference H2_1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "apply Hin.", "exn": "The reference Hin was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'."], "tactic": "apply (borne_1_2 m0 m1).", "exn": "In environment H1 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Hin' : ad The term \"m0\" has type \"Map bool\" while it is expected to have type \"Map state\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "++", "exn": "Wrong bullet ++: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*"], "tactic": "apply H1_1.", "exn": "In environment H1 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d m0\" with \"lem m0 m2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "apply H2_1.", "exn": "The reference H2_1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d."], "tactic": "apply Hin'.", "exn": "The reference Hin' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-"], "tactic": ["apply (map_or_def_ok m0 m1).", ""], "exn": "Applied theorem does not have enough premises.", "type": "no_enough_premises", "handled": false}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-"], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-", "shelve.", "-"], "tactic": "apply (map_or_def_ok_d d m0 m2).", "exn": "In environment H2 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H0 : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d (map_or m0 m2)\" with \"lem m0 m2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-", "shelve.", "-", "qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok."], "tactic": "*", "exn": "Wrong bullet *: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-", "shelve.", "-", "qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok.", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-", "shelve.", "-", "qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok.", "shelve.", "-"], "tactic": "apply H1_2.", "exn": "In environment H2 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H0 : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d m1\" with \"prec_list\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d m0 m1 m2 H1 H2.", "unfold lemd in *.", "destruct H1 as [H1_1 [H1_2 H1_3]].", "destruct H2 as [H2_1 [H2_2 H2_3]].", "split.", "+", "qsimpl.", "+", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "*", "intros Hin'.", "qsimpl use: borne_1_2,map_or_def_ok_d.", "*", "qsimpl use: borne_1_2,map_or_def_ok_d.", "apply prec_list_ind.", "-", "shelve.", "-", "qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok.", "shelve.", "-", "qsimpl use: borne_1_2,map_or_def_ok_d,lem_domain_equal,map_or_def_ok.", "*"], "tactic": "apply H2_2.", "exn": "In environment H1 : forall (d : preDTA) (m0 m1 : Map bool), ensemble_base state d m0 -> ensemble_base state d m1 -> ensemble_base state d (map_or m0 m1) H : forall (m0 m1 : Map state) (s : state), (state_in_dta m0 s -> taille_1 s <= DTA_taille m0) -> (state_in_dta m1 s -> taille_1 s <= DTA_taille m1) -> state_in_dta (M2 state m0 m1) s -> taille_1 s <= Nat.max (DTA_taille m0) (DTA_taille m1) d : preDTA m0, m1, m2 : Map bool H1_1 : ensemble_base state d m0 H1_2 : ensemble_base state d m1 H1_3 : lem m0 m1 H2_2 : ensemble_base state d m2 H2_3 : lem m1 m2 Unable to unify \"ensemble_base state d m2\" with \"prec_list\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros d m0 m1 m2 H1 H2. unfold lemd in *. destruct H1 as [H1_1 [H1_2 H1_3]]. destruct H2 as [H2_1 [H2_2 H2_3]]. split. + split. - apply (borne_1_2 m0 m1). * intros Hin. apply (borne_1_2 m1 m2). ++ intros Hin'. apply (map_or_def_ok_d d m1 m2 H1_2 H2_2). ++ intros Hin''. apply (borne_1_2 m0 m1). ** apply H1_1. ** apply H2_1. ** apply Hin. * intros Hin'. apply (borne_1_2 m0 m1). ++ apply H1_1. ++ apply H2_1. ++ apply Hin'. - apply (map_or_def_ok m0 m1). apply (lem_domain_equal m0 m1 H1_3). + apply (map_or_def_ok_d d m0 m2). * apply H1_2. * apply H2_2.", "succ": true}]