[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "apply orb_incr.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"if ?M1882 || ?M1884 then if ?M1883 || ?M1885 then True else False else if ?M1883 || ?M1885 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1 then if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else False else if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-"], "tactic": "apply orb_incr.", "exn": "In environment a : ad p1 : prec_list a0 : ad p2_1, p2_2 : prec_list m0, m1 : Map bool H : lem m0 m1 E0 : MapGet bool m0 a = None Unable to unify \"if ?M1882 || ?M1884 then if ?M1883 || ?M1885 then True else False else if ?M1883 || ?M1885 then True else True\" with \"if match p2_2 with | prec_cons _ _ _ => match MapGet bool m0 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_2 end | prec_empty => match MapGet bool m0 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m0 p2_1 | None => false end end then if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else False else if match MapGet bool m1 a with | Some b => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => match p2_2 with | prec_cons _ _ _ => match MapGet bool m1 a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_2 end | prec_empty => match MapGet bool m1 a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p2_1 | None => false end end end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-"], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,E,auto,andb_incr,bool,qsimpl,lem_get_leb,leb_reflexive,lem_domain_equal,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-"], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,auto,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-"], "tactic": "+", "exn": "Wrong bullet +: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "apply andb_inc_l.", "exn": "In environment a : ad p1 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Unable to unify \"if ?M1888 && ?M1887 then if ?M1889 && ?M1887 then True else False else if ?M1889 && ?M1887 then True else True\" with \"if b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1 then if match MapGet bool m1 a with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => false end then True else False else if match MapGet bool m1 a with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1 | None => false end then True else True\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,E,auto,andb_incr,bool,qsimpl,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-"], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,auto,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive."], "tactic": "apply leb_transitive with b.", "exn": "In environment H9 : forall a b c : bool, leb a b -> leb b c -> leb a c H8 : forall b0 b1 b2 b3 : bool, leb b0 b1 -> leb b2 b3 -> leb (b0 || b2) (b1 || b3) H7 : forall b c : bool, leb b c -> leb c b -> b = c H6 : forall b b0 b1 : bool, leb b0 b1 -> leb (b && b0) (b && b1) H5 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 H4 : forall b : bool, leb b b H3 : forall (m0 m1 : Map bool) (a : ad) (b0 b1 : bool), lem m0 m1 -> MapGet bool m0 a = Some b0 -> MapGet bool m1 a = Some b1 -> leb b0 b1 H2 : forall b0 b1 b2 b3 : bool, leb b0 b1 -> leb b2 b3 -> leb (b0 && b2) (b1 && b3) H1 : forall (A : Set) (x : Map A), mLattice bool lem (ensemble_base A x) (map_mini A x) (map_maxi A x) H0 : forall b b0 b1 : bool, leb b0 b1 -> leb (b0 && b) (b1 && b) a : ad p1 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b b0 : bool Heqo : MapGet bool m1 a = Some b0 H11 : is_true b0 -> is_true ((fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m1 p1) -> False H10 : is_true b H12 : is_true ((fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1) Unable to unify \"if ?M4452 then if ?M4454 then True else False else if ?M4454 then True else True\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive."], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,E,auto,andb_incr,bool,qsimpl,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive."], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,auto,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*"], "tactic": "apply leb_transitive with (mlattice bool m0 b1).", "exn": "The reference b1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*"], "tactic": "apply lem_get_leb with a b0 b1; auto.", "exn": "The reference b1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*"], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*", "shelve.", "*"], "tactic": "apply leb_transitive with b; auto.", "exn": "In environment H9 : forall a b c : bool, leb a b -> leb b c -> leb a c H8 : forall b0 b1 b2 b3 : bool, leb b0 b1 -> leb b2 b3 -> leb (b0 || b2) (b1 || b3) H7 : forall b c : bool, leb b c -> leb c b -> b = c H6 : forall b b0 b1 : bool, leb b0 b1 -> leb (b && b0) (b && b1) H5 : forall m0 m1 : Map bool, lem m0 m1 -> domain_equal bool bool m0 m1 H4 : forall b : bool, leb b b H3 : forall (m0 m1 : Map bool) (a : ad) (b0 b1 : bool), lem m0 m1 -> MapGet bool m0 a = Some b0 -> MapGet bool m1 a = Some b1 -> leb b0 b1 H2 : forall b0 b1 b2 b3 : bool, leb b0 b1 -> leb b2 b3 -> leb (b0 && b2) (b1 && b3) H1 : forall (A : Set) (x : Map A), mLattice bool lem (ensemble_base A x) (map_mini A x) (map_maxi A x) H0 : forall b b0 b1 : bool, leb b0 b1 -> leb (b0 && b) (b1 && b) a : ad p1 : prec_list m0, m1 : Map bool H : lem m0 m1 b : bool E0 : MapGet bool m0 a = Some b Heqo : MapGet bool m1 a = None H10 : is_true b H11 : is_true ((fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) m0 p1) Unable to unify \"if ?M5438 then if ?M5440 then True else False else if ?M5440 then True else True\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*", "shelve.", "*"], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,E,auto,andb_incr,bool,qsimpl,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference E was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*", "shelve.", "*"], "tactic": "qsimpl time: 2 use: andb_inc_l,mlattice,auto,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "exn": "The reference auto was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*", "shelve.", "*", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive."], "tactic": "-", "exn": "Wrong bullet -: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros p m0 m1 H.", "unfold leb, pl_non_empty in *.", "destruct p; try auto.", "destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto).", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "shelve.", "-", "shelve.", "+", "destruct (MapGet bool m0 a) eqn:E0.", "-", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "*", "shelve.", "*", "qsimpl time: 2 use: andb_inc_l,mlattice,andb_incr,bool,lem_get_leb,leb_reflexive,lem_domain_equal,andb_inc_r,leb_antisymmetric,orb_incr,leb_transitive.", "shelve.", "-"], "tactic": "apply leb_transitive with b; auto.", "exn": "The reference b was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros p m0 m1 H. unfold leb, pl_non_empty in *. destruct p; try auto. destruct p2; try (destruct (MapGet bool m1 a) eqn:E; auto; destruct b; auto). + destruct (MapGet bool m0 a) eqn:E0. - apply orb_incr. * apply andb_inc_l. apply leb_transitive with b. { apply andb_incr. apply leb_reflexive. apply leb_antisymmetric with b0. } { apply leb_transitive with b1. ++ apply (lem_get_leb _ _ a b0 b1 H E0 E). ++ apply leb_transitive with (mlattice bool m0 b1). -- apply lem_domain_equal with m0; auto. -- apply lem_domain_equal with m1; auto. } * apply leb_transitive with (mlattice bool m1 b). { apply lem_domain_equal with m1; auto. } { apply andb_incr; auto. } - apply orb_incr. * apply andb_inc_r. apply leb_transitive with (mlattice bool m0 b1); auto. apply lem_domain_equal with m0; auto. * apply leb_transitive with b; auto. + destruct (MapGet bool m0 a) eqn:E0. - apply andb_inc_l. apply leb_transitive with b. * apply leb_transitive with (mlattice bool m0 b1). { apply lem_get_leb with a b0 b1; auto. } { apply lem_domain_equal with m0; auto. } * apply leb_transitive with b; auto. - apply leb_transitive with b; auto.", "succ": false}]