[{"history": {"proof": "srun best use: dt_non_empty_6, le_n_n unfold: dt_non_empty_def_2.", "repairs": [], "exceptions": [{"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl."], "tactic": "destruct (MapGet bool m a) eqn:E.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl."], "tactic": "apply orb_true_iff.", "exn": "In environment d : preDTA a : ad la : prec_list a0 : ad ls1, ls2 : prec_list hd : term tl : term_list H : reconnaissance d a hd H0 : liste_reconnait d la tl IHliste_reconnait : (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 tl)) la = true Unable to unify \"(?M1865 || ?M1866 = true -> ?M1865 = true \\\\/ ?M1866 = true) /\\\\ (?M1865 = true \\\\/ ?M1866 = true -> ?M1865 || ?M1866 = true)\" with \"match MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) a with | Some b => match ls2 with | prec_cons _ _ _ => match MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) a0 with | Some b0 => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls2 || b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls2 end | prec_empty => match MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) a0 with | Some b0 => b0 && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b1 => pl_non_empty m ls || b1 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b1 => b1 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls1 | None => false end end || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) la | None => match ls2 with | prec_cons _ _ _ => match MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) a0 with | Some b => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls2 || b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls1 | None => (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls2 end | prec_empty => match MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) a0 with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) ls1 | None => false end end end = true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+"], "tactic": "destruct (MapGet bool m a) eqn:E.", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl."], "tactic": "apply orb_true_iff.", "exn": "In environment d : preDTA a : ad la : prec_list hd : term tl : term_list H : reconnaissance d a hd H0 : liste_reconnait d la tl IHliste_reconnait : (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b => pl_non_empty m ls || b && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b => b && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (term_high_0 tl)) la = true Unable to unify \"(?M1865 || ?M1866 = true -> ?M1865 = true \\\\/ ?M1866 = true) /\\\\ (?M1865 = true \\\\/ ?M1866 = true -> ?M1865 || ?M1866 = true)\" with \"match MapGet bool (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) a with | Some b => b && (fix pl_non_empty (m : Map bool) (p : prec_list) {struct p} : bool := match p with | prec_cons a la (prec_cons _ _ _ as ls) => match MapGet bool m a with | Some b0 => pl_non_empty m ls || b0 && pl_non_empty m la | None => pl_non_empty m ls end | prec_cons a la prec_empty => match MapGet bool m a with | Some b0 => b0 && pl_non_empty m la | None => false end | prec_empty => true end) (power (Map bool) (dta_app_ne d) (map_mini state d) (Nat.max (term_high hd) (term_high_0 tl))) la | None => false end = true\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl."], "tactic": "qsimpl time: 2 use: orb_true_iff,qsimpl.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl.", "qsimpl time: 2 use: orb_true_iff."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl.", "qsimpl time: 2 use: orb_true_iff."], "tactic": "qsimpl time: 2 use: orb_true_iff,qsimpl.", "exn": "The reference qsimpl was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl.", "qsimpl time: 2 use: orb_true_iff.", "apply andb_true_intro.", "split."], "tactic": "apply IHpl_non_empty.", "exn": "The reference IHpl_non_empty was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl.", "qsimpl time: 2 use: orb_true_iff.", "apply andb_true_intro.", "split.", "apply positive_ind."], "tactic": "apply IHpl_non_empty.", "exn": "The reference IHpl_non_empty was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros d p t H.", "unfold pl_non_empty.", "induction H.", "-", "reflexivity.", "-", "destruct ls.", "+", "simpl.", "shelve.", "+", "simpl.", "qsimpl time: 2 use: orb_true_iff.", "apply andb_true_intro.", "split.", "apply positive_ind.", "apply positive_ind.", "*"], "tactic": "apply IHpl_non_empty.", "exn": "The reference IHpl_non_empty was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros d p t H. unfold pl_non_empty. induction H. - reflexivity. - destruct ls. + simpl. destruct (MapGet bool m a) eqn:E. * simpl. apply orb_true_iff. left. apply IHpl_non_empty. * apply IHpl_non_empty. + destruct (MapGet bool m a) eqn:E. * simpl. apply orb_true_iff. right. apply andb_true_intro. split. { apply IHpl_non_empty. } { apply IHpl_non_empty. } * apply IHpl_non_empty.", "succ": true}]