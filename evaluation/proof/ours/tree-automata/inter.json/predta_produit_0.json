[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a s d a0 a1 s0 s1 H1 H2.", "unfold preDTA_produit_l."], "tactic": "rewrite -> H1.", "exn": "Found no subterm matching \"MapGet state (M1 state a s) a0\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros a s d a0 a1 s0 s1 H1 H2.", "unfold preDTA_produit_l.", "qsimpl."], "tactic": "rewrite -> H2.", "exn": "Found no subterm matching \"MapGet state d a1\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros a s d a0 a1 s0 s1 H1 H2.", "unfold preDTA_produit_l.", "qsimpl."], "tactic": "reflexivity.", "exn": "In environment d : preDTA a0, a1 : ad s0, s1 : state H2 : MapGet state d a1 = Some s1 Unable to unify \"Some (s_produit s0 s1)\" with \"MapGet state ((fix preDTA_produit_l (a : ad) (s : state) (d : preDTA) {struct d} : preDTA := match d with | @M0 _ => M0 state | @M1 _ a' s' => M1 state (iad_conv a a') (s_produit s s') | @M2 _ s0 s1 => match a with | 0%N => M2 state (M2 state (preDTA_produit_l 0%N s s0) (preDTA_produit_l 0%N s s1)) (M0 state) | N.pos (p'~1)%positive => M2 state (M0 state) (M2 state (preDTA_produit_l (N.pos p') s s0) (preDTA_produit_l (N.pos p') s s1)) | N.pos (p'~0)%positive => M2 state (M2 state (preDTA_produit_l (N.pos p') s s0) (preDTA_produit_l (N.pos p') s s1)) (M0 state) | 1%N => M2 state (M0 state) (M2 state (preDTA_produit_l 0%N s s0) (preDTA_produit_l 0%N s s1)) end end) a0 s0 d) (iad_conv a0 a1)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros a s d a0 a1 s0 s1 H1 H2. unfold preDTA_produit_l. simpl. rewrite -> H1. rewrite -> H2. reflexivity.", "succ": false}]