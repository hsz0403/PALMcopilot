[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a la ls H0 H1.", "unfold pl_produit_1_incr.", "intros n H2."], "tactic": "apply H1 in H2.", "exn": "Unable to apply lemma of type \"pl_produit_0_incr la H0\" on hypothesis of type \"nat\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros a la ls H0 H1.", "unfold pl_produit_1_incr.", "intros n H2.", "qsimpl."], "tactic": "apply H0 in H2.", "exn": "The reference H0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros a la ls H0 H1.", "unfold pl_produit_1_incr.", "intros n H2.", "qsimpl."], "tactic": "apply H2.", "exn": "In environment a : ad la, ls : prec_list a0 : ad H0_, H0_0 : prec_list H1 : pl_produit_0_incr la (prec_cons a0 H0_ H0_0) n : forall n : nat, pl_essence ls (prec_cons a0 H0_ H0_0) <= n -> pl_produit_1 ls (pl_essence ls (prec_cons a0 H0_ H0_0)) (prec_cons a0 H0_ H0_0) = pl_produit_1 ls n (prec_cons a0 H0_ H0_0) H2 : nat H : pl_essence (prec_cons a la ls) (prec_cons a0 H0_ H0_0) <= H2 Unable to unify \"nat\" with \"pl_produit_0 a la (prec_cons a0 H0_ H0_0) (pl_card la + pl_card ls + S (pl_card H0_ + pl_card H0_0)) (pl_produit_1 ls (pl_card la + pl_card ls + S (pl_card H0_ + pl_card H0_0)) (prec_cons a0 H0_ H0_0)) = pl_produit_1 (prec_cons a la ls) H2 (prec_cons a0 H0_ H0_0)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros a la ls H0 H1. unfold pl_produit_1_incr. intros n H2. apply H1 in H2. apply H0 in H2. apply H2.", "succ": false}]