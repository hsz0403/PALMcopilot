[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl."], "tactic": "rewrite E.", "exn": "Found no subterm matching \"(a =? a0)%N\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl."], "tactic": "reflexivity.", "exn": "In environment a0 : ad p0, p : prec_list c : ad E : (c =? a0)%N = true Unable to unify \"Some (pl_produit p p0)\" with \"Some p\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl."], "tactic": "rewrite E.", "exn": "Found no subterm matching \"(a =? a0)%N\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl."], "tactic": "reflexivity.", "exn": "In environment a0 : ad p0, p : prec_list c : ad E : (c =? a0)%N = true H0 : a0 = c -> False Unable to unify \"Some p0\" with \"None\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+"], "tactic": "apply H.", "exn": "In environment s1, s2 : Map prec_list p : prec_list c : ad r : prec_list H : match c with | 0%N => (fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s1) 0%N | N.pos (p1~0)%positive => (fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s1) (N.pos p1) | _ => None end = Some r Unable to unify \"match c with | 0%N => (fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s1) 0%N | N.pos (p1~0)%positive => (fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s1) (N.pos p1) | _ => None end = Some r\" with \"exists r0 r1 : prec_list, MapGet prec_list (M1 prec_list 0%N p) c = Some r0 /\\\\ MapGet prec_list (M2 prec_list s1 s2) c = Some r1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+", "qsimpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+", "qsimpl.", "*", "shelve.", "*", "shelve.", "+", "destruct (N.pos p0~1)%positive.", "*"], "tactic": "apply H.", "exn": "In environment s1, s2 : Map prec_list p0 : positive p : prec_list c : ad r : prec_list H : (fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) match p0 with | (q'~1)%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s2) | (q'~0)%positive => M2 prec_list ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s1) (M0 prec_list) | 1%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s2) end c = Some r Unable to unify \"(fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) match p0 with | (q'~1)%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s2) | (q'~0)%positive => M2 prec_list ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s1) (M0 prec_list) | 1%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s2) end c = Some r\" with \"exists r0 r1 : prec_list, MapGet prec_list (M1 prec_list (N.pos p0) p) c = Some r0 /\\\\ MapGet prec_list (M2 prec_list s1 s2) c = Some r1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+", "qsimpl.", "*", "shelve.", "*", "shelve.", "+", "destruct (N.pos p0~1)%positive.", "*", "qsimpl."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+", "qsimpl.", "*", "shelve.", "*", "shelve.", "+", "destruct (N.pos p0~1)%positive.", "*", "qsimpl.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*"], "tactic": "apply H.", "exn": "In environment s1, s2 : Map prec_list p0 : positive p : prec_list c : ad r : prec_list H : (fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) match p0 with | (q'~1)%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s2) | (q'~0)%positive => M2 prec_list ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s1) (M0 prec_list) | 1%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s2) end c = Some r p1 : positive Unable to unify \"(fix MapGet (m : Map prec_list) : ad -> option prec_list := match m with | @M0 _ => fun _ : ad => None | @M1 _ x y => fun a : ad => if (x =? a)%N then Some y else None | @M2 _ m1 m2 => fun a : ad => match a with | 0%N => MapGet m1 0%N | N.pos (p~1)%positive => MapGet m2 (N.pos p) | N.pos (p~0)%positive => MapGet m1 (N.pos p) | 1%N => MapGet m2 0%N end end) match p0 with | (q'~1)%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s2) | (q'~0)%positive => M2 prec_list ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'0~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q'0) p s1) | N.pos (q'0~0)%positive => M2 prec_list (s_produit_l (N.pos q'0) p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) (N.pos q') p s1) (M0 prec_list) | 1%positive => M2 prec_list (M0 prec_list) ((fix s_produit_l (a : ad) (p : prec_list) (s : state) {struct s} : state := match s with | @M0 _ => M0 prec_list | @M1 _ a' p' => if (a =? a')%N then M1 prec_list a (pl_produit p p') else M0 prec_list | @M2 _ s0 s1 => match a with | 0%N => M2 prec_list (s_produit_l 0%N p s0) (M0 prec_list) | N.pos (q'~1)%positive => M2 prec_list (M0 prec_list) (s_produit_l (N.pos q') p s1) | N.pos (q'~0)%positive => M2 prec_list (s_produit_l (N.pos q') p s0) (M0 prec_list) | 1%N => M2 prec_list (M0 prec_list) (s_produit_l 0%N p s1) end end) 0%N p s2) end c = Some r\" with \"exists r0 r1 : prec_list, MapGet prec_list (M1 prec_list (N.pos p0) p) c = Some r0 /\\\\ MapGet prec_list (M2 prec_list s1 s2) c = Some r1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+", "qsimpl.", "*", "shelve.", "*", "shelve.", "+", "destruct (N.pos p0~1)%positive.", "*", "qsimpl.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p c r H.", "unfold s_produit_l in H.", "unfold MapGet in H.", "destruct s.", "-", "inversion H.", "-", "destruct (a =? a0)%N eqn:E.", "+", "exists r, p0.", "split.", "*", "simpl.", "qsimpl.", "shelve.", "*", "simpl.", "qsimpl.", "shelve.", "+", "inversion H.", "-", "destruct a.", "+", "qsimpl.", "*", "shelve.", "*", "shelve.", "+", "destruct (N.pos p0~1)%positive.", "*", "qsimpl.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "*", "qsimpl.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve.", "--", "shelve."], "tactic": "+", "exn": "Wrong bullet +: No more subgoals.", "type": "no_more_subgoals", "handled": true}]}, "chat": [], "original": "intros s a p c r H. unfold s_produit_l in H. unfold MapGet in H. destruct s. - inversion H. - destruct (a =? a0)%N eqn:E. + exists r, p0. split. * simpl. rewrite E. reflexivity. * simpl. rewrite E. reflexivity. + inversion H. - destruct a. + simpl in H. apply H. + destruct (N.pos p0~1)%positive. * simpl in H. apply H. * simpl in H. apply H. + destruct (N.pos p0~0)%positive. * simpl in H. apply H. * simpl in H. apply H. + simpl in H. apply H.", "succ": false}]