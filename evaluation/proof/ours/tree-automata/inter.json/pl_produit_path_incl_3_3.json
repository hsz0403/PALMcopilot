[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a la ls p H1 H2 n m plp H3 H4 H5 H6."], "tactic": "apply pl_produit_path_incl_def_2.", "exn": "In environment a : ad la, ls, p : prec_list H1 : pl_produit_path_incl_def_2 p ls H2 : pl_produit_path_incl_def_3 p la n, m : nat plp : pl_path H3 : ad H4 : prec_list H5 : pl_path_incl plp (pl_produit_0 H3 p (prec_cons a la ls) m H4) H6 : pl_tl_length p n Unable to unify \"prec_list -> prec_list -> Prop\" with \"pl_tl_length (prec_cons a la ls) (S n) -> pl_essence p (prec_cons a la ls) <= m -> (exists plp0 plp1 : pl_path, plp = pl_path_product plp0 plp1 /\\\\ pl_path_incl plp0 (prec_cons H3 p prec_empty) /\\\\ pl_path_incl plp1 (prec_cons a la ls)) \\\\/ pl_path_incl plp H4\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros a la ls p H1 H2 n m plp H3 H4 H5 H6.", "qsimpl use: pl_produit_path_incl_def_2."], "tactic": "split; [apply H1 | apply H2 | apply pl_produit_path_incl_def_3 with n m; assumption].", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros a la ls p H1 H2 n m plp H3 H4 H5 H6. apply pl_produit_path_incl_def_2. split; [apply H1 | apply H2 | apply pl_produit_path_incl_def_3 with n m; assumption].", "succ": false}]