[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*"], "tactic": "apply Nat.eqb_eq in E.", "exn": "Unable to apply lemma of type \"forall n m : nat, (n =? m) = true <-> n = m\" on hypothesis of type \"(a =? 0)%N = true\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq."], "tactic": "rewrite sproductl_0_def with (s := M1 prec_list a p) (a := N0) (p := p) (c := N0) (r0 := pl_produit a1 p) (r1 := M0 prec_list); auto.", "exn": "The reference a was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq."], "tactic": "rewrite H2.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*"], "tactic": "apply Nat.eqb_neq in E.", "exn": "Unable to apply lemma of type \"forall x y : nat, (x =? y) = false <-> x <> y\" on hypothesis of type \"(a =? 0)%N = false\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq."], "tactic": "simpl.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+"], "tactic": "destruct (a =? N.pos p~1)%N eqn:E.", "exn": "In environment p1 : positive p0 : prec_list a : ad p : prec_list d0, d1 : preDTA H0 : forall (a : ad) (p : prec_list), MapGet prec_list (M1 prec_list (N.pos p1) p0) a = Some p -> prec_list_ref_ok p d1 H1 : forall (a0 : ad) (p0 : prec_list), MapGet prec_list (M1 prec_list a p) a0 = Some p0 -> prec_list_ref_ok p0 d0 H2 : ad H3 : prec_list The term \"p\" has type \"prec_list\" while it is expected to have type \"positive\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq."], "tactic": "apply Nat.eqb_eq in E.", "exn": "No such hypothesis: E", "type": "no_hypos", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq.", "qsimpl use: N,eqb_eq."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq.", "qsimpl use: N,eqb_eq.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq.", "qsimpl use: N,eqb_eq.", "shelve.", "-"], "tactic": "destruct (a =? N.pos p~0)%N eqn:E.", "exn": "In environment s1, s2 : Map prec_list a : ad p : prec_list d0, d1 : preDTA H0 : forall (a : ad) (p : prec_list), MapGet prec_list (M2 prec_list s1 s2) a = Some p -> prec_list_ref_ok p d1 H1 : forall (a0 : ad) (p0 : prec_list), MapGet prec_list (M1 prec_list a p) a0 = Some p0 -> prec_list_ref_ok p0 d0 H2 : ad H3 : prec_list The term \"p\" has type \"prec_list\" while it is expected to have type \"positive\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq.", "qsimpl use: N,eqb_eq.", "shelve.", "-"], "tactic": "qsimpl use: Nat,eqb_neq,eqb_eq,E,N.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq.", "qsimpl use: N,eqb_eq.", "shelve.", "-"], "tactic": "apply Nat.eqb_eq in E.", "exn": "No such hypothesis: E", "type": "no_hypos", "handled": true}, {"ctx": ["intros s a p d0 d1 H0 H1.", "unfold state_ref_ok in *.", "intros H2 H3.", "unfold s_produit_l.", "destruct s.", "-", "simpl in *.", "shelve.", "-", "destruct a0.", "+", "simpl in *.", "destruct (a =? N0)%N eqn:E.", "*", "qsimpl use: eqb_eq.", "qsimpl use: eqb_eq.", "shelve.", "*", "qsimpl use: eqb_eq.", "+", "qsimpl use: N,eqb_eq.", "qsimpl use: N,eqb_eq.", "shelve.", "-"], "tactic": "qsimpl use: Nat,eqb_neq,eqb_eq,E,N.", "exn": "The reference Nat was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros s a p d0 d1 H0 H1. unfold state_ref_ok in *. intros H2 H3. unfold s_produit_l. destruct s. - simpl in *. auto. - destruct a0. + simpl in *. destruct (a =? N0)%N eqn:E. * apply Nat.eqb_eq in E. subst. simpl. rewrite sproductl_0_def with (s := M1 prec_list a p) (a := N0) (p := p) (c := N0) (r0 := pl_produit a1 p) (r1 := M0 prec_list); auto. rewrite H2. reflexivity. * apply Nat.eqb_neq in E. simpl. rewrite E. apply H2. + destruct (a =? N.pos p~1)%N eqn:E. * apply Nat.eqb_eq in E. subst. simpl. reflexivity. * apply Nat.eqb_neq in E. simpl. apply H2. + destruct (a =? N.pos p~0)%N eqn:E. * apply Nat.eqb_eq in E. subst. simpl. reflexivity. * apply Nat.eqb_neq in E. simpl. apply H2. + simpl. apply H2.", "succ": false}]