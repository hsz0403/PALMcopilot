[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold Sup_fct."], "tactic": "unfold Req_EM_T.", "exn": "Cannot coerce Req_EM_T to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T."], "tactic": "destruct (R_eq_dec a b) eqn:E.", "exn": "The reference R_eq_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-"], "tactic": "rewrite E.", "exn": "The LHS of E (Req_dec a b) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T."], "tactic": "reflexivity.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique."], "tactic": "intros x.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+"], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]]."], "tactic": "exists x0.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T."], "tactic": "apply Rmin_r.", "exn": "In environment H3, H0, H, s : forall r1 r2 : R, {r1 = r2} + {r1 = r2 -> False} f : R -> R a, b : R f0 : a = b -> False Heqs0 : s a b = right f0 f1 : b = a -> False Heqs1 : s b a = right f1 x0 : R H1 : Rmin a b < x0 H2 : x0 < Rmax a b r : R Heqr : Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin b a < x < Rmax b a) = r Unable to unify \"Rmin ?M4761 ?M4762 < ?M4762 \\\\/ Rmin ?M4761 ?M4762 = ?M4762\" with \"f x0 < r \\\\/ f x0 = r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r."], "tactic": "apply Rmax_l.", "exn": "In environment H5 : forall x y : R, Rmin x y <= y H4, H3, H0, H, s : forall r1 r2 : R, {r1 = r2} + {r1 = r2 -> False} f : R -> R a, b : R f0 : a = b -> False Heqs0 : s a b = right f0 f1 : b = a -> False Heqs1 : s b a = right f1 x0 : R H1 : Rmin a b < x0 H2 : x0 < Rmax a b r : R Heqr : Lub_Rbar (fun y : R => exists x : R, y = f x /\\\\ Rmin b a < x < Rmax b a) = r Unable to unify \"?M5347 < Rmax ?M5347 ?M5348 \\\\/ ?M5347 = Rmax ?M5347 ?M5348\" with \"f x0 < r \\\\/ f x0 = r\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*"], "tactic": "intros y [x0 [Hfx0 [Hmin Hmax]]].", "exn": "x0 is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*"], "tactic": "intros y [x0' [Hfx0 [Hmin Hmax]]].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*"], "tactic": "apply Rmin_r in Hmin.", "exn": "No such hypothesis: Hmin", "type": "no_hypos", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "apply Rmax_l in Hmax.", "exn": "No such hypothesis: Hmax", "type": "no_hypos", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "exists y.", "exn": "The reference y was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "exists x0.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "split; auto.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "+", "exn": "Wrong bullet +: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "shelve.", "*"], "tactic": "intros y [Hlub1 Hlub2].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "shelve.", "*"], "tactic": "apply Rmin_r in Hlub1.", "exn": "No such hypothesis: Hlub1", "type": "no_hypos", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "shelve.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l."], "tactic": "apply Rmax_l in Hlub2.", "exn": "No such hypothesis: Hlub2", "type": "no_hypos", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "shelve.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "destruct (Rlt_dec a b)."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["unfold Sup_fct.", "qsimpl use: Req_EM_T.", "destruct (Req_dec a b) eqn:E.", "-", "qsimpl use: Req_EM_T.", "-", "apply is_lub_Rbar_unique.", "split.", "+", "qsimpl use: Req_EM_T.", "intros y Hy.", "destruct Hy as [x0 [Hfx0 Hrange]].", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T.", "qsimpl use: Req_EM_T,Rmin_r.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "shelve.", "*", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "qsimpl use: Req_EM_T,Rmin_r,Rmax_l.", "destruct (Rlt_dec a b).", "--", "shelve.", "--", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "unfold Sup_fct. unfold Inf_fct. unfold Req_EM_T. destruct (R_eq_dec a b) eqn:E. - rewrite E. reflexivity. - apply is_lub_Rbar_unique. intros x. split. + unfold is_lub. split. * intros y Hy. destruct Hy as [x0 [Hfx0 Hrange]]. exists x0. split. { apply Rmin_r. } { apply Rmax_l. } * intros y [x0 [Hfx0 [Hmin Hmax]]]. apply Rmin_r in Hmin. apply Rmax_l in Hmax. exists y. split. { exists x0. split; auto. } { auto. } + intros y [Hlub1 Hlub2]. apply Rmin_r in Hlub1. apply Rmax_l in Hlub2. destruct (Rlt_dec a b). * contradict n0. apply Rmin_l in Hlub1. apply Rmax_r in Hlub2. lra. * lra.", "succ": false}]