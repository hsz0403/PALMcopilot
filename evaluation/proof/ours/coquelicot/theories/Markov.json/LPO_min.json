[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros P H."], "tactic": "pose (classical_pick (fun n => P n \\/ ~ P n)) as H'.", "exn": "The reference classical_pick was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-"], "tactic": "left.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl."], "tactic": "exists n.", "exn": "The reference n was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl."], "tactic": "split.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl."], "tactic": "apply H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+"], "tactic": "intros i H2.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+"], "tactic": "apply H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect."], "tactic": "intro.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect."], "tactic": "apply H2 in H3.", "exn": "No such hypothesis: H3", "type": "no_hypos", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect.", "qsimpl."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect.", "qsimpl.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect.", "qsimpl.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect.", "qsimpl.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "qsimpl use: contradiction.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros P H.", "pose (Ring_polynom.mk_monpol_list (fun n => P n \\/ ~ P n)) as H'.", "destruct H' as [[n H1] | H1].", "-", "qsimpl.", "apply Z.le.", "+", "apply RMicromega.Rcst_rect.", "qsimpl.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: Nat.le_0_l."], "tactic": "intro n.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}]}, "chat": [], "original": "intros P H. pose (classical_pick (fun n => P n \\/ ~ P n)) as H'. destruct H' as [[n H1] | H1]. - left. exists n. split. + apply H1. + intros i H2. apply H1. intro. apply H2 in H3. contradiction. - right. intro n. apply not_or_and_not in H1. apply H1.", "succ": false}]