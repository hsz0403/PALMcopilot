[{"history": {"proof": "intros H_int. destruct H_int as [If H_if]. qsimpl use: is_RInt_comp_lin.", "repairs": ["", "", "cannot_unify"], "exceptions": [{"ctx": ["intros H_int.", "destruct H_int as [If H_if]."], "tactic": "apply is_RInt_comp_lin with (u := u) (v := v).", "exn": "In environment V : NormedModule R_AbsRing f : R -> V u, v, a, b : R If : V H_if : is_RInt f (u * a + v) (u * b + v) If Unable to unify \"forall P : V -> Prop, locally ?M2375 P -> filtermap (fun ptd : SF_seq => scal (sign (?M2374 - ?M2373)) (Riemann_sum (fun y : R => scal u (?M2370 (u * y + v))) ptd)) (Riemann_fine ?M2373 ?M2374) P\" with \"exists If : V, is_RInt (fun y : R => scal u (f (u * y + v))) a b If\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros H_int.", "destruct H_int as [If H_if].", "qsimpl use: is_RInt_comp_lin."], "tactic": "auto.", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros H_int. destruct H_int as [If H_if]. apply is_RInt_comp_lin with (u := u) (v := v). auto.", "succ": true}]