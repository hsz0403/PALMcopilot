[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal."], "tactic": "apply filterlim_comp with (f := (fun ptd : SF_seq => scal (sign (b - a) * k) (Riemann_sum f ptd))).", "exn": "In environment V : NormedModule R_AbsRing f : R -> V a, b, k : R If : V H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) P : ?M2367 -> Prop y : ?M2372 P Unable to unify \"?M2370 (fun x : SF_seq => P ((fun x0 : SF_seq => ?M2369 (scal (sign (b - a) * k) (Riemann_sum f x0))) x))\" with \"exists delta : posreal, forall y : SF_seq, (fun ptd : SF_seq => seq_step (SF_lx ptd)) y < delta -> (fun x : SF_seq => (fun ptd : SF_seq => pointed_subdiv ptd /\\\\ SF_h ptd = Rmin a b /\\\\ last (SF_h ptd) (SF_lx ptd) = Rmax a b) x -> (fun x0 : SF_seq => P ((fun ptd : SF_seq => ModuleSpace.scal R_Ring (AbelianGroup.Pack V (ModuleSpace.class R_Ring V) V) (ModuleSpace.class R_Ring V) (sign (b - a)) (Riemann_sum (fun y0 : R => ModuleSpace.scal R_Ring (AbelianGroup.Pack V (ModuleSpace.class R_Ring V) V) (ModuleSpace.class R_Ring V) k (f y0)) ptd)) x0)) x) y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-"], "tactic": "apply filterlim_comp with (f := (fun ptd : SF_seq => scal k (scal (sign (b - a)) (Riemann_sum f ptd)))).", "exn": "In environment sort : Type c : NormedModule.class_of R_AbsRing sort T : Type f : R -> sort a, b, k : R If : sort H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) X1 : (R -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T}) -> SF_seq -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T} X0 : ?K@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} r : R -> R H0 : forall (T U V : Type) (f : T -> U) (g : U -> V) (F : (T -> Prop) -> Prop) (G : (U -> Prop) -> Prop) (H : (V -> Prop) -> Prop), filterlim f F G -> filterlim g G H -> filterlim (fun x : T => g (f x)) F H X : Type sort0 : Type X3 : Type base : NormedModuleAux.class_of R_AbsRing sort0 norm : sort0 -> R norm_factor : R ax1 : forall x y : sort0, norm (plus x y) <= norm x + norm y ax2 : forall (l : R) (x : sort0), norm (scal l x) <= abs l * norm x ax3 : forall (x y : sort0) (eps : R), norm (minus y x) < eps -> ball x eps y ax4 : forall (x y : sort0) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ax5 : forall x : sort0, norm x = 0 -> x = zero ptd : SF_seq The term \"f\" has type \"R -> sort\" while it is expected to have type \"R -> ?V3\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+"], "tactic": "apply filterlim_locally_ball_norm.", "exn": "In environment sort : Type c : NormedModule.class_of R_AbsRing sort T : Type f : R -> sort a, b, k : R If : sort H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) X1 : (R -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T}) -> SF_seq -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T} X0 : ?K@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} r : R -> R H0 : forall (T U V : Type) (f : T -> U) (g : U -> V) (F : (T -> Prop) -> Prop) (G : (U -> Prop) -> Prop) (H : (V -> Prop) -> Prop), filterlim f F G -> filterlim g G H -> filterlim (fun x : T => g (f x)) F H X : Type sort0 : Type X3 : Type base : NormedModuleAux.class_of R_AbsRing sort0 norm : sort0 -> R norm_factor : R ax1 : forall x y : sort0, norm (plus x y) <= norm x + norm y ax2 : forall (l : R) (x : sort0), norm (scal l x) <= abs l * norm x ax3 : forall (x y : sort0) (eps : R), norm (minus y x) < eps -> ball x eps y ax4 : forall (x y : sort0) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ax5 : forall x : sort0, norm x = 0 -> x = zero X5 : (R -> ?V2) -> SF_seq -> ?V2 X4 : ?K0 -> ?V1 -> ?V1 X2 : Type H3 : R Unable to unify \"(filterlim ?M8661 ?F (locally ?M8662) -> forall eps : posreal, ?F (fun x : ?T0 => ball_norm ?M8662 eps (?M8661 x))) /\\\\ ((forall eps : posreal, ?F (fun x : ?T0 => ball_norm ?M8662 eps (?M8661 x))) -> filterlim ?M8661 ?F (locally ?M8662))\" with \"forall P : sort -> Prop, locally (ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c k If) P -> filtermap (fun ptd : SF_seq => ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c (r (b - a)) (Riemann_sum (fun y : R => ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c k (f y)) ptd)) (Riemann_fine a b) P\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps."], "tactic": "exists eps.", "exn": "In environment sort : Type c : NormedModule.class_of R_AbsRing sort T : Type f : R -> sort a, b, k : R If : sort H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) X1 : (R -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T}) -> SF_seq -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T} X0 : ?K@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} r : R -> R H0 : forall (T U V : Type) (f : T -> U) (g : U -> V) (F : (T -> Prop) -> Prop) (G : (U -> Prop) -> Prop) (H : (V -> Prop) -> Prop), filterlim f F G -> filterlim g G H -> filterlim (fun x : T => g (f x)) F H X : Type sort0 : Type X3 : Type base : NormedModuleAux.class_of R_AbsRing sort0 norm : sort0 -> R norm_factor : R ax1 : forall x y : sort0, norm (plus x y) <= norm x + norm y ax2 : forall (l : R) (x : sort0), norm (scal l x) <= abs l * norm x ax3 : forall (x y : sort0) (eps : R), norm (minus y x) < eps -> ball x eps y ax4 : forall (x y : sort0) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ax5 : forall x : sort0, norm x = 0 -> x = zero X5 : (R -> ?V2) -> SF_seq -> ?V2 X4 : ?K0 -> ?V1 -> ?V1 X2 : Type H3 : R H4 : forall (f0 : X2 -> ?U) (y : ?U), (filterlim f0 ?F (locally y) -> forall eps : posreal, ?F (fun x : X2 => ball_norm y eps (f0 x))) /\\\\ ((forall eps : posreal, ?F (fun x : X2 => ball_norm y eps (f0 x))) -> filterlim f0 ?F (locally y)) X8 : (R -> ?V4) -> SF_seq -> ?V4 X7 : ?K1 -> ?V3 -> ?V3 X6 : Type eps : sort -> Prop H1 : locally (ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c k If) eps The term \"eps\" has type \"sort -> Prop\" while it is expected to have type \"posreal\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm."], "tactic": "intros ptd H1.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm."], "tactic": "rewrite scal_assoc.", "exn": "The LHS of scal_assoc (scal _ (scal _ _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,scal_assoc,Riemann_sum,filterlim_locally_ball_norm."], "tactic": "apply Rlt_div_r.", "exn": "In environment sort : Type c : NormedModule.class_of R_AbsRing sort T : Type f : R -> sort a, b, k : R If : sort H : filter_le (filtermap (fun ptd : SF_seq => scal (sign (b - a)) (Riemann_sum f ptd)) (Riemann_fine a b)) (locally If) X1 : (R -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T}) -> SF_seq -> ?V0@{V:=NormedModule.Pack R_AbsRing sort c T} X0 : ?K@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} -> ?V@{V:=NormedModule.Pack R_AbsRing sort c T} r : R -> R H0 : forall (T U V : Type) (f : T -> U) (g : U -> V) (F : (T -> Prop) -> Prop) (G : (U -> Prop) -> Prop) (H : (V -> Prop) -> Prop), filterlim f F G -> filterlim g G H -> filterlim (fun x : T => g (f x)) F H X : Type sort0 : Type X3 : Type base : NormedModuleAux.class_of R_AbsRing sort0 norm : sort0 -> R norm_factor : R ax1 : forall x y : sort0, norm (plus x y) <= norm x + norm y ax2 : forall (l : R) (x : sort0), norm (scal l x) <= abs l * norm x ax3 : forall (x y : sort0) (eps : R), norm (minus y x) < eps -> ball x eps y ax4 : forall (x y : sort0) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ax5 : forall x : sort0, norm x = 0 -> x = zero X5 : (R -> ?V2) -> SF_seq -> ?V2 X4 : ?K0 -> ?V1 -> ?V1 X2 : Type H3 : R H4 : forall (f0 : X2 -> ?U) (y : ?U), (filterlim f0 ?F (locally y) -> forall eps : posreal, ?F (fun x : X2 => ball_norm y eps (f0 x))) /\\\\ ((forall eps : posreal, ?F (fun x : X2 => ball_norm y eps (f0 x))) -> filterlim f0 ?F (locally y)) X8 : (R -> ?V4) -> SF_seq -> ?V4 X7 : ?K1 -> ?V3 -> ?V3 X6 : Type eps : sort -> Prop H5 : forall (f0 : X6 -> ?U0) (y : ?U0), (filterlim f0 ?F0 (locally y) -> forall eps0 : posreal, ?F0 (fun x : X6 => ball_norm y eps0 (f0 x))) /\\\\ ((forall eps0 : posreal, ?F0 (fun x : X6 => ball_norm y eps0 (f0 x))) -> filterlim f0 ?F0 (locally y)) X11 : (R -> ?V6) -> SF_seq -> ?V6 X10 : ?K3 -> ?V5 -> ?V5 X9 : Type H6 : locally (ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c k If) eps H8 : forall (f0 : X9 -> ?U1) (y : ?U1), (filterlim f0 ?F1 (locally y) -> forall eps0 : posreal, ?F1 (fun x : X9 => ball_norm y eps0 (f0 x))) /\\\\ ((forall eps0 : posreal, ?F1 (fun x : X9 => ball_norm y eps0 (f0 x))) -> filterlim f0 ?F1 (locally y)) X14 : (R -> ?V9) -> SF_seq -> ?V9 H7 : forall (x y : ?K6) (u : ?V8), scal x (scal y u) = scal (mult x y) u X13 : ?K5 -> ?V7 -> ?V7 X12 : Type Unable to unify \"(?M1554672 * ?M1554674 < ?M1554673 -> ?M1554672 < ?M1554673 / ?M1554674) /\\\\ (?M1554672 < ?M1554673 / ?M1554674 -> ?M1554672 * ?M1554674 < ?M1554673)\" with \"exists delta : posreal, forall y : SF_seq, (fun ptd : SF_seq => seq_step (SF_lx ptd)) y < delta -> (fun x : SF_seq => (fun ptd : SF_seq => pointed_subdiv ptd /\\\\ SF_h ptd = Rmin a b /\\\\ last (SF_h ptd) (SF_lx ptd) = Rmax a b) x -> (fun x0 : SF_seq => eps ((fun ptd : SF_seq => ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c (r (b - a)) (Riemann_sum (fun y0 : R => ModuleSpace.scal R_Ring (AbelianGroup.Pack sort c sort) c k (f y0)) ptd)) x0)) x) y\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,scal_assoc,Riemann_sum,filterlim_locally_ball_norm."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,scal_assoc,Riemann_sum,filterlim_locally_ball_norm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros f a b k If H.", "unfold is_RInt in *.", "unfold filterlim in *.", "unfold scal.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "-", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum.", "+", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "intros eps.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,Riemann_sum,filterlim_locally_ball_norm.", "qsimpl use: SF_seq,filterlim_comp,sign,scal,scal_assoc,Riemann_sum,filterlim_locally_ball_norm.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros f a b k If H. unfold is_RInt in *. unfold filterlim in *. unfold scal. apply filterlim_comp with (f := (fun ptd : SF_seq => scal (sign (b - a) * k) (Riemann_sum f ptd))). - apply filterlim_comp with (f := (fun ptd : SF_seq => scal k (scal (sign (b - a)) (Riemann_sum f ptd)))). + apply filterlim_locally_ball_norm. intros eps. exists eps. intros ptd H1. rewrite scal_assoc. apply Rlt_div_r. * unfold sign. destruct (b - a). -- apply Rlt_Rminus. apply H1. -- unfold Rgt. apply H1. -- unfold Rlt. apply H1. * destruct (b - a). -- simpl. lia. -- simpl. apply H1. * unfold sign. destruct (b - a). -- apply Rlt_Rminus. apply H1. -- simpl. apply H1. -- simpl. apply H1. + apply filterlim_scal_r. - apply H.", "succ": false}]