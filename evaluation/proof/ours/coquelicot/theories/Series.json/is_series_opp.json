[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros K V a la H.", "exn": "K is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V a la H.", "exn": "V is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V' a la H.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V' a' la H.", "exn": "la is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros K' V' a' la' H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp."], "tactic": "apply filterlim_ext_loc.", "exn": "Unable to find an instance for the variable f.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps."], "tactic": "split; intros H'.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+"], "tactic": "destruct H' as [N HN].", "exn": "The reference H' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+"], "tactic": "exists N.", "exn": "In environment K : AbsRing V : NormedModule K a : nat -> V la : V H : filterlim (sum_n a) eventually (locally la) H0 : forall f g : ?T -> ?U, ?F (fun x : ?T => f x = g x) -> filterlim f ?F ?G -> filterlim g ?F ?G eps : V -> Prop H1 : forall f g : ?T0 -> ?U0, ?F0 (fun x : ?T0 => f x = g x) -> filterlim f ?F0 ?G0 -> filterlim g ?F0 ?G0 H2 : locally (AbelianGroup.opp V (NormedModule.class K V) la) eps The term \"N\" has type \"Set\" while it is expected to have type \"nat\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc."], "tactic": "intros n Hn.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc."], "tactic": "specialize (HN n Hn).", "exn": "The reference HN was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc."], "tactic": "rewrite norm_opp.", "exn": "The LHS of norm_opp (norm (opp _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "apply HN.", "exn": "The reference HN was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "destruct H' as [N HN].", "exn": "The reference H' was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "exists N.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "intros n Hn.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "specialize (HN n Hn).", "exn": "The reference HN was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "rewrite <- norm_opp.", "exn": "Found no subterm matching \"norm ?M7023\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "apply HN.", "exn": "The reference HN was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold is_series in *.", "unfold opp.", "qsimpl use: filterlim_ext_loc.", "-", "intros eps.", "qsimpl use: filterlim_ext_loc.", "+", "qsimpl use: N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "qsimpl use: norm_opp,N,filterlim_ext_loc.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}]}, "chat": [], "original": "intros K V a la H. unfold is_series in *. unfold opp. apply filterlim_ext_loc. - intros eps. split; intros H'. + destruct H' as [N HN]. exists N. intros n Hn. specialize (HN n Hn). rewrite norm_opp. apply HN. + destruct H' as [N HN]. exists N. intros n Hn. specialize (HN n Hn). rewrite <- norm_opp. apply HN. - apply H.", "succ": false}]