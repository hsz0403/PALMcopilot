[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros a b H1 H2.", "exn": "a is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros a' b H1 H2.", "exn": "b is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros a' b' H1 H2.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold Series."], "tactic": "apply is_series_unique.", "exn": "In environment a, b : nat -> R H : forall n : nat, 0 <= a n <= b n H0 : ex_series b Unable to unify \"Series ?M2363 = ?M2364\" with \"Lim_seq (sum_n a) < Lim_seq (sum_n b) \\\\/ Lim_seq (sum_n a) = Lim_seq (sum_n b)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Series.", "qsimpl use: is_series_unique."], "tactic": "apply ex_series_Cauchy.", "exn": "In environment H1 : forall (a : nat -> R) (l : R), is_series a l -> Series a = l a, b : nat -> R H : forall n : nat, a n <= b n H2 : forall n : nat, 0 <= a n x : R H3 : is_series b x Unable to unify \"exists l : ?V, is_series ?M2799 l\" with \"Lim_seq (sum_n a) < Lim_seq (sum_n b) \\\\/ Lim_seq (sum_n a) = Lim_seq (sum_n b)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Series.", "qsimpl use: is_series_unique.", "qsimpl use: is_series_unique,ex_series_Cauchy."], "tactic": "intros eps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros a b H1 H2. unfold Series. apply is_series_unique. apply ex_series_Cauchy. intros eps. specialize (H2 _) as [N H2']. exists N. intros n m H3 H4. unfold norm. rewrite Rabs_right. apply Rle_lt_trans with (r2:= Series (fun k : nat => Rabs (a k - b k))). - apply Series_Rabs. apply ex_series_ext with (b0:= fun k => Rabs (a k - b k)). intros k. unfold Rabs. apply Rabs_minus_sym. apply ex_series_le with (b0:=fun k => Rabs (a k - b k)). + intros k. specialize (H1 k). apply Rabs_minus_sym. apply H1. + apply ex_series_Rabs. apply H2. - apply H2'. auto. ++ apply le_trans with (m:=n); auto. ++ apply le_trans with (m:=m); auto.", "succ": false}]