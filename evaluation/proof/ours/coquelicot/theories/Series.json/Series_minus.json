[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-"], "tactic": "apply ex_series_minus; auto.", "exn": "In environment a, b : nat -> R b_series : ex_series a a_series : ex_series b Unable to unify \"exists l : ?V, is_series (fun n : nat => plus (?M2363 n) (opp (?M2364 n))) l\" with \"exists l : R_NormedModule, is_series (fun n : nat => a n - b n) l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "apply is_series_unique in a_series.", "exn": "Unable to apply lemma of type \"forall (a : nat -> R) (l : R), is_series a l -> Series a = l\" on hypothesis of type \"ex_series b\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique."], "tactic": "apply is_series_unique in b_series.", "exn": "No such hypothesis: b_series", "type": "no_hypos", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique."], "tactic": "apply is_series_ext with (a0 := fun n => a n - b n) in a_series.", "exn": "No such hypothesis: a_series", "type": "no_hypos", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique."], "tactic": "rewrite a_series.", "exn": "The reference a_series was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry."], "tactic": "apply Series_opp.", "exn": "In environment H7 : forall (a : nat -> R) (l : R), is_series a l -> Series a = l a, b : nat -> R H : forall a0 b0 : nat -> ?V0, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) x : R H1 : is_series (fun n : nat => a n - b n) x x0 : R H2 : is_series b x0 x1 : R H3 : is_series a x1 H4 : forall a0 b0 : nat -> ?V1, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H6 : forall a0 b0 : nat -> ?V2, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H0 : forall (a0 b0 : nat -> ?V3) (l : ?V3), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l Unable to unify \"Series (fun n : nat => - ?M5295 n) = - Series ?M5295\" with \"Series a - Series b = Series (fun n : nat => a n - b n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique."], "tactic": "apply Series_ext.", "exn": "In environment H10 : forall (a : nat -> R) (l : R), is_series a l -> Series a = l a, b : nat -> R H : forall a0 b0 : nat -> ?V0, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) x : R H1 : is_series (fun n : nat => a n - b n) x x0 : R H2 : is_series b x0 x1 : R H3 : is_series a x1 H4 : forall a0 b0 : nat -> ?V1, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H6 : forall a0 b0 : nat -> ?V2, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H0 : forall (a0 b0 : nat -> ?V3) (l : ?V3), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H9 : forall a0 b0 : nat -> ?V4, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H8 : forall (a0 b0 : nat -> ?V5) (l : ?V5), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H5 : forall a : nat -> R, Series (fun n : nat => - a n) = - Series a Unable to unify \"Series ?M6877 = Series ?M6878\" with \"Series a - Series b = Series (fun n : nat => a n - b n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique.", "qsimpl use: Series_opp,ex_series_minus,is_series_ext,Series_ext,is_series_unique."], "tactic": "intros n.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique.", "qsimpl use: Series_opp,ex_series_minus,is_series_ext,Series_ext,is_series_unique.", "unfold Rminus.", "rewrite Rplus_comm."], "tactic": "reflexivity.", "exn": "In environment H14 : forall (a : nat -> R) (l : R), is_series a l -> Series a = l H13 : forall a b : nat -> R, (forall n : nat, a n = b n) -> Series a = Series b a, b : nat -> R H : forall a0 b0 : nat -> ?V0, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) x : R H1 : is_series (fun n : nat => a n - b n) x x0 : R H2 : is_series b x0 x1 : R H3 : is_series a x1 H4 : forall a0 b0 : nat -> ?V1, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H6 : forall a0 b0 : nat -> ?V2, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H0 : forall (a0 b0 : nat -> ?V3) (l : ?V3), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H9 : forall a0 b0 : nat -> ?V4, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H8 : forall (a0 b0 : nat -> ?V5) (l : ?V5), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H5 : forall a : nat -> R, Series (fun n : nat => - a n) = - Series a H12 : forall (a0 b0 : nat -> ?V6) (l : ?V6), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H11 : forall a0 b0 : nat -> ?V7, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) Unable to unify \"Series (fun n : nat => a n + - b n)\" with \"- Series b + Series a\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique.", "qsimpl use: Series_opp,ex_series_minus,is_series_ext,Series_ext,is_series_unique.", "unfold Rminus.", "rewrite Rplus_comm."], "tactic": "apply ex_series_Rabs in diff_series.", "exn": "No such hypothesis: diff_series", "type": "no_hypos", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique.", "qsimpl use: Series_opp,ex_series_minus,is_series_ext,Series_ext,is_series_unique.", "unfold Rminus.", "rewrite Rplus_comm.", "qsimpl use: Series_opp,ex_series_minus,ex_series_Rabs,is_series_ext,Series_ext,is_series_unique.", "apply Rle_antisym.", "+"], "tactic": "apply Series_Rabs.", "exn": "In environment H18 : forall (a : nat -> R) (l : R), is_series a l -> Series a = l H17 : forall a b : nat -> R, (forall n : nat, a n = b n) -> Series a = Series b a, b : nat -> R H : forall a0 b0 : nat -> ?V0, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) x : R H1 : is_series (fun n : nat => a n - b n) x x0 : R H2 : is_series b x0 x1 : R H3 : is_series a x1 H4 : forall a0 b0 : nat -> ?V1, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H6 : forall a0 b0 : nat -> ?V2, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H0 : forall (a0 b0 : nat -> ?V3) (l : ?V3), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H9 : forall a0 b0 : nat -> ?V4, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H8 : forall (a0 b0 : nat -> ?V5) (l : ?V5), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H5 : forall a : nat -> R, Series (fun n : nat => - a n) = - Series a H12 : forall (a0 b0 : nat -> ?V6) (l : ?V6), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H11 : forall a0 b0 : nat -> ?V7, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H16 : forall (a0 b0 : nat -> ?V8) (l : ?V8), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H15 : forall a : nat -> R, ex_series (fun n : nat => Rabs (a n)) -> ex_series a H10 : forall a0 b0 : nat -> ?V9, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) Unable to unify \"Rabs (Series ?M11584) < Series (fun n : nat => Rabs (?M11584 n)) \\\\/ Rabs (Series ?M11584) = Series (fun n : nat => Rabs (?M11584 n))\" with \"- Series b + Series a < Series (fun n : nat => a n + - b n) \\\\/ - Series b + Series a = Series (fun n : nat => a n + - b n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique.", "qsimpl use: Series_opp,ex_series_minus,is_series_ext,Series_ext,is_series_unique.", "unfold Rminus.", "rewrite Rplus_comm.", "qsimpl use: Series_opp,ex_series_minus,ex_series_Rabs,is_series_ext,Series_ext,is_series_unique.", "apply Rle_antisym.", "+", "qsimpl use: Series_opp,Series_Rabs,ex_series_minus,ex_series_Rabs,is_series_ext,Series_ext,is_series_unique."], "tactic": "apply ex_series_minus; auto.", "exn": "In environment H22 : forall (a : nat -> R) (l : R), is_series a l -> Series a = l H21 : forall a b : nat -> R, (forall n : nat, a n = b n) -> Series a = Series b a, b : nat -> R H : forall a0 b0 : nat -> ?V0, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) x : R H1 : is_series (fun n : nat => a n - b n) x x0 : R H2 : is_series b x0 x1 : R H3 : is_series a x1 H4 : forall a0 b0 : nat -> ?V1, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H6 : forall a0 b0 : nat -> ?V2, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H0 : forall (a0 b0 : nat -> ?V3) (l : ?V3), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H9 : forall a0 b0 : nat -> ?V4, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H8 : forall (a0 b0 : nat -> ?V5) (l : ?V5), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H5 : forall a : nat -> R, Series (fun n : nat => - a n) = - Series a H12 : forall (a0 b0 : nat -> ?V6) (l : ?V6), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H11 : forall a0 b0 : nat -> ?V7, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H16 : forall (a0 b0 : nat -> ?V8) (l : ?V8), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H15 : forall a : nat -> R, ex_series (fun n : nat => Rabs (a n)) -> ex_series a H10 : forall a0 b0 : nat -> ?V9, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H20 : forall (a0 b0 : nat -> ?V10) (l : ?V10), (forall n : nat, a0 n = b0 n) -> is_series a0 l -> is_series b0 l H14 : forall a0 b0 : nat -> ?V11, ex_series a0 -> ex_series b0 -> ex_series (fun n : nat => plus (a0 n) (opp (b0 n))) H13 : forall a : nat -> R, ex_series (fun n : nat => Rabs (a n)) -> Rabs (Series a) <= Series (fun n : nat => Rabs (a n)) Unable to unify \"exists l : ?V12, is_series (fun n : nat => plus (?M14702 n) (opp (?M14703 n))) l\" with \"- Series b + Series a < Series (fun n : nat => a n + - b n) \\\\/ - Series b + Series a = Series (fun n : nat => a n + - b n)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros b_series a_series.", "assert (ex_series (fun n => a n - b n)) as diff_series.", "-", "qsimpl use: ex_series_minus.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: ex_series_minus,is_series_unique.", "qsimpl use: is_series_ext,ex_series_minus,is_series_unique.", "symmetry.", "qsimpl use: Series_opp,is_series_ext,ex_series_minus,is_series_unique.", "qsimpl use: Series_opp,ex_series_minus,is_series_ext,Series_ext,is_series_unique.", "unfold Rminus.", "rewrite Rplus_comm.", "qsimpl use: Series_opp,ex_series_minus,ex_series_Rabs,is_series_ext,Series_ext,is_series_unique.", "apply Rle_antisym.", "+", "qsimpl use: Series_opp,Series_Rabs,ex_series_minus,ex_series_Rabs,is_series_ext,Series_ext,is_series_unique.", "qsimpl use: Series_opp,Series_Rabs,ex_series_minus,ex_series_Rabs,is_series_ext,Series_ext,is_series_unique."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}]}, "chat": [], "original": "intros b_series a_series. assert (ex_series (fun n => a n - b n)) as diff_series. - apply ex_series_minus; auto. - apply is_series_unique in a_series. apply is_series_unique in b_series. apply is_series_ext with (a0 := fun n => a n - b n) in a_series. rewrite a_series. symmetry. apply Series_opp. apply Series_ext. intros n. unfold Rminus. rewrite Rplus_comm. reflexivity. apply ex_series_Rabs in diff_series. apply Rle_antisym. + apply Series_Rabs. apply ex_series_minus; auto. + apply Ropp_le_cancel. rewrite Series_Rabs. apply ex_series_Rabs. apply ex_series_plus; auto.", "succ": false}]