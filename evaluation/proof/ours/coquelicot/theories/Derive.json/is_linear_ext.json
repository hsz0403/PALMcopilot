[{"history": {"proof": "intros l_eq l1_linear. qsimpl use: is_linear. split. - intros x' y. qsimpl use: is_linear,linear_plus. - intros k x'. qsimpl use: is_linear,linear_scal,linear_plus. - destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]]. destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]. split. + qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus. + intros x'. specialize (norm x). specialize (norm x). qsimpl use: Rmax_case_strong,is_linear,Rmult_le_compat_r,Rmax_l,linear_scal,linear_plus. + hauto lq: on depth: 3. + hauto l: on depth: 3. + hauto lq: on depth: 3.", "repairs": ["", "not_evaluable", "", "", "used_var", "wrong_type", "", "used_var", "wrong_type", "", "", "", "", "", "cannot_unify", "", "used_var", "ref_not_found", "ref_not_found", "cannot_unify", "", "hammer", "", "hammer", "", "hammer"], "exceptions": [{"ctx": ["intros l_eq l1_linear."], "tactic": "unfold is_linear.", "exn": "Cannot coerce is_linear to an evaluable reference.", "type": "not_evaluable", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-"], "tactic": "intros x y.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y."], "tactic": "rewrite <- (linear_plus l1 x y).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x linear_plus0 : forall x y : U, l1 (plus x y) = plus (l1 x) (l1 y) linear_scal0 : forall (k : K) (x : U), l1 (scal k x) = scal k (l1 x) x : R H0 : 0 < x H1 : forall x0 : U, norm (l1 x0) <= x * norm x0 x', y : U The term \"x\" has type \"R\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus."], "tactic": "rewrite -> (linear_plus l2 x y).", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-"], "tactic": "intros k x.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'."], "tactic": "rewrite <- (linear_scal l1 k x).", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x linear_plus0 : forall x y : U, l1 (plus x y) = plus (l1 x) (l1 y) linear_scal0 : forall (k : K) (x : U), l1 (scal k x) = scal k (l1 x) x : R H0 : 0 < x H1 : forall x0 : U, norm (l1 x0) <= x * norm x0 k : K x' : U The term \"k\" has type \"AbsRing.sort K\" while it is expected to have type \"is_linear l1\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus."], "tactic": "rewrite -> (linear_scal l2 k x).", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]."], "tactic": "exists (Rmax M1 M2).", "exn": "The reference M2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+"], "tactic": "apply Rmax_case_strong; auto.", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x linear_plus0 : forall x y : U, l1 (plus x y) = plus (l1 x) (l1 y) linear_scal0 : forall (k : K) (x : U), l1 (scal k x) = scal k (l1 x) x : R H0 : 0 < x H1 : forall x0 : U, norm (l1 x0) <= x * norm x0 Unable to unify \"?M3941 <= ?M3940 -> ?M3942 ?M3940\" with \"let (sort, _, _) := U in sort\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus.", "+"], "tactic": "intros x.", "exn": "x is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus.", "+", "intros x'."], "tactic": "specialize (norm_bound1 x).", "exn": "The reference norm_bound1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus.", "+", "intros x'.", "specialize (norm x)."], "tactic": "specialize (norm_bound2 x).", "exn": "The reference norm_bound2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus.", "+", "intros x'.", "specialize (norm x).", "specialize (norm x)."], "tactic": "apply Rle_trans with (r2 := M1 * norm x).", "exn": "The reference M1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus.", "+", "intros x'.", "specialize (norm x).", "specialize (norm x)."], "tactic": "apply norm_bound1.", "exn": "The reference norm_bound1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros l_eq l1_linear.", "qsimpl use: is_linear.", "split.", "-", "intros x' y.", "qsimpl use: is_linear,linear_plus.", "-", "intros k x'.", "qsimpl use: is_linear,linear_scal,linear_plus.", "-", "destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]].", "destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]].", "split.", "+", "qsimpl use: Rmax_case_strong,is_linear,linear_scal,linear_plus.", "+", "intros x'.", "specialize (norm x).", "specialize (norm x)."], "tactic": "apply Rmult_le_compat_r; [apply Rmax_l | apply norm_bound2].", "exn": "In environment K : AbsRing U, V : NormedModule K l1, l2 : U -> V l_eq : forall x : U, l1 x = l2 x linear_plus0 : forall x y : U, l1 (plus x y) = plus (l1 x) (l1 y) linear_scal0 : forall (k : K) (x : U), l1 (scal k x) = scal k (l1 x) x : R H0 : 0 < x H1 : forall x0 : U, norm (l1 x0) <= x * norm x0 x' : K r2 : R Unable to unify \"0 < ?M4067 \\\\/ 0 = ?M4067\" with \"R\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros l_eq l1_linear. unfold is_linear. split. - intros x y. rewrite <- (linear_plus l1 x y). rewrite -> (linear_plus l2 x y). apply f_equal, l_eq. - intros k x. rewrite <- (linear_scal l1 k x). rewrite -> (linear_scal l2 k x). apply f_equal, l_eq. - destruct (linear_norm l1) as [M1 [M1_pos norm_bound1]]. destruct (linear_norm l2) as [M2 [M2_pos norm_bound2]]. exists (Rmax M1 M2). split. + apply Rmax_case_strong; auto. + intros x. specialize (norm_bound1 x). specialize (norm_bound2 x). apply Rle_trans with (r2 := M1 * norm x). * apply norm_bound1. * apply Rmult_le_compat_r; [apply Rmax_l | apply norm_bound2].", "succ": true}]