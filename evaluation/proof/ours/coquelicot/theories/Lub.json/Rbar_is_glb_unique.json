[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros E l H.", "exn": "E is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros E' l H.", "exn": "l is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros E' l' H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold Rbar_is_glb, Rbar_glb in H.", "destruct H as [H1 H2]."], "tactic": "apply Rbar_is_lub_unique.", "exn": "In environment E : Rbar -> Prop l : Rbar H1 : Rbar_is_lower_bound E l H2 : forall b : Rbar, Rbar_is_lower_bound E b -> Rbar_le b l Unable to unify \"Rbar_lub ?M2288 = ?M2289\" with \"Rbar_glb E = l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Rbar_is_glb, Rbar_glb in H.", "destruct H as [H1 H2].", "qsimpl time: 2 use: Rbar_is_lub_unique."], "tactic": "apply Rbar_glb_lub.", "exn": "In environment H : forall (E : Rbar -> Prop) (l : Rbar), Rbar_is_lub E l -> Rbar_lub E = l E : Rbar -> Prop l : Rbar H1 : Rbar_is_lower_bound E l H2 : forall b : Rbar, Rbar_is_lower_bound E b -> Rbar_le b l Unable to unify \"(Rbar_is_glb (fun x : Rbar => ?M2533 (Rbar_opp x)) (Rbar_opp ?M2534) -> Rbar_is_lub ?M2533 ?M2534) /\\\\ (Rbar_is_lub ?M2533 ?M2534 -> Rbar_is_glb (fun x : Rbar => ?M2533 (Rbar_opp x)) (Rbar_opp ?M2534))\" with \"Rbar_glb E = l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Rbar_is_glb, Rbar_glb in H.", "destruct H as [H1 H2].", "qsimpl time: 2 use: Rbar_is_lub_unique.", "qsimpl time: 2 use: Rbar_glb_lub,Rbar_is_lub_unique."], "tactic": "split.", "exn": "In environment H3 : forall (E : Rbar -> Prop) (l : Rbar), Rbar_is_lub E l -> Rbar_lub E = l E : Rbar -> Prop l : Rbar H1 : Rbar_is_lower_bound E l H2 : forall b : Rbar, Rbar_is_lower_bound E b -> Rbar_le b l H : forall (E : Rbar -> Prop) (l : Rbar), Rbar_is_lub E l -> Rbar_is_glb (fun x : Rbar => E (Rbar_opp x)) (Rbar_opp l) H0 : forall (E : Rbar -> Prop) (l : Rbar), Rbar_is_glb (fun x : Rbar => E (Rbar_opp x)) (Rbar_opp l) -> Rbar_is_lub E l Unable to unify \"l\" with \"Rbar_glb E\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold Rbar_is_glb, Rbar_glb in H.", "destruct H as [H1 H2].", "qsimpl time: 2 use: Rbar_is_lub_unique.", "qsimpl time: 2 use: Rbar_glb_lub,Rbar_is_lub_unique.", "qsimpl time: 2 use: Rbar_glb_lub,Rbar_is_lub_unique."], "tactic": "intros b Hb.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros E l H. unfold Rbar_is_glb, Rbar_glb in H. destruct H as [H1 H2]. apply Rbar_is_lub_unique. apply Rbar_glb_lub. split. + intros b Hb. apply (proj2 (is_glb_Rbar_correct (fun x : Rbar => is_finite x /\\ E x) l)). split. * intros x [Hfin Ex]. apply (Rbar_lb_eq_ub _ _ H1 Hb _ Ex). destruct x; simpl in Hfin; try contradiction. apply Hfin. * intros b' Hb'. apply (Rbar_lb_ub _ _ Hb' H1). + intros b Hb. apply (proj1 (is_glb_Rbar_correct (fun x : Rbar => is_finite x /\\ E x) l)). split. * intros x [Hfin Ex]. apply (Rbar_lb_eq_ub _ _ H1 Hb _ Ex). destruct x; simpl in Hfin; try contradiction. apply Hfin. * intros b' Hb'. apply (Rbar_lb_ub _ _ Hb' H1).", "succ": false}]