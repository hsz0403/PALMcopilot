[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]]."], "tactic": "exists (fun x => - phi x).", "exn": "In environment f : R -> R a, b : R pr : forall eps : posreal, {phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}} eps : posreal phi, psi : StepFun a b H1 : forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t H2 : Rabs (RiemannInt_SF psi) < eps The term \"fun x : R => - phi x\" has type \"R -> R\" while it is expected to have type \"StepFun a b\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi."], "tactic": "intros t Ht.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi.", "unfold Rabs."], "tactic": "rewrite Ropp_minus_distr.", "exn": "The LHS of Ropp_minus_distr (- (_ - _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi.", "unfold Rabs.", "qsimpl time: 2 use: Ropp_minus_distr."], "tactic": "replace (- f t - - phi t) with (phi t - f t) by lra.", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi.", "unfold Rabs.", "qsimpl time: 2 use: Ropp_minus_distr."], "tactic": "apply H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi.", "unfold Rabs.", "qsimpl time: 2 use: Ropp_minus_distr."], "tactic": "apply Ht.", "exn": "The reference Ht was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi.", "unfold Rabs.", "qsimpl time: 2 use: Ropp_minus_distr."], "tactic": "rewrite Rabs_Ropp.", "exn": "The LHS of Rabs_Ropp (Rabs (- _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros f a b pr.", "unfold Riemann_integrable in *.", "intros eps.", "destruct (pr eps) as [phi [psi [H1 H2]]].", "qsimpl time: 2.", "exists psi.", "unfold Rabs.", "qsimpl time: 2 use: Ropp_minus_distr.", "qsimpl time: 2 use: Rabs_Ropp,Ropp_minus_distr."], "tactic": "apply H2.", "exn": "In environment H3 : forall r1 r2 : R, - (r1 - r2) = r2 - r1 H1 : forall x : R, Rabs (- x) = Rabs x f : R -> R a, b : R pr : forall eps : posreal, {phi : StepFun a b & {psi : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> Rabs (f t - phi t) <= psi t) /\\\\ Rabs (RiemannInt_SF psi) < eps}} eps : posreal phi, psi : StepFun a b H2 : Rabs (RiemannInt_SF psi) < eps H : forall t : R, Rmin a b <= t -> t <= Rmax a b -> Rabs (f t - phi t) <= psi t Unable to unify \"Rabs (RiemannInt_SF psi) < eps\" with \"{psi0 : StepFun a b | (forall t : R, Rmin a b <= t <= Rmax a b -> (if Rcase_abs (- f t - psi t) then - (- f t - psi t) else - f t - psi t) <= psi0 t) /\\\\ (if Rcase_abs (RiemannInt_SF psi0) then - RiemannInt_SF psi0 else RiemannInt_SF psi0) < eps}\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros f a b pr. unfold Riemann_integrable in *. intros eps. destruct (pr eps) as [phi [psi [H1 H2]]]. exists (fun x => - phi x). exists psi. split. - intros t Ht. unfold Rabs. rewrite Ropp_minus_distr. replace (- f t - - phi t) with (phi t - f t) by lra. apply H1. apply Ht. - rewrite Rabs_Ropp. apply H2.", "succ": false}]