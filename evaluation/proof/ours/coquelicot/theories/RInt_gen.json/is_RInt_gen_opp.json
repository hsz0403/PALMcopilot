[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "unfold is_RInt_gen."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold is_RInt_gen.", "intros H'.", "unfold is_RInt_gen in H.", "apply is_RInt_gen_swap in H."], "tactic": "apply is_RInt_gen_ext with (f0 := fun y => opp (f y)) in H.", "exn": "Unable to apply lemma of type \"forall (f0 g : R -> V) (l0 : V), filter_prod ?Fa ?Fb (fun ab : R * R => forall x : R, Rmin (fst ab) (snd ab) < x < Rmax (fst ab) (snd ab) -> f0 x = g x) -> is_RInt_gen f0 ?Fa ?Fb l0 -> is_RInt_gen g ?Fa ?Fb l0\" on hypothesis of type \"is_RInt_gen f Fb Fa (opp l)\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros.", "unfold is_RInt_gen.", "intros H'.", "unfold is_RInt_gen in H.", "apply is_RInt_gen_swap in H.", "qsimpl use: is_RInt_gen_ext,opp."], "tactic": "apply H.", "exn": "In environment V : NormedModule R_AbsRing Fa, Fb : (R -> Prop) -> Prop FFa : Filter Fa FFb : Filter Fb f : R -> V l : V H : is_RInt_gen f Fb Fa (opp l) H' : V -> Prop H0 : forall (f g : R -> V) (l : V), filter_prod Fb Fb (fun ab : R * R => forall x : R, Rmin (fst ab) (snd ab) < x < Rmax (fst ab) (snd ab) -> f x = g x) -> is_RInt_gen f Fb Fb l -> is_RInt_gen g Fb Fb l H1 : locally (opp l) H' Unable to unify \"is_RInt_gen f Fb Fa (opp l)\" with \"filtermapi (fun ab : R * R => is_RInt (fun y : R => opp (f y)) (fst ab) (snd ab)) (filter_prod Fa Fb) H'\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. unfold is_RInt_gen. intros H. unfold is_RInt_gen in H. unfold is_RInt_gen. apply is_RInt_gen_swap in H. apply is_RInt_gen_ext with (f0 := fun y => opp (f y)) in H. apply H. apply filter_forall. intros. rewrite Rmin_comm. rewrite Rmax_comm. apply filter_prod_proper. intros. simpl. apply Ropp_involutive. apply H.", "succ": false}]