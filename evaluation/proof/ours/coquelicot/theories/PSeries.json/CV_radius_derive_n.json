[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold CV_radius.", "apply CV_radius_ext."], "tactic": "intros n.", "exn": "n is already used.", "type": "used_var", "handled": true}, {"ctx": ["unfold CV_radius.", "apply CV_radius_ext.", "intros n'.", "unfold PS_derive_n."], "tactic": "apply eq_trans with (PS_derive n a).", "exn": "In environment n : nat a : nat -> R n' : nat The term \"n\" has type \"nat\" while it is expected to have type \"nat -> R\".", "type": "wrong_type", "handled": true}, {"ctx": ["unfold CV_radius.", "apply CV_radius_ext.", "intros n'.", "unfold PS_derive_n.", "qsimpl time: 2 use: PS_derive,eq_trans."], "tactic": "apply CV_radius_derive.", "exn": "In environment H0 : forall (A : Type) (x y z : A), x = y -> y = z -> x = z n : nat a : nat -> R n' : nat H : R Unable to unify \"CV_radius (PS_derive ?M2653) = CV_radius ?M2653\" with \"INR (fact (n' + n)) / INR (fact n') * a (n' + n)%nat = a n'\".", "type": "cannot_unify", "handled": true}, {"ctx": ["unfold CV_radius.", "apply CV_radius_ext.", "intros n'.", "unfold PS_derive_n.", "qsimpl time: 2 use: PS_derive,eq_trans.", "qsimpl time: 2 use: PS_derive,CV_radius_derive,eq_trans."], "tactic": "apply CV_radius_scal_r.", "exn": "In environment H2 : forall (A : Type) (x y z : A), x = y -> y = z -> x = z r : (nat -> R) -> nat -> R H1 : forall a : nat -> R, CV_radius (r a) = CV_radius a n : nat a : nat -> R n' : nat H : R Unable to unify \"CV_radius (PS_scal_r ?M3015 ?M3016) = CV_radius ?M3016\" with \"INR (fact (n' + n)) / INR (fact n') * a (n' + n)%nat = a n'\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold CV_radius. apply CV_radius_ext. intros n. unfold PS_derive_n. apply eq_trans with (PS_derive n a). apply CV_radius_derive. apply CV_radius_scal_r. auto.", "succ": false}]