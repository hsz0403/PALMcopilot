[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "unfold CV_disk, PS_scal."], "tactic": "intros H.", "exn": "H is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal."], "tactic": "intros H'.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H."], "tactic": "apply ex_pseries_scal in H.", "exn": "Unable to find an instance for the variable c.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal."], "tactic": "destruct H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *."], "tactic": "destruct H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *."], "tactic": "split.", "exn": "Unable to find an instance for the variable x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0."], "tactic": "apply Series_scal_l.", "exn": "In environment c : R a : nat -> R x : R H0 : forall (c0 : ?K) (a0 : nat -> ?V) (x0 : ?K), mult x0 c0 = mult c0 x0 -> ex_series (fun k : nat => scal (pow_n x0 k) (a0 k)) -> ex_series (fun k : nat => scal (pow_n x0 k) (PS_scal c0 a0 k)) x0 : R H1 : is_series (fun k : nat => scal (pow_n x k) (a k)) x0 H : forall (c0 : ?K0) (a0 : nat -> ?V0) (x1 : ?K0), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 Unable to unify \"Series (fun n : nat => ?M3273 * ?M3274 n) = ?M3273 * Series ?M3274\" with \"forall P : R_NormedModule -> Prop, locally x0 P -> filtermap (sum_n (fun n : nat => Rabs (scal c (a n) * x ^ n))) eventually P\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "intros eps Heps.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "specialize (H0 eps Heps).", "exn": "The reference Heps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-"], "tactic": "destruct H0 as [N HN].", "exn": "Unable to find an instance for the variables c, a, x.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N."], "tactic": "intros n Hn.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N."], "tactic": "specialize (HN n Hn).", "exn": "The reference HN was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N."], "tactic": "rewrite PSeries_scal.", "exn": "The LHS of PSeries_scal (PSeries (PS_scal _ _) _) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal."], "tactic": "rewrite Rminus_eq_0 in HN.", "exn": "No such hypothesis: HN", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal."], "tactic": "rewrite Rabs_R0.", "exn": "The LHS of Rabs_R0 (Rabs 0) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0."], "tactic": "rewrite Rabs_mult.", "exn": "The LHS of Rabs_mult (Rabs (_ * _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0,Rabs_mult."], "tactic": "rewrite Rabs_Rabsolu.", "exn": "The LHS of Rabs_Rabsolu (Rabs (Rabs _)) does not match any subterm of the goal", "type": "no_match_term", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult."], "tactic": "apply Rmult_lt_compat_r with (r:=Rabs c) in HN.", "exn": "No such hypothesis: HN", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "+"], "tactic": "rewrite Rmult_1_r in HN.", "exn": "No such hypothesis: HN", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "+", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,Rmult_1_r,ex_pseries_scal,Rabs_R0,Rabs_mult."], "tactic": "apply HN.", "exn": "The reference HN was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "+", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,Rmult_1_r,ex_pseries_scal,Rabs_R0,Rabs_mult."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "unfold CV_disk, PS_scal.", "apply CV_disk_correct in H.", "qsimpl use: ex_pseries_scal.", "unfold ex_pseries in *.", "qsimpl use: ex_pseries_scal.", "-", "exists x0.", "qsimpl use: Series_scal_l,ex_pseries_scal.", "+", "shelve.", "+", "shelve.", "+", "shelve.", "-", "qsimpl use: Series_scal_l,N,ex_pseries_scal.", "exists N.", "qsimpl use: Series_scal_l,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rminus_eq_0,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,ex_pseries_scal,Rabs_R0,Rabs_mult.", "+", "qsimpl use: Series_scal_l,Rmult_lt_compat_r,Rminus_eq_0,Rabs,PSeries_scal,N,Rabs_Rabsolu,Rmult_1_r,ex_pseries_scal,Rabs_R0,Rabs_mult.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "+"], "tactic": "apply Rabs_pos.", "exn": "In environment H17 : forall x y : R, Rabs (x * y) = Rabs x * Rabs y H16 : Rabs 0 = 0 c : R a : nat -> R x : R H0 : forall (c0 : ?K) (a0 : nat -> ?V) (x0 : ?K), mult x0 c0 = mult c0 x0 -> ex_series (fun k : nat => scal (pow_n x0 k) (a0 k)) -> ex_series (fun k : nat => scal (pow_n x0 k) (PS_scal c0 a0 k)) x0 : R H1 : is_series (fun k : nat => scal (pow_n x k) (a k)) x0 H2 : forall (c0 : ?K1) (a0 : nat -> ?V2) (x1 : ?K1), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 H : forall (c : R) (a : nat -> R), Series (fun n : nat => c * a n) = c * Series a H5 : forall (c0 : ?K2) (a0 : nat -> ?V3) (x1 : ?K2), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 H4 : forall (c : R) (a : nat -> R) (x : R), PSeries (PS_scal c a) x = c * PSeries a x H8 : forall (c0 : ?K3) (a0 : nat -> ?V4) (x1 : ?K3), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 H6 : forall r : R, r - r = 0 H10 : forall (c0 : ?K4) (a0 : nat -> ?V5) (x1 : ?K4), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 H12 : forall (c0 : ?K5) (a0 : nat -> ?V6) (x1 : ?K5), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 H15 : forall (c0 : ?K6) (a0 : nat -> ?V7) (x1 : ?K6), mult x1 c0 = mult c0 x1 -> ex_pseries a0 x1 -> ex_pseries (PS_scal c0 a0) x1 H11 : forall x : R, Rabs (Rabs x) = Rabs x Unable to unify \"0 < Rabs ?M16172 \\\\/ 0 = Rabs ?M16172\" with \"AbsRing\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. unfold CV_disk, PS_scal. intros H. apply CV_disk_correct in H. apply ex_pseries_scal in H. destruct H. unfold ex_pseries in *. destruct H. split. - exists x0. apply Series_scal_l. - intros eps Heps. specialize (H0 eps Heps). destruct H0 as [N HN]. exists N. intros n Hn. specialize (HN n Hn). rewrite PSeries_scal. unfold R_dist in *. rewrite Rminus_eq_0 in HN. rewrite Rabs_R0. rewrite Rabs_mult. rewrite Rabs_Rabsolu. apply Rmult_lt_compat_r with (r:=Rabs c) in HN. + rewrite Rmult_1_r in HN. apply HN. + apply Rabs_pos.", "succ": false}]