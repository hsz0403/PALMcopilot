[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros X p q Hdec_p Hdec_q.", "exn": "X is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros X' p q Hdec_p Hdec_q.", "exn": "p is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros X' p' q Hdec_p Hdec_q.", "exn": "q is already used.", "type": "used_var", "handled": true}, {"ctx": [], "tactic": "intros X' p' q' Hdec_p Hdec_q.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "unfold decidable in Hdec_p, Hdec_q.", "exn": "No such hypothesis: Hdec_p", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: decidable."], "tactic": "destruct Hdec_p as [f_p Hdecider_p].", "exn": "The reference Hdec_p was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: decidable.", "destruct ZMicromega.Zsor as [f_p Hdecider_p]."], "tactic": "destruct Hdec_q as [f_q Hdecider_q].", "exn": "The reference Hdec_q was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros X p q Hdec_p Hdec_q. unfold decidable in Hdec_p, Hdec_q. destruct Hdec_p as [f_p Hdecider_p]. destruct Hdec_q as [f_q Hdecider_q]. exists (fun x => if (f_p x) && (f_q x) then true else false). intros x. specialize (Hdecider_p x). specialize (Hdecider_q x). split; intro H. - apply andb_true_iff in H. destruct H as [Hp Hq]. apply Hdecider_p in Hp. apply Hdecider_q in Hq. auto. - apply andb_true_iff. split. + apply Hdecider_p. apply H. + apply Hdecider_q. apply H.", "succ": false}]