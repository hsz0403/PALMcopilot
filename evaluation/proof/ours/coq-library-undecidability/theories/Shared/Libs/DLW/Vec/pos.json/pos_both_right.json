[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold pos_right, pos_both."], "tactic": "rewrite pos_both_left.", "exn": "Found no subterm matching \"pos_both ?M1446 ?M1447 (pos_left ?M1447 ?M1448)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold pos_right, pos_both.", "qsimpl use: pos_both_left."], "tactic": "reflexivity.", "exn": "In environment H : forall (n m : nat) (p : pos n), pos_both n m (pos_left m p) = inl p n, m : nat p : pos m Unable to unify \"inr p\" with \"nat_rec (fun n : nat => pos (n + m) -> pos n + pos m) (fun p : pos m => inr p) (fun (n : nat) (IHn : pos (n + m) -> pos n + pos m) (p : pos (S (n + m))) => match match p as t in (pos n0) return (match n0 as x return (pos x -> Set) with | 0 => fun _ : pos 0 => False | S n1 => fun i : pos (S n1) => ((i = pos0) + {p0 : pos n1 | i = pos_nxt p0})%type end t) with | @Fin.F1 n0 => inl eq_refl | @Fin.FS n0 p0 => inr (exist (fun p1 : pos n0 => pos_nxt p0 = pos_nxt p1) p0 eq_refl) end with | inl _ => inl pos0 | inr (exist _ p0 _) => match IHn p0 with | inl a => inl (pos_nxt a) | inr b => inr b end end) n ((fix pos_right (n m : nat) {struct n} : pos m -> pos (n + m) := match n as n0 return (pos m -> pos (n0 + m)) with | 0 => fun x : pos m => x | S n0 => fun p : pos m => pos_nxt (pos_right n0 m p) end) n m p)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "intros. unfold pos_right, pos_both. rewrite pos_both_left. reflexivity.", "succ": false}]