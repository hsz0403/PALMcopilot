[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros."], "tactic": "intros H1 H2 H3.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros."], "tactic": "intros H1' H2 H3.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "apply list_app_inj in H3 as [H4 H5].", "exn": "No such hypothesis: H3", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj."], "tactic": "apply (list_cons_app_cons_eq_inv X l1 l2 r1 r2 x1) in H5 as [H6 | H7].", "exn": "No such hypothesis: H5", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-"], "tactic": "destruct H6 as [m [H8 H9]].", "exn": "The reference H6 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-"], "tactic": "apply list_app_inj in H9 as [H10 H11].", "exn": "No such hypothesis: H9", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj."], "tactic": "split.", "exn": "In environment X1, X0 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 Unable to unify \"l2\" with \"l1\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj."], "tactic": "rewrite H8.", "exn": "The reference H8 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry."], "tactic": "apply H10.", "exn": "The reference H10 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split."], "tactic": "*", "exn": "[Focus] Wrong bullet *: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+"], "tactic": "apply elt_eq_unit with (l1:=m) (l2:=r1).", "exn": "The reference m was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+"], "tactic": "apply H11.", "exn": "The reference H11 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+"], "tactic": "reflexivity.", "exn": "In environment X2, X1, X0 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 x : X l, l' : list X H4 : l ~p l' H5 : l = l' Unable to unify \"x :: l'\" with \"x :: l\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+"], "tactic": "-", "exn": "[Focus] Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve."], "tactic": "-", "exn": "[Focus] Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+"], "tactic": "apply (list_cons_app_cons_eq_inv X l1 l2 r1 r2 x2) in H7 as [H12 | H13].", "exn": "No such hypothesis: H7", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+"], "tactic": "destruct H12 as [m [H14 H15]].", "exn": "The reference H12 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+"], "tactic": "apply list_app_inj in H15 as [H16 H17].", "exn": "No such hypothesis: H15", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj."], "tactic": "apply map_ext_in_iff.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+"], "tactic": "destruct H13 as [m [H23 H24]].", "exn": "The reference H13 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+"], "tactic": "apply app_eq_unit in H24 as [[H25 H26] | [H27 H28]].", "exn": "No such hypothesis: H24", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit."], "tactic": "apply app_eq_unit in H25 as [H29 H30].", "exn": "No such hypothesis: H25", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit."], "tactic": "apply elt_eq_unit in H30 as [H31 [H32 H33]].", "exn": "No such hypothesis: H30", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit."], "tactic": "apply list_app_eq_inv in H23 as [H34 | H35].", "exn": "No such hypothesis: H23", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "destruct H34 as [lm [l3 H34]].", "exn": "The reference H34 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "rewrite H34 in H31.", "exn": "No such hypothesis: H31", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso."], "tactic": "apply H2.", "exn": "In environment X9 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H7 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil X8 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X7 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X6 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X5, X4, X3, X2, X1, X0 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H4 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"?M19896 = ?M19897\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "rewrite H29.", "exn": "The reference H29 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "apply in_eq.", "exn": "In environment X11 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H5 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil X10 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X9 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X8 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X7 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X6 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X5, X4, X3, X2, X1, X0 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H4 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"?M22015 = ?M22015 \\\\/ (fix In (a : ?M22014) (l : list ?M22014) {struct l} : Prop := match l with | nil => False | b :: m => b = a \\\\/ In a m end) ?M22015 ?M22016\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "destruct H35 as [lm [l3 H35]].", "exn": "The reference H35 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "rewrite H35 in H2.", "exn": "The reference H35 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "apply H2.", "exn": "In environment X13 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H9 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil H7 : forall (A : Type) (a : A) (l : list A), a = a \\\\/ In a l X12 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X11 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X10 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X9 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X8 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X7 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X6 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X5, X4, X3, X2, X1, X0 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H4 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"?M24400 = ?M24401\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "apply in_eq.", "exn": "In environment X15 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H10 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil H5 : forall (A : Type) (a : A) (l : list A), a = a \\\\/ In a l X14 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X13 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X12 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X11 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X10 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X9 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X8 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X7 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X6 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X5, X4, X3, X2, X1, X0 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H4 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"?M26989 = ?M26989 \\\\/ (fix In (a : ?M26988) (l : list ?M26988) {struct l} : Prop := match l with | nil => False | b :: m => b = a \\\\/ In a m end) ?M26989 ?M26990\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "apply app_eq_unit in H28 as [H29 H30].", "exn": "No such hypothesis: H28", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "apply elt_eq_unit in H29 as [H31 [H32 H33]].", "exn": "No such hypothesis: H29", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1))."], "tactic": "apply list_app_inj in H23.", "exn": "No such hypothesis: H23", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "destruct H34 as [H34 | H34].", "exn": "The reference H34 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an]."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve."], "tactic": "+", "exn": "[Focus] Wrong bullet +: Expecting -.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-"], "tactic": "destruct H34.", "exn": "The reference H34 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit."], "tactic": "apply app_inv_head in H23.", "exn": "No such hypothesis: H23", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit."], "tactic": "apply app_inv_head.", "exn": "In environment H7 : forall (A : Type) (l l1 l2 : list A), l ++ l1 = l ++ l2 -> l1 = l2 X1 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H5 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil H4 : forall (A : Type) (a : A) (l : list A), a = a \\\\/ In a l X0 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H9 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"?M50649 = ?M50650\" with \"x1 = x2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit."], "tactic": "apply H23.", "exn": "The reference H23 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry."], "tactic": "apply app_nil_l.", "exn": "In environment H12 : forall (A : Type) (l l1 l2 : list A), l ++ l1 = l ++ l2 -> l1 = l2 X5 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H5 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil H4 : forall (A : Type) (a : A) (l : list A), a = a \\\\/ In a l X4 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X3 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X2 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X1 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X0 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H9 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"nil ++ ?M55398 = ?M55398\" with \"x2 :: nil ~p x1 :: nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry."], "tactic": "apply app_nil_l.", "exn": "In environment H14 : forall (A : Type) (l l1 l2 : list A), l ++ l1 = l ++ l2 -> l1 = l2 X7 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H11 : forall (A : Type) (l : list A), l = l H10 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil H7 : forall (A : Type) (a : A) (l : list A), a = a \\\\/ In a l X6 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X5 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X4 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X3 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X2 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X1 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X0 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H9 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b Unable to unify \"nil ++ ?M58528 = ?M58528\" with \"x1 :: nil ~p x2 :: nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "+"], "tactic": "destruct H34.", "exn": "The reference H34 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "+", "destruct RingMicromega.OpLt."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "+", "destruct RingMicromega.OpLt.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit."], "tactic": "apply app_eq_unit in H30 as [H36 H37].", "exn": "No such hypothesis: H30", "type": "no_hypos", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "+", "destruct RingMicromega.OpLt.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit."], "tactic": "apply H36.", "exn": "The reference H36 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "+", "destruct RingMicromega.OpLt.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_Add."], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "qsimpl use: list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "-", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "rewrite app_nil_end.", "symmetry.", "apply Permutation_ind.", "+", "split.", "+", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "shelve.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj.", "+", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: elt_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "exfalso.", "qsimpl use: list_app_eq_inv,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)).", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "destruct list_an as [list_an | list_an].", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "*", "shelve.", "-", "destruct BinIntDef.Z.of_nat.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_length_1.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "symmetry.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "+", "destruct RingMicromega.OpLt.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit.", "apply Permutation_Add.", "qsimpl use: list_app_eq_inv,in_eq,app_eq_unit,app_nil_l,list_cons_app_cons_eq_inv,list_app_inj,app_inv_head,elt_eq_unit."], "tactic": "assert (H38: l1 = cons X x2 r1).", "exn": "In environment H14 : forall (A : Type) (l l1 l2 : list A), l ++ l1 = l ++ l2 -> l1 = l2 X15 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} H11 : forall (A : Type) (l : list A), l = l H10 : forall (A : Type) (x y : list A) (a : A), x ++ y = a :: nil -> x = nil /\\\\ y = a :: nil \\\\/ x = a :: nil /\\\\ y = nil H7 : forall (A : Type) (a : A) (l : list A), a = a \\\\/ In a l X14 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X13 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X12 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X11 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X10 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X9 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X8 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X7 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X6 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X5 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X4 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X3 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X2 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X1 : forall (X : Type) (l2 r1 r2 : list X) (x y : X), x :: r1 = l2 ++ y :: r2 -> (l2 = nil /\\\\ x = y /\\\\ r1 = r2) + {m : list X | l2 = x :: m /\\\\ r1 = m ++ y :: r2} X0 : forall (X : Type) (l1 l2 r1 r2 : list X), l1 ++ r1 = l2 ++ r2 -> {m : list X | l1 ++ m = l2 /\\\\ r1 = m ++ r2} + {m : list X | l2 ++ m = l1 /\\\\ r2 = m ++ r1} X : Type l1 : list X x1 : X r1, l2 : list X x2 : X r2 : list X H : In x1 l2 -> False H0 : In x2 l1 -> False H1 : l1 ++ x1 :: r1 = l2 ++ x2 :: r2 H2 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> r1 = r2 H3 : forall (X : Type) (l1 l2 r1 r2 : list X), length l1 = length l2 -> l1 ++ r1 = l2 ++ r2 -> l1 = l2 H8 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l2 = nil H9 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> l1 = nil H6 : forall (A : Type) (l1 l2 : list A) (a b : A), l1 ++ a :: l2 = b :: nil -> a = b The term \"x2\" has type \"X\" while it is expected to have type \"list Type\".", "type": "wrong_type", "handled": true}]}, "chat": [], "original": "intros. intros H1 H2 H3. apply list_app_inj in H3 as [H4 H5]. apply (list_cons_app_cons_eq_inv X l1 l2 r1 r2 x1) in H5 as [H6 | H7]. - destruct H6 as [m [H8 H9]]. apply list_app_inj in H9 as [H10 H11]. split. + rewrite H8. symmetry. apply H10. + split. * apply elt_eq_unit with (l1:=m) (l2:=r1). apply H11. * reflexivity. - apply (list_cons_app_cons_eq_inv X l1 l2 r1 r2 x2) in H7 as [H12 | H13]. + destruct H12 as [m [H14 H15]]. apply list_app_inj in H15 as [H16 H17]. apply map_ext_in_iff. intros a Ha. apply in_split in Ha as [l3 [l4 H18]]. apply list_app_inj in H18 as [H19 H20]. apply app_inv_tail in H20 as H21. apply app_inv_head in H19. rewrite H19. assert (H22: x2 = x1). { apply app_inv_head in H21 as H22. apply app_inv_tail in H22. apply H22. } split. * rewrite <- H21, <- H19, <- H16. reflexivity. * split. { rewrite H22. reflexivity. } { rewrite app_nil_l in H17. symmetry. apply H17. } + destruct H13 as [m [H23 H24]]. apply app_eq_unit in H24 as [[H25 H26] | [H27 H28]]. * apply app_eq_unit in H25 as [H29 H30]. apply elt_eq_unit in H30 as [H31 [H32 H33]]. subst. apply list_app_eq_inv in H23 as [H34 | H35]. { destruct H34 as [lm [l3 H34]]. rewrite H34 in H31. exfalso. apply H2. rewrite H29. apply in_eq. } { destruct H35 as [lm [l3 H35]]. rewrite H35 in H2. apply H2. apply in_eq. } * apply app_eq_unit in H28 as [H29 H30]. apply elt_eq_unit in H29 as [H31 [H32 H33]]. subst. { assert (H34: l2 = r2 /\\ (r1 = l1 \\/ l1 = r1)). { apply list_app_inj in H23. auto. } destruct H34 as [H34 | H34]. + destruct H34. split. { apply app_inv_head in H23. apply app_inv_head. apply H23. } { split. { symmetry. apply app_nil_l. } { symmetry. apply app_nil_l. } } + destruct H34. { split. apply app_eq_unit in H30 as [H36 H37]. apply H36. split. assert (H38: l1 = cons X x2 r1). reflexivity. rewrite H38. reflexivity. assert (H39: cons X x1 r2 = r2). reflexivity. apply H39. } { split. apply app_eq_unit in H29 as [H35 H36]. apply H35. split. assert (H37: cons X x1 r2 = r1). reflexivity. apply H37. assert (H38: l1 = l2). reflexivity. apply H38. }", "succ": false}]