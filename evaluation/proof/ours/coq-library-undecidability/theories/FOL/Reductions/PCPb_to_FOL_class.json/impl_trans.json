[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["unfold trans.", "unfold \"==>\"."], "tactic": "rewrite map_map.", "exn": "Found no subterm matching \"map ?M2238 (map ?M2237 ?M2239)\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["unfold trans.", "unfold \"==>\".", "qsimpl use: map_map."], "tactic": "reflexivity.", "exn": "In environment H : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A), map g (map f l) = map (fun x : A => g (f x)) l R : BSRS ff : falsity_flag A : list form phi : form Unable to unify \"(fix impl (A : list form) (phi : form) {struct A} : form := match A with | [] => phi | psi :: A0 => psi --> impl A0 phi end) (map ((fix trans b (phi : form) {struct phi} : form := match phi in (form f) return form with | falsity => Q | atom _ _ _ b0 P v => match P as P0 return (Vector.t term (if P0 then 2 else 0) -> form) with | sPr => fun v0 : Vector.t term 2 => dnQ (atom sPr v0) | sQ => fun _ : Vector.t term 0 => Q end v | bin _ _ _ b0 Impl phi1 phi2 => trans b0 phi1 --> trans b0 phi2 | quant _ _ _ b0 All phi0 => \u2200 trans b0 phi0 end) ff) A) ((fix trans b (phi : form) {struct phi} : form := match phi in (form f) return form with | falsity => Q | atom _ _ _ b0 P v => match P as P0 return (Vector.t term (if P0 then 2 else 0) -> form) with | sPr => fun v0 : Vector.t term 2 => dnQ (atom sPr v0) | sQ => fun _ : Vector.t term 0 => Q end v | bin _ _ _ b0 Impl phi1 phi2 => trans b0 phi1 --> trans b0 phi2 | quant _ _ _ b0 All phi0 => \u2200 trans b0 phi0 end) ff phi)\" with \"(fix trans b (phi : form) {struct phi} : form := match phi in (form f) return form with | falsity => Q | atom _ _ _ b0 P v => match P as P0 return (Vector.t term (if P0 then 2 else 0) -> form) with | sPr => fun v0 : Vector.t term 2 => dnQ (atom sPr v0) | sQ => fun _ : Vector.t term 0 => Q end v | bin _ _ _ b0 Impl phi1 phi2 => trans b0 phi1 --> trans b0 phi2 | quant _ _ _ b0 All phi0 => \u2200 trans b0 phi0 end) ff ((fix impl (A : list form) (phi : form) {struct A} : form := match A with | [] => phi | psi :: A0 => psi --> impl A0 phi end) A phi)\".", "type": "cannot_unify", "handled": true}]}, "chat": [], "original": "unfold trans. unfold \"==>\". rewrite map_map. reflexivity.", "succ": false}]