[{"history": {"proof": "intros n m p H1 H2. apply not_lt. intro H3. qsimpl use: not_ge. qsimpl use: mult_gt_compat_rev_l2,not_ge. qsimpl use: mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r. qsimpl use: le_lt_trans,mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r. qsimpl use: lt_le_trans,not_ge,le_lt_trans,mult_gt_compat_rev_l2,mult_lt_compat_r. qsimpl use: mult_lt_compat_l,lt_le_trans,not_ge,le_lt_trans,mult_gt_compat_rev_l2,mult_lt_compat_r. hauto use: Nat.nle_gt, Nat.mul_le_mono_pos_l unfold: ge.", "repairs": ["", "", "", "cannot_apply_in", "cannot_apply_in", "no_instance_var", "cannot_apply_in", "cannot_apply_in", "no_instance_var", "hammer"], "exceptions": [{"ctx": ["intros n m p H1 H2.", "apply not_lt.", "intro H3."], "tactic": "apply not_ge in H3.", "exn": "Unable to apply lemma of type \"forall n m : nat, ~ n >= m -> n < m\" on hypothesis of type \"n < m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m p H1 H2.", "apply not_lt.", "intro H3.", "qsimpl use: not_ge."], "tactic": "apply (mult_gt_compat_rev_l2 _ _ p) in H3.", "exn": "Unable to apply lemma of type \"p * ?n > p * ?m -> ?n > ?m\" on hypothesis of type \"n < m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m p H1 H2.", "apply not_lt.", "intro H3.", "qsimpl use: not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge."], "tactic": "apply mult_lt_compat_r with (n := n) in H3; auto.", "exn": "Unable to find an instance for the variable p.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros n m p H1 H2.", "apply not_lt.", "intro H3.", "qsimpl use: not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r."], "tactic": "apply Nat.le_lt_trans with (m := p * m) in H1; auto.", "exn": "Unable to apply lemma of type \"forall n m p : nat, n <= m -> m < p -> n < p\" on hypothesis of type \"p * n >= p * m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m p H1 H2.", "apply not_lt.", "intro H3.", "qsimpl use: not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r.", "qsimpl use: le_lt_trans,mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r."], "tactic": "apply Nat.lt_le_trans with (m := p * n) in H3; auto.", "exn": "Unable to apply lemma of type \"forall n m p : nat, n < m -> m <= p -> n < p\" on hypothesis of type \"n < m\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros n m p H1 H2.", "apply not_lt.", "intro H3.", "qsimpl use: not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge.", "qsimpl use: mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r.", "qsimpl use: le_lt_trans,mult_gt_compat_rev_l2,not_ge,mult_lt_compat_r.", "qsimpl use: lt_le_trans,not_ge,le_lt_trans,mult_gt_compat_rev_l2,mult_lt_compat_r."], "tactic": "apply Mult.mult_lt_compat_l in H3; auto.", "exn": "Unable to find an instance for the variable p.", "type": "no_instance_var", "handled": true}]}, "chat": [], "original": "intros n m p H1 H2. apply not_lt. intro H3. apply not_ge in H3. apply (mult_gt_compat_rev_l2 _ _ p) in H3. apply mult_lt_compat_r with (n := n) in H3; auto. apply Nat.le_lt_trans with (m := p * m) in H1; auto. apply Nat.lt_le_trans with (m := p * n) in H3; auto. apply Mult.mult_lt_compat_l in H3; auto.", "succ": true}]