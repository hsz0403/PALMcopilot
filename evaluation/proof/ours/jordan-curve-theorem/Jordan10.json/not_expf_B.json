[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t."], "tactic": "destruct (eq_dim_dec d zero).", "exn": "In environment m : fmap x, z, t : dart f : fmap d : dart t0 : tag p : point Em : m = I f d t0 p Hmap : inv_hmap (I f d t0 p) Hplanar : planar (I f d t0 p) Hsucc_y : succ (I f d t0 p) zero x A_eq_y_x := A (I f d t0 p) zero x : dart bottom_x0_x := bottom (I f d t0 p) zero x : dart other_exps : ~ expf (I f d t0 p) A_eq_y_x z /\\\\ ~ expf (I f d t0 p) bottom_x0_x z \\\\/ ~ expf (I f d t0 p) A_eq_y_x t /\\\\ ~ expf (I f d t0 p) bottom_x0_x t not_exp_z_t : ~ expf (I f d t0 p) z t Hexp_B_not_z_t : (inv_hmap (B f zero x) /\\\\ prec_I (B f zero x) d) /\\\\ MF.expo (I (B f zero x) d t0 p) z t The term \"d\" has type \"dart\" while it is expected to have type \"dim\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+"], "tactic": "destruct (eq_dart_dec d0 x).", "exn": "The reference x was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+"], "tactic": "destruct other_exps as [H1 | H2].", "exn": "The reference other_exps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+"], "tactic": "destruct H1 as [H11 H12].", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2]."], "tactic": "unfold not in H12.", "exn": "No such hypothesis: H12", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not."], "tactic": "apply H12 in Hexp_B_not_z_t.", "exn": "No such hypothesis: Hexp_B_not_z_t", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+"], "tactic": "apply H11.", "exn": "In environment H0 : forall i k : dim, {i = k} + {i = k -> False} H : dim x, z : dart f : fmap t0 : tag p : point x0 : nat not_exp_z_t : expf (I f x t0 p) z (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Hsucc_y : succ (I f x t0 p) zero x H2 : inv_hmap (B f zero x) H4 : inv_hmap f H7 : expf (I f x t0 p) (A f zero x) z -> False H8 : expf (I f x t0 p) x z -> False Heqs : eq_dart_dec x x = left eq_refl H6 : x = nil -> False H9 : exd f x -> False H10 : exd (B f zero x) x -> False H11 : genus (I f x t0 p) = 0 H1 : exd (B f zero x) z Unable to unify \"genus (I f x t0 p) = 0\" with \"False\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+"], "tactic": "qsimpl use: contradiction,eq_dart_dec,not,d1,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+"], "tactic": "apply H12.", "exn": "The reference H12 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y."], "tactic": "split; auto.", "exn": "In environment H0 : forall i k : dim, {i = k} + {i = k -> False} H : dim x, z : dart f : fmap t0 : tag p : point Hsucc_y : succ (I f z t0 p) zero x x0 : nat not_exp_z_t : expf (I f z t0 p) z (Iter (MF.f (I (B f zero x) z t0 p)) x0 z) -> False H2 : inv_hmap (B f zero x) H4 : inv_hmap f H11 : genus (I f z t0 p) = 0 H10 : exd (B f zero x) z -> False H9 : exd f z -> False H6 : z = nil -> False H8 : expf (I f z t0 p) (bottom f zero x) z -> False n : z = x -> False Heqs : eq_dart_dec z x = right n H7 : expf (I f z t0 p) (A f zero x) z -> False Unable to unify \"nil\" with \"A (I f z t0 p) zero x\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y."], "tactic": "qsimpl use: contradiction,eq_dart_dec,not,d1,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+"], "tactic": "apply H21.", "exn": "The reference H21 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y."], "tactic": "-", "exn": "Wrong bullet -: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve."], "tactic": "-", "exn": "Wrong bullet -: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+"], "tactic": "apply H22.", "exn": "The reference H22 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y."], "tactic": "split; auto.", "exn": "In environment H0 : forall i k : dim, {i = k} + {i = k -> False} H : dim z : dart f : fmap t0 : tag p : point x0 : nat H2 : inv_hmap (B f zero z) Hsucc_y : succ (I f z t0 p) zero z not_exp_z_t : expf (I f z t0 p) z (Iter (MF.f (I (B f zero z) z t0 p)) x0 z) -> False H4 : inv_hmap f H11 : genus (I f z t0 p) = 0 H10 : exd (B f zero z) z -> False H9 : exd f z -> False H6 : z = nil -> False Heqs : eq_dart_dec z z = left eq_refl H7 : expf (I f z t0 p) (A f zero z) (Iter (MF.f (I (B f zero z) z t0 p)) x0 z) -> False Unable to unify \"nil\" with \"A (I f z t0 p) zero z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y."], "tactic": "qsimpl use: contradiction,eq_dart_dec,not,d1,t,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f)."], "tactic": "apply Hmap.", "exn": "The reference Hmap was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f)."], "tactic": "apply Hplanar.", "exn": "The reference Hplanar was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind."], "tactic": "assert (Hsucc_y' : succ f zero d1).", "exn": "In environment H0 : forall i k : dim, {i = k} + {i = k -> False} H : dim x, z : dart f : fmap t0 : tag p : point x0 : nat not_exp_z_t : expf (I f x t0 p) z (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Hsucc_y : succ (I f x t0 p) zero x H2 : inv_hmap (B f zero x) H4 : inv_hmap f H8 : expf (I f x t0 p) x (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False H7 : expf (I f x t0 p) (A f zero x) (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Heqs : eq_dart_dec x x = left eq_refl H6 : x = nil -> False H9 : exd f x -> False H10 : exd (B f zero x) x -> False H11 : genus (I f x t0 p) = 0 H1 : exd (B f zero x) z The term \"d1\" has type \"Differential -> R -> R\" while it is expected to have type \"dart\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind."], "tactic": "qsimpl use: contradiction,eq_dart_dec,succ,not,d1,t,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind."], "tactic": "apply Hsucc_y.", "exn": "In environment H0 : forall i k : dim, {i = k} + {i = k -> False} H : dim x, z : dart f : fmap t0 : tag p : point x0 : nat not_exp_z_t : expf (I f x t0 p) z (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Hsucc_y : succ (I f x t0 p) zero x H2 : inv_hmap (B f zero x) H4 : inv_hmap f H8 : expf (I f x t0 p) x (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False H7 : expf (I f x t0 p) (A f zero x) (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Heqs : eq_dart_dec x x = left eq_refl H6 : x = nil -> False H9 : exd f x -> False H10 : exd (B f zero x) x -> False H11 : genus (I f x t0 p) = 0 H1 : exd (B f zero x) z Unable to unify \"succ (I f x t0 p) zero x\" with \"planar f\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind."], "tactic": "qsimpl use: contradiction,eq_dart_dec,succ,not,d1,t,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind."], "tactic": "assert (Hexp_B : MF.expo (L (B f zero d) d d d1) x0 x).", "exn": "The reference d was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind."], "tactic": "apply other_exps.", "exn": "The reference other_exps was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind."], "tactic": "left.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind."], "tactic": "qsimpl use: contradiction,eq_dart_dec,succ,not,d1,t,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind."], "tactic": "split; auto.", "exn": "In environment H0 : forall i k : dim, {i = k} + {i = k -> False} H : dim x, z : dart f : fmap t0 : tag p : point x0 : nat not_exp_z_t : expf (I f x t0 p) z (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Hsucc_y : succ (I f x t0 p) zero x H2 : inv_hmap (B f zero x) H4 : inv_hmap f H8 : expf (I f x t0 p) x (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False H7 : expf (I f x t0 p) (A f zero x) (Iter (MF.f (I (B f zero x) x t0 p)) x0 z) -> False Heqs : eq_dart_dec x x = left eq_refl H6 : x = nil -> False H9 : exd f x -> False H10 : exd (B f zero x) x -> False H11 : genus (I f x t0 p) = 0 H1 : exd (B f zero x) z Unable to unify \"0\" with \"genus f\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind."], "tactic": "qsimpl use: contradiction,eq_dart_dec,succ,not,d1,t,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind."], "tactic": "assert (Hexp_B_not_z_t' : MF.expo (L (B f zero d) d d d1) z t).", "exn": "The reference t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind."], "tactic": "apply Hexp_B_not_z_t.", "exn": "The reference Hexp_B_not_z_t was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind.", "apply Decidable.dec_not_not."], "tactic": "apply other_faces_in_cut_B0 with (m:=f) (x:=d) (z:=z) (t:=t) in Hmap'.", "exn": "No such hypothesis: Hmap'", "type": "no_hypos", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind.", "apply Decidable.dec_not_not."], "tactic": "qsimpl use: contradiction,eq_dart_dec,succ,not,d1,other_faces_in_cut_B0,t,zero,eq_dim_dec.", "exn": "The reference contradiction was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t.", "unfold not.", "intros Hexp_B_not_z_t.", "unfold expf in Hexp_B_not_z_t.", "destruct m eqn:Em.", "-", "simpl in Hexp_B_not_z_t.", "contradiction.", "-", "simpl in Hexp_B_not_z_t.", "qsimpl use: zero,eq_dim_dec.", "+", "destruct Heqs as [Heqs1 Heqs2].", "qsimpl use: zero,eq_dim_dec,not.", "qsimpl use: zero,eq_dim_dec,not.", "shelve.", "+", "qsimpl use: exd_dec,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "qsimpl use: MA1.R_degree_aux_rect,eq_dart_dec,not,d1,zero,eq_dim_dec.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "apply Hsucc_y.", "shelve.", "+", "assert (Hmap' : inv_hmap f).", "apply dim_ind.", "assert (Hplanar' : planar f).", "apply dim_ind.", "apply dim_ind.", "apply Decidable.dec_not_not."], "tactic": "apply Hmap'.", "exn": "The reference Hmap' was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros m x z t Hmap Hplanar Hsucc_y A_eq_y_x bottom_x0_x other_exps not_exp_z_t. unfold not. intros Hexp_B_not_z_t. unfold expf in Hexp_B_not_z_t. unfold expf. unfold B. destruct m eqn:Em. - simpl in Hexp_B_not_z_t. contradiction. - simpl in Hexp_B_not_z_t. simpl. destruct (eq_dim_dec d zero). + destruct (eq_dart_dec d0 x). * subst. unfold not in not_exp_z_t. destruct other_exps as [H1 | H2]. { destruct H1 as [H11 H12]. unfold not in H12. apply H12 in Hexp_B_not_z_t. contradiction. } { destruct H2 as [H21 H22]. unfold not in H22. apply H22 in Hexp_B_not_z_t. contradiction. } * unfold not in not_exp_z_t. destruct other_exps as [H1 | H2]. { destruct H1 as [H11 H12]. destruct (eq_dart_dec d1 z). - subst. apply H11. - apply H12. split; auto. } { destruct H2 as [H21 H22]. destruct (eq_dart_dec d1 t). - subst. apply H21. - apply H22. split; auto. } + assert (Hmap' : inv_hmap f). { apply Hmap. } assert (Hplanar' : planar f). { apply Hplanar. } assert (Hsucc_y' : succ f zero d1). { apply Hsucc_y. } assert (Hexp_B : MF.expo (L (B f zero d) d d d1) x0 x). { apply other_exps. left. split; auto. } assert (Hexp_B_not_z_t' : MF.expo (L (B f zero d) d d d1) z t). { apply Hexp_B_not_z_t. } apply other_faces_in_cut_B0 with (m:=f) (x:=d) (z:=z) (t:=t) in Hmap'. apply Hmap'. all: auto.", "succ": false}]