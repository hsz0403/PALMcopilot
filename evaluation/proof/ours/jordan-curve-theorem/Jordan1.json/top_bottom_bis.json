[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom."], "tactic": "case_eq (exd m z).", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom.", "qsimpl time: 2 use: exd."], "tactic": "apply top_nil.", "exn": "In environment m : fmap k : dim z : dart H1 : inv_hmap m H2 : exd m z X : Prop Unable to unify \"top ?M2371 ?M2372 nil = nil\" with \"(fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k z) = (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom.", "qsimpl time: 2 use: exd.", "qsimpl time: 2 use: top_nil,exd."], "tactic": "apply H1.", "exn": "In environment H : forall (m : fmap) (k : dim), inv_hmap m -> top m k nil = nil m : fmap k : dim z : dart H1 : inv_hmap m H2 : exd m z X, X0 : Prop Unable to unify \"inv_hmap m\" with \"(fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k z) = (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom.", "qsimpl time: 2 use: exd.", "qsimpl time: 2 use: top_nil,exd.", "qsimpl time: 2 use: top_nil,exd."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom.", "qsimpl time: 2 use: exd.", "qsimpl time: 2 use: top_nil,exd.", "qsimpl time: 2 use: top_nil,exd.", "apply Decidable.dec_not_not.", "-"], "tactic": "apply not_exd_top.", "exn": "In environment H0 : forall (m : fmap) (k : dim), inv_hmap m -> top m k nil = nil m : fmap k : dim z : dart H1 : inv_hmap m H2 : exd m z X, X0, X1 : Prop Unable to unify \"top ?M2730 ?M2731 ?M2732 = nil\" with \"(fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k z) = (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k z \\\\/ (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k z) <> (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom.", "qsimpl time: 2 use: exd.", "qsimpl time: 2 use: top_nil,exd.", "qsimpl time: 2 use: top_nil,exd.", "apply Decidable.dec_not_not.", "-", "qsimpl time: 2 use: not_exd_top,top_nil,exd."], "tactic": "apply H1.", "exn": "In environment H3 : forall (m : fmap) (k : dim), inv_hmap m -> top m k nil = nil H : forall (m : fmap) (k : dim) (z : dart), inv_hmap m -> (exd m z -> False) -> top m k z = nil m : fmap k : dim z : dart H1 : inv_hmap m H2 : exd m z X, X0, X1, X2 : Prop Unable to unify \"inv_hmap m\" with \"Decidable.decidable ((fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k ((fix bottom (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else bottom m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y (bottom m0 k0 z) then bottom m0 k0 x else bottom m0 k0 z else bottom m0 k z end) m k z) = (fix top (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else top m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x (top m0 k0 z) then top m0 k0 y else top m0 k0 z else top m0 k z end) m k z)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k z H1 H2.", "unfold top.", "unfold bottom.", "qsimpl time: 2 use: exd.", "qsimpl time: 2 use: top_nil,exd.", "qsimpl time: 2 use: top_nil,exd.", "apply Decidable.dec_not_not.", "-", "qsimpl time: 2 use: not_exd_top,top_nil,exd.", "qsimpl time: 2 use: not_exd_top,top_nil,exd."], "tactic": "apply H.", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros m k z H1 H2. unfold top. unfold bottom. case_eq (exd m z). - intros. apply top_nil. + apply H1. + apply H. - intros. apply not_exd_top. + apply H1. + apply H.", "succ": false}]