[{"history": {"proof": "strivial use: cA_cA_1_B_ter.", "repairs": [], "exceptions": [{"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B."], "tactic": "destruct Hmap.", "exn": "Not an inductive product.", "type": "not_inductive_product", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst."], "tactic": "reflexivity.", "exn": "In environment m : fmap j : dim z : dart Hmap : inv_hmap m Hneq : zero = j -> False Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m zero z) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst."], "tactic": "*", "exn": "Wrong bullet *: Current bullet * is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*"], "tactic": "destruct (eq_dart_dec (cA_1 m0 zero z) z) as [H1 | H1].", "exn": "The reference m0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*"], "tactic": "rewrite H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA."], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k = j -> False e : k = zero n : x <> z Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++"], "tactic": "rewrite H1.", "exn": "The reference H1 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA."], "tactic": "apply cA_cA_1; auto.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k = j -> False e : k = zero n : x <> z Unable to unify \"cA ?M2466 ?M2467 (cA_1 ?M2466 ?M2467 ?M2468) = ?M2468\" with \"nil = nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1."], "tactic": "+", "exn": "Wrong bullet +: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve."], "tactic": "+", "exn": "Wrong bullet +: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one)."], "tactic": "*", "exn": "Wrong bullet *: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve."], "tactic": "*", "exn": "Wrong bullet *: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z)."], "tactic": "++", "exn": "Wrong bullet ++: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve."], "tactic": "++", "exn": "Wrong bullet ++: Expecting +.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+"], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k = j -> False n : k <> zero Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) ((fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end) m k x) j z\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+"], "tactic": "destruct (eq_dart_dec (cA_1 m0 one z) z) as [H2 | H2].", "exn": "The reference m0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+"], "tactic": "rewrite H2.", "exn": "The reference H2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA."], "tactic": "reflexivity.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k = j -> False n : k <> zero Unable to unify \"(fix cA (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec x z then y else if eq_dart_dec (cA_1 m0 k y) z then cA m0 k x else cA m0 k z else cA m0 k z end with cA_1 (m : fmap) (k : dim) (z : dart) {struct m} : dart := match m with | V => nil | I m0 x _ _ => if eq_dart_dec x z then z else cA_1 m0 k z | L m0 k0 x y => if eq_dim_dec k0 k then if eq_dart_dec y z then x else if eq_dart_dec (cA m0 k x) z then cA_1 m0 k y else cA_1 m0 k z else cA_1 m0 k z end for cA) m j z\" with \"nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--"], "tactic": "rewrite H2.", "exn": "The reference H2 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA."], "tactic": "apply cA_cA_1; auto.", "exn": "In environment m : fmap k, j : dim x, z : dart Hmap : inv_hmap m Hneq : k = j -> False n : k <> zero Unable to unify \"cA ?M2512 ?M2513 (cA_1 ?M2512 ?M2513 ?M2514) = ?M2514\" with \"nil = nil\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*"], "tactic": "destruct (eq_dim_dec k k0).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++"], "tactic": "destruct (eq_dart_dec x0 x).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x)."], "tactic": "--", "exn": "Wrong bullet --: Current bullet ++ is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve."], "tactic": "--", "exn": "Wrong bullet --: Expecting ++.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++"], "tactic": "reflexivity.", "exn": "Cannot find a relation to rewrite.", "type": "no_rewrite_relation", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto."], "tactic": "--", "exn": "Wrong bullet --: Expecting *.", "type": "wrong_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*"], "tactic": "destruct (eq_dart_dec x0 z).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst."], "tactic": ["reflexivity.", ""], "exn": "Illegal application: The term \"exd\" of type \"fmap -> dart -> Prop\" cannot be applied to the terms \"x0\" : \"fmap\" \"y\" : \"fmap\" The 2nd term has type \"fmap\" which should be coercible to \"dart\".", "type": "term_cannot_apply", "handled": false}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst."], "tactic": "**", "exn": "Wrong bullet **: Current bullet ** is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**"], "tactic": "destruct (eq_dim_dec k0 zero).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---"], "tactic": "rewrite not_exd_cA; try auto.", "exn": "Found no subterm matching \"cA ?M2554 ?M2555 ?M2556\" in the current goal.", "type": "no_subterm", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1."], "tactic": "apply cA_exd; auto.", "exn": "No such goal. Focus next goal with bullet ---.", "type": "next_goal", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---"], "tactic": ["reflexivity.", ""], "exn": "Illegal application: The term \"exd\" of type \"fmap -> dart -> Prop\" cannot be applied to the terms \"x0\" : \"fmap\" \"y\" : \"fmap\" The 2nd term has type \"fmap\" which should be coercible to \"dart\".", "type": "term_cannot_apply", "handled": false}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---"], "tactic": "--", "exn": "Wrong bullet --: Current bullet --- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---", "shelve.", "--"], "tactic": "destruct (eq_dart_dec x0 x).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---", "shelve.", "--"], "tactic": ["reflexivity.", ""], "exn": "Illegal application: The term \"fix B (m : fmap) (k : dim) (x : dart) {struct m} : fmap := match m with | V => V | I m0 x0 t0 p0 => I (B m0 k x) x0 t0 p0 | L m0 k0 x0 y0 => if eq_dim_dec k0 k then if eq_dart_dec x0 x then m0 else L (B m0 k x) k0 x0 y0 else L (B m0 k x) k0 x0 y0 end\" of type \"fmap -> dim -> dart -> fmap\" cannot be applied to the terms \"m\" : \"fmap\" \"x0\" : \"dim\" \"y\" : \"dim\" The 3rd term has type \"dim\" which should be coercible to \"dart\".", "type": "term_cannot_apply", "handled": false}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---", "shelve.", "--"], "tactic": "--", "exn": "Wrong bullet --: Current bullet -- is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---", "shelve.", "--", "shelve.", "--"], "tactic": "destruct (eq_dim_dec k k0).", "exn": "The reference k0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---", "shelve.", "--", "shelve.", "--"], "tactic": "destruct (eq_dart_dec x0 x).", "exn": "The reference x0 was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros m k j x z Hmap Hneq.", "unfold cA, B.", "qsimpl time: 2.", "destruct (eq_dim_dec k zero).", "+", "destruct (eq_dart_dec x z).", "*", "subst.", "shelve.", "*", "rewrite not_exd_cA.", "++", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dim_dec k one).", "**", "shelve.", "**", "shelve.", "++", "destruct (eq_dart_dec x z).", "**", "shelve.", "**", "shelve.", "+", "rewrite not_exd_cA.", "--", "rewrite not_exd_cA.", "qsimpl time: 2 use: cA_cA_1.", "*", "destruct (eq_dim_dec k k).", "++", "destruct (eq_dart_dec nil x).", "**", "shelve.", "**", "shelve.", "++", "auto.", "*", "destruct (eq_dart_dec nil z).", "**", "subst.", "shelve.", "**", "destruct (eq_dim_dec k zero).", "---", "qsimpl time: 2 use: not_exd_cA,cA_cA_1.", "---", "shelve.", "--", "shelve.", "--"], "tactic": ["reflexivity.", ""], "exn": "Illegal application: The term \"exd\" of type \"fmap -> dart -> Prop\" cannot be applied to the terms \"x0\" : \"fmap\" \"y\" : \"fmap\" The 2nd term has type \"fmap\" which should be coercible to \"dart\".", "type": "term_cannot_apply", "handled": false}]}, "chat": [], "original": "intros m k j x z Hmap Hneq. unfold cA, B. destruct Hmap. unfold cA, cA_1 in *. destruct (eq_dim_dec k zero). + destruct (eq_dart_dec x z). * subst. reflexivity. * destruct (eq_dart_dec (cA_1 m0 zero z) z) as [H1 | H1]. ++ rewrite H1. reflexivity. ++ rewrite H1. apply cA_cA_1; auto. + destruct (eq_dim_dec k one). * destruct (eq_dart_dec x z). ++ subst. reflexivity. ++ destruct (eq_dart_dec (cA_1 m0 one z) z) as [H2 | H2]. -- rewrite H2. reflexivity. -- rewrite H2. apply cA_cA_1; auto. * destruct (eq_dim_dec k k0). ++ destruct (eq_dart_dec x0 x). -- reflexivity. -- destruct (eq_dart_dec x0 z). ** subst. reflexivity. ** destruct (eq_dim_dec k0 zero). --- rewrite not_exd_cA; try auto. apply cA_exd; auto. --- reflexivity. ++ destruct (eq_dim_dec k k0). -- destruct (eq_dart_dec x0 x). ** reflexivity. ** destruct (eq_dart_dec x0 z). --- subst. reflexivity. --- destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. +++ rewrite H2. reflexivity. +++ rewrite H2. apply cA_cA_1; auto. -- destruct (eq_dim_dec k k0). ** destruct (eq_dart_dec x0 x). --- reflexivity. --- destruct (eq_dart_dec x0 z). +++ subst. unfold cA. rewrite not_exd_cA; try auto. apply cA_exd; auto. +++ destruct (eq_dart_dec (cA_1 m0 k0 y0) z) as [H2 | H2]. ++++ rewrite H2. reflexivity. ++++ rewrite H2. apply cA_cA_1; auto. ** simpl. destruct (eq_dart_dec x0 x); try reflexivity. destruct (eq_dart_dec x0 z); try reflexivity. destruct (eq_dart_dec (cA_1 (B m0 k0 x) k z) z0); try reflexivity. destruct (eq_dim_dec k0 zero); try reflexivity. destruct (eq_dart_dec x0 z0); try reflexivity. destruct (eq_dart_dec (cA_1 m0 zero z0) z); try reflexivity. apply cA_cA_1; auto.", "succ": true}]