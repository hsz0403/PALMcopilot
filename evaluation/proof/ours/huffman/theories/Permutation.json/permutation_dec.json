[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": [], "tactic": "intros eq_bool_dec l1 l2 H.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros."], "tactic": "induction H as [| a l1 l2 H0 IH | a b l | l1 l2 l3 H1 IH1 H2 IH2 ].", "exn": "The reference H was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "left."], "tactic": "apply permutation_nil.", "exn": "In environment A : Type X : forall a b : A, {a = b} + {a <> b} l1, l2 : list A Unable to unify \"permutation [] []\" with \"permutation l1 l2\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros.", "left.", "qsimpl use: permutation_nil."], "tactic": "destruct (eq_bool_dec a b) as [E | NE].", "exn": "The reference eq_bool_dec was not found in the current environment.", "type": "ref_not_found", "handled": true}, {"ctx": ["intros.", "left.", "qsimpl use: permutation_nil."], "tactic": "right.", "exn": "Not an inductive goal with 2 constructors.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "left.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil."], "tactic": "intros contra.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "left.", "qsimpl use: permutation_nil.", "qsimpl use: permutation_nil."], "tactic": "inversion contra.", "exn": "No such hypothesis: contra", "type": "no_hypos", "handled": true}]}, "chat": [], "original": "intros eq_bool_dec l1 l2 H. induction H as [| a l1 l2 H0 IH | a b l | l1 l2 l3 H1 IH1 H2 IH2 ]. - left. apply permutation_nil. - destruct (eq_bool_dec a b) as [E | NE]. + right. intros contra. inversion contra. contradiction. + destruct IH as [IHl | IHr]. * left. apply (permutation_skip _ _ _ IHl). * right. intros contra. apply NE. inversion contra. reflexivity. - destruct (eq_bool_dec a b) as [E | NE]. + left. apply permutation_swap. + right. intros contra. inversion contra. - destruct IH1 as [H1' | H1'']; destruct IH2 as [H2' | H2'']. + left. apply (permutation_trans _ _ _ H1' H2'). + right. intros contra. apply H2''. apply (permutation_trans _ _ _ H1). auto. + right. intros contra. apply H1''. apply (permutation_trans _ _ _ H2). auto. + right. intros contra. apply H1''. apply (permutation_trans _ _ _ H2). apply (permutation_sym _ _ H2').", "succ": false}]