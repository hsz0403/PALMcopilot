[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros a l1 l2 Hperm l11 l12 Heq."], "tactic": "apply Forall2_app_inv_r with (l1' := l11) (l2' := a :: l12) in Hperm.", "exn": "Unable to apply lemma of type \"forall (A B : Type) (R : A -> B -> Prop) (l1' l2' : list B) (l : list A), Forall2 R l (l1' ++ l2') -> exists l1 l2 : list A, Forall2 R l1 l1' /\\\\ Forall2 R l2 l2' /\\\\ l = l1 ++ l2\" on hypothesis of type \"permutation l1 l2\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros a l1 l2 Hperm l11 l12 Heq.", "qsimpl use: Forall2_app_inv_r."], "tactic": ["destruct Hperm as [l3 [l4 [H1 [H2 H3]]]].", ""], "exn": "Expects a disjunctive pattern with 4 branches.", "type": "num_branch", "handled": false}]}, "chat": [], "original": "intros a l1 l2 Hperm l11 l12 Heq. apply Forall2_app_inv_r with (l1' := l11) (l2' := a :: l12) in Hperm. destruct Hperm as [l3 [l4 [H1 [H2 H3]]]]. apply app_inv_app in Heq. destruct Heq as [Heq1 | [Heq2 | [Heq3 Heq4]]]. - exists l3, l4. split. + rewrite Heq1. rewrite H1. reflexivity. + rewrite Heq1. rewrite H2. apply H3. - exists l3, (l4 ++ a :: nil). split. + rewrite Heq2. rewrite H1. reflexivity. + rewrite Heq2. rewrite H2. simpl. rewrite app_nil_r. apply H3. - destruct Heq3. destruct l3. + discriminate H. + simpl in H. discriminate H. apply Forall2_app_inv_r with (l1' := l11) (l2' := l12) in Hperm. destruct Hperm as [l3 [l4 [H1 [H2 H3]]]]. apply app_inv_head in H1. subst l4. apply app_inv_tail in H2. subst l3. exists l11, l12. split. - reflexivity. - apply Hperm.", "succ": false}]