[{"history": {"proof": "intros a1 l1 l Hin_npb Hdist. unfold distinct_pbleaves in Hdist. srun best use: all_pbleaves_unique, all_pbleaves_ulist, ulist_pbadd_prop2 unfold: distinct_pbleaves.", "repairs": ["", "", "hammer"], "exceptions": [{"ctx": ["intros a1 l1 l Hin_npb Hdist.", "unfold distinct_pbleaves in Hdist.", "intros t0 t1 t2 Hin1 Hin2 Hin3."], "tactic": "intros Hin4 Hin5.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros a1 l1 l Hin_npb Hdist.", "unfold distinct_pbleaves in Hdist.", "intros t0 t1 t2 Hin1 Hin2 Hin3."], "tactic": "apply Hdist with (t1 := t1) (t2 := t2).", "exn": "Unable to find an instance for the variable t0.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros a1 l1 l Hin_npb Hdist.", "unfold distinct_pbleaves in Hdist.", "intros t0 t1 t2 Hin1 Hin2 Hin3.", "qsimpl.", "apply inpb_pbadd_ex in Hin1.", "destruct Hin1 as [Hin1 | Hin1].", "+"], "tactic": "apply inpbleaf_eq in Hin4.", "exn": "No such hypothesis: Hin4", "type": "no_hypos", "handled": true}, {"ctx": ["intros a1 l1 l Hin_npb Hdist.", "unfold distinct_pbleaves in Hdist.", "intros t0 t1 t2 Hin1 Hin2 Hin3.", "qsimpl.", "apply inpb_pbadd_ex in Hin1.", "destruct Hin1 as [Hin1 | Hin1].", "+", "qsimpl use: inpbleaf_eq."], "tactic": "+", "exn": "Wrong bullet +: Current bullet + is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros a1 l1 l Hin_npb Hdist.", "unfold distinct_pbleaves in Hdist.", "intros t0 t1 t2 Hin1 Hin2 Hin3.", "qsimpl.", "apply inpb_pbadd_ex in Hin1.", "destruct Hin1 as [Hin1 | Hin1].", "+", "qsimpl use: inpbleaf_eq.", "shelve.", "+"], "tactic": "apply inpb_pbadd_ex in Hin1.", "exn": "Unable to apply lemma of type \"forall (a1 : A) (l1 : list bool) (t1 t : pbtree), inpb t (pbadd a1 t1 l1) -> inpb (pbleaf a1) t \\\\/ inpb t t1\" on hypothesis of type \"inpb (pbnode t1 t2) l\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros a1 l1 l Hin_npb Hdist.", "unfold distinct_pbleaves in Hdist.", "intros t0 t1 t2 Hin1 Hin2 Hin3.", "qsimpl.", "apply inpb_pbadd_ex in Hin1.", "destruct Hin1 as [Hin1 | Hin1].", "+", "qsimpl use: inpbleaf_eq.", "shelve.", "+", "qsimpl use: inpbleaf_eq,inpb_pbadd_ex."], "tactic": "destruct Hin1 as [Hin6 | Hin6].", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros a1 l1 l Hin_npb Hdist. unfold distinct_pbleaves in Hdist. intros t0 t1 t2 Hin1 Hin2 Hin3. intros Hin4 Hin5. apply Hdist with (t1 := t1) (t2 := t2). apply inpb_pbadd_ex in Hin1. destruct Hin1 as [Hin1 | Hin1]. + apply inpbleaf_eq in Hin4. subst. auto. + apply inpb_pbadd_ex in Hin1. destruct Hin1 as [Hin6 | Hin6]. ++ apply inpbleaf_pbadd_inv in Hin4. destruct Hin4 as [Heq | Hin4]. +++ subst. auto. +++ apply inpb_compute_ex in Hin4. destruct Hin4 as [l Hin4]. pose (H := Hin5 l). unfold all_pbleaves in H. simpl in H. destruct H as [Heq | Hfalse]. ++++ left. auto. ++++ right. apply all_pbleaves_pbadd in Heq. apply Hdist in Heq; auto. ++ apply inpbleaf_eq in Hin6. subst. apply in_frequency_map in Hin2. contradiction. apply inpb_compute_ex in Hin5. destruct Hin5 as [l Hin5]. apply all_pbleaves_pbadd in Hin5. apply in_frequency_map in Hin2. contradiction.", "succ": true}]