[{"history": {"proof": "intros c a l in_algo. unfold in_alphabet in in_algo. intros a' in_a'_alg. qsimpl use: in_inv.", "repairs": ["", "", "", "cannot_apply_in"], "exceptions": [{"ctx": ["intros c a l in_algo.", "unfold in_alphabet in in_algo.", "intros a' in_a'_alg."], "tactic": "apply in_inv in in_a'_alg.", "exn": "Unable to apply lemma of type \"forall (A : Type) (a b : A) (l : list A), In b (a :: l) -> a = b \\\\/ In b l\" on hypothesis of type \"In a' l\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros c a l in_algo.", "unfold in_alphabet in in_algo.", "intros a' in_a'_alg.", "qsimpl use: in_inv."], "tactic": "destruct in_a'_alg as [eq_a_a' | in_a_alg]; [exists nil; left; assumption | apply in_algo; assumption].", "exn": "No such goal.", "type": "no_goal", "handled": true}]}, "chat": [], "original": "intros c a l in_algo. unfold in_alphabet in in_algo. intros a' in_a'_alg. apply in_inv in in_a'_alg. destruct in_a'_alg as [eq_a_a' | in_a_alg]; [exists nil; left; assumption | apply in_algo; assumption].", "succ": true}]