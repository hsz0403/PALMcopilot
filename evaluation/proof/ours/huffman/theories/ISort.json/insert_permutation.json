[{"history": {"proof": "intros L a. induction L. - simpl. qsimpl use: permutation_one_inv_aux. - simpl. destruct (order_fun a a0) eqn:H. + apply order_fun_true in H. qsimpl use: permutation_one_inv_aux,insert_ordered. + apply order_fun_false in H. qsimpl use: permutation_one_inv_aux,ordered_skip,insert_ordered. qsimpl use: permutation_one_inv_aux,ordered_skip,ordered_inv_order,insert_ordered. sauto lq: on depth: 3.", "repairs": ["", "", "", "", "cannot_unify", "", "", "", "", "", "cannot_unify", "", "", "cannot_unify", "no_hypos", "hammer"], "exceptions": [{"ctx": ["intros L a.", "induction L.", "-", "simpl."], "tactic": "apply permutation_one_inv_aux.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a : A Unable to unify \"?M1431 = [?M1433]\" with \"permutation [a] [a]\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "qsimpl use: permutation_one_inv_aux."], "tactic": "apply permutation_swap.", "exn": "No such goal. Focus next goal with bullet -.", "type": "next_goal", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "qsimpl use: permutation_one_inv_aux.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H."], "tactic": "apply insert_ordered.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a0 : A L : list A a : A IHL : permutation (a :: L) (insert a L) H : order a a0 Unable to unify \"ordered order (insert ?M1470 ?M1468)\" with \"permutation (a :: a0 :: L) (a :: a0 :: L)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "qsimpl use: permutation_one_inv_aux.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "qsimpl use: permutation_one_inv_aux,insert_ordered."], "tactic": "apply ordered_one.", "exn": "No such goal. Focus next goal with bullet +.", "type": "next_goal", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "qsimpl use: permutation_one_inv_aux.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "qsimpl use: permutation_one_inv_aux,insert_ordered.", "+", "apply order_fun_false in H."], "tactic": "apply ordered_skip.", "exn": "In environment A : Type order : A -> A -> Prop order_fun : A -> A -> bool order_fun_true : forall a b : A, order_fun a b = true -> order a b order_fun_false : forall a b : A, order_fun a b = false -> order b a a0 : A L : list A a : A IHL : permutation (a :: L) (insert a L) H : order a0 a Unable to unify \"ordered ?M1512 (?M1514 :: ?M1516)\" with \"permutation (a :: a0 :: L) (a0 :: insert a L)\".", "type": "cannot_unify", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "qsimpl use: permutation_one_inv_aux.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "qsimpl use: permutation_one_inv_aux,insert_ordered.", "+", "apply order_fun_false in H.", "qsimpl use: permutation_one_inv_aux,ordered_skip,insert_ordered."], "tactic": "apply ordered_inv_order in IHl.", "exn": "No such hypothesis: IHl", "type": "no_hypos", "handled": true}, {"ctx": ["intros L a.", "induction L.", "-", "simpl.", "qsimpl use: permutation_one_inv_aux.", "-", "simpl.", "destruct (order_fun a a0) eqn:H.", "+", "apply order_fun_true in H.", "qsimpl use: permutation_one_inv_aux,insert_ordered.", "+", "apply order_fun_false in H.", "qsimpl use: permutation_one_inv_aux,ordered_skip,insert_ordered.", "qsimpl use: permutation_one_inv_aux,ordered_skip,ordered_inv_order,insert_ordered."], "tactic": "apply IHl.", "exn": "The reference IHl was not found in the current environment.", "type": "ref_not_found", "handled": true}]}, "chat": [], "original": "intros L a. induction L. - simpl. apply permutation_one_inv_aux. apply permutation_swap. - simpl. destruct (order_fun a a0) eqn:H. + apply order_fun_true in H. apply insert_ordered. apply ordered_one. + apply order_fun_false in H. apply ordered_skip. apply ordered_inv_order in IHl. apply IHl.", "succ": true}]