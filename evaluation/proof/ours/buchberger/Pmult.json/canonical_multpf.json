[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf."], "tactic": "apply canonical_pluspf with (ltM:=ltM) (ltM_dec:=ltM_dec) in os; auto.", "exn": "Unable to find an instance for the variables A, A0, eqA, plusA, eqA_dec, l1, l2.", "type": "no_instance_var", "handled": true}, {"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf.", "qsimpl use: canonical_pluspf."], "tactic": "apply H1l in H1r.", "exn": "Unable to apply lemma of type \"olist (A:=A) ltM l1\" on hypothesis of type \"nZterm A0 eqA (n:=n) l1\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf.", "qsimpl use: canonical_pluspf.", "qsimpl use: canonical_pluspf."], "tactic": "apply H2l in H2r.", "exn": "Unable to apply lemma of type \"olist (A:=A) ltM l2\" on hypothesis of type \"nZterm A0 eqA (n:=n) l2\".", "type": "cannot_apply_in", "handled": true}, {"ctx": ["intros l1 l2 H1 H2.", "unfold canonical in H1, H2.", "destruct H1 as [H1l H1r].", "destruct H2 as [H2l H2r].", "unfold multpf.", "qsimpl use: canonical_pluspf.", "qsimpl use: canonical_pluspf.", "qsimpl use: canonical_pluspf."], "tactic": "split; [apply order_pluspf|apply canonical_mults_inv]; auto.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}]}, "chat": [], "original": "intros l1 l2 H1 H2. unfold canonical in H1, H2. destruct H1 as [H1l H1r]. destruct H2 as [H2l H2r]. unfold multpf. simpl. apply canonical_pluspf with (ltM:=ltM) (ltM_dec:=ltM_dec) in os; auto. apply H1l in H1r. apply H2l in H2r. split; [apply order_pluspf|apply canonical_mults_inv]; auto.", "succ": false}]