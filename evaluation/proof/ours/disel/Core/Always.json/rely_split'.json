[{"history": {"proof": "", "repairs": [], "exceptions": [{"ctx": ["intros.", "split.", "-"], "tactic": "intros H1 H2 H3.", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "split.", "-"], "tactic": "intros H1' H2 H3.", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}, {"ctx": ["intros.", "split.", "-"], "tactic": "split.", "exn": "Not an inductive goal with 1 constructor.", "type": "not_inductive_goal", "handled": true}, {"ctx": ["intros.", "split.", "-", "qsimpl."], "tactic": "apply (Idle V z s1 s2).", "exn": "In environment V : world K : hooks A : Type this, z : nid s1 : state s1' : union_map Label dstatelet s2 : state s2' : union_map Label dstatelet E : world H1 : network_step (V \\\\+ E \\\\+ (Unit, K)) z (s1 \\\\+ s1') (s2 \\\\+ s2') H2 : valid V H3 : valid s2 H4 : hook_complete V H5 : dom V.1 =i dom s2 H6 : forall l : nat, coh (getProtocol V l) (getStatelet s2 l) H7 : valid s1 H9 : dom V.1 =i dom s1 H10 : forall l : nat, coh (getProtocol V l) (getStatelet s1 l) H12 : hooks_consistent (V.1 \\\\+ E.1) K H15 : forall (s1 s2 : state) (s1' s2' : union_map Label dstatelet) (this : nid), s1 \\\\In Coh V -> s2 \\\\In Coh V -> network_step (V \\\\+ E \\\\+ (Unit, K)) this (s1 \\\\+ s1') (s2 \\\\+ s2') -> network_step V this s1 s2 /\\\\ s1' = s2' \\\\/ network_step E this s1' s2' /\\\\ s1 = s2 H14 : forall (s1 : union_map Label dstatelet) (s2 : state) (s : union_map Label dstatelet) (this : nid), s1 \\\\+ s \\\\In Coh (V \\\\+ E \\\\+ (Unit, K)) -> network_step V this s1 s2 -> network_step (V \\\\+ E \\\\+ (Unit, K)) this (s1 \\\\+ s) (s2 \\\\+ s) H16 : hook_complete E H : forall s : state, (exists s1 s2 : union_map Label dstatelet, [/\\\\ s = s1 \\\\+ s2, Coh V s1 & Coh E s2]) -> Coh (V \\\\+ E \\\\+ (Unit, K)) s H0 : forall s : state, Coh (V \\\\+ E \\\\+ (Unit, K)) s -> exists s1 s2 : union_map Label dstatelet, [/\\\\ s = s1 \\\\+ s2, Coh V s1 & Coh E s2] The term \"V\" has type \"world\" while it is expected to have type \"nid\".", "type": "wrong_type", "handled": true}, {"ctx": ["intros.", "split.", "-", "qsimpl.", "qsimpl use: Idle."], "tactic": "apply (Idle W2 z s1' s2').", "exn": "The variable w was not found in the current environment.", "type": "var_not_found", "handled": true}, {"ctx": ["intros.", "split.", "-", "qsimpl.", "qsimpl use: Idle."], "tactic": "-", "exn": "Wrong bullet -: Current bullet - is not finished.", "type": "unfinished_bullet", "handled": true}, {"ctx": ["intros.", "split.", "-", "qsimpl.", "qsimpl use: Idle.", "shelve.", "-"], "tactic": "intros [H1 H2].", "exn": "H1 is already used.", "type": "used_var", "handled": true}, {"ctx": ["intros.", "split.", "-", "qsimpl.", "qsimpl use: Idle.", "shelve.", "-"], "tactic": "intros [H1' H2].", "exn": "No product even after head-reduction.", "type": "no_product", "handled": true}]}, "chat": [], "original": "intros. split. - intros H1 H2 H3. split. + apply (Idle V z s1 s2). auto. + apply (Idle W2 z s1' s2'). auto. - intros [H1 H2]. apply (sem_split _ _ _ _ _ this). auto. auto. auto.", "succ": false}]