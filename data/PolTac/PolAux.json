{"code": ["Require Export Replace2.", "Require Import NAux ZAux RAux.", "Require P.", "Definition Natopp := (fun x:nat => 0%nat).", "Definition Nopp := (fun x:N => 0%N).", "Definition is_Z0 := Zeq_bool 0.", "Definition is_Z1 := Zeq_bool 1.", "Definition is_Zpos := Zle_bool 0.", "Definition is_Zdiv x y := if Zeq_bool x Z0 then false else Zeq_bool Z0 (Zmod y x).", "Definition Zgcd x y := if is_Zdiv x y then x else if is_Zdiv y x then y else 1%Z.", "Ltac is_NatCst p := match p with | O => constr:(true) | S ?p' => is_NatCst p' | _ => constr:(false) end.", "Ltac NatCst t := match is_NatCst t with | false => constr:(false) | _ => let res := eval compute in (Z_of_nat t) in constr:(res) end.", "Ltac is_PCst p := match p with | xH => constr:(true) | xO ?p' => is_PCst p' | xI ?p' => is_PCst p' | _ => constr:(false) end.", "Ltac is_NCst p := match p with | N0 => constr:(true) | Npos ?p' => is_PCst p' | _ => constr:(false) end.", "Ltac NCst t := match is_NCst t with | false => constr:(false) | _ => let res := eval compute in (Z_of_N t) in constr:(res) end.", "Ltac ZCst t := match t with | Z0 => constr:(t) | Zpos ?p => match is_PCst p with | false => constr:(false) | _ => constr:(t) end | Zneg ?p => match is_PCst p with | false => constr:(false) | _ => constr:(t) end | _ => constr:(false) end.", "Ltac is_ZCst t := match t with | Z0 => constr:(true) | Zpos ?p => is_PCst p | Zneg ?p => is_PCst p | _ => constr:(false) end.", "Fixpoint P2R (z: positive) {struct z}: R := match z with | xH => 1%R | xO xH => 2%R | xI xH => 3%R | xO z1 => (2 * P2R z1)%R | xI z1 => (1 + 2 * P2R z1)%R end.", "Definition Z2R (z: Z): R := match z with | Z0 => 0%R | Zpos z1 => (P2R z1)%R | Zneg z1 => (-(P2R z1))%R end.", "Ltac RCst t := match t with | R0 => constr:(Z0) | R1 => constr:(Zpos xH) | Rplus ?e1 ?e2 => match (RCst e1) with | false => constr:(false) | ?e3 => match (RCst e2) with | false => constr:(false) | ?e4 => eval vm_compute in (Zplus e3 e4) end end | Rminus ?e1 ?e2 => match (RCst e1) with | false => constr:(false) | ?e3 => match (RCst e2) with | false => constr:(false) | ?e4 => eval vm_compute in (Zminus e3 e4) end end | Rmult ?e1 ?e2 => match (RCst e1) with | false => constr:(false) | ?e3 => match (RCst e2) with | false => constr:(false) | ?e4 => eval vm_compute in (Zmult e3 e4) end end | Ropp ?e1 => match (RCst e1) with | false => constr:(false) | ?e3 => eval vm_compute in (Z.opp e3) end | IZR ?e1 => match (ZCst e1) with | false => constr:(false) | ?e3 => e3 end | _ => constr:(false) end.", "Ltac clean_zabs term := match term with | context id [(Z.abs_nat ?X)] => match is_ZCst X with | true => let x := (eval vm_compute in (Z.abs_nat X)) in let y := context id [x] in clean_zabs y | false => term end | _ => term end.", "Ltac clean_zabs_N term := match term with | context id [(Z.abs_N ?X)] => match is_ZCst X with | true => let x := (eval vm_compute in (Z.abs_N X)) in let y := context id [x] in clean_zabs_N y | false => term end | _ => term end.", "Ltac eqterm t1 t2 := match constr:((t1,t2)) with (?X, ?X) => true | _ => false end.", "Theorem trans_equal_r : forall (A : Set) (x y z :A), y = z -> x = y -> x = z.", "Proof.", "intros; apply trans_equal with y; auto.", "Qed.", "Open Scope nat_scope.", "Theorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.", "Proof.", "intros; apply f_equal2 with (f := plus); auto.", "Qed.", "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.", "Proof.", "intros a b c H H1; case H; apply plus_reg_l with a; auto.", "Qed.", "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.", "Proof.", "intros n m p H; unfold ge; apply plus_le_compat_l; auto.", "Qed.", "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.", "Proof.", "intros a b c H H1; case H; subst; auto.", "Qed.", "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.", "Proof.", "intros n m p H; unfold ge; apply plus_le_reg_l with p; auto.", "Qed.", "Theorem eq_lt_trans_l : forall x y z, x = z -> x < y -> z < y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_lt_trans_r : forall x y z, y = z -> x < y -> x < z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_gt_trans_l : forall x y z, x = z -> x > y -> z > y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_gt_trans_r : forall x y z, y = z -> x > y -> x > z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_le_trans_l : forall x y z, x = z -> x <= y -> z <= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_le_trans_r : forall x y z, y = z -> x <= y -> x <= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_ge_trans_l : forall x y z, x = z -> x >= y -> z >= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_ge_trans_r : forall x y z, y = z -> x >= y -> x >= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem ge_trans: forall x y z, x >= z -> z >= y -> x >= y.", "Proof.", "intros x y z H1 H2; red; apply le_trans with z; auto.", "Qed.", "Close Scope nat_scope.", "Open Scope N_scope.", "Theorem Nplus_eq_compat_l: forall a b c, b = c -> a + b = a + c.", "Proof.", "intros; apply f_equal2 with (f:= Nplus); auto.", "Qed.", "Theorem Nplus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.", "Proof.", "intros a b c H1 H2; case H1; apply Nplus_reg_l with a; auto.", "Qed.", "Theorem Nplus_lt_compat_l: forall n m p, n < m -> p + n < p + m.", "Proof.", "intros; to_nat; auto with arith.", "Qed.", "Theorem Nplus_gt_compat_l: forall n m p, n > m -> p + n > p + m.", "Proof.", "intros; to_nat; auto with arith.", "Qed.", "Theorem Nplus_le_compat_l: forall n m p, n <= m -> p + n <= p + m.", "Proof.", "intros; to_nat; auto with arith.", "Qed.", "Theorem Nplus_ge_compat_l: forall n m p, n >= m -> p + n >= p + m.", "Proof.", "intros; to_nat; auto with arith.", "Qed.", "Theorem Nplus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.", "Proof.", "intros a b c H H1; case H; apply f_equal2 with (f:= Nplus); auto.", "Qed.", "Theorem Nplus_lt_reg_l: forall n m p, p + n < p + m -> n < m.", "Proof.", "intros; to_nat; apply plus_lt_reg_l with nn1; auto with arith.", "Qed.", "Theorem Nplus_gt_reg_l: forall n m p, p + n > p + m -> n > m.", "Proof.", "intros; to_nat; apply plus_gt_reg_l with nn1; auto with arith.", "Qed.", "Theorem Nplus_le_reg_l: forall n m p, p + n <= p + m -> n <= m.", "Proof.", "intros; to_nat; apply plus_le_reg_l with nn1; auto with arith.", "Qed.", "Theorem Nplus_ge_reg_l: forall n m p, p + n >= p + m -> n >= m.", "Proof.", "intros; to_nat; apply plus_ge_reg_l with nn1; auto with arith.", "Qed.", "Theorem Neq_lt_trans_l : forall x y z, x = z -> x < y -> z < y.", "Proof.", "intros; subst; auto.", "Qed.", "Theorem Neq_lt_trans_r : forall x y z, y = z -> x < y -> x < z.", "Proof.", "intros; subst; auto.", "Qed.", "Theorem Neq_gt_trans_l : forall x y z, x = z -> x > y -> z > y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Neq_gt_trans_r : forall x y z, y = z -> x > y -> x > z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Neq_le_trans_l : forall x y z, x = z -> x <= y -> z <= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Neq_le_trans_r : forall x y z, y = z -> x <= y -> x <= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Neq_ge_trans_l : forall x y z, x = z -> x >= y -> z >= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Neq_ge_trans_r : forall x y z, y = z -> x >= y -> x >= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Nge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).", "Proof.", "intros; to_nat; red; apply le_trans with nn1; auto with arith.", "Qed.", "Close Scope N_scope.", "Open Scope Z_scope.", "Theorem eq_Zlt_trans_l : forall x y z, x = z -> x < y -> z < y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zlt_trans_r : forall x y z, y = z -> x < y -> x < z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zgt_trans_l : forall x y z, x = z -> x > y -> z > y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zgt_trans_r : forall x y z, y = z -> x > y -> x > z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zle_trans_l : forall x y z, x = z -> x <= y -> z <= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zle_trans_r : forall x y z, y = z -> x <= y -> x <= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zge_trans_l : forall x y z, x = z -> x >= y -> z >= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Zge_trans_r : forall x y z, y = z -> x >= y -> x >= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Zge_trans: forall x y z, x >= z -> z >= y -> x >= y.", "Proof.", "intros x y z H1 H2; red; apply Zge_trans with z; auto.", "Qed.", "Close Scope Z_scope.", "Open Scope R_scope.", "Theorem eq_Rlt_trans_l : forall x y z, x = z -> x < y -> z < y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rlt_trans_r : forall x y z, y = z -> x < y -> x < z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rgt_trans_l : forall x y z, x = z -> x > y -> z > y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rgt_trans_r : forall x y z, y = z -> x > y -> x > z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rle_trans_l : forall x y z, x = z -> x <= y -> z <= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rle_trans_r : forall x y z, y = z -> x <= y -> x <= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rge_trans_l : forall x y z, x = z -> x >= y -> z >= y.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem eq_Rge_trans_r : forall x y z, y = z -> x >= y -> x >= z.", "Proof.", "intros x y z H; rewrite H; auto.", "Qed.", "Theorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).", "Proof.", "intros x y z H1 H2; red; apply Rge_trans with z; auto.", "Qed.", "Theorem Z2R_correct: forall p, Z2R p = IZR p.", "Proof.", "intros p; case p; auto.", "intros p1; elim p1; auto.", "intros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z by auto.", "rewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.", "simpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.", "intros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z by auto.", "rewrite mult_IZR; rewrite <- Rec.", "simpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.", "intros p1; elim p1; auto.", "intros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z by auto.", "rewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.", "simpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.", "intros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z by auto.", "rewrite mult_IZR; rewrite <- Rec.", "simpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.", "Qed.", "Theorem Z2R_le: forall p q, (p <= q)%Z -> (Z2R p <= Z2R q)%R.", "Proof.", "intros p q; repeat rewrite Z2R_correct; intros; apply IZR_le; auto.", "Qed.", "Theorem Z2R_lt: forall p q, (p < q)%Z -> (Z2R p < Z2R q)%R.", "Proof.", "intros p q; repeat rewrite Z2R_correct; intros; apply IZR_lt; auto.", "Qed.", "Theorem Z2R_ge: forall p q, (p >= q)%Z -> (Z2R p >= Z2R q)%R.", "Proof.", "intros p q; repeat rewrite Z2R_correct; intros; apply IZR_ge; auto.", "Qed.", "Theorem Z2R_gt: forall p q, (p > q)%Z -> (Z2R p > Z2R q)%R.", "Proof.", "intros p q; repeat rewrite Z2R_correct; intros; red; apply IZR_lt; apply Z.gt_lt; auto.", "Qed.", "Close Scope R_scope."], "theorems": [{"name": "trans_equal_r", "kind": "Theorem", "begin": 23, "end": 26}, {"name": "plus_eq_compat_l", "kind": "Theorem", "begin": 28, "end": 31}, {"name": "plus_neg_compat_l", "kind": "Theorem", "begin": 32, "end": 35}, {"name": "plus_ge_compat_l", "kind": "Theorem", "begin": 36, "end": 39}, {"name": "plus_neg_reg_l", "kind": "Theorem", "begin": 40, "end": 43}, {"name": "plus_ge_reg_l", "kind": "Theorem", "begin": 44, "end": 47}, {"name": "eq_lt_trans_l", "kind": "Theorem", "begin": 48, "end": 51}, {"name": "eq_lt_trans_r", "kind": "Theorem", "begin": 52, "end": 55}, {"name": "eq_gt_trans_l", "kind": "Theorem", "begin": 56, "end": 59}, {"name": "eq_gt_trans_r", "kind": "Theorem", "begin": 60, "end": 63}, {"name": "eq_le_trans_l", "kind": "Theorem", "begin": 64, "end": 67}, {"name": "eq_le_trans_r", "kind": "Theorem", "begin": 68, "end": 71}, {"name": "eq_ge_trans_l", "kind": "Theorem", "begin": 72, "end": 75}, {"name": "eq_ge_trans_r", "kind": "Theorem", "begin": 76, "end": 79}, {"name": "ge_trans", "kind": "Theorem", "begin": 80, "end": 83}, {"name": "Nplus_eq_compat_l", "kind": "Theorem", "begin": 86, "end": 89}, {"name": "Nplus_neg_compat_l", "kind": "Theorem", "begin": 90, "end": 93}, {"name": "Nplus_lt_compat_l", "kind": "Theorem", "begin": 94, "end": 97}, {"name": "Nplus_gt_compat_l", "kind": "Theorem", "begin": 98, "end": 101}, {"name": "Nplus_le_compat_l", "kind": "Theorem", "begin": 102, "end": 105}, {"name": "Nplus_ge_compat_l", "kind": "Theorem", "begin": 106, "end": 109}, {"name": "Nplus_neg_reg_l", "kind": "Theorem", "begin": 110, "end": 113}, {"name": "Nplus_lt_reg_l", "kind": "Theorem", "begin": 114, "end": 117}, {"name": "Nplus_gt_reg_l", "kind": "Theorem", "begin": 118, "end": 121}, {"name": "Nplus_le_reg_l", "kind": "Theorem", "begin": 122, "end": 125}, {"name": "Nplus_ge_reg_l", "kind": "Theorem", "begin": 126, "end": 129}, {"name": "Neq_lt_trans_l", "kind": "Theorem", "begin": 130, "end": 133}, {"name": "Neq_lt_trans_r", "kind": "Theorem", "begin": 134, "end": 137}, {"name": "Neq_gt_trans_l", "kind": "Theorem", "begin": 138, "end": 141}, {"name": "Neq_gt_trans_r", "kind": "Theorem", "begin": 142, "end": 145}, {"name": "Neq_le_trans_l", "kind": "Theorem", "begin": 146, "end": 149}, {"name": "Neq_le_trans_r", "kind": "Theorem", "begin": 150, "end": 153}, {"name": "Neq_ge_trans_l", "kind": "Theorem", "begin": 154, "end": 157}, {"name": "Neq_ge_trans_r", "kind": "Theorem", "begin": 158, "end": 161}, {"name": "Nge_trans", "kind": "Theorem", "begin": 162, "end": 165}, {"name": "eq_Zlt_trans_l", "kind": "Theorem", "begin": 168, "end": 171}, {"name": "eq_Zlt_trans_r", "kind": "Theorem", "begin": 172, "end": 175}, {"name": "eq_Zgt_trans_l", "kind": "Theorem", "begin": 176, "end": 179}, {"name": "eq_Zgt_trans_r", "kind": "Theorem", "begin": 180, "end": 183}, {"name": "eq_Zle_trans_l", "kind": "Theorem", "begin": 184, "end": 187}, {"name": "eq_Zle_trans_r", "kind": "Theorem", "begin": 188, "end": 191}, {"name": "eq_Zge_trans_l", "kind": "Theorem", "begin": 192, "end": 195}, {"name": "eq_Zge_trans_r", "kind": "Theorem", "begin": 196, "end": 199}, {"name": "Zge_trans", "kind": "Theorem", "begin": 200, "end": 203}, {"name": "eq_Rlt_trans_l", "kind": "Theorem", "begin": 206, "end": 209}, {"name": "eq_Rlt_trans_r", "kind": "Theorem", "begin": 210, "end": 213}, {"name": "eq_Rgt_trans_l", "kind": "Theorem", "begin": 214, "end": 217}, {"name": "eq_Rgt_trans_r", "kind": "Theorem", "begin": 218, "end": 221}, {"name": "eq_Rle_trans_l", "kind": "Theorem", "begin": 222, "end": 225}, {"name": "eq_Rle_trans_r", "kind": "Theorem", "begin": 226, "end": 229}, {"name": "eq_Rge_trans_l", "kind": "Theorem", "begin": 230, "end": 233}, {"name": "eq_Rge_trans_r", "kind": "Theorem", "begin": 234, "end": 237}, {"name": "Rge_trans", "kind": "Theorem", "begin": 238, "end": 241}, {"name": "Z2R_correct", "kind": "Theorem", "begin": 242, "end": 259}, {"name": "Z2R_le", "kind": "Theorem", "begin": 260, "end": 263}, {"name": "Z2R_lt", "kind": "Theorem", "begin": 264, "end": 267}, {"name": "Z2R_ge", "kind": "Theorem", "begin": 268, "end": 271}, {"name": "Z2R_gt", "kind": "Theorem", "begin": 272, "end": 275}]}