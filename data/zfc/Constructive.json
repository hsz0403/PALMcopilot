{"code": ["Require Import Sets.", "Require Import Axioms.", "Definition EQC : Ens -> Ens -> Type.", "simple induction 1; intros A f eq1.", "simple induction 1; intros B g eq2.", "refine (prod_t _ _).", "exact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).", "exact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).", "Defined.", "Definition CIN : Ens -> Ens -> Type.", "simple induction 2.", "intros.", "exact (depprod _ (fun y : A => EQC X (e y))).", "Defined.", "Definition CINC : Ens -> Ens -> Type.", "intros E1 E2.", "exact (forall E : Ens, CIN E E1 -> CIN E E2).", "Defined.", "Theorem EQC_refl : forall E : Ens, EQC E E.", "simple induction E.", "intros A f HR.", "simpl in |- *.", "split; intros.", "exists x; auto with zfc.", "exists y; auto with zfc.", "Qed.", "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.", "simple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.", "split; (elim X2; intros; elim X3; intros).", "elim (a x); intros.", "elim (a0 x0); intros.", "exists x1.", "apply X with (e0 x0); auto with zfc.", "elim (b0 y); intros.", "elim (b x); intros.", "exists x0.", "apply X with (e0 x); auto with zfc.", "Qed.", "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.", "simple induction E1; simple induction E2; simpl in |- *; intros.", "elim X1; intros; split; intros.", "elim (b x); intros.", "exists x0; auto with zfc.", "elim (a y); intros; exists x; auto with zfc.", "Qed.", "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.", "simple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.", "elim X1; intros.", "elim X2; intros.", "elim (a x); intros.", "exists x0; apply EQC_tran with (e x); auto with zfc.", "Qed.", "Hint Resolve EQC_sym EQC_refl EQC_INC: zfc.", "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.", "simple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.", "apply X1.", "exists x; auto with zfc.", "cut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).", "apply X2; exists y; auto with zfc.", "Qed.", "Hint Resolve CINC_EQC: zfc.", "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.", "simple induction E''; simpl in |- *; intros.", "elim X1; intros y p; exists y.", "apply EQC_tran with E; auto with zfc.", "Qed.", "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.", "simple induction E'; simple induction E''; simpl in |- *; intros.", "elim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.", "Qed.", "Theorem CINC_refl : forall E : Ens, CINC E E.", "unfold CINC in |- *; auto with zfc.", "Qed.", "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.", "unfold CINC in |- *; auto with zfc.", "Qed.", "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.", "simple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.", "apply CIN_sound_right with E'; auto with zfc.", "Qed.", "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.", "simple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.", "elim (X2 E0); try assumption; intros.", "elim X1; intros XA XB; elim (XA x); intros.", "exists x0; apply EQC_tran with (e x); auto with zfc.", "Qed.", "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.", "unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.", "intros; elim (H (e x)); auto with zfc.", "exists x; auto with zfc.", "simple induction y.", "Qed.", "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).", "unfold Paire in |- *.", "simpl in |- *.", "intros; split.", "simple induction x.", "exists true; auto with zfc.", "exists false; auto with zfc.", "simple induction y; simpl in |- *.", "exists true; auto with zfc.", "exists false; auto with zfc.", "Qed.", "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').", "unfold Paire in |- *; simpl in |- *; intros; split.", "simple induction x.", "exists true; auto with zfc.", "exists false; auto with zfc.", "simple induction y.", "exists true; auto with zfc.", "exists false; auto with zfc.", "Qed.", "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').", "unfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.", "Qed.", "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').", "unfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.", "Qed.", "Inductive sum_t (A B : Type) : Type := | inl_t : A -> sum_t A B | inr_t : B -> sum_t A B.", "Hint Resolve inl_t inr_t: zfc.", "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').", "unfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.", "Qed.", "Hint Resolve CIN_Paire_left CIN_Paire_right: zfc.", "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).", "unfold Sing in |- *; auto with zfc.", "Qed.", "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.", "unfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.", "Qed.", "Theorem EQC_EQ : forall E E' : Ens, EQC E E' -> EQ E E'.", "simple induction E; intros A f ra; simple induction E'; intros B g rb; simpl in |- *; simple induction 1; intros H1 H2; split.", "intros a; elim (H1 a); intros b; intros; exists b; auto with zfc.", "intros b; elim (H2 b); intros a; intros; exists a; auto with zfc.", "Qed.", "Theorem CIN_IN : forall E E' : Ens, CIN E E' -> IN E E'.", "simple induction E; intros A f ra; simple induction E'; intros B g rb; simple induction 1; intros a; unfold IN in |- *; exists a; auto with zfc.", "apply EQC_EQ; auto with zfc.", "Qed.", "Theorem EQC_EXType : forall E E' : Ens, EQC E E' -> forall a : pi1 E, depprod (pi1 E') (fun b : pi1 E' => EQC (pi2 E a) (pi2 E' b)).", "simple induction E; simple induction E'; simpl in |- *.", "intros.", "elim X1; intros.", "elim (a0 a); intros.", "exists x; auto with zfc.", "Defined.", "Theorem CIN_EXType : forall E E' : Ens, CIN E' E -> depprod (pi1 E) (fun a : pi1 E => EQC E' (pi2 E a)).", "simple induction E; simpl in |- *.", "intros A f r.", "simple induction 1; simpl in |- *.", "intros.", "exists x; auto with zfc.", "Qed.", "Theorem CIN_Union : forall E E' E'' : Ens, CIN E' E -> CIN E'' E' -> CIN E'' (Union E).", "simple induction E; intros A f r.", "intros.", "simpl in |- *.", "elim (CIN_EXType (sup A f) E' X).", "intros x e.", "cut (EQC (pi2 (sup A f) x) E'); auto with zfc.", "intros e1.", "cut (CIN E'' (pi2 (sup A f) x)).", "intros i1.", "elim (CIN_EXType _ _ i1).", "intros x0 e2.", "simpl in x0.", "exists (dep_i A (fun x : A => pi1 (f x)) x x0).", "simpl in |- *.", "exact e2.", "apply CIN_sound_right with E'; auto with zfc.", "Qed.", "Theorem CIN_CINC_Union : forall E E' : Ens, CIN E' E -> CINC E' (Union E).", "unfold CINC in |- *; simple induction E; intros A f r.", "unfold Union in |- *.", "intros.", "simpl in |- *.", "elim (CIN_EXType (sup A f) E' X).", "intro.", "simpl in x.", "intros.", "simpl in p.", "elim (CIN_EXType E' E0 X0).", "cut (CIN E0 (f x)).", "intros.", "elim (CIN_EXType _ _ X1).", "simpl in |- *.", "intros.", "exists (dep_i A (fun x : A => pi1 (f x)) x x1); auto with zfc.", "apply CIN_sound_right with E'; auto with zfc.", "Qed.", "Inductive depprod' (A : Type) (P : A -> Type) : Type := dep_i' : forall x : A, P x -> depprod' A P.", "Theorem Union_CIN : forall E E' : Ens, CIN E' (Union E) -> depprod' _ (fun E1 : Ens => prod_t (CIN E1 E) (CIN E' E1)).", "simple induction E; unfold Union in |- *; simpl in |- *; intros A f r.", "simple induction 1.", "simple induction x.", "intros a b; simpl in |- *.", "intros.", "exists (f a).", "split.", "exists a; auto with zfc.", "apply CIN_sound_left with (pi2 (f a) b); auto with zfc.", "simpl in |- *.", "generalize b; elim (f a); simpl in |- *.", "intros.", "exists b0; auto with zfc.", "Qed.", "Theorem Union_soundC : forall E E' : Ens, EQC E E' -> EQC (Union E) (Union E').", "unfold Union in |- *.", "simpl in |- *.", "simple induction E; intros A f r; simple induction E'; intros A' f' r'.", "simpl in |- *.", "intros.", "elim X; intros.", "split.", "simple induction x.", "intros.", "elim (a x0).", "intros.", "elim (EQC_EXType (f x0) (f' x1) p0 p).", "intros.", "exists (dep_i A' (fun x : A' => pi1 (f' x)) x1 x2).", "simpl in |- *.", "auto with zfc.", "simple induction y; intros.", "elim (b x); intros.", "cut (EQC (f' x) (f x0)); auto with zfc.", "intros e.", "elim (EQC_EXType (f' x) (f x0) e p); intros.", "exists (dep_i A (fun x0 : A => pi1 (f x0)) x0 x1).", "simpl in |- *; auto with zfc.", "Qed.", "Theorem Union_monC : forall E E' : Ens, CINC E E' -> CINC (Union E) (Union E').", "unfold CINC in |- *; intros.", "elim (Union_CIN E E0 X0); intros.", "apply CIN_Union with x; elim p; intros; auto with zfc.", "Qed."], "theorems": [{"name": "EQC", "kind": "Definition", "begin": 2, "end": 8}, {"name": "CIN", "kind": "Definition", "begin": 9, "end": 13}, {"name": "CINC", "kind": "Definition", "begin": 14, "end": 17}, {"name": "EQC_refl", "kind": "Theorem", "begin": 18, "end": 25}, {"name": "EQC_tran", "kind": "Theorem", "begin": 26, "end": 37}, {"name": "EQC_sym", "kind": "Theorem", "begin": 38, "end": 44}, {"name": "EQC_INC", "kind": "Theorem", "begin": 45, "end": 51}, {"name": "CINC_EQC", "kind": "Theorem", "begin": 53, "end": 59}, {"name": "CIN_sound_left", "kind": "Theorem", "begin": 61, "end": 65}, {"name": "CIN_sound_right", "kind": "Theorem", "begin": 66, "end": 69}, {"name": "CINC_refl", "kind": "Theorem", "begin": 70, "end": 72}, {"name": "CINC_tran", "kind": "Theorem", "begin": 73, "end": 75}, {"name": "CINC_sound_left", "kind": "Theorem", "begin": 76, "end": 79}, {"name": "CINC_sound_right", "kind": "Theorem", "begin": 80, "end": 85}, {"name": "tout_vide_est_VideC", "kind": "Theorem", "begin": 86, "end": 91}, {"name": "Paire_sound_leftC", "kind": "Theorem", "begin": 92, "end": 102}, {"name": "Paire_sound_rightC", "kind": "Theorem", "begin": 103, "end": 111}, {"name": "CIN_Paire_left", "kind": "Theorem", "begin": 112, "end": 114}, {"name": "CIN_Paire_right", "kind": "Theorem", "begin": 115, "end": 117}, {"name": "Paire_CIN", "kind": "Theorem", "begin": 120, "end": 122}, {"name": "CIN_Sing", "kind": "Theorem", "begin": 124, "end": 126}, {"name": "CIN_Sing_EQ", "kind": "Theorem", "begin": 127, "end": 129}, {"name": "EQC_EQ", "kind": "Theorem", "begin": 130, "end": 134}, {"name": "CIN_IN", "kind": "Theorem", "begin": 135, "end": 138}, {"name": "EQC_EXType", "kind": "Theorem", "begin": 139, "end": 145}, {"name": "CIN_EXType", "kind": "Theorem", "begin": 146, "end": 152}, {"name": "CIN_Union", "kind": "Theorem", "begin": 153, "end": 170}, {"name": "CIN_CINC_Union", "kind": "Theorem", "begin": 171, "end": 189}, {"name": "Union_CIN", "kind": "Theorem", "begin": 191, "end": 205}, {"name": "Union_soundC", "kind": "Theorem", "begin": 206, "end": 230}, {"name": "Union_monC", "kind": "Theorem", "begin": 231, "end": 235}]}