{"code": ["Require Import Utf8.", "Require Import Bool.", "Require Import SetoidList.", "Require Import RelationPairs.", "Require Import Orders.", "Require Import Coqlib.", "Require Import DepMapInterface.", "Require Import DepMapFactsInterface.", "Set Implicit Arguments.", "Module DepMapFactsOn (X : OrderedType) (S : DepMap X) : DepMapFacts(X) with Definition key := X.t.", "Include S.", "Definition eq {A : Type} dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) := forall x, find x m\u2081 = find x m\u2082.", "Instance eq_refl : forall A dom, Reflexive (@eq A dom dom).", "Proof.", "repeat intro.", "reflexivity.", "Qed.", "Lemma eq_sym : forall A dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), eq m\u2081 m\u2082 -> eq m\u2082 m\u2081.", "Proof.", "intros * Heq x.", "rewrite Heq.", "reflexivity.", "Qed.", "Lemma eq_trans : forall A dom\u2081 dom\u2082 dom3 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) (m3 : t A dom3), eq m\u2081 m\u2082 -> eq m\u2082 m3 -> eq m\u2081 m3.", "Proof.", "intros * Heq\u2081 Heq\u2082 x.", "rewrite Heq\u2081, Heq\u2082.", "reflexivity.", "Qed.", "Instance eq_equiv : forall A dom, Equivalence (@eq A dom dom).", "Proof.", "unfold eq.", "split.", "+", "intros ?.", "reflexivity.", "+", "intros ? ? Heq ?.", "rewrite Heq.", "reflexivity.", "+", "intros ? ? ? Heq\u2081 Heq\u2082 ?.", "rewrite Heq\u2081, Heq\u2082.", "reflexivity.", "Qed.", "Definition incl {A : Type} dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) := forall x v, find x m\u2081 = Some v -> find x m\u2082 = Some v.", "Instance incl_refl : forall A dom (m : t A dom), Reflexive (@incl A dom dom).", "Proof.", "repeat intro.", "assumption.", "Qed.", "Lemma incl_trans : forall A dom\u2081 dom\u2082 dom3 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) (m3 : t A dom3), incl m\u2081 m\u2082 -> incl m\u2082 m3 -> incl m\u2081 m3.", "Proof.", "repeat intro.", "auto.", "Qed.", "Instance incl_preorder : forall A dom, PreOrder (@incl A dom dom).", "Proof.", "split.", "+", "repeat intro; assumption.", "+", "intros ? ? ? Hle\u2081 Hle\u2082 ? ? ?.", "now apply Hle\u2082, Hle\u2081.", "Qed.", "Instance eq_incl_compat : forall A dom, PartialOrder (@eq A dom dom) (@incl A dom dom).", "Proof.", "intros A dom m\u2081 m\u2082.", "split; intro Heq.", "+", "split; intros x v Hin.", "-", "now rewrite <- Heq.", "-", "now rewrite Heq.", "+", "intro x.", "destruct (find x m\u2081) as [v\u2081 |] eqn:Hin\u2081, (find x m\u2082) as [v\u2082 |] eqn:Hin\u2082.", "-", "apply Heq in Hin\u2081.", "rewrite Hin\u2081 in Hin\u2082.", "assumption.", "-", "apply Heq in Hin\u2081.", "rewrite Hin\u2081 in Hin\u2082.", "discriminate Hin\u2082.", "-", "apply Heq in Hin\u2082.", "rewrite Hin\u2082 in Hin\u2081.", "discriminate Hin\u2081.", "-", "reflexivity.", "Qed.", "Instance mem_compat (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@mem A dom).", "Proof.", "intros x y Hxy m\u2081 m\u2082 Heq.", "destruct (mem y m\u2082) eqn:Hmem.", "+", "rewrite mem_spec in *.", "destruct Hmem as [v Hmem].", "exists v.", "rewrite Heq.", "now rewrite (find_elt_compat _ Hxy).", "+", "destruct (mem x m\u2081) eqn:Hmem'; trivial.", "rewrite mem_spec in *.", "destruct Hmem' as [v Hmem'].", "rewrite Heq, (find_elt_compat _ Hxy) in Hmem'.", "assert (Hex : exists v, find y m\u2082 = Some v) by now exists v.", "rewrite <- mem_spec, Hmem in Hex.", "discriminate Hex.", "Qed.", "Theorem find_compat : forall A x y dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> find x m\u2081 = find y m\u2082.", "Proof.", "intros * Hxy Heq.", "rewrite Heq.", "apply find_elt_compat.", "assumption.", "Qed.", "Instance find_compat2 (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@find A dom).", "Proof.", "repeat intro.", "apply find_compat; assumption.", "Qed.", "Arguments set {A} {dom} x v m _.", "Theorem set_compat : forall A x y v dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) (Hin\u2081 : Dom.In x dom\u2081) (Hin\u2082 : Dom.In y dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> eq (set x v m\u2081 Hin\u2081) (set y v m\u2082 Hin\u2082).", "Proof.", "intros A x y v dom\u2081 dom\u2082 m\u2081 m\u2082 Hin\u2081 Hin\u2082 Hxy Hm z.", "destruct (X.eq_dec z x) as [Hxz | Hxz].", "+", "rewrite Hxz.", "rewrite Hxy at 3.", "do 2 rewrite set_same.", "reflexivity.", "+", "repeat rewrite set_other; auto.", "rewrite <- Hxy.", "assumption.", "Qed.", "Instance set_compat2 (A : Type) x dom : Proper (Logic.eq ==> @eq A dom dom ==> full_relation ==> @eq A dom dom) (@set A dom x).", "Proof.", "do 9 intro.", "subst.", "apply set_compat; trivial; reflexivity.", "Qed.", "Theorem add_compat : forall A x y v dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> eq (add x v m\u2081) (add y v m\u2082).", "Proof.", "intros ? x y * Hxy Heq z.", "destruct (X.eq_dec z x) as [Hxz | Hxz].", "+", "rewrite Hxz.", "rewrite Hxy at 4.", "do 2 rewrite add_same.", "reflexivity.", "+", "repeat rewrite add_other.", "apply Heq.", "now rewrite <- Hxy.", "assumption.", "Qed.", "Instance add_compat2 (A : Type) x dom : Proper (Logic.eq ==> @eq A dom dom ==> @eq A (Dom.add x dom) (Dom.add x dom)) (@add A dom x).", "Proof.", "do 6 intro.", "subst.", "apply add_compat; auto.", "reflexivity.", "Qed.", "Theorem remove_compat : forall A x y dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> eq (remove x m\u2081) (remove y m\u2082).", "Proof.", "intros ? x y * Hxy Heq z.", "destruct (X.eq_dec z x) as [Hxz | Hxz].", "+", "rewrite Hxz.", "rewrite Hxy at 4.", "do 2 rewrite remove_same.", "reflexivity.", "+", "repeat rewrite remove_other.", "apply Heq.", "now rewrite <- Hxy.", "assumption.", "Qed.", "Instance remove_compat2 (A : Type) x dom : Proper (@eq A dom dom ==> @eq A (Dom.remove x dom) (Dom.remove x dom)) (@remove A dom x).", "Proof.", "repeat intro.", "apply remove_compat; auto.", "reflexivity.", "Qed.", "Theorem find_None : forall A dom x (m : t A dom), find x m = None <-> \u00acDom.In x dom.", "Proof.", "intros.", "rewrite <- (find_spec x m).", "destruct (find x m).", "+", "split; intro Hfind.", "discriminate Hfind.", "elim Hfind.", "eexists; reflexivity.", "+", "split; intro Hfind.", "intros [? Habs].", "discriminate Habs.", "reflexivity.", "Qed.", "Corollary find_dom : forall A x v dom (m : t A dom), find x m = Some v -> Dom.In x dom.", "Proof.", "intros.", "rewrite <- find_spec.", "eexists; eassumption.", "Qed.", "Theorem set_Some : forall A x y v u dom (m : t A dom) (Hin : Dom.In x dom), find y (set x v m Hin) = Some u <-> X.eq y x \u2227 u = v \u2228 \u00acX.eq y x \u2227 find y m = Some u.", "Proof.", "intros A x y v u dom m Hin.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy.", "rewrite set_same.", "split; intro Heq.", "-", "left.", "inversion Heq.", "split; reflexivity.", "-", "destruct Heq as [[_ Heq] | [Habs _]].", "now subst.", "now elim Habs.", "+", "rewrite set_other; trivial.", "split; intro Heq.", "-", "right.", "split; assumption.", "-", "destruct Heq as [[Habs _] | [_ Heq]].", "contradiction.", "assumption.", "Qed.", "Theorem set_None : forall A x y v dom (m : t A dom) (Hin : Dom.In x dom), find y (set x v m Hin) = None <-> \u00acX.eq y x \u2227 find y m = None.", "Proof.", "intros A x y v dom m Hdom.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, set_same.", "split; intro Hin.", "-", "discriminate Hin.", "-", "destruct Hin as [Hin _].", "now elim Hin.", "+", "rewrite set_other; trivial.", "intuition.", "Qed.", "Theorem add_Some : forall A x y v u dom (m : t A dom), find y (add x v m) = Some u <-> X.eq y x \u2227 u = v \u2228 \u00acX.eq y x \u2227 find y m = Some u.", "Proof.", "intros A x y v u dom m.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy.", "rewrite add_same.", "split; intro Heq.", "-", "left.", "inversion Heq.", "split; reflexivity.", "-", "destruct Heq as [[_ Heq] | [Habs _]].", "now subst.", "now elim Habs.", "+", "rewrite add_other; trivial.", "split; intro Heq.", "-", "right.", "split; assumption.", "-", "destruct Heq as [[Habs _] | [_ Heq]].", "contradiction.", "assumption.", "Qed.", "Theorem add_None : forall A x y v dom (m : t A dom), find y (add x v m) = None <-> \u00acX.eq y x \u2227 find y m = None.", "Proof.", "intros A x y v dom m.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, add_same.", "split; intro Hin.", "-", "discriminate Hin.", "-", "destruct Hin as [Hin _].", "now elim Hin.", "+", "rewrite add_other; trivial.", "intuition.", "Qed.", "Theorem remove_Some : forall A x y u dom (m : t A dom), find y (remove x m) = Some u <-> \u00acX.eq y x \u2227 find y m = Some u.", "Proof.", "intros A x y u dom m.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, remove_same.", "split; intro Hin.", "-", "discriminate Hin.", "-", "destruct Hin as [Hin _].", "now elim Hin.", "+", "rewrite remove_other; trivial.", "intuition.", "Qed.", "Theorem remove_None : forall A x y dom (m : t A dom), find y (remove x m) = None <-> X.eq y x \u2228 find y m = None.", "Proof.", "intros A x y dom m.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy.", "rewrite remove_same.", "split; intro Heq; try left; reflexivity.", "+", "rewrite remove_other; trivial.", "split; intro Heq.", "-", "right.", "assumption.", "-", "destruct Heq.", "contradiction.", "assumption.", "Qed.", "Theorem add_cancel : forall A x v dom (m : t A dom), find x m = Some v -> eq (add x v m) m.", "Proof.", "intros A x v dom m Heq y.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, add_same, Heq.", "reflexivity.", "+", "rewrite add_other; trivial.", "Qed.", "Theorem remove_cancel : forall A x dom (m : t A dom), find x m = None -> eq (remove x m) m.", "Proof.", "intros A x dom m Heq y.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, remove_same, Heq.", "reflexivity.", "+", "rewrite remove_other; trivial.", "Qed.", "Theorem add_merge : forall A x v\u2081 v\u2082 dom (m : t A dom), eq (add x v\u2082 (add x v\u2081 m)) (add x v\u2082 m).", "Proof.", "intros A x v\u2081 v\u2082 dom m y.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, add_same, add_same.", "reflexivity.", "+", "repeat rewrite add_other; trivial.", "Qed.", "Theorem add_comm : forall A x y v\u2081 v\u2082 dom (m : t A dom), \u00acX.eq x y -> eq (add y v\u2082 (add x v\u2081 m)) (add x v\u2081 (add y v\u2082 m)).", "Proof.", "intros A x y v\u2081 v\u2082 dom m Hxy z.", "destruct (X.eq_dec z x) as [Hxz | Hxz].", "+", "rewrite Hxz, add_same, add_other, add_same; trivial.", "+", "destruct (X.eq_dec z y) as [Hyz | Hyz].", "-", "rewrite Hyz, add_same, add_other, add_same; trivial.", "rewrite <- Hyz.", "assumption.", "-", "repeat rewrite add_other; trivial.", "Qed.", "Theorem remove_add_cancel : forall A x v dom (m : t A dom), eq (remove x (add x v m)) (remove x m).", "Proof.", "intros A x v dom m y.", "destruct (X.eq_dec y x) as [Hxy | Hxy].", "+", "rewrite Hxy, remove_same, remove_same.", "reflexivity.", "+", "rewrite remove_other, remove_other, add_other; trivial.", "Qed.", "Theorem map_None : forall A B (f : A -> B) dom (m : t A dom) x, find x (map f m) = None <-> \u00acDom.In x dom.", "Proof.", "intros A B f dom m x.", "rewrite <- (find_spec x m).", "split; intro Hin.", "+", "intros [v Hv].", "assert (Hconj : exists v', find x m = Some v' \u2227 f v' = f v) by now exists v; split.", "rewrite <- map_spec in Hconj.", "rewrite Hconj in Hin.", "discriminate Hin.", "+", "destruct (find x (map f m)) eqn:Hmap; trivial.", "elim Hin.", "rewrite map_spec in Hmap.", "destruct Hmap as [v [Hv _]].", "exists v.", "assumption.", "Qed.", "Theorem combine_None : forall A B C (f : A -> B -> C) g\u2081 g\u2082 dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t B dom\u2082) x, find x (combine f g\u2081 g\u2082 m\u2081 m\u2082) = None <-> find x m\u2081 = None \u2227 find x m\u2082 = None.", "Proof.", "intros A B C f g\u2081 g\u2082 dom\u2081 dom\u2082 m\u2081 m\u2082 x.", "destruct (find x m\u2081) as [v\u2081 |] eqn:Hin\u2081, (find x m\u2082) as [v\u2082 |] eqn:Hin\u2082.", "+", "assert (Hin : find x (combine f g\u2081 g\u2082 m\u2081 m\u2082) = Some (f v\u2081 v\u2082)).", "{", "rewrite combine_spec.", "left.", "exists v\u2081, v\u2082.", "auto.", "}", "rewrite Hin.", "intuition discriminate.", "+", "assert (Hin : find x (combine f g\u2081 g\u2082 m\u2081 m\u2082) = Some (g\u2081 v\u2081)).", "{", "rewrite combine_spec.", "right; left.", "exists v\u2081.", "auto.", "}", "rewrite Hin.", "intuition discriminate.", "+", "assert (Hin : find x (combine f g\u2081 g\u2082 m\u2081 m\u2082) = Some (g\u2082 v\u2082)).", "{", "rewrite combine_spec.", "do 2 right.", "exists v\u2082.", "auto.", "}", "rewrite Hin.", "intuition discriminate.", "+", "destruct (find x (combine f g\u2081 g\u2082 m\u2081 m\u2082)) eqn:Hin.", "-", "rewrite combine_spec in Hin.", "destruct Hin as [[v\u2081 [v\u2082 [? [? ?]]]] | [[? [? [? ?]]] | [? [? [? ?]]]]]; rewrite Hin\u2081, Hin\u2082 in *; discriminate.", "-", "intuition.", "Qed.", "Theorem add_incl : forall A x v dom (m : t A dom), \u00acDom.In x dom -> incl m (add x v m).", "Proof.", "intros A x v dom m Hdom y v' Hin.", "rewrite add_other; trivial.", "intro Habs.", "apply Hdom.", "rewrite <- Habs, <- find_spec.", "exists v'.", "eassumption.", "Qed.", "Theorem remove_incl : forall A x dom (m : t A dom), incl (remove x m) m.", "Proof.", "intros * x v Hin.", "rewrite remove_Some in Hin.", "intuition.", "Qed.", "Theorem cast_spec : forall A dom\u2081 dom\u2082 (Heq : Dom.eq dom\u2081 dom\u2082) (m : t A dom\u2081), eq (cast Heq m) m.", "Proof.", "repeat intro.", "apply cast_spec_find.", "Qed.", "Lemma eq_dom : forall A dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), eq m\u2081 m\u2082 -> Dom.eq dom\u2081 dom\u2082.", "Proof.", "intros * Heq ?.", "do 2 rewrite <- S.find_spec.", "setoid_rewrite Heq.", "reflexivity.", "Qed.", "Definition for_all {A : Type} (f : key -> A -> bool) dom (m : t A dom) := fold (fun x v b => b && f x v) m true.", "Lemma for_all_spec_aux : forall dom A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall (m : t A dom) l b, fold_left (fun acc xv => acc && f (fst xv) (snd xv)) l b = true <-> b = true \u2227 (forall x (v : A), InA (X.eq * Logic.eq)%signature (x, v) l -> f x v = true).", "Proof.", "intros dom A f Hf m l.", "induction l as [| [x v] l]; intro b; simpl.", "*", "setoid_rewrite InA_nil.", "tauto.", "*", "rewrite IHl.", "split; intros [Hb Hl].", "+", "rewrite andb_true_iff in Hb.", "destruct Hb as [? Hb].", "split; trivial.", "intros x' v' Hin.", "inversion_clear Hin.", "-", "destruct H0 as [Heq\u2081 Heq\u2082].", "hnf in Heq\u2081, Heq\u2082.", "simpl in Heq\u2081, Heq\u2082.", "rewrite Heq\u2081, Heq\u2082.", "assumption.", "-", "apply Hl.", "assumption.", "+", "subst b.", "simpl.", "split; intros; apply Hl; solve [left; reflexivity | right; assumption].", "Qed.", "Lemma for_all_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom), for_all f m = true <-> forall x v, find x m = Some v -> f x v = true.", "Proof.", "intros A f Hf dom m.", "unfold for_all, find.", "rewrite fold_spec.", "change (\u2200 (x : key) (v : A), S.find x m = Some v \u2192 f x v = true) with (\u2200 (x : key) (v : A), S.find (fst (x, v)) m = Some (snd (x, v)) \u2192 f x v = true).", "setoid_rewrite <- elements_spec.", "rewrite for_all_spec_aux; tauto || eassumption.", "Qed.", "Definition exists_ {A : Type} (f : key -> A -> bool) dom (m : t A dom) := fold (fun x v b => b || f x v) m false.", "Lemma exists_spec_aux : forall dom A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall (m : t A dom) l b, fold_left (fun acc xv => acc || f (fst xv) (snd xv)) l b = true <-> b = true \u2228 (exists x (v : A), InA (X.eq * Logic.eq)%signature (x, v) l \u2227 f x v = true).", "Proof.", "intros dom A f Hf m l.", "induction l as [| [x v] l]; intro b; simpl.", "*", "setoid_rewrite InA_nil.", "firstorder.", "*", "rewrite IHl.", "split; intros [Hb | Hl].", "+", "rewrite orb_true_iff in Hb.", "destruct Hb as [Hb | Hb].", "-", "now left.", "-", "right.", "exists x, v.", "split; trivial.", "now left.", "+", "destruct Hl as [x' [v' [Hl Hfx]]].", "right.", "exists x', v'.", "split; trivial.", "now right.", "+", "subst b.", "now left.", "+", "destruct Hl as [x' [v' [Hl Hfx]]].", "inversion_clear Hl.", "-", "left.", "destruct H as [Heq\u2081 Heq\u2082].", "hnf in Heq\u2081, Heq\u2082.", "simpl in Heq\u2081, Heq\u2082.", "rewrite Heq\u2081, Heq\u2082 in Hfx.", "rewrite Hfx.", "apply orb_b_true.", "-", "right.", "exists x', v'.", "split; trivial.", "Qed.", "Lemma exists_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom), exists_ f m = true <-> exists x v, find x m = Some v \u2227 f x v = true.", "Proof.", "intros A f Hf dom m.", "unfold exists_, find.", "rewrite fold_spec.", "change (exists x (v : A), S.find x m = Some v \u2227 f x v = true) with (exists x (v : A), S.find (fst (x, v)) m = Some (snd (x, v)) \u2227 f x v = true).", "setoid_rewrite <- elements_spec.", "rewrite exists_spec_aux; intuition discriminate || eassumption.", "Qed.", "End DepMapFactsOn."], "theorems": [{"name": "eq_refl", "kind": "Instance", "begin": 12, "end": 16}, {"name": "eq_sym", "kind": "Lemma", "begin": 17, "end": 22}, {"name": "eq_trans", "kind": "Lemma", "begin": 23, "end": 28}, {"name": "eq_equiv", "kind": "Instance", "begin": 29, "end": 44}, {"name": "incl_refl", "kind": "Instance", "begin": 46, "end": 50}, {"name": "incl_trans", "kind": "Lemma", "begin": 51, "end": 55}, {"name": "incl_preorder", "kind": "Instance", "begin": 56, "end": 64}, {"name": "eq_incl_compat", "kind": "Instance", "begin": 65, "end": 92}, {"name": "mem_compat", "kind": "Instance", "begin": 93, "end": 111}, {"name": "find_compat", "kind": "Theorem", "begin": 112, "end": 118}, {"name": "find_compat2", "kind": "Instance", "begin": 119, "end": 123}, {"name": "set_compat", "kind": "Theorem", "begin": 125, "end": 138}, {"name": "set_compat2", "kind": "Instance", "begin": 139, "end": 144}, {"name": "add_compat", "kind": "Theorem", "begin": 145, "end": 159}, {"name": "add_compat2", "kind": "Instance", "begin": 160, "end": 166}, {"name": "remove_compat", "kind": "Theorem", "begin": 167, "end": 181}, {"name": "remove_compat2", "kind": "Instance", "begin": 182, "end": 187}, {"name": "find_None", "kind": "Theorem", "begin": 188, "end": 203}, {"name": "find_dom", "kind": "Corollary", "begin": 204, "end": 209}, {"name": "set_Some", "kind": "Theorem", "begin": 210, "end": 236}, {"name": "set_None", "kind": "Theorem", "begin": 237, "end": 252}, {"name": "add_Some", "kind": "Theorem", "begin": 253, "end": 279}, {"name": "add_None", "kind": "Theorem", "begin": 280, "end": 295}, {"name": "remove_Some", "kind": "Theorem", "begin": 296, "end": 311}, {"name": "remove_None", "kind": "Theorem", "begin": 312, "end": 330}, {"name": "add_cancel", "kind": "Theorem", "begin": 331, "end": 340}, {"name": "remove_cancel", "kind": "Theorem", "begin": 341, "end": 350}, {"name": "add_merge", "kind": "Theorem", "begin": 351, "end": 360}, {"name": "add_comm", "kind": "Theorem", "begin": 361, "end": 375}, {"name": "remove_add_cancel", "kind": "Theorem", "begin": 376, "end": 385}, {"name": "map_None", "kind": "Theorem", "begin": 386, "end": 404}, {"name": "combine_None", "kind": "Theorem", "begin": 405, "end": 446}, {"name": "add_incl", "kind": "Theorem", "begin": 447, "end": 456}, {"name": "remove_incl", "kind": "Theorem", "begin": 457, "end": 462}, {"name": "cast_spec", "kind": "Theorem", "begin": 463, "end": 467}, {"name": "eq_dom", "kind": "Lemma", "begin": 468, "end": 474}, {"name": "for_all_spec_aux", "kind": "Lemma", "begin": 476, "end": 505}, {"name": "for_all_spec", "kind": "Lemma", "begin": 506, "end": 514}, {"name": "exists_spec_aux", "kind": "Lemma", "begin": 516, "end": 560}, {"name": "exists_spec", "kind": "Lemma", "begin": 561, "end": 569}]}