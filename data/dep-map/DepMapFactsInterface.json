{"code": ["Require Import Utf8.", "Require Import Orders.", "Require Import Coqlib.", "Require Import DepMapInterface.", "Set Implicit Arguments.", "Module Type DepMapFacts (X : OrderedType).", "Include DepMap(X).", "Definition eq {A : Type} {dom\u2081 dom\u2082} (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) := forall x, find x m\u2081 = find x m\u2082.", "Definition incl {A : Type} {dom\u2081 dom\u2082} (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) := forall x v, find x m\u2081 = Some v -> find x m\u2082 = Some v.", "Declare Instance eq_refl : forall A dom, Reflexive (@eq A dom dom).", "Parameter eq_sym : forall A dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), eq m\u2081 m\u2082 -> eq m\u2082 m\u2081.", "Parameter eq_trans : forall A dom\u2081 dom\u2082 dom3 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) (m3 : t A dom3), eq m\u2081 m\u2082 -> eq m\u2082 m3 -> eq m\u2081 m3.", "Declare Instance eq_equiv : forall A dom, Equivalence (@eq A dom dom).", "Declare Instance incl_refl : forall A dom (m : t A dom), Reflexive (@incl A dom dom).", "Parameter incl_trans : forall A dom\u2081 dom\u2082 dom3 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) (m3 : t A dom3), incl m\u2081 m\u2082 -> incl m\u2082 m3 -> incl m\u2081 m3.", "Declare Instance incl_preorder : forall A dom, PreOrder (@incl A dom dom).", "Declare Instance eq_incl_compat : forall A dom, PartialOrder (@eq A dom dom) (@incl A dom dom).", "Declare Instance mem_compat (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@mem A dom).", "Parameter find_compat : forall A x y dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> find x m\u2081 = find y m\u2082.", "Declare Instance find_compat2 (A : Type) dom : Proper (X.eq ==> @eq A dom dom ==> Logic.eq) (@find A dom).", "Arguments set {A} {dom} x v m _.", "Parameter set_compat : forall A x y v dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082) (Hin\u2081 : Dom.In x dom\u2081) (Hin\u2082 : Dom.In y dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> eq (set x v m\u2081 Hin\u2081) (set y v m\u2082 Hin\u2082).", "Declare Instance set_compat2 (A : Type) x dom : Proper (Logic.eq ==> @eq A dom dom ==> full_relation ==> @eq A dom dom) (@set A dom x).", "Parameter add_compat : forall A x y v dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> eq (add x v m\u2081) (add y v m\u2082).", "Declare Instance add_compat2 (A : Type) x dom : Proper (Logic.eq ==> @eq A dom dom ==> @eq A (Dom.add x dom) (Dom.add x dom)) (@add A dom x).", "Parameter remove_compat : forall A x y dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), X.eq x y -> eq m\u2081 m\u2082 -> eq (remove x m\u2081) (remove y m\u2082).", "Declare Instance remove_compat2 (A : Type) x dom : Proper (@eq A dom dom ==> @eq A (Dom.remove x dom) (Dom.remove x dom)) (@remove A dom x).", "Parameter find_None : forall A dom x (m : t A dom), find x m = None <-> \u00acDom.In x dom.", "Parameter find_dom : forall A x v dom (m : t A dom), find x m = Some v -> Dom.In x dom.", "Parameter set_Some : forall A x y v u dom (m : t A dom) (Hin : Dom.In x dom), find y (set x v m Hin) = Some u <-> X.eq y x \u2227 u = v \u2228 \u00acX.eq y x \u2227 find y m = Some u.", "Parameter set_None : forall A x y v dom (m : t A dom) (Hin : Dom.In x dom), find y (set x v m Hin) = None <-> \u00acX.eq y x \u2227 find y m = None.", "Parameter add_Some : forall A x y v u dom (m : t A dom), find y (add x v m) = Some u <-> X.eq y x \u2227 u = v \u2228 \u00acX.eq y x \u2227 find y m = Some u.", "Parameter add_None : forall A x y v dom (m : t A dom), find y (add x v m) = None <-> \u00acX.eq y x \u2227 find y m = None.", "Parameter remove_Some : forall A x y u dom (m : t A dom), find y (remove x m) = Some u <-> \u00acX.eq y x \u2227 find y m = Some u.", "Parameter remove_None : forall A x y dom (m : t A dom), find y (remove x m) = None <-> X.eq y x \u2228 find y m = None.", "Parameter add_cancel : forall A x v dom (m : t A dom), find x m = Some v -> eq (add x v m) m.", "Parameter remove_cancel : forall A x dom (m : t A dom), find x m = None -> eq (remove x m) m.", "Parameter add_merge : forall A x v\u2081 v\u2082 dom (m : t A dom), eq (add x v\u2082 (add x v\u2081 m)) (add x v\u2082 m).", "Parameter add_comm : forall A x y v\u2081 v\u2082 dom (m : t A dom), \u00acX.eq x y -> eq (add y v\u2082 (add x v\u2081 m)) (add x v\u2081 (add y v\u2082 m)).", "Parameter remove_add_cancel : forall A s v dom (m : t A dom), eq (remove s (add s v m)) (remove s m).", "Parameter map_None : forall A B (f : A -> B) dom (m : t A dom) x, find x (map f m) = None <-> \u00acDom.In x dom.", "Parameter combine_None : forall A B C (f : A -> B -> C) g\u2081 g\u2082 dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t B dom\u2082) x, find x (combine f g\u2081 g\u2082 m\u2081 m\u2082) = None <-> find x m\u2081 = None \u2227 find x m\u2082 = None.", "Parameter add_incl : forall A x v dom (m : t A dom), \u00acDom.In x dom -> incl m (add x v m).", "Parameter remove_incl : forall A x dom (m : t A dom), incl (remove x m) m.", "Parameter cast_spec : forall A dom\u2081 dom\u2082 (Heq : Dom.eq dom\u2081 dom\u2082) (m : t A dom\u2081), eq (cast Heq m) m.", "Parameter eq_dom : forall A dom\u2081 dom\u2082 (m\u2081 : t A dom\u2081) (m\u2082 : t A dom\u2082), eq m\u2081 m\u2082 -> Dom.eq dom\u2081 dom\u2082.", "Parameter for_all : forall {A}, (key -> A -> bool) -> forall {dom}, t A dom -> bool.", "Parameter for_all_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom), for_all f m = true <-> forall x v, find x m = Some v -> f x v = true.", "Parameter exists_ : forall {A}, (key -> A -> bool) -> forall {dom}, t A dom -> bool.", "Parameter exists_spec : forall A f, Proper (X.eq ==> Logic.eq ==> Logic.eq) f -> forall dom (m : t A dom), exists_ f m = true <-> exists x v, find x m = Some v \u2227 f x v = true.", "End DepMapFacts."], "theorems": []}