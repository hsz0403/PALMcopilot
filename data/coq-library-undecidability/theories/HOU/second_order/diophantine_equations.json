{"code": ["Require Import Arith Lia List.", "From Undecidability.HOU Require Import std.std calculus.prelim.", "Import ListNotations.", "Inductive deq := | Con (x: nat) | Add (x y z: nat) | Mul (x y z: nat).", "Notation \"x =\u2091 1\" := (Con x) (at level 66).", "Notation \"x +\u2091 y =\u2091 z\" := (Add x y z) (at level 66, y at next level).", "Notation \"x *\u2091 y =\u2091 z\" := (Mul x y z) (at level 66, y at next level).", "Reserved Notation \"sigma \u22a2\u2091 e\" (at level 60, e at level 99).", "Inductive sol (sigma: nat -> nat) : deq -> Prop := | solC x: sigma x = 1 -> sigma \u22a2\u2091 x =\u2091 1 | solA x y z: sigma x + sigma y = sigma z -> sigma \u22a2\u2091 x +\u2091 y =\u2091 z | solM x y z: sigma x * sigma y = sigma z -> sigma \u22a2\u2091 x *\u2091 y =\u2091 z where \"sigma \u22a2\u2091 e\" := (sol sigma e).", "Definition Sol (sigma: nat -> nat) (E: list deq) := forall e, e \u2208 E -> sigma \u22a2\u2091 e.", "Notation \"sigma \u22a2\u207a\u2091 E\" := (Sol sigma E) (at level 60, E at level 99).", "Definition H10 (E: list deq) := exists sigma, sigma \u22a2\u207a\u2091 E.", "Definition vars__de (e: deq) := match e with | x =\u2091 1 => [x] | x +\u2091 y =\u2091 z => [x; y; z] | x *\u2091 y =\u2091 z => [x; y; z] end.", "Definition Vars__de E := nodup Nat.eq_dec (flat_map vars__de E).", "Lemma Vars__de_in e E: e \u2208 E -> forall y, y \u2208 vars__de e -> y \u2208 Vars__de E.", "Proof.", "unfold Vars__de; intros; eapply nodup_In, in_flat_map.", "exists e.", "intuition.", "Qed."], "theorems": [{"name": "Vars__de_in", "kind": "Lemma", "begin": 14, "end": 19}]}