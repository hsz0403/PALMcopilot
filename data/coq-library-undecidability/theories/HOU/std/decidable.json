{"code": ["Set Implicit Arguments.", "Set Default Proof Using \"Type\".", "Class Dec (P: Prop) := dec: {P} + {~P}.", "Arguments dec _ {_}.", "Class Dec1 {X} (p: X -> Prop) := dec1: forall x, Dec (p x).", "Arguments dec1 {_} _ {_}.", "Class Dec2 {X Y} (p: X -> Y -> Prop) := dec2: forall x, Dec1 (p x).", "Arguments dec2 {_} {_} _ {_}.", "Instance dec_conj P Q: Dec P -> Dec Q -> Dec (P /\\ Q).", "Proof.", "intros [p|np] [q|nq]; firstorder.", "Qed.", "Instance dec_disj P Q: Dec P -> Dec Q -> Dec (P \\/ Q).", "Proof.", "intros [p|np] [q|nq]; firstorder.", "Qed.", "Instance dec_imp P Q: Dec P -> Dec Q -> Dec (P -> Q).", "Proof.", "intros [p|np] [q|nq]; firstorder.", "Qed.", "Instance dec_iff P Q: Dec P -> Dec Q -> Dec (P <-> Q).", "Proof.", "intros; unfold iff; typeclasses eauto.", "Qed.", "Instance dec_neg P: Dec P -> Dec (~ P).", "Proof.", "intros [p|np]; firstorder.", "Qed.", "Lemma iff_dec P Q: Q <-> P -> Dec P -> Dec Q.", "Proof.", "firstorder.", "Qed.", "Instance dec1_dec X P (x: X): Dec1 P -> (Dec (P x)).", "Proof.", "intros H; apply H.", "Qed.", "Instance dec1_conj X (P: X -> Prop) (Q: X -> Prop): Dec1 P -> Dec1 Q -> Dec1 (fun x => P x /\\ Q x).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec1_disj X (P: X -> Prop) (Q: X -> Prop): Dec1 P -> Dec1 Q -> Dec1 (fun x => P x \\/ Q x).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec1_imp X (P: X -> Prop) (Q: X -> Prop): Dec1 P -> Dec1 Q -> Dec1 (fun x => P x -> Q x).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec1_iff X (P: X -> Prop) (Q: X -> Prop): Dec1 P -> Dec1 Q -> Dec1 (fun x => P x <-> Q x).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec1_neg X (P: X -> Prop): Dec1 P -> Dec1 (fun x => ~ P x).", "Proof.", "intros Hq x; typeclasses eauto.", "Qed.", "Instance dec2_dec1 X Y (P: X -> Y -> Prop) x: Dec2 P -> Dec1 (P x).", "Proof.", "intros H; apply H.", "Qed.", "Instance dec2_dec1' X Y (P: X -> Y -> Prop) y: Dec2 P -> Dec1 (fun x => P x y).", "Proof.", "intros H x; apply H.", "Qed.", "Instance dec2_conj X Y (P: X -> Y -> Prop) (Q: X -> Y -> Prop): Dec2 P -> Dec2 Q -> Dec2 (fun x y => P x y /\\ Q x y).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec2_disj X Y (P: X -> Y -> Prop) (Q: X -> Y -> Prop): Dec2 P -> Dec2 Q -> Dec2 (fun x y => P x y \\/ Q x y).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec2_imp X Y (P: X -> Y -> Prop) (Q: X -> Y -> Prop): Dec2 P -> Dec2 Q -> Dec2 (fun x y => P x y -> Q x y).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec2_iff X Y (P: X -> Y -> Prop) (Q: X -> Y -> Prop): Dec2 P -> Dec2 Q -> Dec2 (fun x y => P x y <-> Q x y).", "Proof.", "intros Hp Hq x; typeclasses eauto.", "Qed.", "Instance dec2_neg X Y (P: X -> Y -> Prop): Dec2 P -> Dec2 (fun x y => ~ P x y).", "Proof.", "intros Hq x; typeclasses eauto.", "Qed.", "Section DecBool.", "Definition decb P {D: Dec P} := if dec P then true else false.", "Arguments decb _ {_}.", "Definition decb1 {X: Type} (Q: X -> Prop) {D: Dec1 Q} x := decb (Q x).", "Arguments decb1 {_} _ {_} _.", "Definition decb2 {X Y: Type} (R: X -> Y -> Prop) {D: Dec2 R} x := decb1 (R x).", "Arguments decb2 {_} {_} _ {_} _.", "Lemma dec_decb (P: Prop) {D: Dec P}: P -> decb P = true.", "Proof.", "unfold decb; destruct (dec P); intuition; discriminate.", "Qed.", "Lemma decb_dec (P: Prop) {D: Dec P}: decb P = true -> P.", "Proof.", "unfold decb; destruct (dec P); intuition; discriminate.", "Qed.", "End DecBool.", "Hint Resolve dec_decb : core.", "Arguments decb _ {_}.", "Arguments decb1 {_} _ {_} _.", "Arguments decb2 {_} {_} _ {_} _.", "Class Dis (X: Type) := eq_dec: Dec2 (@eq X).", "Notation \"a == b\" := (eq_dec a b) (at level 60).", "Instance dis_dec X (D: Dis X): Dec2 (@eq X).", "Proof.", "firstorder.", "Qed.", "Instance discrete_False: Dis False.", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "Qed.", "Instance discrete_unit: Dis unit.", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "Qed.", "Instance discrete_nat: Dis nat.", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "Qed.", "Instance discrete_bool: Dis bool.", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "Qed.", "Instance discrete_option (X: Type) {D: Dis X}: Dis (option X).", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "eapply eq_dec.", "Qed.", "Instance discrete_sum (X Y: Type) {D1: Dis X} {D2: Dis Y}: Dis (X + Y).", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "all: eapply eq_dec.", "Qed.", "Instance discrete_prod (X Y: Type) {D1: Dis X} {D2: Dis Y}: Dis (X * Y).", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "all: eapply eq_dec.", "Qed.", "Instance discrete_list (X: Type) {D: Dis X}: Dis (list X).", "Proof.", "unfold Dis, Dec2, Dec1, Dec; decide equality.", "eapply eq_dec.", "Qed.", "Require Import List Arith Lia.", "Instance In_dec (X: Type) {D: Dis X}: Dec2 (@In X).", "Proof.", "intros ??; eapply in_dec, eq_dec.", "Qed.", "Definition dec_in {X: Type} {D: Dis X} (x: X) (A: list X) := dec2 (@In X) x A.", "Notation \"x 'el' A\" := (dec_in x A) (at level 60).", "Instance lt_dec : Dec2 lt.", "Proof.", "intros ??; eapply lt_dec.", "Qed.", "Instance le_dec : Dec2 le.", "Proof.", "intros ??; eapply le_dec.", "Qed.", "Instance gt_dec : Dec2 gt.", "Proof.", "intros ??; eapply lt_dec.", "Qed.", "Instance ge_dec : Dec2 ge.", "Proof.", "intros ??; eapply le_dec.", "Qed.", "Instance dec_all Y (P: Y -> Prop) (D: Dec1 P): Dec1 (fun A => forall x, In x A -> P x).", "Proof.", "intros A.", "eapply iff_dec; [symmetry; eapply Forall_forall|].", "unfold Dec; eapply Forall_dec; eauto.", "Qed."], "theorems": [{"name": "dec_conj", "kind": "Instance", "begin": 8, "end": 11}, {"name": "dec_disj", "kind": "Instance", "begin": 12, "end": 15}, {"name": "dec_imp", "kind": "Instance", "begin": 16, "end": 19}, {"name": "dec_iff", "kind": "Instance", "begin": 20, "end": 23}, {"name": "dec_neg", "kind": "Instance", "begin": 24, "end": 27}, {"name": "iff_dec", "kind": "Lemma", "begin": 28, "end": 31}, {"name": "dec1_dec", "kind": "Instance", "begin": 32, "end": 35}, {"name": "dec1_conj", "kind": "Instance", "begin": 36, "end": 39}, {"name": "dec1_disj", "kind": "Instance", "begin": 40, "end": 43}, {"name": "dec1_imp", "kind": "Instance", "begin": 44, "end": 47}, {"name": "dec1_iff", "kind": "Instance", "begin": 48, "end": 51}, {"name": "dec1_neg", "kind": "Instance", "begin": 52, "end": 55}, {"name": "dec2_dec1", "kind": "Instance", "begin": 56, "end": 59}, {"name": "dec2_dec1'", "kind": "Instance", "begin": 60, "end": 63}, {"name": "dec2_conj", "kind": "Instance", "begin": 64, "end": 67}, {"name": "dec2_disj", "kind": "Instance", "begin": 68, "end": 71}, {"name": "dec2_imp", "kind": "Instance", "begin": 72, "end": 75}, {"name": "dec2_iff", "kind": "Instance", "begin": 76, "end": 79}, {"name": "dec2_neg", "kind": "Instance", "begin": 80, "end": 83}, {"name": "dec_decb", "kind": "Lemma", "begin": 91, "end": 94}, {"name": "decb_dec", "kind": "Lemma", "begin": 95, "end": 98}, {"name": "dis_dec", "kind": "Instance", "begin": 106, "end": 109}, {"name": "discrete_False", "kind": "Instance", "begin": 110, "end": 113}, {"name": "discrete_unit", "kind": "Instance", "begin": 114, "end": 117}, {"name": "discrete_nat", "kind": "Instance", "begin": 118, "end": 121}, {"name": "discrete_bool", "kind": "Instance", "begin": 122, "end": 125}, {"name": "discrete_option", "kind": "Instance", "begin": 126, "end": 130}, {"name": "discrete_sum", "kind": "Instance", "begin": 131, "end": 135}, {"name": "discrete_prod", "kind": "Instance", "begin": 136, "end": 140}, {"name": "discrete_list", "kind": "Instance", "begin": 141, "end": 145}, {"name": "In_dec", "kind": "Instance", "begin": 147, "end": 150}, {"name": "lt_dec", "kind": "Instance", "begin": 153, "end": 156}, {"name": "le_dec", "kind": "Instance", "begin": 157, "end": 160}, {"name": "gt_dec", "kind": "Instance", "begin": 161, "end": 164}, {"name": "ge_dec", "kind": "Instance", "begin": 165, "end": 168}, {"name": "dec_all", "kind": "Instance", "begin": 169, "end": 174}]}