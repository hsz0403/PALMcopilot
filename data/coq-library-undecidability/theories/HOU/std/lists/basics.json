{"code": ["Set Implicit Arguments.", "Require Import List Arith Lia Morphisms FinFun Init.Wf.", "From Undecidability.HOU Require Import std.decidable.", "Import ListNotations.", "Set Default Proof Using \"Type\".", "Arguments incl {_} _ _.", "Definition seteq {X: Type} (A B: list X) := incl A B /\\ incl B A.", "Definition strict_incl {X: Type} (A B: list X) := incl A B /\\ exists x, In x B /\\ ~ In x A.", "Notation \"a \u2208 A\" := (In a A) (at level 70).", "Notation \"A \u2286 B\" := (incl A B) (at level 70).", "Notation \"A \u228a B\" := (strict_incl A B) (at level 70).", "Notation \"A === B\" := (seteq A B) (at level 70).", "Notation \"| A |\" := (length A) (at level 65).", "Section BasicLemmas.", "Variable X Y: Type.", "Implicit Type f: X -> Y.", "Implicit Type p: X -> bool.", "Implicit Type A B C : list X.", "Implicit Type a b c : X.", "Lemma incl_refl A: A \u2286 A.", "Proof.", "firstorder.", "Qed.", "Lemma incl_trans A B C: A \u2286 B -> B \u2286 C -> A \u2286 C.", "Proof.", "firstorder.", "Qed.", "Lemma strict_incl_trans A B C: A \u228a B -> B \u228a C -> A \u228a C.", "Proof.", "firstorder.", "Qed.", "Lemma strict_incl_incl_trans A B C: A \u228a B -> B \u2286 C -> A \u228a C.", "Proof.", "firstorder.", "Qed.", "Lemma incl_strict_incl_trans A B C: A \u2286 B -> B \u228a C -> A \u228a C.", "Proof.", "firstorder.", "Qed.", "Lemma seteq_refl A: A === A.", "Proof.", "firstorder.", "Qed.", "Lemma seteq_trans A B C: A === B -> B === C -> A === C.", "Proof.", "firstorder.", "Qed.", "Lemma seteq_sym A B: A === B -> B === A.", "Proof.", "firstorder.", "Qed.", "Global Instance incl_preorder: PreOrder (@incl X).", "Proof.", "firstorder.", "Qed.", "Global Instance strict_incl_transitive: Transitive (@strict_incl X).", "Proof.", "firstorder.", "Qed.", "Global Instance seteq_preorder: PreOrder (@seteq X).", "Proof.", "firstorder.", "Qed.", "Global Instance seteq_equivalence: Equivalence (@seteq X).", "Proof.", "firstorder.", "Qed.", "Hint Resolve incl_refl seteq_refl : listdb.", "Lemma in_ind e (P: list X -> Prop): (forall A, P (e :: A)) -> (forall a A, P A -> P (a :: A)) -> forall A, e \u2208 A -> P A.", "Proof.", "intros BH IH; induction A; cbn; intuition; subst; intuition.", "Qed.", "Global Instance proper_in_incl: Proper (eq ++> incl ==> Basics.impl) (@In X).", "Proof.", "intros ?? -> ???.", "firstorder.", "Qed.", "Global Instance in_seteq_proper: Proper (eq ++> seteq ++> iff) (@In X).", "Proof.", "intros ?? -> ???.", "firstorder.", "Qed.", "Global Instance subrel_incl_seteq: subrelation seteq (@incl X).", "Proof.", "intros ??; firstorder.", "Qed.", "Global Instance incl_seteq_proper: Proper (seteq ++> seteq ++> iff) (@incl X).", "Proof.", "firstorder.", "Qed.", "Lemma incl_app A B C: A ++ B \u2286 C <-> A \u2286 C /\\ B \u2286 C.", "Proof.", "induction A; firstorder.", "Qed.", "Lemma seteq_incl_left A B: A === B -> A \u2286 B.", "Proof.", "firstorder.", "Qed.", "Lemma seteq_incl_right A B: A === B -> B \u2286 A.", "Proof.", "firstorder.", "Qed.", "Lemma incl_seteq A B: A \u2286 B -> B \u2286 A -> A === B.", "Proof.", "firstorder.", "Qed.", "Lemma incl_nil A: nil \u2286 A.", "Proof.", "intros x [].", "Qed.", "Lemma incl_cons a A B: a :: A \u2286 B <-> a \u2208 B /\\ A \u2286 B.", "Proof.", "split; unfold incl; firstorder; congruence.", "Qed.", "Lemma incl_cons_build a A B: a \u2208 B -> A \u2286 B -> a :: A \u2286 B.", "Proof.", "intuition.", "Qed.", "Lemma incl_cons_project_l a A B: a :: A \u2286 B -> a \u2208 B.", "Proof.", "intuition.", "Qed.", "Lemma incl_cons_project_r a A B: a :: A \u2286 B -> A \u2286 B.", "Proof.", "firstorder.", "Qed.", "Lemma incl_cons_drop b A B : A \u2286 B -> A \u2286 b :: B.", "Proof.", "firstorder.", "Qed.", "Lemma incl_filter p A: filter p A \u2286 A.", "Proof.", "induction A as [|a A]; cbn; try destruct (p a); firstorder.", "Qed.", "Lemma incl_distr_left A B C: A \u2286 B -> A \u2286 B ++ C.", "Proof.", "intuition.", "Qed.", "Lemma incl_distr_right A B C: A \u2286 C -> A \u2286 B ++ C.", "Proof.", "intuition.", "Qed.", "Lemma incl_app_project_left A B C: A ++ B \u2286 C -> A \u2286 C.", "Proof.", "intros H x Hx.", "eapply H, in_app_iff.", "eauto.", "Qed.", "Lemma incl_app_project_right A B C: A ++ B \u2286 C -> B \u2286 C.", "Proof.", "intros H x Hx.", "eapply H, in_app_iff.", "eauto.", "Qed.", "Lemma incl_app_build A B C: A \u2286 C -> B \u2286 C -> A ++ B \u2286 C.", "Proof.", "intros; eapply incl_app; intuition.", "Qed.", "Global Instance incl_cons_proper: Proper (eq ++> incl ++> incl) (@cons X).", "Proof.", "intros ??-> ???; firstorder.", "Qed.", "Global Instance seteq_cons_proper: Proper (eq ++> seteq ++> seteq) (@cons X).", "Proof.", "intros ??-> ???; firstorder.", "Qed.", "Hint Resolve incl_seteq seteq_incl_left seteq_incl_right incl_nil incl_cons incl_cons_build incl_cons_project_l incl_cons_project_r incl_cons_drop incl_filter incl_distr_left incl_distr_right incl_app_project_left incl_app_project_right incl_app_build : listdb.", "Lemma strict_incl_incl A B: A \u228a B -> A \u2286 B.", "Proof.", "firstorder.", "Qed.", "Lemma incl_strict_incl x A B: x \u2208 A -> ~ x \u2208 B -> A \u2286 B -> A \u228a B.", "Proof.", "firstorder.", "Qed.", "Lemma strict_incl_eq A B: A \u228a B -> ~ A === B.", "Proof.", "firstorder.", "Qed.", "Lemma strict_incl_project A B: A \u228a B -> exists x, x \u2208 B /\\ ~ x \u2208 A.", "Proof.", "firstorder.", "Qed.", "Global Instance strict_incl_incl_subrel: subrelation (@strict_incl X) (@incl X).", "Proof.", "firstorder.", "Qed.", "Section WellFoundedStrictInclusion.", "Context {D: Dis X}.", "Lemma nodup_seteq A: nodup D A === A.", "Proof.", "split; intros ?; eapply nodup_In; eauto.", "Qed.", "Lemma wf_strict_incl: well_founded (@strict_incl X).", "Proof using D.", "eapply well_founded_lt_compat with (f := fun A => length (nodup eq_dec A)).", "intros A B [H [x [H1 H2]]].", "assert (nodup eq_dec A \u2286 nodup eq_dec B) as H3 by now rewrite !nodup_seteq.", "eapply NoDup_incl_length in H3 as H4; [| eapply NoDup_nodup].", "eapply le_lt_or_eq in H4 as []; eauto; exfalso.", "eapply NoDup_length_incl in H3.", "rewrite !nodup_seteq in H3; intuition.", "eapply NoDup_nodup.", "lia.", "Qed.", "End WellFoundedStrictInclusion.", "Global Instance proper_app_incl: Proper (incl ++> incl ++> incl) (@app X).", "Proof.", "intros A A' H1 B B' H2; induction A; firstorder auto with *.", "Qed.", "Global Instance proper_app_seteq: Proper (seteq ++> seteq ++> seteq) (@app X).", "Proof.", "intros A A' [H1 H2] B B' [H3 H4].", "split; eapply proper_app_incl; firstorder.", "Qed.", "Hint Rewrite app_nil_l app_nil_r : listdb.", "Hint Rewrite <- app_comm_cons : listdb.", "Hint Rewrite -> in_app_iff : listdb.", "Lemma app_comm A B: A ++ B === B ++ A.", "Proof.", "split; intros ?; autorewrite with listdb; firstorder.", "Qed.", "Lemma rev_seteq A: rev A === A.", "Proof.", "induction A; cbn; autorewrite with listdb; intuition.", "Qed.", "Global Instance proper_incl_seteq: Proper (@seteq X ++> @seteq X ++> iff) incl.", "Proof.", "intros ??????; firstorder.", "Qed.", "Global Instance proper_rev_incl: Proper (incl ++> incl) (@rev X).", "Proof.", "intros A B H.", "now rewrite rev_seteq, H, rev_seteq.", "Qed.", "Global Instance proper_rev_seteq: Proper (seteq ++> seteq) (@rev X).", "Proof.", "intros A B [H1 H2]; split; eapply proper_rev_incl; eauto.", "Qed.", "Hint Rewrite rev_seteq rev_involutive rev_length rev_app_distr : listdb.", "Lemma map_id_list (g: X -> X) A: (forall x, x \u2208 A -> g x = x) -> map g A = A.", "Proof.", "intros.", "induction A; cbn in *; eauto.", "rewrite H; intuition.", "rewrite IHA; firstorder.", "Qed.", "Lemma map_id A: map id A = A.", "Proof.", "induction A; unfold id in *; cbn; congruence.", "Qed.", "Lemma map_nil f: map f nil = nil.", "Proof.", "reflexivity.", "Qed.", "Global Instance map_incl_proper : Proper (eq ++> incl ++> incl) (@map Y X).", "Proof.", "intros ?? -> A B H.", "induction A; cbn; eauto with listdb.", "eapply incl_cons_build; firstorder.", "eapply in_map; firstorder.", "Qed.", "Global Instance map_seteq_proper : Proper (eq ++> seteq ++> seteq) (@map Y X).", "Proof.", "intros ?? -> A B [H1 H2]; split; apply map_incl_proper; firstorder.", "Qed.", "Hint Rewrite map_id map_rev map_nil map_cons map_app map_length : listdb.", "Hint Resolve in_map : listdb.", "Hint Rewrite app_length map_length rev_length : listdb.", "Lemma filter_length p A: length (filter p A) <= length A.", "Proof.", "induction A; cbn; [ constructor | ]; destruct (p a); cbn; lia.", "Qed.", "Global Instance filter_incl_proper: Proper (eq ++> incl ++> incl) (@filter X).", "Proof.", "intros ?? -> A B H2; induction A; cbn; eauto with listdb.", "destruct y eqn: H1; eauto with listdb.", "eapply incl_cons_build; eauto with listdb.", "eapply filter_In; intuition.", "Qed.", "Global Instance filter_seqteq_proper: Proper (eq ++> seteq ++> seteq) (@filter X).", "Proof.", "intros f g -> A B [H2 H3]; split; apply filter_incl_proper; firstorder.", "Qed.", "End BasicLemmas.", "Hint Resolve incl_refl seteq_refl : listdb.", "Hint Resolve incl_seteq seteq_incl_left seteq_incl_right incl_nil incl_cons incl_cons_build incl_cons_project_l incl_cons_project_r incl_cons_drop incl_filter incl_distr_left incl_distr_right incl_app_project_left incl_app_project_right incl_app_build : listdb.", "Hint Rewrite -> in_app_iff : listdb.", "Hint Rewrite <- app_comm_cons : listdb.", "Hint Rewrite app_nil_l app_nil_r : listdb.", "Hint Rewrite rev_seteq rev_involutive rev_length rev_app_distr : listdb.", "Hint Rewrite map_id map_rev map_nil map_cons map_app : listdb.", "Hint Resolve in_map : listdb.", "Hint Rewrite app_length map_length rev_length : listdb.", "Hint Extern 4 => match goal with |[ H: ?x \u2208 nil |- _ ] => destruct H end : core.", "Ltac lsimpl := autorewrite with listdb.", "Tactic Notation \"lsimpl\" \"in\" hyp_list(H) := autorewrite with listdb in H.", "Tactic Notation \"lsimpl\" \"in\" \"*\" := autorewrite with listdb in *.", "Ltac lauto := eauto with listdb."], "theorems": [{"name": "incl_refl", "kind": "Lemma", "begin": 19, "end": 22}, {"name": "incl_trans", "kind": "Lemma", "begin": 23, "end": 26}, {"name": "strict_incl_trans", "kind": "Lemma", "begin": 27, "end": 30}, {"name": "strict_incl_incl_trans", "kind": "Lemma", "begin": 31, "end": 34}, {"name": "incl_strict_incl_trans", "kind": "Lemma", "begin": 35, "end": 38}, {"name": "seteq_refl", "kind": "Lemma", "begin": 39, "end": 42}, {"name": "seteq_trans", "kind": "Lemma", "begin": 43, "end": 46}, {"name": "seteq_sym", "kind": "Lemma", "begin": 47, "end": 50}, {"name": "in_ind", "kind": "Lemma", "begin": 68, "end": 71}, {"name": "incl_app", "kind": "Lemma", "begin": 90, "end": 93}, {"name": "seteq_incl_left", "kind": "Lemma", "begin": 94, "end": 97}, {"name": "seteq_incl_right", "kind": "Lemma", "begin": 98, "end": 101}, {"name": "incl_seteq", "kind": "Lemma", "begin": 102, "end": 105}, {"name": "incl_nil", "kind": "Lemma", "begin": 106, "end": 109}, {"name": "incl_cons", "kind": "Lemma", "begin": 110, "end": 113}, {"name": "incl_cons_build", "kind": "Lemma", "begin": 114, "end": 117}, {"name": "incl_cons_project_l", "kind": "Lemma", "begin": 118, "end": 121}, {"name": "incl_cons_project_r", "kind": "Lemma", "begin": 122, "end": 125}, {"name": "incl_cons_drop", "kind": "Lemma", "begin": 126, "end": 129}, {"name": "incl_filter", "kind": "Lemma", "begin": 130, "end": 133}, {"name": "incl_distr_left", "kind": "Lemma", "begin": 134, "end": 137}, {"name": "incl_distr_right", "kind": "Lemma", "begin": 138, "end": 141}, {"name": "incl_app_project_left", "kind": "Lemma", "begin": 142, "end": 147}, {"name": "incl_app_project_right", "kind": "Lemma", "begin": 148, "end": 153}, {"name": "incl_app_build", "kind": "Lemma", "begin": 154, "end": 157}, {"name": "strict_incl_incl", "kind": "Lemma", "begin": 167, "end": 170}, {"name": "incl_strict_incl", "kind": "Lemma", "begin": 171, "end": 174}, {"name": "strict_incl_eq", "kind": "Lemma", "begin": 175, "end": 178}, {"name": "strict_incl_project", "kind": "Lemma", "begin": 179, "end": 182}, {"name": "nodup_seteq", "kind": "Lemma", "begin": 189, "end": 192}, {"name": "wf_strict_incl", "kind": "Lemma", "begin": 193, "end": 204}, {"name": "app_comm", "kind": "Lemma", "begin": 218, "end": 221}, {"name": "rev_seteq", "kind": "Lemma", "begin": 222, "end": 225}, {"name": "map_id_list", "kind": "Lemma", "begin": 240, "end": 246}, {"name": "map_id", "kind": "Lemma", "begin": 247, "end": 250}, {"name": "map_nil", "kind": "Lemma", "begin": 251, "end": 254}, {"name": "filter_length", "kind": "Lemma", "begin": 269, "end": 272}]}