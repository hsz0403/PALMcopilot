{"code": ["Require Import List Lia.", "Import ListNotations.", "From Undecidability.HOU.calculus Require Import prelim terms syntax semantics equivalence typing order evaluator.", "Set Default Proof Using \"Type\".", "Section UnificationDefinitions.", "Context {X: Const}.", "Class uni := { Gamma\u1d64 : ctx; s\u1d64 : exp X; t\u1d64 : exp X; A\u1d64 : type; H1\u1d64 : Gamma\u1d64 \u22a2 s\u1d64 : A\u1d64; H2\u1d64 : Gamma\u1d64 \u22a2 t\u1d64 : A\u1d64 }.", "Definition U (I: uni) := exists (Delta: ctx) (sigma: fin -> exp X), Delta \u22a9 sigma : Gamma\u1d64 /\\ sigma \u2022 s\u1d64 \u2261 sigma \u2022 t\u1d64.", "End UnificationDefinitions.", "Arguments uni _ : clear implicits.", "Arguments U _ : clear implicits.", "Hint Resolve H1\u1d64 H2\u1d64 : core.", "Definition NU {X: Const} (I: uni X) := exists Delta sigma, Delta \u22a9 sigma : Gamma\u1d64 /\\ sigma \u2022 s\u1d64 \u2261 sigma \u2022 t\u1d64 /\\ forall x, normal (sigma x).", "Section Normalisation.", "Section SubstitutionTransformations.", "Variable (X: Const) (n: nat) (s t: exp X) (A: type) (Gamma: ctx).", "Hypothesis (Leq: 1 <= n).", "Hypothesis (T1: Gamma \u22a2(n) s : A) (T2: Gamma \u22a2(n) t : A).", "Implicit Types (Delta: ctx) (sigma : fin -> exp X).", "Lemma normalise_subst Delta sigma: Delta \u22a9 sigma : Gamma -> { tau | (forall x, sigma x >* tau x) /\\ (forall x, x \u2208 dom Gamma -> normal (tau x)) /\\ Delta \u22a9 tau : Gamma}.", "Proof.", "intros T.", "assert (forall x, x \u2208 dom Gamma -> { A | nth Gamma x = Some A }) as I.", "{", "intros x H1.", "destruct nth eqn: ?; eauto.", "exfalso.", "domin H1.", "congruence.", "}", "exists (fun x => match x el dom Gamma with | left H => eta (sigma x) (T _ _ (proj2_sig (I x H))) | right _ => sigma x end).", "split; [| split].", "1-2: intros x; destruct dec_in; intuition.", "eapply eta_correct.", "eapply eta_normal.", "intros x B H.", "destruct dec_in; intuition.", "destruct I; cbn.", "generalize (T x x0 e).", "rewrite H in e; injection e as ->.", "eapply eta_typing.", "Qed.", "End SubstitutionTransformations.", "Variable (X: Const).", "Arguments s\u1d64 {_} _.", "Arguments t\u1d64 {_} _.", "Arguments Gamma\u1d64 {_} _.", "Arguments A\u1d64 {_} _.", "Lemma U_NU I: U X I <-> NU I.", "Proof.", "split; intros (Delta & sigma & H1 & H2); [| exists Delta; exists sigma; intuition].", "eapply normalise_subst in H1 as (tau & H5 & H6 & H7).", "pose (theta x := if nth (Gamma\u1d64 I) x then tau x else var x).", "exists Delta.", "exists theta.", "intuition.", "+", "intros ???; unfold theta; rewrite H; eapply H7; eauto.", "+", "rewrite subst_pointwise_equiv with (sigma0 := theta) (tau0 := sigma).", "rewrite subst_pointwise_equiv with (sigma0 := theta) (tau0 := sigma); eauto.", "all: intros ? H; eapply typing_variables in H; eauto; domin H.", "all: unfold theta; now rewrite H, H5.", "+", "unfold theta; destruct nth eqn: ?; [|eauto].", "domin Heqo; eauto.", "Qed.", "Lemma U_reduction (I I': uni X): s\u1d64 I \u2261 s\u1d64 I' -> t\u1d64 I \u2261 t\u1d64 I' -> Gamma\u1d64 I = Gamma\u1d64 I' -> A\u1d64 I = A\u1d64 I' -> U X I -> U X I'.", "Proof.", "intros H1 H2 H3 H4; intros (Delta & sigma & T & N); exists Delta; exists sigma; split.", "rewrite <-H3; eauto.", "now rewrite <-H1, <-H2, N.", "Qed.", "Program Instance uni_normalise (I: uni X) : uni X := { Gamma\u1d64 := Gamma\u1d64 I; s\u1d64 := eta (s\u1d64 I) H1\u1d64; t\u1d64 := eta (t\u1d64 I) H2\u1d64; A\u1d64 := A\u1d64 I }.", "Next Obligation.", "eapply preservation_under_steps.", "rewrite <-eta_correct.", "all: eauto.", "Qed.", "Next Obligation.", "eapply preservation_under_steps.", "rewrite <-eta_correct.", "all: eauto.", "Qed.", "Lemma uni_normalise_correct I: U X I <-> U X (uni_normalise I).", "Proof.", "split; intros H; [eapply @U_reduction|eapply @U_reduction with (I := uni_normalise I)].", "all: eauto; cbn; eapply equiv_join.", "1, 3, 6, 8: rewrite eta_correct.", "all: reflexivity.", "Qed.", "End Normalisation."], "theorems": [{"name": "normalise_subst", "kind": "Lemma", "begin": 19, "end": 41}, {"name": "U_NU", "kind": "Lemma", "begin": 48, "end": 66}, {"name": "U_reduction", "kind": "Lemma", "begin": 67, "end": 72}, {"name": "uni_normalise_correct", "kind": "Lemma", "begin": 84, "end": 90}]}