{"code": ["From Coq Require List Vector.", "From Undecidability.L Require Import L Datatypes.Lists Datatypes.LNat.", "From Undecidability.TM Require Import TM Util.TM_facts.", "Import ListNotations Vector.VectorNotations.", "Definition encBoolsListTM {\u03a3 : Type} (s b : \u03a3) (l : list bool) := (map (fun (x : bool) => (if x then s else b)) l).", "Definition encBoolsTM {\u03a3 : Type} (s b : \u03a3) (l : list bool) := @midtape \u03a3 [] b (encBoolsListTM s b l).", "Definition encNatTM {\u03a3 : Type} (s b : \u03a3) (n : nat) := @midtape \u03a3 [] b (repeat s n).", "Definition TM_bool_computable {k} (R : Vector.t (list bool) k -> (list bool) -> Prop) := exists n : nat, exists \u03a3 : finType, exists s b : \u03a3, s <> b /\\ exists M : TM \u03a3 (1 + k + n), forall v : Vector.t (list bool) k, (forall m, R v m <-> exists q t, TM.eval M (start M) ((niltape :: Vector.map (encBoolsTM s b) v) ++ Vector.const niltape n) q t /\\ Vector.hd t = encBoolsTM s b m) /\\ (forall q t, TM.eval M (start M) ((niltape :: Vector.map (encBoolsTM s b) v) ++ Vector.const niltape n) q t -> exists m, Vector.hd t = encBoolsTM s b m).", "Definition TM_computable {k} (R : Vector.t nat k -> nat -> Prop) := exists n : nat, exists \u03a3 : finType, exists s b : \u03a3, s <> b /\\ exists M : TM \u03a3 (1 + k + n), forall v : Vector.t nat k, (forall m, R v m <-> exists q t, TM.eval M (start M) ((niltape :: Vector.map (encNatTM s b) v) ++ Vector.const niltape n) q t /\\ Vector.hd t = encNatTM s b m) /\\ (forall q t, TM.eval M (start M) ((niltape :: Vector.map (encNatTM s b) v) ++ Vector.const niltape n) q t -> exists m, Vector.hd t = encNatTM s b m).", "Definition TM\u2081_bool_computable {k} (\u03a3 : finType) (R : Vector.t (list bool) k -> (list bool) -> Prop) := exists s1 s2 b : \u03a3, s1 <> s2 /\\ s1 <> b /\\ s2 <> b /\\ exists M : TM \u03a3 1, forall v : Vector.t (list bool) k, (forall m, R v m <-> exists q, TM.eval M (start M) [midtape [] b (Vector.fold_right (fun l s => encBoolsListTM s1 s2 l ++ s)%list v List.nil)] q [encBoolsTM s1 s2 m]) /\\ (forall q t, TM.eval M (start M) [midtape [] b (Vector.fold_right (fun l s => encBoolsListTM s1 s2 l ++ s)%list v List.nil)] q t -> exists m, t = [encBoolsTM s1 s2 m]).", "Definition encBoolsL (l : list bool) := list_enc l.", "Definition L_bool_computable {k} (R : Vector.t (list bool) k -> (list bool) -> Prop) := exists s, forall v : Vector.t (list bool) k, (forall m, R v m <-> L.eval (Vector.fold_left (fun s n => L.app s (encBoolsL n)) s v) (encBoolsL m)) /\\ (forall o, L.eval (Vector.fold_left (fun s n => L.app s (encBoolsL n)) s v) o -> exists m, o = encBoolsL m).", "Definition encNatL (n : nat) := nat_enc n.", "Definition L_computable {k} (R : Vector.t nat k -> nat -> Prop) := exists s, forall v : Vector.t nat k, (forall m, R v m <-> L.eval (Vector.fold_left (fun s n => L.app s (encNatL n)) s v) (encNatL m)) /\\ (forall o, L.eval (Vector.fold_left (fun s n => L.app s (encNatL n)) s v) o -> exists m, o = encNatL m)."], "theorems": []}