{"code": ["Require Import List PeanoNat Lia.", "Import ListNotations.", "Require Import Undecidability.SetConstraints.FMsetC Undecidability.SetConstraints.Util.Facts.", "Require Import ssreflect ssrbool ssrfun.", "Set Default Goal Selector \"!\".", "Local Notation \"A \u2261 B\" := (mset_eq A B) (at level 65).", "Arguments mset_eq !A !B.", "Lemma eq_refl {A} : A \u2261 A.", "Proof.", "done.", "Qed.", "Lemma eq_eq {A B}: A = B -> A \u2261 B.", "Proof.", "by move=> ->.", "Qed.", "Lemma eq_symm {A B} : A \u2261 B -> B \u2261 A.", "Proof.", "by firstorder done.", "Qed.", "Lemma eq_in_iff {A B} : A \u2261 B -> forall c, In c A <-> In c B.", "Proof.", "rewrite /mset_eq => H c.", "constructor=> Hc.", "-", "have := iffLR (count_occ_In Nat.eq_dec A c) Hc.", "move: (H c) => ->.", "by move /(count_occ_In Nat.eq_dec B c).", "-", "have := iffLR (count_occ_In Nat.eq_dec B c) Hc.", "move: (H c) => <-.", "by move /(count_occ_In Nat.eq_dec A c).", "Qed.", "Lemma eq_nilE {A} : [] \u2261 A -> A = [].", "Proof.", "case: A; first done.", "move=> a A /eq_in_iff /(_ a) /iffRL.", "apply: unnest; [by left | done].", "Qed.", "Lemma eq_trans {A B C} : A \u2261 B -> B \u2261 C -> A \u2261 C.", "Proof.", "rewrite /mset_eq => + + c.", "move=> /(_ c) + /(_ c).", "by move=> -> ->.", "Qed.", "Lemma eq_Forall_iff {A B} : A \u2261 B -> forall P, (Forall P A <-> Forall P B).", "Proof.", "move /eq_in_iff => H P.", "rewrite ? Forall_forall.", "constructor; by firstorder done.", "Qed.", "Lemma eq_lr {A B A' B'}: A \u2261 A' -> B \u2261 B' -> (A \u2261 B) <-> (A' \u2261 B').", "Proof.", "move=> HA HB.", "constructor.", "-", "move /eq_trans.", "move /(_ _ HB).", "move /(eq_trans _).", "by move /(_ _ (eq_symm HA)).", "-", "move /eq_trans.", "move /(_ _ (eq_symm HB)).", "move /(eq_trans _).", "by move /(_ _ HA).", "Qed.", "Lemma eq_appI {A B A' B'} : A \u2261 A' -> B \u2261 B' -> A ++ B \u2261 A' ++ B'.", "Proof.", "rewrite /mset_eq => + + c.", "move=> /(_ c) + /(_ c).", "rewrite ? count_occ_app.", "by move=> -> ->.", "Qed.", "Ltac eq_trivial := move=> ?; rewrite ? (count_occ_app, count_occ_cons, count_occ_nil, eta_reduction); unlock; by lia.", "Lemma eq_cons_iff {a A B} : (a :: A) \u2261 (a :: B) <-> A \u2261 B.", "Proof.", "rewrite /mset_eq.", "constructor=> + c => /(_ c).", "all: rewrite -/([a] ++ A) -/([a] ++ B) ?count_occ_app; by lia.", "Qed.", "Lemma eq_app_iff {A B C} : (A ++ B) \u2261 (A ++ C) <-> B \u2261 C.", "Proof.", "elim: A; first done.", "move=> a A IH /=.", "by rewrite eq_cons_iff.", "Qed.", "Lemma eq_app_comm {A B} : A ++ B \u2261 B ++ A.", "Proof.", "move=> ?.", "rewrite ?count_occ_app.", "by lia.", "Qed.", "Lemma eq_length {A B} : A \u2261 B -> length A = length B.", "elim /(measure_ind (@length nat)) : A B.", "case.", "{", "by move=> _ B /eq_nilE ->.", "}", "move=> a A IH B /copy [/eq_in_iff /(_ a) /iffLR].", "apply: unnest; first by left.", "move /(@in_split _ _) => [B1 [B2 ->]].", "under (eq_lr eq_refl (B' := a :: (B1 ++ B2))).", "{", "by eq_trivial.", "}", "move /eq_cons_iff.", "move /IH.", "apply: unnest; first done.", "rewrite ? app_length => /=.", "by lia.", "Qed.", "Lemma eq_repeatE {a A n} : repeat a n \u2261 A -> A = repeat a n.", "Proof.", "move=> /copy [/eq_length].", "rewrite repeat_length => HlA.", "move /eq_Forall_iff /(_ (fun c => a = c)) /iffLR.", "apply: unnest.", "{", "clear.", "elim: n; firstorder (by constructor).", "}", "subst n.", "elim: A; first done.", "move=> b A IH /Forall_cons_iff [<-] /IH -> /=.", "by rewrite repeat_length.", "Qed.", "Lemma eq_singletonE {a A} : [a] \u2261 A -> A = [a].", "Proof.", "have -> : [a] = repeat a 1 by done.", "by move /eq_repeatE.", "Qed.", "Lemma eq_mapE {A f} : (forall n, n < f n) -> map f A \u2261 A -> A = [].", "Proof.", "case (nil_or_ex_max A); first done.", "move=> [a [Ha /Forall_forall HA]] Hf /eq_in_iff /(_ (f a)) /iffLR.", "rewrite in_map_iff.", "apply: unnest; first by exists a.", "move /HA.", "move: (Hf a).", "by lia.", "Qed.", "Lemma eq_consP {a A B}: a :: A \u2261 a :: B <-> A \u2261 B.", "Proof.", "rewrite /mset_eq.", "constructor; move=> + c => /(_ c).", "all: rewrite ? count_occ_cons; by lia.", "Qed.", "Lemma eq_consE {a A B}: a :: A \u2261 B -> exists B1 B2, B = B1 ++ (a :: B2) /\\ A \u2261 (B1 ++ B2).", "Proof.", "move=> /copy [/mset_eq_utils.eq_in_iff /(_ a) /iffLR /(_ ltac:(by left))].", "move /(@in_split _ _) => [B1 [B2 ->]].", "under (mset_eq_utils.eq_lr mset_eq_utils.eq_refl (B' := a :: (B1 ++ B2))).", "{", "by mset_eq_utils.eq_trivial.", "}", "move /mset_eq_utils.eq_consP => H.", "exists B1, B2.", "by constructor.", "Qed.", "Lemma eq_app_nil_nilP {A B} : A \u2261 A ++ B -> B = [].", "Proof.", "elim: A; first by move /eq_nilE.", "move=> a A IH /=.", "by move /eq_consP.", "Qed.", "Lemma eq_mapI {A B} : A \u2261 B -> map S A \u2261 map S B.", "Proof.", "rewrite /mset_eq => + c.", "move=> /(_ (Nat.pred c)).", "case: c.", "{", "move=> _.", "have H := iffLR (count_occ_not_In _ _ _).", "rewrite ? {}H; last done.", "all: by rewrite in_map_iff=> [[? [? ?]]].", "}", "move=> c.", "rewrite - ? (count_occ_map S Nat.eq_dec Nat.eq_dec); last done.", "all: move=> >; by case.", "Qed."], "theorems": [{"name": "eq_refl", "kind": "Lemma", "begin": 7, "end": 10}, {"name": "eq_eq", "kind": "Lemma", "begin": 11, "end": 14}, {"name": "eq_symm", "kind": "Lemma", "begin": 15, "end": 18}, {"name": "eq_in_iff", "kind": "Lemma", "begin": 19, "end": 31}, {"name": "eq_nilE", "kind": "Lemma", "begin": 32, "end": 37}, {"name": "eq_trans", "kind": "Lemma", "begin": 38, "end": 43}, {"name": "eq_Forall_iff", "kind": "Lemma", "begin": 44, "end": 49}, {"name": "eq_lr", "kind": "Lemma", "begin": 50, "end": 64}, {"name": "eq_appI", "kind": "Lemma", "begin": 65, "end": 71}, {"name": "eq_cons_iff", "kind": "Lemma", "begin": 73, "end": 78}, {"name": "eq_app_iff", "kind": "Lemma", "begin": 79, "end": 84}, {"name": "eq_app_comm", "kind": "Lemma", "begin": 85, "end": 90}, {"name": "eq_length", "kind": "Lemma", "begin": 91, "end": 109}, {"name": "eq_repeatE", "kind": "Lemma", "begin": 110, "end": 124}, {"name": "eq_singletonE", "kind": "Lemma", "begin": 125, "end": 129}, {"name": "eq_mapE", "kind": "Lemma", "begin": 130, "end": 139}, {"name": "eq_consP", "kind": "Lemma", "begin": 140, "end": 145}, {"name": "eq_consE", "kind": "Lemma", "begin": 146, "end": 157}, {"name": "eq_app_nil_nilP", "kind": "Lemma", "begin": 158, "end": 163}, {"name": "eq_mapI", "kind": "Lemma", "begin": 164, "end": 178}]}