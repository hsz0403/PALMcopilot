{"code": ["Require Import List Permutation.", "From Undecidability.ILL Require Import ILL.", "Set Implicit Arguments.", "Local Infix \"~p\" := (@Permutation _) (at level 70).", "Notation eill_vars := nat.", "Inductive eill_cmd : Set := | in_eill_cmd_inc : eill_vars -> eill_vars -> eill_vars -> eill_cmd | in_eill_cmd_dec : eill_vars -> eill_vars -> eill_vars -> eill_cmd | in_eill_cmd_fork : eill_vars -> eill_vars -> eill_vars -> eill_cmd.", "Notation LL_INC := in_eill_cmd_inc.", "Notation LL_DEC := in_eill_cmd_dec.", "Notation LL_FORK := in_eill_cmd_fork.", "Definition eill_cmd_vars c := match c with | LL_INC a p q => a::p::q::nil | LL_DEC a p q => a::p::q::nil | LL_FORK p q r => p::q::r::nil end.", "Definition eill_cmd_map c := match c with | LL_INC a p q => (\u00a3a \u22b8 \u00a3p) \u22b8 \u00a3 q | LL_DEC a p q => \u00a3a \u22b8 \u00a3p \u22b8 \u00a3 q | LL_FORK p q r => (\u00a3p & \u00a3q) \u22b8 \u00a3 r end.", "Section GeILL.", "Reserved Notation \"\u03a3 ; \u0393 \u22a6 u\" (at level 70, no associativity).", "Inductive G_eill (\u03a3 : list eill_cmd) : list eill_vars -> eill_vars -> Prop := | in_geill_ax : forall u, \u03a3; u::\u2205 \u22a6 u | in_geill_perm : forall \u0393 \u0394 p, \u0393 ~p \u0394 -> \u03a3; \u0393 \u22a6 p -> \u03a3; \u0394 \u22a6 p | in_geill_inc : forall \u0393 a p q, In (LL_INC a p q) \u03a3 -> \u03a3; a::\u0393 \u22a6 p -> \u03a3; \u0393 \u22a6 q | in_geill_dec : forall \u0393 \u0394 p q r, In (LL_DEC p q r) \u03a3 -> \u03a3; \u0393 \u22a6 p -> \u03a3; \u0394 \u22a6 q -> \u03a3; \u0393++\u0394 \u22a6 r | in_geill_fork : forall \u0393 p q r, In (LL_FORK p q r) \u03a3 -> \u03a3; \u0393 \u22a6 p -> \u03a3; \u0393 \u22a6 q -> \u03a3; \u0393 \u22a6 r where \"\u03a3 ; \u0393 \u22a6 u\" := (G_eill \u03a3 \u0393 u).", "End GeILL.", "Definition EILL_SEQUENT := (list eill_cmd * list eill_vars * eill_vars)%type.", "Definition EILL_PROVABILITY (c : EILL_SEQUENT) := match c with (\u03a3,\u0393,u) => G_eill \u03a3 \u0393 u end."], "theorems": []}