{"code": ["Require Import List Permutation Arith Lia.", "From Undecidability.MinskyMachines Require Import ndMM2.", "From Undecidability.ILL Require Import IMSELL imsell.", "From Undecidability.Shared.Libs.DLW Require Import utils pos vec.", "From Undecidability.Synthetic Require Import Definitions ReducibilityFacts.", "Set Implicit Arguments.", "Local Infix \"~p\" := (@Permutation _) (at level 70).", "Local Notation \"X \u2286 Y\" := (forall a, X a -> Y a : Prop) (at level 70).", "Local Infix \"\u220a\" := In (at level 70).", "Local Reserved Notation \"'\u27e6' A '\u27e7'\" (at level 1, format \"\u27e6 A \u27e7\").", "Local Fact pair_plus x1 y1 x2 y2 : vec_plus (x1##y1##vec_nil) (x2##y2##vec_nil) = (x1+x2)##(y1+y2)##vec_nil.", "Proof.", "reflexivity.", "Qed.", "Local Tactic Notation \"pair\" \"split\" hyp(v) \"as\" ident(x) ident(y) := vec split v with x; vec split v with y; vec nil v; clear v.", "Local Tactic Notation \"intro\" \"pair\" \"as\" ident(x) ident (y) := let v := fresh in intro v; pair split v as x y.", "Local Notation \"\u29b3\" := vec_zero.", "Local Notation \u00f8 := vec_nil.", "Local Infix \"\u2264\" := (@IMSELL_le _) (at level 70).", "Local Notation \"u \u2270 v\" := (~ u \u2264 v) (at level 70).", "Local Notation U := (@IMSELL_U _).", "Section ndmm2_imsell.", "Variable (sig : IMSELL_sig) (a b i : sig).", "Notation \"\u221e\" := i.", "Notation bang_le := (IMSELL_le sig).", "Hypothesis (Hai : a \u2264 \u221e) (Hbi : b \u2264 \u221e) (Hab : a \u2270 b) (Hba : b \u2270 a) (Ha : ~ U a) (Hb : ~ U b) (Hi : U \u221e).", "Implicit Type u v w : sig.", "Local Definition bang_le_refl : forall u, u \u2264 u := IMSELL_refl _.", "Local Definition bang_le_trans : forall u v w, u \u2264 v -> v \u2264 w -> u \u2264 w := IMSELL_trans _.", "Local Definition bang_U_clos : forall u v, U u -> u \u2264 v -> U v := IMSELL_clos _.", "Hint Resolve Hai Hbi Ha Hb Hi Hab Hba bang_le_refl bang_U_clos : core.", "Notation \"\u00a3 A\" := (@imsell_var _ _ A) (at level 1).", "Notation \"\u203c l\" := (@imsell_lban nat sig l).", "Notation \"\u203c\u221e\" := (map (fun A => ![\u221e]A)).", "Local Definition formA : imsell_form nat sig := ![a](\u00a30).", "Local Definition formB : imsell_form nat sig := ![b](\u00a31).", "Local Definition var2pc p : imsell_form nat sig := \u00a3 (2+p).", "Notation \u03b1 := formA.", "Notation \u03b2 := formB.", "Notation \"\u230a p \u230b\" := (var2pc p) (format \"\u230a p \u230b\").", "Local Definition bool2form (x : bool) := if x then \u03b1 else \u03b2.", "Local Definition bool2bang_op (x : bool) := if x then b else a.", "Notation STOP\u2099 := (@ndmm2_stop _).", "Notation INC\u2099 := (@ndmm2_inc _).", "Notation DEC\u2099 := (@ndmm2_dec _).", "Notation ZERO\u2099 := (@ndmm2_zero _).", "Definition ndmm2_imsell_form c := match c with | STOP\u2099 p => (\u230ap\u230b \u22b8 \u230ap\u230b) \u22b8 \u230ap\u230b | INC\u2099 x p q => (bool2form x \u22b8 \u230aq\u230b) \u22b8 \u230ap\u230b | DEC\u2099 x p q => bool2form x \u22b8 \u230aq\u230b \u22b8 \u230ap\u230b | ZERO\u2099 x p q => (![bool2bang_op x]\u230aq\u230b) \u22b8 \u230ap\u230b end.", "Notation \"\u27ec c \u27ed\" := (ndmm2_imsell_form c) (at level 1, format \"\u27ec c \u27ed\").", "Definition ndmm2_imsell_ctx \u03a3 x y := \u203c\u221e (map (fun c => \u27ecc\u27ed) \u03a3) ++ repeat \u03b1 x ++ repeat \u03b2 y.", "Notation \"\u27ec \u03a3 , x , y \u27ed\" := (ndmm2_imsell_ctx \u03a3 x y) (at level 1, format \"\u27ec \u03a3 , x , y \u27ed\").", "Fact ndmm2_imsell_eq1 \u03a3 : map (fun c => ![\u221e]\u27ecc\u27ed) \u03a3 = \u203c(map (fun c => (\u221e,\u27ecc\u27ed)) \u03a3).", "Proof.", "unfold imsell_lban; rewrite map_map; auto.", "Qed.", "Fact ndmm2_imsell_eq2 \u03a3 x y : \u27ec\u03a3,x,y\u27ed = \u203c(map (fun c => (\u221e,\u27ecc\u27ed)) \u03a3 ++ repeat (a,\u00a30) x ++ repeat (b,\u00a31) y).", "Proof.", "unfold ndmm2_imsell_ctx.", "rewrite map_map, ndmm2_imsell_eq1.", "unfold imsell_lban; rewrite !map_app, !map_map; f_equal.", "induction x; simpl; f_equal; auto.", "induction y; simpl; f_equal; auto.", "Qed.", "Fact ndmm2_imsell_perm1 \u03a3 x y : \u27ec\u03a3,1+x,y\u27ed ~p \u03b1::\u27ec\u03a3,x,y\u27ed .", "Proof.", "unfold ndmm2_imsell_ctx.", "apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _).", "rewrite !app_ass; apply Permutation_app; auto.", "simpl; apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _).", "now rewrite app_ass.", "Qed.", "Fact ndmm2_imsell_perm2 \u03a3 x y : \u27ec\u03a3,x,1+y\u27ed ~p \u03b2::\u27ec\u03a3,x,y\u27ed .", "Proof.", "unfold ndmm2_imsell_ctx.", "apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _).", "rewrite !app_ass; repeat apply Permutation_app; auto.", "simpl; apply Permutation_sym, perm_trans with (1 := Permutation_cons_append _ _); auto.", "Qed.", "Notation \"\u0393 \u22a2 A\" := (S_imsell bang_le U \u0393 A) (at level 70).", "Theorem ndmm2_imsell_weak c \u03a3 x y A : c \u220a \u03a3 -> \u27ec\u03a3,x,y\u27ed \u22a2 A <-> ![\u221e]\u27ecc\u27ed :: \u27ec\u03a3,x,y\u27ed ++ nil \u22a2 A.", "Proof.", "intros H; rewrite <- app_nil_end.", "apply S_imsell_extract; auto.", "apply in_app_iff; left.", "apply in_map_iff.", "exists \u27ecc\u27ed ; split; auto.", "apply in_map_iff; eauto.", "Qed.", "Notation \"\u03a3 //\u2099 a \u2295 b \u22a6 p\" := (ndmm2_accept \u03a3 a b p) (at level 70, no associativity).", "Hint Resolve ndmm2_imsell_perm1 ndmm2_imsell_perm2 in_imsell_ax : core.", "Theorem ndmm2_imsell_sound \u03a3 x y p : \u03a3 //\u2099 x \u2295 y \u22a6 p -> \u27ec\u03a3,x,y\u27ed \u22a2 \u230ap\u230b.", "Proof.", "induction 1 as [ p H1 | x y p q H1 H2 IH2 | x y p q H1 H2 IH2 | x y p q H1 H2 IH2 | x y p q H1 H2 IH2 | y p q H1 H2 IH2 | x p q H1 H2 IH2 ].", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l, in_imsell_limp_l; auto.", "apply in_imsell_limp_r.", "apply in_imsell_perm with (1 := Permutation_sym (Permutation_cons_append _ _)).", "unfold ndmm2_imsell_ctx; simpl; rewrite <- app_nil_end.", "apply S_imsell_gen_weak; auto.", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l, in_imsell_limp_l; auto.", "apply in_imsell_limp_r.", "revert IH2; apply in_imsell_perm; auto.", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l, in_imsell_limp_l; auto.", "apply in_imsell_limp_r.", "revert IH2; apply in_imsell_perm; auto.", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l.", "apply in_imsell_perm with (\u0393 := \u03b1\u22b8\u230aq\u230b\u22b8\u230ap\u230b :: (\u03b1::nil) ++ \u27ec\u03a3,x,y\u27ed).", "*", "apply Permutation_sym, perm_skip; rewrite <- app_nil_end; simpl; auto.", "*", "apply in_imsell_limp_l; auto.", "rewrite app_nil_end with (l := \u27ec_,_,_\u27ed).", "apply in_imsell_limp_l; auto.", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l.", "apply in_imsell_perm with (\u0393 := \u03b2\u22b8\u230aq\u230b\u22b8\u230ap\u230b :: (\u03b2::nil) ++ \u27ec\u03a3,x,y\u27ed).", "*", "apply Permutation_sym, perm_skip; rewrite <- app_nil_end; simpl; auto.", "*", "apply in_imsell_limp_l; auto.", "rewrite app_nil_end with (l := \u27ec_,_,_\u27ed).", "apply in_imsell_limp_l; auto.", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l, in_imsell_limp_l; auto.", "rewrite ndmm2_imsell_eq2 in IH2 |- *.", "apply in_imsell_bang_r; auto.", "intros (v,A); simpl.", "rewrite in_app_iff, in_map_iff.", "intros [ (? & HvA & ?) | HvA ].", "*", "now inversion HvA; subst.", "*", "now apply repeat_spec in HvA; inversion HvA.", "+", "apply ndmm2_imsell_weak with (1 := H1); simpl.", "apply in_imsell_bang_l, in_imsell_limp_l; auto.", "rewrite ndmm2_imsell_eq2 in IH2 |- *.", "apply in_imsell_bang_r; auto.", "intros (v,A); simpl.", "rewrite <- app_nil_end, in_app_iff, in_map_iff.", "intros [ (? & HvA & ?) | HvA ].", "*", "now inversion HvA; subst.", "*", "now apply repeat_spec in HvA; inversion HvA.", "Qed.", "Variable \u03a3 : list (ndmm2_instr nat).", "Let sem p (w : vec nat 2) := let x := vec_head w in let y := vec_head (vec_tail w) in match p with | 0 => x = 1 /\\ y = 0 | 1 => x = 0 /\\ y = 1 | S (S i) => \u03a3 //\u2099 x \u2295 y \u22a6 i end.", "Local Fact sem_0 x y : sem 0 (x##y##\u00f8) <-> x = 1 /\\ y = 0.", "Proof.", "simpl; tauto.", "Qed.", "Local Fact sem_1 x y : sem 1 (x##y##\u00f8) <-> x = 0 /\\ y = 1.", "Proof.", "simpl; tauto.", "Qed.", "Local Fact sem_2 p x y : sem (2+p) (x##y##\u00f8) <-> \u03a3 //\u2099 x \u2295 y \u22a6 p.", "Proof.", "simpl; tauto.", "Qed.", "Let K m (w : vec nat 2) := let x := vec_head w in let y := vec_head (vec_tail w) in (a \u2264 m -> y = 0) /\\ (b \u2264 m -> x = 0) /\\ (U m -> x = 0 /\\ y = 0).", "Infix \"\u229b\" := imsell_tps_mult (at level 65, right associativity).", "Infix \"-\u229b\" := imsell_tps_imp (at level 65, right associativity).", "Notation \"\u27e6 A \u27e7\" := (imsell_tps sem K A).", "Notation \"\u27ea \u0393 \u27eb\" := (imsell_tps_list sem K \u0393).", "Local Fact HK1 p q : p \u2264 q -> K q \u2286 K p.", "Proof.", "intros Hpq; intro pair as x y.", "unfold K; simpl; intros (H1 & H2 & H3); msplit 2; intros H.", "+", "apply H1, bang_le_trans with (2 := Hpq); auto.", "+", "apply H2, bang_le_trans with (2 := Hpq); auto.", "+", "apply H3, bang_U_clos with (2 := Hpq); auto.", "Qed.", "Local Fact HK2 : forall m, K m \u29b3.", "Proof.", "intros; split; auto.", "Qed.", "Local Fact HK3 m : K m \u229b K m \u2286 K m.", "Proof.", "intro pair as x y.", "intros (p & q & H); revert p q H.", "intro pair as x1 y1; intro pair as x2 y2; simpl.", "rewrite pair_plus; unfold K; simpl.", "intros (H1 & (H2 & H3 & H6) & H4 & H5 & H7).", "inversion H1; subst x y; clear H1.", "msplit 2; intros.", "+", "rewrite H2, H4; auto.", "+", "rewrite H3, H5; auto.", "+", "destruct H6; subst; auto.", "Qed.", "Local Fact HK4 u : U u -> forall x, K u x -> x = \u29b3.", "Proof.", "intros Hu; intro pair as x y; unfold K; simpl.", "intros (_ & _ & H); destruct H; subst; auto.", "Qed.", "Local Fact HKa x y : K a (x##y##vec_nil) <-> y = 0.", "Proof.", "split; unfold K; simpl.", "+", "intros []; auto.", "+", "intros ->; msplit 2; auto; intros; tauto.", "Qed.", "Local Fact HKb x y : K b (x##y##vec_nil) <-> x = 0.", "Proof.", "split; unfold K; simpl.", "+", "intros (? & ? & ?); auto.", "+", "intros ->; msplit 2; auto; tauto.", "Qed.", "Local Fact HKi : forall x, K \u221e x -> x = \u29b3.", "Proof.", "intro pair as x y; unfold K; simpl.", "intros (H1 & H2 & ?); rewrite H1, H2; auto.", "Qed.", "Local Lemma sem_\u03a3 c : c \u220a \u03a3 -> \u27e6\u27ec c\u27ed\u27e7 \u29b3.", "Proof.", "intros H.", "destruct c as [ p | [] p q | [] p q | [] p q ]; simpl; apply imsell_tps_imp_zero; intro pair as x y; simpl; intros H1.", "+", "specialize (H1 \u29b3); rewrite vec_zero_plus in H1.", "apply H1; constructor; auto.", "+", "constructor 2 with (1 := H).", "apply (H1 (1##0##vec_nil)).", "simpl; rewrite HKa; auto.", "+", "constructor 3 with (1 := H).", "apply (H1 (0##1##vec_nil)); auto.", "simpl; rewrite HKb; auto.", "+", "destruct H1 as ((-> & ->) & _); simpl.", "intro pair as x y; simpl; rewrite (plus_comm x), (plus_comm y).", "constructor 4 with q; auto.", "+", "destruct H1 as ((-> & ->) & _); simpl.", "intro pair as x y; simpl; rewrite (plus_comm x), (plus_comm y).", "constructor 5 with q; auto.", "+", "rewrite HKb in H1.", "destruct H1 as (H1 & ->).", "constructor 6 with q; auto.", "+", "rewrite HKa in H1.", "destruct H1 as (H1 & ->).", "constructor 7 with q; auto.", "Qed.", "Hint Resolve HK1 HK2 HK3 HK4 HKa HKb HKi sem_\u03a3 : core.", "Local Fact sem_\u03a3_zero : \u27eamap (fun c => ![\u221e]\u27ec c\u27ed) \u03a3\u27eb \u29b3.", "Proof.", "apply imsell_tps_list_zero.", "intros A; rewrite in_map_iff.", "intros (c & <- & Hc); simpl; auto.", "Qed.", "Theorem ndmm2_imsell_complete p x y : \u27ec\u03a3,x,y\u27ed \u22a2 \u230ap\u230b -> \u03a3 //\u2099 x \u2295 y \u22a6 p.", "Proof.", "intros Hxy; apply imsell_tps_sound with (s := sem) (K := K) in Hxy; eauto.", "specialize (Hxy (x##y##vec_nil)).", "rewrite vec_plus_comm, vec_zero_plus in Hxy.", "apply Hxy; clear Hxy.", "unfold ndmm2_imsell_ctx.", "apply imsell_tps_app.", "exists \u29b3, (x##y##\u00f8).", "rewrite vec_zero_plus; msplit 2; auto.", "+", "rewrite map_map; apply sem_\u03a3_zero; auto.", "+", "apply imsell_tps_app.", "exists (x##0##\u00f8), (0##y##\u00f8); msplit 2; auto.", "*", "rewrite pair_plus; f_equal; lia.", "*", "generalize x; clear x y; intros n.", "induction n as [ | n IHn ]; simpl; auto.", "exists (1##0##\u00f8), (n##0##\u00f8); simpl; msplit 2; auto.", "rewrite HKa; auto.", "*", "generalize y; clear x y; intros n.", "induction n as [ | n IHn ]; simpl; auto.", "exists (0##1##\u00f8), (0##n##\u00f8); simpl; msplit 2; auto.", "rewrite HKb; auto.", "Qed.", "Hint Resolve ndmm2_imsell_sound ndmm2_imsell_complete : core.", "Theorem ndmm2_imsell_correct p x y : \u03a3 //\u2099 x \u2295 y \u22a6 p <-> \u27ec\u03a3,x,y\u27ed \u22a2 \u230ap\u230b.", "Proof.", "split; auto.", "Qed.", "End ndmm2_imsell.", "Theorem conditional_reduction (S : IMSELL_sig) : (exists a b i : S, a \u2264 i /\\ b \u2264 i /\\ a \u2270 b /\\ b \u2270 a /\\ ~ U a /\\ ~ U b /\\ U i) -> @ndMM2_ACCEPT nat \u2aaf @IMSELL_cf_PROVABILITY S.", "Proof.", "intros (a & b & i & ?).", "apply reduces_dependent; exists.", "intros (\u03a3 & u & x & y).", "exists (ndmm2_imsell_ctx _ a b i \u03a3 x y, imsell_var _ (2+u)).", "apply ndmm2_imsell_correct; simpl; tauto.", "Qed.", "Theorem reduction (S : IMSELL_sig3) : @ndMM2_ACCEPT nat \u2aaf @IMSELL_cf_PROVABILITY3 S.", "Proof.", "destruct S as (S & HS).", "apply conditional_reduction, HS.", "Qed."], "theorems": [{"name": "ndmm2_imsell_eq1", "kind": "Fact", "begin": 50, "end": 53}, {"name": "ndmm2_imsell_eq2", "kind": "Fact", "begin": 54, "end": 61}, {"name": "ndmm2_imsell_perm1", "kind": "Fact", "begin": 62, "end": 69}, {"name": "ndmm2_imsell_perm2", "kind": "Fact", "begin": 70, "end": 76}, {"name": "ndmm2_imsell_weak", "kind": "Theorem", "begin": 78, "end": 86}, {"name": "ndmm2_imsell_sound", "kind": "Theorem", "begin": 89, "end": 153}, {"name": "ndmm2_imsell_complete", "kind": "Theorem", "begin": 269, "end": 296}, {"name": "ndmm2_imsell_correct", "kind": "Theorem", "begin": 298, "end": 301}, {"name": "conditional_reduction", "kind": "Theorem", "begin": 303, "end": 310}, {"name": "reduction", "kind": "Theorem", "begin": 311, "end": 315}]}