{"code": ["Require Import List Permutation.", "From Undecidability.ILL Require Import IMSELL.", "From Undecidability.Shared.Libs.DLW Require Import utils pos vec.", "Set Implicit Arguments.", "Local Infix \"~p\" := (@Permutation _) (at level 70).", "Local Notation \"X \u2286 Y\" := (forall a, X a -> Y a : Prop) (at level 70).", "Local Infix \"\u220a\" := In (at level 70).", "Local Reserved Notation \"'\u27e6' A '\u27e7'\" (at level 1, format \"\u27e6 A \u27e7\").", "Section IMSELL.", "Variable bang : Type.", "Notation \"\u00a3 A\" := (@imsell_var _ _ A) (at level 1).", "Notation \"\u203c l\" := (@imsell_lban nat bang l).", "Fact imsell_lban_perm \u03a3 \u0393 : \u03a3 ~p \u0393 -> \u203c\u03a3 ~p \u203c\u0393.", "Proof.", "apply Permutation_map.", "Qed.", "Variable (bang_le : bang -> bang -> Prop) (bang_U : bang -> Prop).", "Infix \"\u2264\" := bang_le (at level 70).", "Notation U := bang_U.", "Notation \"u \u227c l\" := (forall '(v,A), (v,A) \u220a l -> u \u2264 v) (at level 70).", "Notation \"\u0393 \u22a2 A\" := (@S_imsell nat _ bang_le bang_U \u0393 A) (at level 70).", "Fact S_imsell_weak \u0393 \u0394 B : Forall (fun '(u,_) => U u) \u0393 -> \u0394 \u22a2 B -> \u203c\u0393++\u0394 \u22a2 B.", "Proof.", "intros H1 H2; revert H1.", "induction 1 as [ | (u,A) \u0393 H1 IH1 ]; simpl; auto.", "apply in_imsell_weak; auto.", "Qed.", "Fact S_imsell_gen_weak u \u0393 \u0394 B : U u -> \u0394 \u22a2 B -> map (fun A => ![u]A) \u0393++\u0394 \u22a2 B.", "Proof.", "intros H1 H2.", "replace (map (fun A => ![u]A) \u0393) with (\u203c (map (fun A => (u,A)) \u0393)).", "+", "apply S_imsell_weak; auto.", "apply Forall_forall.", "intros ?; rewrite in_map_iff.", "intros (? & <- & ?); auto.", "+", "unfold imsell_lban; rewrite map_map; auto.", "Qed.", "Fact S_imsell_cntr \u0393 \u0394 B : Forall (fun '(u,_) => U u) \u0393 -> \u203c\u0393++\u203c\u0393++\u0394 \u22a2 B -> \u203c\u0393++\u0394 \u22a2 B.", "Proof.", "intros H; revert H \u0394.", "induction 1 as [ | (u,A) \u0393 H1 H2 IH2 ]; simpl; auto; intros \u0394 H.", "apply in_imsell_cntr; auto.", "apply in_imsell_perm with (\u203c\u0393 ++ (![u]A::![u]A::\u0394)).", "+", "apply Permutation_sym.", "do 2 apply Permutation_cons_app; auto.", "+", "apply IH2.", "revert H; apply in_imsell_perm.", "rewrite app_assoc.", "apply Permutation_cons_app.", "rewrite <- app_assoc.", "apply Permutation_app; auto.", "apply Permutation_cons_app; auto.", "Qed.", "Theorem S_imsell_extract \u0393 u A B : ![u]A \u220a \u0393 -> U u -> \u0393 \u22a2 B <-> ![u]A::\u0393 \u22a2 B.", "Proof.", "intros H1 H2; split.", "+", "apply in_imsell_weak; auto.", "+", "intros H3.", "apply In_perm in H1 as (\u0394 & H1).", "apply in_imsell_perm with (1 := H1).", "apply in_imsell_cntr; auto.", "apply in_imsell_perm with (2 := H3).", "apply perm_skip, Permutation_sym; auto.", "Qed.", "Section Trivial_Phase_semantics.", "Variables (n : nat) (s : nat -> vec nat n -> Prop).", "Notation \"\u29b3\" := vec_zero.", "Notation \u00f8 := vec_nil.", "Definition imsell_tps_mult (X Y : _ -> Prop) (x : vec _ n) := exists a b, x = vec_plus a b /\\ X a /\\ Y b.", "Definition imsell_tps_imp (X Y : _ -> Prop) (v : vec _ n) := forall x, X x -> Y (vec_plus x v).", "Infix \"\u229b\" := imsell_tps_mult (at level 65, right associativity).", "Infix \"-\u229b\" := imsell_tps_imp (at level 65, right associativity).", "Fact imsell_tps_imp_zero X Y : (X -\u229b Y) \u29b3 <-> X \u2286 Y.", "Proof.", "split.", "+", "intros ? ? ?; rewrite <- vec_zero_plus, vec_plus_comm; auto.", "+", "intros ? ?; rewrite vec_plus_comm, vec_zero_plus; auto.", "Qed.", "Variable (K : bang -> vec nat n -> Prop).", "Hypothesis HK_antitone : forall p q, p \u2264 q -> K q \u2286 K p.", "Hypothesis HK_unit0 : forall m, K m \u29b3.", "Hypothesis HK_plus : forall m, K m \u229b K m \u2286 K m.", "Hypothesis HK_unit1 : forall u, U u -> forall x, K u x -> x = \u29b3.", "Fact imsell_tps_mult_mono (X1 X2 Y1 Y2 : _ -> Prop) : X1 \u2286 X2 -> Y1 \u2286 Y2 -> X1\u229bY1 \u2286 X2\u229bY2.", "Proof.", "intros H1 H2 x (y & z & H3 & H4 & H5); subst.", "exists y, z; auto.", "Qed.", "Fixpoint imsell_tps (A : imsell_form nat bang) x : Prop := match A with | \u00a3 X => s X x | ![m]A => \u27e6A\u27e7 x /\\ K m x | A\u22b8B => (\u27e6A\u27e7-\u229b\u27e6B\u27e7) x end where \"\u27e6 A \u27e7\" := (imsell_tps A).", "Fact imsell_tps_bang_zero m A : \u27e6![m]A\u27e7 \u29b3 <-> \u27e6A\u27e7 \u29b3.", "Proof.", "simpl; split; auto; tauto.", "Qed.", "Fact imsell_tps_bang_U u A : U u -> (forall v, \u27e6![u]A\u27e7 v <-> v = \u29b3) <-> \u27e6A\u27e7 \u29b3.", "Proof.", "intros Hu; split.", "+", "intros H; rewrite <- imsell_tps_bang_zero, H; auto.", "+", "intros H v; split; simpl.", "*", "intros (_ & H1); revert H1; eauto.", "*", "intros ->; auto.", "Qed.", "Reserved Notation \"\u27ea \u0393 \u27eb\" (at level 1, format \"\u27ea \u0393 \u27eb\").", "Fixpoint imsell_tps_list \u0393 := match \u0393 with | nil => eq \u29b3 | A::\u0393 => \u27e6A\u27e7\u229b\u27ea\u0393\u27eb end where \"\u27ea \u0393 \u27eb\" := (imsell_tps_list \u0393).", "Fact imsell_tps_app \u0393 \u0394 x : \u27ea\u0393++\u0394\u27eb x <-> (\u27ea\u0393\u27eb\u229b\u27ea\u0394\u27eb) x.", "Proof.", "revert \u0393 \u0394 x; intros Ga De.", "induction Ga as [ | A Ga IH ]; intros x; simpl; split; intros Hx.", "+", "exists vec_zero, x; simpl; rew vec.", "+", "destruct Hx as (? & ? & ? & ? & ?); subst; auto; rewrite vec_zero_plus; auto.", "+", "destruct Hx as (y & z & H1 & H2 & H3).", "apply IH in H3.", "destruct H3 as (c & d & H4 & H5 & H6).", "exists (vec_plus y c), d; split.", "*", "subst; apply vec_plus_assoc.", "*", "split; auto.", "exists y, c; auto.", "+", "destruct Hx as (y & d & ? & (z & g & ? & ? & ?) & ?).", "exists z, (vec_plus g d); split.", "*", "subst; symmetry; apply vec_plus_assoc.", "*", "split; auto.", "apply IH.", "exists g, d; auto.", "Qed.", "Fact imsell_tps_perm \u0393 \u0394 : \u0393 ~p \u0394 -> \u27ea\u0393\u27eb \u2286 \u27ea\u0394\u27eb.", "Proof.", "induction 1 as [ | A Ga De H IH | A B Ga | ]; simpl; auto.", "+", "intros x (y & z & H1 & H2 & H3).", "exists y, z; repeat split; auto.", "+", "intros x (y & z & H1 & H2 & c & d & H3 & H4 & H5).", "exists c, (vec_plus y d); split.", "*", "subst; rewrite (vec_plus_comm c), vec_plus_assoc, (vec_plus_comm c); auto.", "*", "split; auto.", "exists y, d; auto.", "Qed.", "Fact imsell_tps_list_zero \u0393 : (forall A, A \u220a \u0393 -> \u27e6A\u27e7 \u29b3) -> \u27ea\u0393\u27eb \u29b3.", "Proof.", "induction \u0393 as [ | A \u0393 IH ]; simpl; auto; intros H.", "exists \u29b3, \u29b3; msplit 2; auto; now rewrite vec_zero_plus.", "Qed.", "Definition imsell_sequent_tps \u0393 A := \u27ea\u0393\u27eb -\u229b \u27e6A\u27e7.", "Notation \"'[<' \u0393 '|-' A '>]'\" := (imsell_sequent_tps \u0393 A) (at level 1, format \"[< \u0393 |- A >]\").", "Fact imsell_sequent_tps_mono \u0393 A B : \u27e6A\u27e7 \u2286 \u27e6B\u27e7 -> [< \u0393 |- A >] \u2286 [< \u0393 |- B >].", "Proof.", "intros H x; simpl; unfold imsell_sequent_tps.", "intros H1 ? H2; apply H, H1; auto.", "Qed.", "Fact imsell_perm_tps \u0393 \u0394 : \u0393 ~p \u0394 -> forall A, [< \u0393 |- A >] \u2286 [< \u0394 |- A >].", "Proof.", "intros H1 B x; unfold imsell_sequent_tps.", "intros H2 ? H3; apply H2; revert H3.", "apply imsell_tps_perm, Permutation_sym; auto.", "Qed.", "Fact imsell_sequent_tps_eq \u0393 A : [< \u0393 |- A >] \u29b3 <-> \u27ea\u0393\u27eb \u2286 \u27e6A\u27e7.", "Proof.", "split.", "*", "intros H x Hx.", "rewrite <- vec_zero_plus, vec_plus_comm.", "apply (H x); trivial.", "*", "intros H x Hx.", "rewrite vec_plus_comm, vec_zero_plus; auto.", "Qed.", "Fact imsell_tps_lbang m \u0393 : m \u227c \u0393 -> \u27ea\u203c\u0393\u27eb \u2286 K m.", "Proof.", "induction \u0393 as [ | (v,A) \u0393 IH ]; simpl; intros H1 x.", "+", "intros <-; auto.", "+", "intros (y & z & -> & (G1 & G2) & G3).", "apply HK_plus; exists y, z; msplit 2; auto.", "*", "revert G2; apply HK_antitone; auto.", "apply (H1 (v,A)); auto.", "*", "revert G3; apply IH.", "intros (w,B) ?; apply (H1 (_,B)); auto.", "Qed.", "Theorem imsell_tps_sound \u0393 A : \u0393 \u22a2 A -> [< \u0393 |- A >] \u29b3.", "Proof.", "induction 1 as [ A | \u0393 \u0394 A H1 H2 IH2 | \u0393 \u0394 A B C H1 IH1 H2 IH2 | \u0393 A B H1 IH1 | \u0393 m A B H1 IH1 | \u0393 m A H1 H2 IH2 | \u0393 u A B H1 H2 IH2 | \u0393 u A B H1 H2 IH2 ]; unfold imsell_sequent_tps in * |- *.", "+", "intros x; simpl; intros (y & z & H1 & H2 & H3); subst; eq goal H2.", "f_equal; do 2 rewrite vec_plus_comm, vec_zero_plus; auto.", "+", "revert IH2; apply imsell_perm_tps; auto.", "+", "intros x (y & z & H3 & H4 & H5); simpl.", "apply IH2.", "apply imsell_tps_app in H5 as (g & d & H5 & H6 & H7).", "simpl in H4; apply IH1, H4 in H6.", "exists (vec_plus y g), d; repeat split; auto.", "*", "subst; apply vec_plus_assoc.", "*", "eq goal H6; f_equal; rew vec.", "+", "simpl; intros y Hy x Hx.", "rewrite vec_plus_assoc.", "apply IH1.", "exists x, y; repeat split; auto.", "+", "intros x (y & z & H2 & H3 & H4).", "apply IH1; exists y, z; repeat split; auto.", "apply H3.", "+", "intros x Hx; split.", "*", "apply IH2; auto.", "*", "rew vec.", "revert Hx; apply imsell_tps_lbang; auto.", "+", "intros x (y & z & -> & H3 & H4); rew vec.", "apply proj2, HK_unit1 in H3; auto; subst.", "rewrite vec_plus_comm.", "now apply IH2.", "+", "intros x (y & z & G2 & G3 & G4).", "apply IH2.", "exists y, z; repeat (split; auto).", "exists y, z; repeat (split; auto).", "apply proj2, HK_unit1 in G3; auto.", "subst; rew vec; auto.", "Qed.", "End Trivial_Phase_semantics.", "End IMSELL."], "theorems": [{"name": "imsell_lban_perm", "kind": "Fact", "begin": 12, "end": 15}, {"name": "S_imsell_weak", "kind": "Fact", "begin": 21, "end": 26}, {"name": "S_imsell_gen_weak", "kind": "Fact", "begin": 27, "end": 38}, {"name": "S_imsell_cntr", "kind": "Fact", "begin": 39, "end": 56}, {"name": "S_imsell_extract", "kind": "Theorem", "begin": 57, "end": 69}, {"name": "imsell_tps_imp_zero", "kind": "Fact", "begin": 78, "end": 85}, {"name": "imsell_tps_mult_mono", "kind": "Fact", "begin": 91, "end": 95}, {"name": "imsell_tps_bang_zero", "kind": "Fact", "begin": 97, "end": 100}, {"name": "imsell_tps_bang_U", "kind": "Fact", "begin": 101, "end": 112}, {"name": "imsell_tps_app", "kind": "Fact", "begin": 115, "end": 142}, {"name": "imsell_tps_perm", "kind": "Fact", "begin": 143, "end": 157}, {"name": "imsell_tps_list_zero", "kind": "Fact", "begin": 158, "end": 162}, {"name": "imsell_sequent_tps_mono", "kind": "Fact", "begin": 165, "end": 169}, {"name": "imsell_perm_tps", "kind": "Fact", "begin": 170, "end": 175}, {"name": "imsell_sequent_tps_eq", "kind": "Fact", "begin": 176, "end": 186}, {"name": "imsell_tps_lbang", "kind": "Fact", "begin": 187, "end": 201}, {"name": "imsell_tps_sound", "kind": "Theorem", "begin": 202, "end": 248}]}