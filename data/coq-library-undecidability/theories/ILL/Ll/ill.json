{"code": ["Require Import List Permutation Arith Lia.", "From Undecidability.Shared.Libs.DLW Require Import utils pos vec.", "From Undecidability.ILL Require Import ILL.", "Set Implicit Arguments.", "Section obvious_links_between_fragments.", "Notation \"P \u21d2 Q\" := (forall \u0393 A, P \u0393 A -> Q \u0393 A) (at level 70).", "Fact S_ill_restr_restr_wc : S_ill_restr \u21d2 S_ill_restr_wc.", "Proof.", "induction 1.", "all: try now constructor.", "now constructor 3 with (\u0393 := \u0393).", "Qed.", "Fact S_ill_full_wc : S_ill \u21d2 S_ill_wc.", "Proof.", "induction 1.", "all: try now constructor.", "now constructor 3 with (\u0393 := \u0393).", "Qed.", "Fact S_ill_restr_full : S_ill_restr \u21d2 S_ill.", "Proof.", "induction 1.", "all: try now constructor.", "now constructor 2 with (\u0393 := \u0393).", "Qed.", "Fact S_ill_restr_full_wc : S_ill_restr_wc \u21d2 S_ill_wc.", "Proof.", "induction 1.", "all: try now constructor.", "+", "now constructor 2 with A.", "+", "now constructor 3 with (\u0393 := \u0393).", "Qed.", "End obvious_links_between_fragments.", "Local Notation \"\u0393 '\u22a2r' A\" := (S_ill_restr \u0393 A) (at level 70, no associativity).", "Local Notation \"\u0393 '\u22a2' A\" := (S_ill_wc \u0393 A) (at level 70, no associativity).", "Fact S_ill_restr_weak \u0393 \u0394 B : \u0394 \u22a2r B -> \u203c\u0393++\u0394 \u22a2r B.", "Proof.", "intro; induction \u0393; simpl; auto; apply in_ill1_weak; auto.", "Qed.", "Fact S_ill_wc_weak \u0393 \u0394 B : \u0394 \u22a2 B -> \u203c\u0393++\u0394 \u22a2 B.", "Proof.", "intro; induction \u0393; simpl; auto; apply in_ill4_weak; auto.", "Qed.", "Fact S_ill_restr_cntr \u0393 \u0394 B : \u203c\u0393++\u203c\u0393++\u0394 \u22a2r B -> \u203c\u0393++ \u0394 \u22a2r B.", "Proof.", "revert \u0393 \u0394; intros Ga.", "induction Ga as [ | A Ga IH ]; simpl; auto; intros De.", "intros H.", "apply in_ill1_cntr.", "apply in_ill1_perm with (\u203cGa ++ (!A::!A::De)).", "+", "apply Permutation_sym.", "do 2 apply Permutation_cons_app; auto.", "+", "apply IH.", "revert H; apply in_ill1_perm.", "rewrite app_assoc.", "apply Permutation_cons_app.", "rewrite <- app_assoc.", "apply Permutation_app; auto.", "apply Permutation_cons_app; auto.", "Qed.", "Fact S_ill_wc_cntr \u0393 \u0394 B : \u203c\u0393++\u203c\u0393++\u0394 \u22a2 B -> \u203c\u0393++ \u0394 \u22a2 B.", "Proof.", "revert \u0393 \u0394; intros Ga.", "induction Ga as [ | A Ga IH ]; simpl; auto; intros De.", "intros H.", "apply in_ill4_cntr.", "apply in_ill4_perm with (\u203cGa ++ (!A::!A::De)).", "+", "apply Permutation_sym.", "do 2 apply Permutation_cons_app; auto.", "+", "apply IH.", "revert H; apply in_ill4_perm.", "rewrite app_assoc.", "apply Permutation_cons_app.", "rewrite <- app_assoc.", "apply Permutation_app; auto.", "apply Permutation_cons_app; auto.", "Qed.", "Theorem S_ill_restr_weak_cntr \u03a3 \u0393 A B : In A \u03a3 -> \u203c\u03a3++\u0393 \u22a2r B <-> !A::\u203c\u03a3++\u0393 \u22a2r B.", "Proof.", "revert \u03a3 \u0393; intros Si Ga.", "intros H.", "apply In_perm in H.", "destruct H as (Si' & H).", "split.", "+", "apply in_ill1_weak.", "+", "intros H1.", "apply in_ill1_perm with (\u203c(A :: Si') ++ Ga).", "*", "apply Permutation_app; auto.", "apply Permutation_map; auto.", "*", "simpl; apply in_ill1_cntr.", "revert H1; apply in_ill1_perm.", "simpl; apply Permutation_cons; auto.", "change (!A::\u203cSi'++Ga) with (\u203c(A::Si')++Ga).", "apply Permutation_app; auto.", "apply Permutation_map, Permutation_sym; auto.", "Qed.", "Theorem S_ill_wc_weak_cntr \u03a3 \u0393 A B : In A \u03a3 -> \u203c\u03a3++\u0393 \u22a2 B <-> !A::\u203c\u03a3++\u0393 \u22a2 B.", "Proof.", "revert \u03a3 \u0393; intros Si Ga.", "intros H.", "apply In_perm in H.", "destruct H as (Si' & H).", "split.", "+", "apply in_ill4_weak.", "+", "intros H1.", "apply in_ill4_perm with (\u203c(A :: Si') ++ Ga).", "*", "apply Permutation_app; auto.", "apply Permutation_map; auto.", "*", "simpl; apply in_ill4_cntr.", "revert H1; apply in_ill4_perm.", "simpl; apply Permutation_cons; auto.", "change (!A::\u203cSi'++Ga) with (\u203c(A::Si')++Ga).", "apply Permutation_app; auto.", "apply Permutation_map, Permutation_sym; auto.", "Qed.", "Section trivial_phase_semantics.", "Variables (n : nat) (s : ill_vars -> vec nat n -> Prop).", "Reserved Notation \"'\u27e6' A '\u27e7'\" (at level 65).", "Definition ill_tps_imp (X Y : _ -> Prop) (v : vec _ n) := forall x, X x -> Y (vec_plus x v).", "Definition ill_tps_mult (X Y : _ -> Prop) (x : vec _ n) := exists a b, x = vec_plus a b /\\ X a /\\ Y b.", "Infix \"**\" := ill_tps_mult (at level 65, right associativity).", "Infix \"-*\" := ill_tps_imp (at level 65, right associativity).", "Fact ll_tps_mult_mono (X1 X2 Y1 Y2 : _ -> Prop) : (forall x, X1 x -> X2 x) -> (forall x, Y1 x -> Y2 x) -> (forall x, (X1**Y1) x -> (X2**Y2) x).", "Proof.", "intros H1 H2 x (a & b & H3 & H4 & H5); subst.", "exists a, b; auto.", "Qed.", "Fixpoint ill_tps A x : Prop := match A with | \u00a3 X => s X x | A & B => \u27e6A\u27e7 x /\\ \u27e6B\u27e7 x | !A => \u27e6A\u27e7 x /\\ x = vec_zero | A \u22b8 B => (\u27e6A\u27e7 -* \u27e6B\u27e7) x | A \u2297 B => (\u27e6A\u27e7 ** \u27e6B\u27e7) x | A \u2295 B => \u27e6A\u27e7 x \\/ \u27e6B\u27e7 x | \u27d8 => False | \u27d9 => True | \ud835\udf50 => x = vec_zero end where \"\u27e6 A \u27e7\" := (ill_tps A).", "Reserved Notation \"'[[' \u0393 ']]'\" (at level 0).", "Fixpoint ill_tps_list \u0393 := match \u0393 with | \u2205 => eq vec_zero | A::\u0393 => \u27e6A\u27e7 ** [[\u0393]] end where \"[[ \u0393 ]]\" := (ill_tps_list \u0393).", "Fact ill_tps_app \u0393 \u0394 x : [[\u0393++\u0394]] x <-> ([[\u0393]]**[[\u0394]]) x.", "Proof.", "revert \u0393 \u0394 x; intros Ga De.", "induction Ga as [ | A Ga IH ]; intros x; simpl; split; intros Hx.", "+", "exists vec_zero, x; simpl; rew vec.", "+", "destruct Hx as (a & b & H1 & H2 & H3); subst; auto; rewrite vec_zero_plus; auto.", "+", "destruct Hx as (a & b & H1 & H2 & H3).", "apply IH in H3.", "destruct H3 as (c & d & H4 & H5 & H6).", "exists (vec_plus a c), d; split.", "*", "subst; apply vec_plus_assoc.", "*", "split; auto.", "exists a, c; auto.", "+", "destruct Hx as (y & d & H1 & H2 & H3).", "destruct H2 as (a & g & H2 & H4 & H5).", "exists a, (vec_plus g d); split.", "*", "subst; symmetry; apply vec_plus_assoc.", "*", "split; auto.", "apply IH.", "exists g, d; auto.", "Qed.", "Fact ill_tps_lbang \u0393 x : [[\u203c\u0393]] x <-> [[\u0393]] x /\\ x = vec_zero.", "Proof.", "revert \u0393 x; intros Ga.", "induction Ga as [ | A Ga IH ]; intros x.", "+", "simpl; split; auto; tauto.", "+", "split.", "*", "intros (a & g & H1 & H2 & H3).", "split.", "-", "exists a, g; repeat split; auto.", "**", "apply H2.", "**", "apply IH; auto.", "-", "apply IH, proj2 in H3.", "apply proj2 in H2; subst; auto.", "apply vec_zero_plus.", "*", "intros ((a & g & H1 & H2 & H3) & H4).", "exists x, x.", "assert (a = vec_zero /\\ g = vec_zero) as E.", "{", "apply vec_plus_is_zero; subst; auto.", "}", "destruct E; subst; repeat split; auto; rew vec.", "apply IH; auto.", "Qed.", "Fact ill_tps_list_bang_zero \u0393 : [[\u203c\u0393]] vec_zero <-> forall A, In A \u0393 -> \u27e6A\u27e7 vec_zero.", "Proof.", "induction \u0393 as [ | A Ga IH ].", "+", "split.", "*", "simpl; tauto.", "*", "intros _; simpl; auto.", "+", "split.", "*", "intros (u & v & H1 & H2 & H3).", "destruct H2 as [ H2 H4 ]; subst; auto.", "rewrite vec_zero_plus in H1; subst.", "rewrite IH in H3.", "intros B [ E | HB ]; subst; auto.", "*", "intros H.", "exists vec_zero, vec_zero.", "rewrite vec_zero_plus; repeat split; auto.", "-", "apply H; left; auto.", "-", "rewrite IH.", "intros; apply H; right; auto.", "Qed.", "Fact ill_tps_perm \u0393 \u0394 : \u0393 ~p \u0394 -> forall x, [[\u0393]] x -> [[\u0394]] x.", "Proof.", "induction 1 as [ | A Ga De H IH | A B Ga | ]; simpl; auto.", "+", "intros x (a & b & H1 & H2 & H3).", "exists a, b; repeat split; auto.", "+", "intros x (a & b & H1 & H2 & c & d & H3 & H4 & H5).", "exists c, (vec_plus a d); split.", "*", "subst; rewrite (vec_plus_comm c), vec_plus_assoc, (vec_plus_comm c); auto.", "*", "split; auto.", "exists a, d; auto.", "Qed.", "Definition ill_sequent_tps \u0393 A := [[\u0393]] -* \u27e6A\u27e7.", "Notation \"'[<' \u0393 '|-' A '>]'\" := (ill_sequent_tps \u0393 A).", "Fact ill_sequent_tps_mono \u0393 A B : (forall x, \u27e6A\u27e7 x -> \u27e6B\u27e7 x) -> forall x, [< \u0393 |- A >] x -> [< \u0393 |- B >] x.", "Proof.", "intros H x; simpl; unfold ill_sequent_tps.", "intros H1 a H2.", "apply H, H1; auto.", "Qed.", "Fact ill_perm_tps \u0393 \u0394 : \u0393 ~p \u0394 -> forall x A, [< \u0393 |- A >] x -> [< \u0394 |- A >] x.", "Proof.", "intros H1 x B; unfold ill_sequent_tps.", "intros H2 a H3.", "apply H2; revert H3.", "apply ill_tps_perm, Permutation_sym; auto.", "Qed.", "Fact ill_sequent_tps_eq \u0393 A : [< \u0393 |- A >] vec_zero <-> forall x, [[\u0393]] x -> \u27e6A\u27e7 x.", "Proof.", "split.", "*", "intros H x Hx.", "rewrite <- vec_zero_plus, vec_plus_comm.", "apply (H x); trivial.", "*", "intros H x Hx.", "rewrite vec_plus_comm, vec_zero_plus; auto.", "Qed.", "Theorem ill_tps_sound \u0393 A : \u0393 \u22a2 A -> [< \u0393 |- A >] vec_zero.", "Proof.", "induction 1 as [ A | \u0393 \u0394 A B H1 IH1 H2 IH2 | \u0393 \u0394 A H1 H2 IH2 | \u0393 \u0394 A B C H1 IH1 H2 IH2 | \u0393 A B H1 IH1 | \u0393 A B C H1 IH1 | \u0393 A B C H1 IH1 | \u0393 A B H1 IH1 H2 IH2 | \u0393 A B H1 IH1 | \u0393 A H1 IH1 | \u0393 A B H1 IH1 | \u0393 A B H1 IH1 | \u0393 A B C H1 IH1 | \u0393 \u0394 A B H1 IH1 H2 IH2 | \u0393 A B C H1 IH1 H2 IH2 | \u0393 A B H1 IH1 | \u0393 A B H1 IH1 | \u0393 A | \u0393 | \u0393 A H1 IH1 | ]; unfold ill_sequent_tps in * |- *.", "+", "intros x; simpl; intros (a & b & H1 & H2 & H3); subst; eq goal H2.", "f_equal; do 2 rewrite vec_plus_comm, vec_zero_plus; auto.", "+", "intros x Hx.", "rewrite ill_tps_app in Hx.", "apply IH2.", "destruct Hx as (a & b & G1 & G2 & G3); subst.", "exists a, b; split; auto.", "split; auto.", "rewrite <- vec_zero_plus, vec_plus_comm.", "apply IH1; auto.", "+", "revert IH2; apply ill_perm_tps; auto.", "+", "intros x (y & z & H3 & H4 & H5); simpl.", "apply IH2.", "apply ill_tps_app in H5.", "destruct H5 as (g & d & H5 & H6 & H7).", "simpl in H4.", "apply IH1, H4 in H6.", "exists (vec_plus y g), d; repeat split; auto.", "*", "subst; apply vec_plus_assoc.", "*", "eq goal H6; f_equal; rew vec.", "+", "simpl; intros y Hy a Ha.", "rewrite vec_plus_assoc.", "apply IH1.", "exists a, y; repeat split; auto; lia.", "+", "intros x (a & b & H2 & H3 & H4); apply IH1.", "exists a, b; repeat split; auto; apply H3.", "+", "intros x (a & b & H2 & H3 & H4); apply IH1.", "exists a, b; repeat split; auto; apply H3.", "+", "intros x Hx; split.", "*", "apply IH1; auto.", "*", "apply IH2; auto.", "+", "intros x (a & g & H2 & H3 & H4).", "apply IH1; exists a, g; repeat split; auto.", "apply H3.", "+", "intros x Hx; split.", "apply IH1; auto.", "rew vec.", "apply ill_tps_lbang in Hx; tauto.", "+", "intros x (a & g & H2 & H3 & H4).", "apply IH1.", "apply proj2 in H3; subst; auto.", "rew vec; auto.", "+", "intros x (a & g & H2 & H3 & H4).", "apply IH1.", "exists a, g.", "repeat (split; auto).", "exists a, g.", "repeat (split; auto).", "apply proj2 in H3.", "subst; rew vec; auto.", "+", "intros x Hx.", "apply IH1.", "destruct Hx as (c & g & ? & (a & b & ? & H2 & H3) & H4); subst.", "exists a, (vec_plus b g); split; auto.", "*", "rewrite vec_plus_assoc; trivial.", "*", "split; auto; exists b, g; auto.", "+", "intros x Hx.", "apply ill_tps_app in Hx.", "destruct Hx as (a & b & ? & H3 & H4); subst.", "exists a, b; split.", "*", "rewrite vec_plus_comm, vec_zero_plus; auto.", "*", "split; rewrite <- vec_zero_plus, vec_plus_comm.", "-", "apply IH1; auto.", "-", "apply IH2; auto.", "+", "intros x Hx.", "destruct Hx as (u & g & ? & [ G1 | G1 ] & G2); subst.", "*", "apply IH1; exists u, g; auto.", "*", "apply IH2; exists u, g; auto.", "+", "intros x Hx; left; apply IH1; auto.", "+", "intros x Hx; right; apply IH1; auto.", "+", "intros ? (? & _ & _ & [] & _).", "+", "intros x _; red; trivial.", "+", "intros x (i & g & ? & H2 & H3); subst.", "red in H2; subst.", "rewrite vec_zero_plus.", "apply IH1; auto.", "+", "intros x Hx; red in Hx; subst.", "rewrite vec_zero_plus; red; trivial.", "Qed.", "End trivial_phase_semantics."], "theorems": [{"name": "S_ill_restr_restr_wc", "kind": "Fact", "begin": 6, "end": 11}, {"name": "S_ill_full_wc", "kind": "Fact", "begin": 12, "end": 17}, {"name": "S_ill_restr_full", "kind": "Fact", "begin": 18, "end": 23}, {"name": "S_ill_restr_full_wc", "kind": "Fact", "begin": 24, "end": 32}, {"name": "S_ill_restr_weak", "kind": "Fact", "begin": 36, "end": 39}, {"name": "S_ill_wc_weak", "kind": "Fact", "begin": 40, "end": 43}, {"name": "S_ill_restr_cntr", "kind": "Fact", "begin": 44, "end": 62}, {"name": "S_ill_wc_cntr", "kind": "Fact", "begin": 63, "end": 81}, {"name": "S_ill_restr_weak_cntr", "kind": "Theorem", "begin": 82, "end": 104}, {"name": "S_ill_wc_weak_cntr", "kind": "Theorem", "begin": 105, "end": 127}, {"name": "ll_tps_mult_mono", "kind": "Fact", "begin": 135, "end": 139}, {"name": "ill_tps_app", "kind": "Fact", "begin": 143, "end": 171}, {"name": "ill_tps_lbang", "kind": "Fact", "begin": 172, "end": 202}, {"name": "ill_tps_list_bang_zero", "kind": "Fact", "begin": 203, "end": 229}, {"name": "ill_tps_perm", "kind": "Fact", "begin": 230, "end": 244}, {"name": "ill_sequent_tps_mono", "kind": "Fact", "begin": 247, "end": 252}, {"name": "ill_perm_tps", "kind": "Fact", "begin": 253, "end": 259}, {"name": "ill_sequent_tps_eq", "kind": "Fact", "begin": 260, "end": 270}, {"name": "ill_tps_sound", "kind": "Theorem", "begin": 271, "end": 385}]}