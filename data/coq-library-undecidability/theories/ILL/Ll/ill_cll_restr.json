{"code": ["Require Import List Permutation Arith.", "From Undecidability.ILL Require Import ILL CLL ill_cll.", "Set Implicit Arguments.", "Fact app_eq_single_inv X (l m : list X) x : l++m = x::nil -> l = nil /\\ m = x::nil \\/ l = x::nil /\\ m = nil.", "Proof.", "intros H.", "destruct l as [ | y l ]; auto.", "right.", "inversion H.", "destruct l; destruct m; auto; discriminate.", "Qed.", "Tactic Notation \"app\" \"inv\" \"singleton\" \"in\" hyp(H) := apply app_eq_single_inv in H as [ (-> & ->) | (-> & ->) ].", "Tactic Notation \"app\" \"inv\" \"nil\" \"in\" hyp(H) := apply app_eq_nil in H as (-> & ->).", "Local Infix \"~p\" := (@Permutation _) (at level 70).", "Section S_ill_cll_restr.", "Notation \"\u0393 '\u22a2i' A\" := (S_ill_restr \u0393 A) (at level 70).", "Notation \"\u0393 '\u22a2c' \u0394\" := (S_cll_restr \u0393 \u0394) (at level 70).", "Hint Resolve Permutation_map : core.", "Theorem S_ill_cll_restr \u0393 A : \u0393 \u22a2i A -> \u27e6\u0393\u27e7 \u22a2c [A]::\u2205.", "Proof.", "induction 1.", "+", "apply in_cll1_ax.", "+", "apply (@in_cll1_perm \u27e6\u0393\u27e7 ([A]::nil)); auto.", "+", "simpl; rewrite map_app; now apply in_cll1_limp_l with (\u0394 := \u2205) (\u0394' := _::_).", "+", "now apply in_cll1_limp_r with (\u0394 := \u2205).", "+", "now apply in_cll1_with_l1.", "+", "now apply in_cll1_with_l2.", "+", "now apply in_cll1_with_r with (\u0394 := \u2205).", "+", "now apply in_cll1_bang_l.", "+", "rewrite ill_cll_lbang in *; simpl; now apply in_cll1_bang_r.", "+", "now apply in_cll1_weak_l.", "+", "now apply in_cll1_cntr_l.", "Qed.", "Let cll_ill_empty_rec \u0393 \u0394 : \u0393 \u22a2c \u0394 -> \u0394 <> \u2205.", "Proof.", "induction 1 as [ A (* ax *) | \u0393 \u0394 \u0393' \u0394' H1 H2 H3 IH3 (* perm *) | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 | \u0393 \u0394 A B H1 IH1 (* -o *) | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 H2 IH2 (* & *) | \u0393 A \u0394 H1 IH1 | \u0393 A H1 IH1 (* bang *) | \u0393 A \u0394 H1 IH1 (* weak *) | \u0393 A \u0394 H1 IH1 ]; (* cntr *) auto; try discriminate.", "+", "intros ->; now apply IH3, Permutation_nil, Permutation_sym.", "+", "intros H; now app inv nil in H.", "Qed.", "Let cll_ill_empty \u0393 : ~ \u0393 \u22a2c \u2205.", "Proof.", "intros H; now apply cll_ill_empty_rec with (1 := H).", "Qed.", "Let cll_ill_rec \u0393 \u0394 : \u0393 \u22a2c \u0394 -> forall A, \u0394 = A::\u2205 -> \u27ea\u0393\u27eb \u22a2i \u27e8A\u27e9.", "Proof.", "induction 1 as [ A (* ax *) | \u0393 \u0394 \u0393' \u0394' H1 H2 H3 IH3 (* perm *) | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 | \u0393 \u0394 A B H1 IH1 (* -o *) | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 H2 IH2 (* & *) | \u0393 A \u0394 H1 IH1 | \u0393 A H1 IH1 (* bang *) | \u0393 A \u0394 H1 IH1 (* weak *) | \u0393 A \u0394 H1 IH1 ]; (* cntr *) intros C HC; try discriminate.", "+", "inversion HC; constructor.", "+", "subst.", "apply (Permutation_map cll_ill) in H1.", "constructor 2 with (1 := H1).", "apply Permutation_sym, Permutation_length_1_inv in H2 as ->.", "apply IH3; auto.", "+", "app inv singleton in HC.", "*", "simpl; rewrite map_app; constructor; auto.", "*", "apply cll_ill_empty in H2 as [].", "+", "inversion HC; subst.", "constructor; apply IH1; auto.", "+", "rewrite HC in *.", "apply in_ill1_with_l1, IH1; auto.", "+", "rewrite HC in *.", "apply in_ill1_with_l2, IH1; auto.", "+", "inversion HC; subst; clear HC.", "constructor; auto.", "+", "subst; constructor; apply IH1; auto.", "+", "inversion HC; subst.", "rewrite cll_ill_lbang; simpl.", "constructor.", "rewrite <- cll_ill_lbang; auto.", "+", "subst; apply in_ill1_weak; auto.", "+", "subst; apply in_ill1_cntr; auto.", "Qed.", "Theorem S_cll_ill_restr \u0393 A : \u0393 \u22a2c A::\u2205 -> \u27ea\u0393\u27eb \u22a2i \u27e8A\u27e9.", "Proof.", "intros H; now apply cll_ill_rec with (1 := H).", "Qed.", "Hint Resolve S_ill_cll_restr S_cll_ill_restr : core.", "Theorem S_ill_cll_restr_equiv \u0393 A : \u0393 \u22a2i A <-> \u27e6\u0393\u27e7 \u22a2c [A]::\u2205.", "Proof.", "split; auto.", "intros H; apply S_cll_ill_restr in H; revert H.", "now rewrite ill_cll_ill_list, ill_cll_ill.", "Qed.", "End S_ill_cll_restr."], "theorems": [{"name": "app_eq_single_inv", "kind": "Fact", "begin": 3, "end": 10}, {"name": "S_ill_cll_restr", "kind": "Theorem", "begin": 18, "end": 43}, {"name": "cll_ill_empty_rec", "kind": "Let", "begin": 44, "end": 51}, {"name": "cll_ill_empty", "kind": "Let", "begin": 52, "end": 55}, {"name": "cll_ill_rec", "kind": "Let", "begin": 56, "end": 96}, {"name": "S_cll_ill_restr", "kind": "Theorem", "begin": 97, "end": 100}, {"name": "S_ill_cll_restr_equiv", "kind": "Theorem", "begin": 102, "end": 107}]}