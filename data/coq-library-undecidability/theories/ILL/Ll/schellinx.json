{"code": ["Require Import List Permutation.", "From Undecidability.Shared.Libs.DLW Require Import utils.", "From Undecidability.ILL Require Import ILL CLL ill_cll.", "Set Implicit Arguments.", "Fact app_eq_single_inv X (l m : list X) x : l++m = x::nil -> l = nil /\\ m = x::nil \\/ l = x::nil /\\ m = nil.", "Proof.", "intros H.", "destruct l as [ | y l ]; auto.", "right.", "inversion H.", "destruct l; destruct m; auto; discriminate.", "Qed.", "Tactic Notation \"app\" \"inv\" \"singleton\" \"in\" hyp(H) := apply app_eq_single_inv in H as [ (-> & ->) | (-> & ->) ].", "Tactic Notation \"app\" \"inv\" \"nil\" \"in\" hyp(H) := apply app_eq_nil in H as (-> & ->).", "Local Infix \"~p\" := (@Permutation _) (at level 70).", "Notation \"\u0393 '\u22a2i' A\" := (S_ill \u0393 A) (at level 70, no associativity).", "Notation \"\u0393 '\u22a2c' \u0394\" := (S_cll \u0393 \u0394) (at level 70, no associativity).", "Section ill_cll_is_sound.", "Hint Resolve Permutation_map : core.", "Theorem ill_cll_soundness \u0393 A : \u0393 \u22a2i A -> \u27e6\u0393\u27e7 \u22a2c [A]::\u2205.", "Proof.", "induction 1; simpl in *.", "+", "apply in_cll_ax.", "+", "apply (@in_cll_perm \u27e6\u0393\u27e7 ([A]::nil)); auto.", "+", "rewrite map_app.", "now apply in_cll_limp_l with (\u0394 := \u2205) (\u0394' := _::_).", "+", "now apply in_cll_limp_r with (\u0394 := \u2205).", "+", "now apply in_cll_with_l1.", "+", "now apply in_cll_with_l2.", "+", "now apply in_cll_with_r with (\u0394 := \u2205).", "+", "now apply in_cll_bang_l.", "+", "rewrite ill_cll_lbang in *.", "now apply in_cll_bang_r with (\u0394 := \u2205).", "+", "now apply in_cll_weak_l.", "+", "now apply in_cll_cntr_l.", "+", "now apply in_cll_times_l.", "+", "rewrite map_app.", "now apply in_cll_times_r with (\u0394 := \u2205) (\u0394' := \u2205).", "+", "now apply in_cll_plus_l.", "+", "now apply in_cll_plus_r1.", "+", "now apply in_cll_plus_r2.", "+", "apply in_cll_bot_l.", "+", "apply in_cll_top_r.", "+", "now apply in_cll_unit_l.", "+", "apply in_cll_unit_r.", "Qed.", "End ill_cll_is_sound.", "Section Schellinx_observation.", "Let schellinx_rec \u0393 \u0394 : \u0393 \u22a2c \u0394 -> \u0394 = \u2205 -> exists f, In f \u0393 /\\ cll_has_bot_zero_neg f.", "Proof.", "induction 1 as [ A (* ax *) | \u0393 \u0394 \u0393' \u0394' H1 H2 H3 IH3 (* perm *) | \u0393 \u0394 A H1 IH1 | \u0393 \u0394 A H1 IH1 (* negation *) | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 | \u0393 \u0394 A B H1 IH1 (* -o *) | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 H2 IH2 (* & *) | \u0393 A B \u0394 H1 IH1 | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 (* * *) | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 | \u0393 A B \u0394 H1 IH1 (* par *) | \u0393 A B \u0394 H1 IH1 H2 IH2 | \u0393 A B \u0394 H1 IH1 | \u0393 A B \u0394 H1 IH1 (* + *) | | (* bot, top *) | \u0393 \u0394 H1 IH1 | (* unit *) | | (* zero *) | \u0393 A \u0394 H1 IH1 | \u0393 A \u0394 H1 IH1 (* bang *) | \u0393 A \u0394 H1 IH1 | (* qmrk *) | \u0393 A \u0394 H1 IH1 | (* weak *) | \u0393 A \u0394 H1 IH1 | ]; (* cntr *) try discriminate.", "+", "intros ->.", "apply Permutation_sym, Permutation_nil in H2 as ->; auto.", "destruct IH3 as (f & G1 & G2); auto.", "exists f; split; auto.", "revert G1; now apply Permutation_in.", "+", "intros ->; exists (\u2296A); simpl; auto.", "+", "intros H.", "app inv nil in H.", "destruct IH2 as (f & [ <- | ] & ?); auto.", "*", "exists (A \u22b8 B); simpl; split; auto.", "*", "exists f; split; auto.", "right; apply in_or_app; tauto.", "+", "intros ->.", "destruct IH1 as (f & [ <- | ] & ?); auto.", "*", "exists (A&B); simpl; auto.", "*", "exists f; simpl; auto.", "+", "intros ->.", "destruct IH1 as (f & [ <- | ] & ?); auto.", "*", "exists (A&B); simpl; auto.", "*", "exists f; simpl; auto.", "+", "intros ->.", "destruct IH1 as (f & [ <- | [ <- | ] ] & ?); auto.", "*", "exists (A\u2297B); simpl; auto.", "*", "exists (A\u2297B); simpl; auto.", "*", "exists f; simpl; auto.", "+", "intros H.", "app inv nil in H.", "destruct IH1 as (f & [ <- | ] & ?); auto.", "*", "exists (A\u214bB); simpl; auto.", "*", "exists f; simpl; split; auto.", "rewrite in_app_iff; auto.", "+", "intros ->.", "destruct IH1 as (f & [ <- | ] & ?); auto.", "*", "exists (A\u2295B); simpl; auto.", "*", "exists f; simpl; auto.", "+", "exists \u27d8; simpl; auto.", "+", "intros ->.", "destruct IH1 as (f & ? & ?); auto.", "exists f; simpl; auto.", "+", "exists \ud835\udfd8; simpl; auto.", "+", "intros ->.", "destruct IH1 as (f & [ <- | ] & ?); auto.", "*", "exists (!A); simpl; auto.", "*", "exists f; simpl; auto.", "+", "destruct \u0394; try discriminate; intros _ ; simpl in *.", "destruct IH1 as (f & [ <- | ] & ?); auto.", "*", "exists (\u203dA); simpl; auto.", "*", "exists f; simpl; auto.", "+", "intros ->.", "destruct IH1 as (f & ? & ?); auto.", "*", "exists f; simpl; auto.", "+", "intros ->.", "destruct IH1 as (f & [ <- | [ <- | ] ] & ?); auto.", "*", "exists (!A); simpl; auto.", "*", "exists (!A); simpl; auto.", "*", "exists f; simpl; auto.", "Qed.", "Lemma Schellinx_observation \u0393 : \u0393 \u22a2c \u2205 -> exists f, In f \u0393 /\\ cll_has_bot_zero_neg f.", "Proof.", "intros; now apply schellinx_rec with (2 := eq_refl).", "Qed.", "End Schellinx_observation.", "Section cll_ill_soundness.", "Tactic Notation \"solve\" \"Forall\" := repeat rewrite Forall_cons_inv in *; repeat rewrite Forall_app in *; simpl in *; tauto.", "Let cll_ill_rec \u0393 \u0394 A : \u0393 \u22a2c \u0394 -> \u0394 = A::\u2205 -> Forall from_ill (A::\u0393) -> \u27ea\u0393\u27eb \u22a2i \u27e8A\u27e9 \\/ cll_has_bot_zero_neg A \\/ exists f, In f \u0393 /\\ cll_has_bot_zero_neg f.", "Proof.", "intros H; revert H A.", "induction 1 as [ A (* ax *) | \u0393 \u0394 \u0393' \u0394' H1 H2 H3 IH3 (* perm *) | \u0393 \u0394 A H1 IH1 | \u0393 \u0394 A H1 IH1 (* negation *) | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 | \u0393 \u0394 A B H1 IH1 (* -o *) | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 | \u0393 \u0394 A B H1 IH1 H2 IH2 (* & *) | \u0393 A B \u0394 H1 IH1 | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 (* * *) | \u0393 \u0394 \u0393' \u0394' A B H1 IH1 H2 IH2 | \u0393 A B \u0394 H1 IH1 (* par *) | \u0393 A B \u0394 H1 IH1 H2 IH2 | \u0393 A B \u0394 H1 IH1 | \u0393 A B \u0394 H1 IH1 (* + *) | | (* bot, top *) | \u0393 \u0394 H1 IH1 | (* unit *) | | (* zero *) | \u0393 A \u0394 H1 IH1 | \u0393 A \u0394 H1 IH1 (* bang *) | \u0393 A \u0394 H1 IH1 | (* qmrk *) | \u0393 A \u0394 H1 IH1 | (* weak *) | \u0393 A \u0394 H1 IH1 | ]; (* cntr *) intros C H\u0394 H\u0393.", "+", "inversion H\u0394; left; simpl; constructor.", "+", "subst.", "apply Permutation_sym, Permutation_length_1_inv in H2 as ->.", "destruct (IH3 _ eq_refl) as [ H | [ | (f & H & ?) ] ]; auto.", "*", "rewrite Forall_cons_inv in *.", "destruct H\u0393 as (? & H\u0393); split; auto.", "revert H\u0393; apply Permutation_Forall, Permutation_sym; auto.", "*", "left; apply in_ill3_perm with (2 := H).", "now apply Permutation_map.", "*", "do 2 right; exists f; split; auto.", "revert H; now apply Permutation_in.", "+", "contradict H\u0393; solve Forall.", "+", "inversion H\u0394; subst; contradict H\u0393; solve Forall.", "+", "app inv singleton in H\u0394.", "*", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; auto.", "-", "solve Forall.", "-", "destruct (IH2 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; auto.", "++", "solve Forall.", "++", "left; simpl; rewrite map_app; constructor; auto.", "++", "do 2 right; exists (A\u22b8B); simpl; tauto.", "++", "do 2 right; exists f; split; auto; right; apply in_or_app; tauto.", "-", "do 2 right; exists (A\u22b8B); simpl; tauto.", "-", "do 2 right; exists f; split; auto; right; apply in_or_app; tauto.", "*", "apply Schellinx_observation in H2 as (f & [ <- | ] & ?).", "-", "do 2 right; exists (A\u22b8B); simpl; tauto.", "-", "do 2 right; exists f; split; auto; right; apply in_or_app; tauto.", "+", "inversion H\u0394; subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; constructor; auto.", "*", "do 2 right; exists f; auto.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; apply in_ill3_with_l1; auto.", "*", "do 2 right; exists (A&B); simpl; tauto.", "*", "do 2 right; exists f; auto.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; apply in_ill3_with_l2; auto.", "*", "do 2 right; exists (A&B); simpl; tauto.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst; clear H\u0394.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "destruct (IH2 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "-", "solve Forall.", "-", "left; simpl; constructor; auto.", "-", "do 2 right; exists f; simpl; tauto.", "*", "do 2 right; exists f; simpl; tauto.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | [ <- | ] ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; constructor; auto.", "*", "do 2 right; exists (A\u2297B); simpl; tauto.", "*", "do 2 right; exists (A\u2297B); simpl; tauto.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst.", "app inv nil in H3.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "destruct (IH2 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "-", "solve Forall.", "-", "left; rewrite map_app; constructor; auto.", "-", "do 2 right; exists f; split; auto.", "apply in_or_app; auto.", "*", "do 2 right; exists f; split; auto.", "apply in_or_app; auto.", "+", "contradict H\u0393; solve Forall.", "+", "inversion H\u0394; subst; contradict H\u0393; solve Forall.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "destruct (IH2 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; simpl; auto.", "-", "solve Forall.", "-", "left; simpl; now constructor.", "-", "do 2 right; exists (A\u2295B); simpl; tauto.", "-", "do 2 right; exists f; auto.", "*", "do 2 right; exists (A\u2295B); simpl; tauto.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; now apply in_ill3_plus_r1.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; now apply in_ill3_plus_r2.", "*", "do 2 right; exists f; auto.", "+", "left; constructor.", "+", "inversion H\u0394; subst; left; constructor.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; now constructor.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst; left; constructor.", "+", "discriminate.", "+", "inversion H\u0394; subst; contradict H\u0393; solve Forall.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; now constructor.", "*", "do 2 right; exists (!A); simpl; auto.", "*", "do 2 right; exists f; auto.", "+", "destruct \u0394; try discriminate.", "inversion H\u0394; subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; rewrite cll_ill_lbang in *; now constructor.", "*", "do 2 right; exists f; auto.", "+", "destruct \u0394 as [ | D [ ] ]; try discriminate.", "inversion H\u0394; subst; contradict H\u0393; solve Forall.", "+", "inversion H\u0394; subst; contradict H\u0393; solve Forall.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & ? & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; now constructor.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst.", "rewrite Forall_cons_inv in H\u0393; simpl in H\u0393; tauto.", "+", "subst.", "destruct (IH1 _ eq_refl) as [ ? | [ | (f & [ <- | [ <- | ] ] & ?) ] ]; simpl; auto.", "*", "solve Forall.", "*", "left; now constructor.", "*", "do 2 right; exists (!A); simpl; auto.", "*", "do 2 right; exists (!A); simpl; auto.", "*", "do 2 right; exists f; auto.", "+", "inversion H\u0394; subst; contradict H\u0393; solve Forall.", "Qed.", "Lemma cll_ill_soundness \u0393 A : \u27e6\u0393\u27e7 \u22a2c [A]::\u2205 -> \u0393 \u22a2i A \\/ ill_has_bot A \\/ exists f, In f \u0393 /\\ ill_has_bot f.", "Proof.", "intros H.", "apply cll_ill_rec with (2 := eq_refl) in H.", "*", "rewrite ill_cll_ill_list, ill_cll_ill, <- ill_cll_has_bot_eq in H.", "destruct H as [ | [ | (f & G1 & G2) ] ]; auto.", "do 2 right.", "apply in_map_iff in G1.", "destruct G1 as (g & <- & ?).", "exists g; rewrite ill_cll_has_bot_eq; auto.", "*", "rewrite -> Forall_map with (f := ill_cll) (ll := A::\u0393), Forall_forall.", "intros; apply ill_cll_from_ill.", "Qed.", "End cll_ill_soundness.", "Theorem ill_cll_equiv \u0393 A : (forall f, In f (A::\u0393) -> ~ ill_has_bot f) -> \u0393 \u22a2i A <-> \u27e6\u0393\u27e7 \u22a2c [A]::\u2205.", "Proof.", "intros H; split.", "+", "apply ill_cll_soundness.", "+", "intros H1.", "apply cll_ill_soundness in H1 as [ | [ ? | (f & ? & ?) ] ]; auto.", "*", "destruct (H A); simpl; auto.", "*", "destruct (H f); simpl; auto.", "Qed."], "theorems": [{"name": "app_eq_single_inv", "kind": "Fact", "begin": 4, "end": 11}, {"name": "ill_cll_soundness", "kind": "Theorem", "begin": 19, "end": 65}, {"name": "schellinx_rec", "kind": "Let", "begin": 68, "end": 163}, {"name": "Schellinx_observation", "kind": "Lemma", "begin": 164, "end": 167}, {"name": "cll_ill_rec", "kind": "Let", "begin": 171, "end": 411}, {"name": "cll_ill_soundness", "kind": "Lemma", "begin": 412, "end": 426}, {"name": "ill_cll_equiv", "kind": "Theorem", "begin": 428, "end": 440}]}