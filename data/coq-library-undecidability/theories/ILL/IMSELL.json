{"code": ["Require Import List Permutation.", "Set Implicit Arguments.", "Local Infix \"~p\" := (@Permutation _) (at level 70).", "Reserved Notation \"A \u22b8 B\" (at level 51, right associativity, format \"A \u22b8 B\").", "Reserved Notation \"'![' m ']' x\" (at level 52, format \"![ m ] x\").", "Reserved Notation \"\u203c x\" (at level 60, format \"\u203c x\").", "Section IMSELL.", "Variables (var bang : Type) (bang_le : bang -> bang -> Prop) (* a pre-order on modalities *) (bang_U : bang -> Prop) (* universal modalities have structural rules *) .", "Notation \u039b := bang.", "Inductive imsell_form : Type := | imsell_var : var -> imsell_form | imsell_ban : \u039b -> imsell_form -> imsell_form | imsell_imp : imsell_form -> imsell_form -> imsell_form.", "Infix \"\u22b8\" := imsell_imp.", "Notation \"![ m ] x\" := (imsell_ban m x).", "Notation \"\u00a3\" := imsell_var.", "Definition imsell_lban := map (fun '(m,A) => ![m]A).", "Notation \"\u203c \u0393\" := (imsell_lban \u0393).", "Notation \"u \u227c l\" := (forall '(v,A), In (v,A) l -> bang_le u v) (at level 70).", "Notation U := bang_U.", "Reserved Notation \"l \u22a2 x\" (at level 70, no associativity).", "Inductive S_imsell : list imsell_form -> imsell_form -> Prop := | in_imsell_ax A : A::nil \u22a2 A (* [identity] *) | in_imsell_perm \u0393 \u0394 A : \u0393 ~p \u0394 -> \u0393 \u22a2 A (*----------------------------- [permutation] *) -> \u0394 \u22a2 A | in_imsell_limp_l \u0393 \u0394 A B C : \u0393 \u22a2 A -> B::\u0394 \u22a2 C (*----------------------------- [\u22b8L] *) -> A\u22b8B::\u0393++\u0394 \u22a2 C | in_imsell_limp_r \u0393 A B : A::\u0393 \u22a2 B (*----------------------------- [\u22b8R] *) -> \u0393 \u22a2 A\u22b8B | in_imsell_bang_l \u0393 m A B : A::\u0393 \u22a2 B (*----------------------------- [!L] *) -> ![m]A::\u0393 \u22a2 B | in_imsell_bang_r \u0393 m A : m \u227c \u0393 -> \u203c\u0393 \u22a2 A (*----------------------------- [!R] *) -> \u203c\u0393 \u22a2 ![m]A | in_imsell_weak \u0393 u A B : U u -> \u0393 \u22a2 B (*----------------------------- [weakening] *) -> ![u]A::\u0393 \u22a2 B | in_imsell_cntr \u0393 u A B : U u -> ![u]A::![u]A::\u0393 \u22a2 B (*----------------------------- [contraction] *) -> ![u]A::\u0393 \u22a2 B where \"\u0393 \u22a2 A\" := (S_imsell \u0393 A).", "End IMSELL.", "Infix \"\u22b8\" := imsell_imp.", "Notation \"![ m ] x\" := (imsell_ban m x).", "Notation \"\u00a3\" := imsell_var.", "Notation \"\u203c \u0393\" := (imsell_lban \u0393).", "Record IMSELL_sig : Type := { IMSELL_\u039b :> Type; IMSELL_le : IMSELL_\u039b -> IMSELL_\u039b -> Prop; IMSELL_refl : forall m, IMSELL_le m m; IMSELL_trans : forall u v w, IMSELL_le u v -> IMSELL_le v w -> IMSELL_le u w; IMSELL_U : IMSELL_\u039b -> Prop; IMSELL_clos : forall u v, IMSELL_U u -> IMSELL_le u v -> IMSELL_U v }.", "Section imsell3.", "Let bang := option bool.", "Let bang_le (u v : bang) := match v with | None => True | Some _ => u = v end.", "Let bang_U := @eq bang None.", "Definition imsell3 : IMSELL_sig.", "Proof.", "exists bang bang_le bang_U; trivial.", "all: repeat intros [[]|]; now simpl.", "Defined.", "End imsell3.", "Local Infix \"\u2264\" := (@IMSELL_le _) (at level 70).", "Local Notation \"u \u2270 v\" := (~ u \u2264 v) (at level 70).", "Local Notation U := (@IMSELL_U _).", "Definition IMSELL_sig3 := { S : IMSELL_sig | exists a b i : S, a \u2264 i /\\ b \u2264 i /\\ a \u2270 b /\\ b \u2270 a /\\ ~ U a /\\ ~ U b /\\ U i }.", "Definition IMSELL_problem (S : IMSELL_sig) := let F := imsell_form nat (IMSELL_\u039b S) in (list F * F)%type.", "Definition IMSELL_problem3 (S : IMSELL_sig3) := IMSELL_problem (proj1_sig S).", "Definition IMSELL_cf_PROVABILITY S (P : IMSELL_problem S) := let (\u0393,A) := P in S_imsell (IMSELL_le S) (IMSELL_U S) \u0393 A.", "Definition IMSELL_cf_PROVABILITY3 S (P : IMSELL_problem3 S) := IMSELL_cf_PROVABILITY P."], "theorems": [{"name": "imsell3", "kind": "Definition", "begin": 29, "end": 33}]}