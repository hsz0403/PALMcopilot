{"code": ["Require Import Arith Lia List Bool.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list sums bounded_quantification.", "From Undecidability.H10.Matija Require Import cipher.", "From Undecidability.H10.Dio Require Import dio_logic dio_cipher dio_elem.", "Set Implicit Arguments.", "Set Default Proof Using \"Type\".", "Local Notation power := (mscal mult 1).", "Local Notation \"\u2211\" := (msum plus 0).", "Section dio_rel_bounded_fall.", "Section dio_bounded_elem.", "Variable (k : nat).", "Notation iq := (k+1).", "Notation il := (k+2).", "Let dc_Code (c : dio_constraint) \u03c9 := match c with | (u, dee_nat n) => Const (\u03c9 il) (\u03c9 iq) n (\u03c9 u) | (u, dee_var v) => \u03c9 u = \u03c9 v | (u, dee_par 0) => \u03c9 u = \u03c9 k | (u, dee_par (S p)) => Const (\u03c9 il) (\u03c9 iq) (\u03c9 (k+2+p)) (\u03c9 u) | (u, dee_comp do_add v w) => Code_plus (\u03c9 u) (\u03c9 v) (\u03c9 w) | (u, dee_comp do_mul v w) => Code_mult (\u03c9 il) (\u03c9 iq) (\u03c9 u) (\u03c9 v) (\u03c9 w) end.", "Local Fact dio_rel_dc_Code c : \ud835\udd3bR (dc_Code c).", "Proof.", "destruct c as (u & [ n | v | [] | [] v w ]); unfold dc_Code; dio auto.", "Defined.", "Hint Resolve dio_rel_dc_Code : dio_rel_db.", "Local Fact dc_Code_spec c \u03c6 \u03c0 \u03bd \u03c9 : (forall i, i < k -> is_cipher_of (\u03bd 0) (\u03c0 iq) (\u03c6 i) (\u03c0 i)) -> (is_cipher_of (\u03bd 0) (\u03c0 iq) (fun n => n) (\u03c0 k)) -> (forall x, dc_vars c x -> x < k) -> (forall i, i < il -> \u03c9 i = \u03c0 i) -> (forall i, il <= i -> \u03c9 i = \u03bd (i-il)) -> dc_Code c \u03c9 <-> forall j, j < \u03bd 0 -> dc_eval (fun i => \u03c6 i j) (j\u00b7\u03bd) c.", "Proof.", "intros G1 G2 G3 G4 G5.", "assert (\u03c9 il = \u03bd 0) as G0.", "{", "rewrite G5; try lia; f_equal; lia.", "}", "destruct c as (u & [ n | v | [ | p ] | [] v w ]); simpl.", "+", "assert (u < k) as Hu.", "{", "apply G3; left; auto.", "}", "rewrite G0, G4, G4; try lia.", "specialize (G1 _ Hu).", "unfold dc_eval; simpl; split.", "*", "intros (g & Hg1 & Hg4).", "generalize (is_cipher_of_inj G1 Hg1); intros G6.", "intros; rewrite G6, Hg4; auto; lia.", "*", "intros; exists (\u03c6 u); split; auto.", "+", "assert (u < k) as Hu.", "{", "apply G3; cbv; auto.", "}", "assert (v < k) as Hv.", "{", "apply G3; cbv; auto.", "}", "do 2 (rewrite G4; try lia).", "unfold dc_eval; simpl.", "apply G1 in Hu.", "apply G1 in Hv.", "apply (is_cipher_of_equiv Hu Hv).", "+", "assert (u < k) as Hu.", "{", "apply G3; cbv; auto.", "}", "do 2 (rewrite G4; try lia).", "unfold dc_eval; simpl.", "apply G1 in Hu.", "apply (is_cipher_of_equiv Hu G2).", "+", "rewrite G0, G4; try lia.", "rewrite G5; try lia.", "replace (il+p-il) with p by lia.", "assert (u < k) as Hu.", "{", "apply G3; cbv; auto.", "}", "rewrite G4; try lia.", "apply G1 in Hu.", "unfold dc_eval; simpl; split.", "*", "intros (g & Hg1 & Hg2).", "generalize (proj1 (is_cipher_of_equiv Hu Hg1) eq_refl); intros G6.", "intros; rewrite G6, Hg2; auto.", "*", "intro; exists (\u03c6 u); auto.", "+", "assert (Hu : u < k).", "{", "apply G3; cbv; auto.", "}", "assert (Hv : v < k).", "{", "apply G3; cbv; auto.", "}", "assert (Hw : w < k).", "{", "apply G3; cbv; auto.", "}", "do 3 (rewrite G4; try lia).", "apply G1 in Hu; apply G1 in Hv; apply G1 in Hw.", "rewrite Code_plus_spec with (1 := Hu) (2 := Hv) (3 := Hw).", "unfold dc_eval; simpl; tauto.", "+", "assert (Hu : u < k).", "{", "apply G3; cbv; auto.", "}", "assert (Hv : v < k).", "{", "apply G3; cbv; auto.", "}", "assert (Hw : w < k).", "{", "apply G3; cbv; auto.", "}", "rewrite G0; do 4 (rewrite G4; try lia).", "apply G1 in Hu; apply G1 in Hv; apply G1 in Hw.", "rewrite Code_mult_spec with (1 := Hu) (2 := Hv) (3 := Hw).", "unfold dc_eval; simpl; tauto.", "Qed.", "Local Definition dc_list_Code ll \u03bd := fold_right (fun c P => dc_Code c \u03bd /\\ P) True ll.", "Local Fact dio_rel_dc_list_Code ll : \ud835\udd3bR (dc_list_Code ll).", "Proof.", "induction ll; unfold dc_list_Code; simpl; dio auto.", "Qed.", "Hint Resolve dio_rel_dc_list_Code : dio_rel_db.", "Local Fact dc_list_Code_spec ll \u03c6 \u03c0 \u03bd \u03c9 : (forall i, i < k -> is_cipher_of (\u03bd 0) (\u03c0 iq) (\u03c6 i) (\u03c0 i)) -> (is_cipher_of (\u03bd 0) (\u03c0 iq) (fun n => n) (\u03c0 k)) -> (forall c, In c ll -> forall x, dc_vars c x -> x < k) -> (forall i, i < il -> \u03c9 i = \u03c0 i) -> (forall i, il <= i -> \u03c9 i = \u03bd (i-il)) -> dc_list_Code ll \u03c9 <-> forall j, j < \u03bd 0 -> Forall (dc_eval (fun i => \u03c6 i j) (j\u00b7\u03bd)) ll.", "Proof.", "intros G1 G2 G3 G4 G5; revert G3.", "rewrite <- Forall_forall.", "induction 1 as [ | c ll F1 F2 IF2 ]; simpl.", "+", "split; auto.", "+", "rewrite IF2, dc_Code_spec; auto.", "split.", "*", "intros (E1 & E2) j Hj; constructor; auto.", "*", "intros E1; split; intros j Hj; specialize (E1 _ Hj); rewrite Forall_cons_inv in E1; tauto.", "Qed.", "Local Definition ciphers \u03bd := CodeNat (\u03bd il) (\u03bd iq) (\u03bd k) /\\ forall i, i < k -> Code (\u03bd il) (\u03bd iq) (\u03bd i).", "Local Fact dio_rel_ciphers : \ud835\udd3bR ciphers.", "Proof.", "unfold ciphers; dio auto.", "apply dio_rel_finite_conj; intros; dio auto.", "Defined.", "Hint Resolve dio_rel_ciphers : dio_rel_db.", "Local Fact ciphers_spec \u03bd : ciphers \u03bd <-> is_cipher_of (\u03bd il) (\u03bd iq) (fun n => n) (\u03bd k) /\\ exists \u03c6, forall i, i < k -> is_cipher_of (\u03bd il) (\u03bd iq) (\u03c6 i) (\u03bd i).", "Proof.", "unfold ciphers, Code, CodeNat.", "split; intros (H1 & H2); split; auto; clear H1.", "+", "apply fmap_reifier_default in H2; auto.", "+", "destruct H2 as (phi & Hphi).", "intros i Hi; exists (phi i); auto.", "Qed.", "Variables (ll : list dio_constraint) (Hll : forall c x, In c ll -> dc_vars c x -> x < k).", "Let Hll' : forall c, In c ll -> forall x, dc_vars c x -> x < k.", "Proof.", "intros c ? x ?; apply (@Hll c x); auto.", "Qed.", "Let pre_quant \u03bd := \u03bd il+1 < \u03bd iq /\\ ciphers \u03bd /\\ dc_list_Code ll \u03bd.", "Let dio_rel_pre_quant : \ud835\udd3bR pre_quant.", "Proof.", "unfold pre_quant; dio auto.", "Defined.", "Let dc_list_bfall \u03bd := exists \u03c0, pre_quant (fun i => if le_lt_dec il i then \u03bd (i-il) else \u03c0 i).", "Let dc_list_bfall_spec_1 \u03bd : dc_list_bfall \u03bd <-> exists q \u03c6, \u03bd 0+1 < q /\\ (forall i j, i < k -> j < \u03bd 0 -> \u03c6 i j < power q 2) /\\ forall j, j < \u03bd 0 -> Forall (dc_eval (fun i => \u03c6 i j) (j\u00b7\u03bd)) ll.", "Proof.", "split.", "+", "intros (pi & G0 & G1 & G4).", "rewrite ciphers_spec in G1.", "destruct (le_lt_dec il k) as [ ? | _ ]; try lia.", "destruct (le_lt_dec il il) as [ _ | ? ]; try lia.", "destruct (le_lt_dec il iq) as [ ? | _ ]; try lia.", "replace (il-il) with 0 in * by lia.", "destruct G1 as (G1 & phi & G3).", "assert (forall i, i < k -> is_cipher_of (\u03bd 0) (pi iq) (phi i) (pi i)) as G2.", "{", "intros i Hi; generalize (G3 _ Hi); destruct (le_lt_dec il i); auto; lia.", "}", "clear G3.", "rewrite dc_list_Code_spec with (\u03c0 := pi) (\u03c6 := phi) (\u03bd := \u03bd) in G4; auto.", "2,3: intros i Hi; destruct (le_lt_dec il i) as [ H | H ]; auto; try lia.", "exists (pi iq), phi; repeat (split; auto).", "intros i j Hi Hj; destruct (G2 _ Hi) as (_ & G3 & _); auto.", "+", "intros (q & phi & Hq & Hphi1 & Hphi2).", "assert (q <= power q 2) as Hq' by (apply power_ge_n; auto).", "destruct (the_cipher (fun i => i) Hq) as (u & Hu).", "{", "intros; lia.", "}", "set (pi i := match lt_eq_lt_dec i k with | inleft (left H) => proj1_sig (the_cipher (phi i) Hq (fun j Hj => Hphi1 _ _ H Hj)) | inleft (right H) => u | inright H => q end).", "assert (Hpi_k : pi k = u).", "{", "unfold pi; destruct (lt_eq_lt_dec k k) as [ [] | ]; auto; try lia.", "}", "assert (forall i, i < k -> is_cipher_of (\u03bd 0) q (phi i) (pi i)) as Hpi.", "{", "unfold pi; intros i Hi.", "destruct (lt_eq_lt_dec i k) as [ [H | ] | ]; try lia.", "apply (proj2_sig (the_cipher (phi i) Hq (fun j Hj => Hphi1 _ _ H Hj))).", "}", "assert (Hpi_q : pi iq = q).", "{", "unfold pi; destruct (lt_eq_lt_dec iq k) as [ [H | ] | ]; try lia.", "}", "generalize pi Hpi_k Hpi_q Hpi; clear pi Hpi_k Hpi Hpi_q.", "intros pi Hpi_k Hpi_q Hpi; subst u.", "exists pi; red.", "rewrite ciphers_spec.", "destruct (le_lt_dec il k) as [ ? | _ ]; try lia.", "destruct (le_lt_dec il il) as [ _ | ? ]; try lia.", "destruct (le_lt_dec il iq) as [ ? | _ ]; try lia.", "rewrite Nat.sub_diag.", "subst q; repeat (split; auto).", "*", "exists phi; intros i Hi.", "destruct (le_lt_dec il i); try lia; auto.", "*", "rewrite dc_list_Code_spec with (\u03c0 := pi) (\u03c6 := phi); auto; intros i Hi; destruct (le_lt_dec il i); auto; lia.", "Qed.", "Let dc_list_bfall_spec \u03bd : (forall i, i < \u03bd 0 -> exists \u03c6, Forall (dc_eval \u03c6 i\u00b7\u03bd) ll) <-> dc_list_bfall \u03bd.", "Proof.", "rewrite dc_list_bfall_spec_1; split.", "+", "intros H.", "apply fmmap_reifer_bound with (p := k) in H.", "-", "destruct H as (m & phi & Hf).", "set (q := power (\u03bd 0+2+m) 2).", "assert (\u03bd 0+1 < q) as Hlq.", "{", "apply lt_le_trans with (\u03bd 0+2+m); try lia.", "apply power_ge_n; auto.", "}", "assert (m <= power q 2) as Hmq.", "{", "apply le_trans with q.", "apply le_trans with (\u03bd 0+2+m); try lia.", "apply power_ge_n; auto.", "apply power_ge_n; auto.", "}", "exists q, (fun i j => phi j i); split; [ | split ]; auto.", "*", "intros i j Hi Hj; apply lt_le_trans with m; auto; apply Hf; auto.", "*", "intros; apply Hf; auto.", "-", "intros x f g Hfg.", "apply Forall_impl.", "intros c Hc; apply dc_eval_ext; auto.", "intros z Hz; symmetry; apply Hfg, Hll with c; auto.", "+", "intros (q & phi & Hq & H1 & H2) j Hj.", "exists (fun i => phi i j); auto.", "Qed.", "Local Theorem dio_rel_dc_list_bfall : \ud835\udd3bR (fun \u03bd => forall i, i < \u03bd 0 -> exists \u03c6, Forall (dc_eval \u03c6 i\u00b7\u03bd) ll).", "Proof using Hll.", "dio by lemma dc_list_bfall_spec; unfold dc_list_bfall.", "destruct dio_rel_pre_quant as (f & Hf).", "exists (df_mexists il f).", "abstract (intros; rewrite df_mexists_spec; split; intros (phi & H); exists phi; revert H; rewrite <- Hf; auto).", "Defined.", "End dio_bounded_elem.", "Local Theorem dio_rel_bounded_fall R : \ud835\udd3bR R -> \ud835\udd3bR (fun \u03bd => forall i, i < \u03bd 0 -> R i\u00b7\u03bd).", "Proof.", "intros (f & Hf).", "destruct (dio_formula_elem f) as (ll & H1 & H2 & H3).", "revert H2; generalize (4*df_size f); intros k H2.", "generalize (dio_rel_dc_list_bfall _ H2); apply dio_rel_equiv.", "abstract (intros v; split; intros H i Hi; generalize (H _ Hi); rewrite <- Hf, H3; auto).", "Defined.", "End dio_rel_bounded_fall.", "Theorem dio_rel_fall_lt a (R : nat -> (nat -> nat) -> Prop) : \ud835\udd3bF a -> \ud835\udd3bR (fun \u03bd => R (\u03bd 0) \u03bd\u2b73) -> \ud835\udd3bR (fun \u03bd => forall x, x < a \u03bd -> R x \u03bd).", "Proof.", "intros Ha H.", "by dio equiv (fun \u03bd => exists y, y = a \u03bd /\\ forall x, x < y -> R x \u03bd).", "+", "abstract(intros v; split; [ exists (a v); auto | intros (? & -> & ?); auto ]).", "+", "set (T v := R (v 0) v\u2b73\u2b73).", "by dio equiv (fun v => forall x, x < v 0 -> T (x\u00b7v)).", "*", "abstract (intros v; unfold T; simpl; tauto).", "*", "apply dio_rel_bounded_fall; unfold T; simpl.", "revert H; apply dio_rel_ren with (\u03c1 := fun n => match n with 0 => 0 | S n => S (S n) end).", "Defined.", "Hint Resolve dio_rel_fall_lt : dio_rel_db.", "Corollary dio_rel_fall_lt_bound a (R : nat -> nat -> (nat -> nat) -> Prop) : \ud835\udd3bF a -> \ud835\udd3bR (fun \u03bd => R (\u03bd 0) (a \u03bd\u2b73) \u03bd\u2b73) -> \ud835\udd3bR (fun \u03bd => forall x, x < a \u03bd -> R x (a \u03bd) \u03bd).", "Proof.", "intros; dio auto.", "Defined.", "Corollary dio_rel_fall_le a (R : nat -> (nat -> nat) -> Prop) : \ud835\udd3bF a -> \ud835\udd3bR (fun \u03bd => R (\u03bd 0) \u03bd\u2b73) -> \ud835\udd3bR (fun \u03bd => forall x, x <= a \u03bd -> R x \u03bd).", "Proof.", "intros Ha HK.", "by dio equiv (fun v => forall x, x < 1+a v -> R x v).", "abstract (intros v; split; intros H x Hx; apply H; lia).", "Defined.", "Hint Resolve dio_rel_fall_lt_bound dio_rel_fall_le : dio_rel_db."], "theorems": [{"name": "Hll'", "kind": "Let", "begin": 155, "end": 158}, {"name": "dio_rel_pre_quant", "kind": "Let", "begin": 160, "end": 163}, {"name": "dc_list_bfall_spec_1", "kind": "Let", "begin": 165, "end": 221}, {"name": "dc_list_bfall_spec", "kind": "Let", "begin": 222, "end": 256}, {"name": "dio_rel_fall_lt", "kind": "Theorem", "begin": 274, "end": 288}, {"name": "dio_rel_fall_lt_bound", "kind": "Corollary", "begin": 290, "end": 293}, {"name": "dio_rel_fall_le", "kind": "Corollary", "begin": 294, "end": 299}]}