{"code": ["Require Import Arith ZArith List.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac sums rel_iter gcd.", "From Undecidability.H10.Matija Require Import alpha expo_diophantine.", "From Undecidability.H10.Dio Require Import dio_logic.", "Set Implicit Arguments.", "Local Notation power := (mscal mult 1).", "Local Notation expo := (mscal mult 1).", "Local Notation \"x \u2250 \u231e n \u231f\" := (df_cst x n) (at level 49, no associativity, format \"x \u2250 \u231e n \u231f\").", "Local Notation \"x \u2250 y\" := (df_eq x y) (at level 49, no associativity, format \"x \u2250 y\").", "Local Notation \"x \u2250 y \u2a22 z\" := (df_add x y z) (at level 49, no associativity, y at next level, format \"x \u2250 y \u2a22 z\").", "Local Notation \"x \u2250 y \u2a30 z\" := (df_mul x y z) (at level 49, no associativity, y at next level, format \"x \u2250 y \u2a30 z\").", "Theorem dio_rel_alpha a b c : \ud835\udd3bF a -> \ud835\udd3bF b -> \ud835\udd3bF c -> \ud835\udd3bR (fun \u03bd => 3 < b \u03bd /\\ a \u03bd = alpha_nat (b \u03bd) (c \u03bd)).", "Proof.", "dio by lemma (fun v => alpha_diophantine (a v) (b v) (c v)).", "Defined.", "Hint Resolve dio_rel_alpha : dio_rel_db.", "Local Fact dio_rel_alpha_example : \ud835\udd3bR (fun \u03bd => 3 < \u03bd 1 /\\ \u03bd 0 = alpha_nat (\u03bd 1) (\u03bd 2)).", "Proof.", "dio auto.", "Defined.", "Fact dio_rel_alpha_size : df_size_Z (proj1_sig dio_rel_alpha_example) = 1445%Z.", "Proof.", "reflexivity.", "Qed.", "Theorem dio_fun_expo q r : \ud835\udd3bF q -> \ud835\udd3bF r -> \ud835\udd3bF (fun \u03bd => expo (r \u03bd) (q \u03bd)).", "Proof.", "dio by lemma (fun v => expo_diophantine (v 0) (q v\u2b73) (r v\u2b73)).", "Defined.", "Hint Resolve dio_fun_expo : dio_fun_db.", "Local Fact dio_fun_expo_example : \ud835\udd3bF (fun \u03bd => expo (\u03bd 0) (\u03bd 1)).", "Proof.", "dio auto.", "Defined.", "Local Fact dio_fun_expo_example_size : df_size_Z (proj1_sig dio_fun_expo_example) = 4903%Z.", "Proof.", "reflexivity.", "Qed.", "Local Fact is_digit_eq c q i y : is_digit c q i y <-> y < q /\\ exists a b p, c = (a*q+y)*p+b /\\ b < p /\\ p = power i q.", "Proof.", "split; intros (H1 & a & b & H2).", "+", "split; auto; exists a, b, (power i q); repeat split; tauto.", "+", "destruct H2 as (p & H2 & H3 & H4).", "split; auto; exists a, b; subst; auto.", "Qed.", "Lemma dio_rel_is_digit c q i y : \ud835\udd3bF c -> \ud835\udd3bF q -> \ud835\udd3bF i -> \ud835\udd3bF y -> \ud835\udd3bR (fun \u03bd => is_digit (c \u03bd) (q \u03bd) (i \u03bd) (y \u03bd)).", "Proof.", "dio by lemma (fun \u03bd => is_digit_eq (c \u03bd) (q \u03bd) (i \u03bd) (y \u03bd)).", "Defined.", "Hint Resolve dio_rel_is_digit : dio_rel_db.", "Local Fact dio_rel_is_digit_example : \ud835\udd3bR (fun \u03bd => is_digit (\u03bd 0) (\u03bd 1) (\u03bd 2) (\u03bd 3)).", "Proof.", "dio auto.", "Defined."], "theorems": [{"name": "dio_rel_alpha", "kind": "Theorem", "begin": 11, "end": 14}, {"name": "dio_rel_alpha_size", "kind": "Fact", "begin": 20, "end": 23}, {"name": "dio_fun_expo", "kind": "Theorem", "begin": 24, "end": 27}, {"name": "dio_rel_is_digit", "kind": "Lemma", "begin": 46, "end": 49}]}