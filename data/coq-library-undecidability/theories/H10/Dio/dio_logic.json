{"code": ["Require Import Arith Nat ZArith Lia.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac gcd sums bounded_quantification.", "Set Implicit Arguments.", "Set Default Proof Using \"Type\".", "Definition de_bruijn_ext {X} (\u03bd : nat -> X) x := fix dbe n := match n with | 0 => x | S n => \u03bd n end.", "Notation \"x \u00b7 \u03bd\" := (de_bruijn_ext \u03bd x) (at level 1, format \"x \u00b7 \u03bd\", left associativity).", "Notation \"\u03bd \u2b73\" := (fun n => \u03bd (S n)) (at level 1, format \"\u03bd \u2b73\", no associativity).", "Fact de_bruijn_ext_proj X (\u03bd : nat -> X) x n : (x\u00b7\u03bd)\u2b73 n = \u03bd n.", "Proof.", "reflexivity.", "Qed.", "Fact de_bruijn_proj_ext X (\u03bd : nat -> X) n : (\u03bd 0)\u00b7(\u03bd\u2b73) n = \u03bd n.", "Proof.", "destruct n; reflexivity.", "Qed.", "Inductive dio_op := do_add | do_mul.", "Definition de_op_sem (o : dio_op) := match o with | do_add => plus | do_mul => mult end.", "Definition df_op_sem (o : dio_op) := match o with | do_add => or | do_mul => and end.", "Inductive dio_formula : Set := | df_cst : forall (x : nat) (n : nat), dio_formula | df_eq : forall (x y : nat), dio_formula | df_op : forall (o : dio_op) (x y z : nat), dio_formula | df_bin : forall (o : dio_op) (f g : dio_formula), dio_formula | df_exst : dio_formula -> dio_formula.", "Notation df_add := (df_op do_add).", "Notation df_mul := (df_op do_mul).", "Notation df_conj := (df_bin do_mul).", "Notation df_disj := (df_bin do_add).", "Notation \"\u2203 x\" := (df_exst x) (at level 54, right associativity).", "Notation \"x \u2227 y\" := (df_conj x y) (at level 51, right associativity, format \"x \u2227 y\").", "Notation \"x \u2228 y\" := (df_disj x y) (at level 52, right associativity, format \"x \u2228 y\").", "Local Notation \"x \u2250 \u231e n \u231f\" := (df_cst x n) (at level 49, no associativity, format \"x \u2250 \u231e n \u231f\").", "Local Notation \"x \u2250 y\" := (df_eq x y) (at level 49, no associativity, format \"x \u2250 y\").", "Local Notation \"x \u2250 y \u2a22 z\" := (df_add x y z) (at level 49, no associativity, y at next level, format \"x \u2250 y \u2a22 z\").", "Local Notation \"x \u2250 y \u2a30 z\" := (df_mul x y z) (at level 49, no associativity, y at next level, format \"x \u2250 y \u2a30 z\").", "Local Reserved Notation \"'\u27e6' t '\u27e7'\" (at level 1, format \"\u27e6 t \u27e7\").", "Local Reserved Notation \"f '\u2983' \u03c3 '\u2984'\" (at level 1, format \"f \u2983 \u03c3 \u2984\").", "Section diophantine_logic_basics.", "Fixpoint df_size f := match f with | df_cst _ _ => 3 | df_eq _ _ => 3 | df_op _ _ _ _ => 5 | df_bin _ f g => 1 + df_size f + df_size g | df_exst f => 1 + df_size f end.", "Fixpoint df_size_Z f := (match f with | df_cst _ _ => 3 | df_eq _ _ => 3 | df_op _ _ _ _ => 5 | df_bin _ f g => 1 + df_size_Z f + df_size_Z g | df_exst f => 1 + df_size_Z f end)%Z.", "Fact df_size_Z_spec f : df_size_Z f = Z.of_nat (df_size f).", "Proof.", "induction f as [ | | | ? f Hf g Hg | f Hf ]; simpl df_size; rewrite Nat2Z.inj_succ; try rewrite Nat2Z.inj_add; unfold df_size_Z; fold df_size_Z; auto; try lia.", "Qed.", "Fixpoint df_pred f \u03bd := match f with | df_cst x n => \u03bd x = n | df_eq x y => \u03bd x = \u03bd y | df_op o x y z => \u03bd x = de_op_sem o (\u03bd y) (\u03bd z) | df_bin o f g => df_op_sem o (\u27e6f\u27e7 \u03bd) (\u27e6g\u27e7 \u03bd) | df_exst f => exists n, \u27e6f\u27e7 n\u00b7\u03bd end where \"\u27e6 f \u27e7\" := (df_pred f).", "Fact df_pred_cst x n \u03bd : \u27e6x \u2250 \u231en\u231f\u27e7 \u03bd = (\u03bd x = n).", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_eq x y \u03bd : \u27e6x \u2250 y\u27e7 \u03bd = (\u03bd x = \u03bd y).", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_add x y z \u03bd : \u27e6x \u2250 y \u2a22 z\u27e7 \u03bd = (\u03bd x = \u03bd y + \u03bd z).", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_mul x y z \u03bd : \u27e6x \u2250 y \u2a30 z\u27e7 \u03bd = (\u03bd x = \u03bd y * \u03bd z).", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_conj f g \u03bd : \u27e6f \u2227 g\u27e7 \u03bd = (\u27e6f\u27e7 \u03bd /\\ \u27e6g\u27e7 \u03bd).", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_disj f g \u03bd : \u27e6f \u2228 g\u27e7 \u03bd = (\u27e6f\u27e7 \u03bd \\/ \u27e6g\u27e7 \u03bd).", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_exst f \u03bd : \u27e6\u2203f\u27e7 \u03bd = exists n, \u27e6f\u27e7 n\u00b7\u03bd.", "Proof.", "reflexivity.", "Qed.", "Fact df_pred_ext f \u03bd \u03c9 : (forall x, \u03bd x = \u03c9 x) -> \u27e6f\u27e7 \u03bd <-> \u27e6f\u27e7 \u03c9.", "Proof.", "induction f as [ | | [] | [] f Hf g Hg | f Hf ] in \u03bd, \u03c9 |- *; intros H; simpl.", "1-4: rewrite !H; tauto.", "1-2: rewrite Hf, Hg; auto; tauto.", "split; intros (n & Hn); exists n; revert Hn; apply Hf; intros []; simpl; auto.", "Qed.", "Definition der_lift \u03c1 x := match x with 0 => 0 | S x => S (\u03c1 x) end.", "Fixpoint df_ren \u03c1 f := match f with | df_cst x n => df_cst (\u03c1 x) n | df_eq x y => df_eq (\u03c1 x) (\u03c1 y) | df_op o x y z => df_op o (\u03c1 x) (\u03c1 y) (\u03c1 z) | df_bin o f g => df_bin o f\u2983\u03c1\u2984 g\u2983\u03c1\u2984 | df_exst f => df_exst f\u2983der_lift \u03c1\u2984 end where \"f \u2983 \u03c1 \u2984\" := (df_ren \u03c1 f).", "Fact df_ren_size \u03c1 f : df_size f\u2983\u03c1\u2984 = df_size f.", "Proof.", "revert \u03c1; induction f; intros; simpl; auto; do 2 f_equal; auto.", "Qed.", "Fact df_ren_size_Z \u03c1 f : df_size_Z f\u2983\u03c1\u2984 = df_size_Z f.", "Proof.", "do 2 rewrite df_size_Z_spec; f_equal; apply df_ren_size.", "Qed.", "Fact df_pred_ren f \u03bd \u03c1 : \u27e6f\u2983\u03c1\u2984\u27e7 \u03bd <-> \u27e6f\u27e7 (fun x => \u03bd (\u03c1 x)).", "Proof.", "revert \u03bd \u03c1; induction f as [ | | [] | [] f Hf g Hg | f Hf ]; intros \u03bd \u03c1; simpl; try tauto.", "1-2: rewrite Hf, Hg; tauto.", "split; intros (n & Hn); exists n; revert Hn; rewrite Hf; apply df_pred_ext; intros []; simpl; auto.", "Qed.", "Fact df_pred_lift f \u03bd : \u27e6f\u2983S\u2984\u27e7 \u03bd <-> \u27e6f\u27e7 \u03bd\u2b73.", "Proof.", "apply df_pred_ren.", "Qed.", "End diophantine_logic_basics.", "Local Notation \"\u27e6 f \u27e7\" := (df_pred f).", "Local Notation \"f \u2983 \u03c1 \u2984\" := (df_ren \u03c1 f).", "Definition dio_rel R := { f | forall \u03bd, \u27e6f\u27e7 \u03bd <-> R \u03bd }.", "Notation \ud835\udd3bR := dio_rel.", "Section dio_rel_closure_properties.", "Implicit Types R S : (nat -> nat) -> Prop.", "Fact dio_rel_cst x n : \ud835\udd3bR (fun \u03bd => \u03bd x = n).", "Proof.", "exists (x \u2250 \u231en\u231f); abstract (intro; simpl; tauto).", "Defined.", "Fact dio_rel_eq x y : \ud835\udd3bR (fun \u03bd => \u03bd x = \u03bd y).", "Proof.", "exists (x \u2250 y); simpl; tauto.", "Defined.", "Fact dio_rel_add x y z : \ud835\udd3bR (fun \u03bd => \u03bd x = \u03bd y + \u03bd z).", "Proof.", "exists (x \u2250 y \u2a22 z); abstract (intro; simpl; tauto).", "Defined.", "Fact dio_rel_mul x y z : \ud835\udd3bR (fun \u03bd => \u03bd x = \u03bd y * \u03bd z).", "Proof.", "exists (x \u2250 y \u2a30 z); abstract (intro; simpl; tauto).", "Defined.", "Fact dio_rel_conj R S : \ud835\udd3bR R -> \ud835\udd3bR S -> \ud835\udd3bR (fun \u03bd => R \u03bd /\\ S \u03bd).", "Proof.", "intros (fR & H1) (fS & H2); exists (fR \u2227 fS).", "abstract (intro; rewrite df_pred_conj, H1, H2; tauto).", "Defined.", "Fact dio_rel_disj R S : \ud835\udd3bR R -> \ud835\udd3bR S -> \ud835\udd3bR (fun \u03bd => R \u03bd \\/ S \u03bd).", "Proof.", "intros (fR & H1) (fS & H2); exists (fR \u2228 fS).", "abstract (intro; rewrite df_pred_disj, H1, H2; tauto).", "Defined.", "Fact dio_rel_exst (K : nat -> (nat -> nat) -> Prop) : \ud835\udd3bR (fun \u03bd => K (\u03bd 0) \u03bd\u2b73) -> \ud835\udd3bR (fun \u03bd => exists x, K x \u03bd).", "Proof.", "intros (f & Hf); exists (\u2203f).", "abstract (intros \u03bd; rewrite df_pred_exst; split; intros (n & Hn); exists n; revert Hn; rewrite Hf; simpl; auto).", "Defined.", "Fact dio_rel_equiv R S : (forall \u03bd, S \u03bd <-> R \u03bd) -> \ud835\udd3bR R -> \ud835\udd3bR S.", "Proof.", "intros H (f & Hf); exists f.", "abstract (intro; rewrite Hf, H; tauto).", "Defined.", "Fact dio_rel_ren R \u03c1 : \ud835\udd3bR R -> \ud835\udd3bR (fun \u03bd => R (fun n => \u03bd (\u03c1 n))).", "Proof.", "intros (f & Hf); exists (f\u2983\u03c1\u2984).", "abstract (intros; rewrite df_pred_ren, Hf; tauto).", "Defined.", "End dio_rel_closure_properties.", "Definition dio_fun t := \ud835\udd3bR (fun \u03bd => \u03bd 0 = t \u03bd\u2b73).", "Notation \ud835\udd3bF := dio_fun.", "Fact dio_fun_var x : \ud835\udd3bF (fun \u03bd => \u03bd x).", "Proof.", "apply dio_rel_eq.", "Defined.", "Fact dio_fun_cst c : \ud835\udd3bF (fun _ => c).", "Proof.", "red; apply dio_rel_cst.", "Defined.", "Fact dio_fun_add_im x y : \ud835\udd3bF (fun \u03bd => \u03bd x + \u03bd y).", "Proof.", "apply dio_rel_add.", "Defined.", "Fact dio_fun_mul_im x y : \ud835\udd3bF (fun \u03bd => \u03bd x * \u03bd y).", "Proof.", "apply dio_rel_mul.", "Defined.", "Fact dio_fun_equiv r s : (forall \u03bd, s \u03bd = r \u03bd) -> \ud835\udd3bF r -> \ud835\udd3bF s.", "Proof.", "intros H1; apply dio_rel_equiv.", "abstract (intro; rewrite H1; tauto).", "Defined.", "Fact dio_fun_ren t f : \ud835\udd3bF t -> \ud835\udd3bF (fun \u03bd => t (fun n => \u03bd (f n))).", "Proof.", "apply dio_rel_ren with (\u03c1 := der_lift f).", "Defined.", "Section utilities_for_better_efficiency.", "Ltac dio_sym H := now (apply dio_rel_equiv with (2 := H)).", "Fact dio_rel_cst_sym x n : \ud835\udd3bR (fun \u03bd => n = \u03bd x).", "Proof.", "dio_sym (dio_rel_cst x n).", "Defined.", "Fact dio_rel_add_sym x y z : \ud835\udd3bR (fun \u03bd => \u03bd y + \u03bd z = \u03bd x).", "Proof.", "dio_sym (dio_rel_add x y z).", "Defined.", "Fact dio_rel_mul_sym x y z : \ud835\udd3bR (fun \u03bd => \u03bd y * \u03bd z = \u03bd x).", "Proof.", "dio_sym (dio_rel_mul x y z).", "Defined.", "Fact dio_rel_fun x t : \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => \u03bd x = t \u03bd).", "Proof.", "apply dio_rel_ren with (\u03c1 := fun n => match n with | 0 => x | S n => n end).", "Defined.", "Fact dio_rel_fun_sym x t : \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => t \u03bd = \u03bd x).", "Proof.", "intros H; dio_sym (dio_rel_fun x H).", "Defined.", "End utilities_for_better_efficiency.", "Fact dio_rel_fun_eq r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => r \u03bd = t \u03bd).", "Proof.", "intros H1 H2; red in H1, H2.", "apply dio_rel_equiv with (R := fun \u03bd => exists x, x = r \u03bd /\\ x = t \u03bd).", "+", "abstract (intros v; split; [ intros ->; exists (t v); auto | intros (? & -> & ?); auto ]).", "+", "apply dio_rel_exst, dio_rel_conj; auto.", "Defined.", "Create HintDb dio_fun_db.", "Create HintDb dio_rel_db.", "Create HintDb dio_rel_im_db.", "Ltac dio_fun_auto := apply dio_fun_var || apply dio_fun_cst || apply dio_fun_add_im || apply dio_fun_mul_im || auto 7 with dio_fun_db (* the depth of 7 is mostly enough *) .", "Ltac dio_rel_immediate := auto with dio_rel_im_db.", "Ltac dio_rel_eq := apply dio_rel_fun (* x = t *) || apply dio_rel_fun_sym (* t = x *) || apply dio_rel_fun_eq (* r = t *) .", "Ltac dio_rel_decompose := apply dio_rel_exst (* exists x, ... *) || apply dio_rel_conj (* ... /\\ ... *) || apply dio_rel_disj (* ... \\/ ... *) .", "Ltac dio_rel_auto := dio_rel_immediate; auto 7 with dio_rel_db dio_fun_db; ( (dio_rel_eq; dio_fun_auto) || (dio_rel_decompose; dio_rel_auto) || idtac ).", "Tactic Notation \"dio\" \"auto\" := match goal with | |- \ud835\udd3bR _ => dio_rel_auto | |- \ud835\udd3bF _ => dio_fun_auto end.", "Tactic Notation \"by\" \"dio\" \"equiv\" uconstr(f) := match goal with | |- \ud835\udd3bR _ => apply dio_rel_equiv with (R := f); [ | dio auto ] | |- \ud835\udd3bF _ => apply dio_fun_equiv with (r := f); [ | dio auto ] end.", "Tactic Notation \"dio\" \"by\" \"lemma\" uconstr(f) := intros; apply dio_rel_equiv with (1 := f); dio auto.", "Hint Resolve dio_fun_var dio_fun_cst dio_fun_ren : dio_fun_db.", "Hint Resolve dio_rel_eq dio_rel_cst dio_rel_cst_sym dio_rel_add dio_rel_add_sym dio_rel_mul dio_rel_mul_sym : dio_rel_im_db.", "Fact dio_fun_plus r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bF (fun \u03bd => r \u03bd + t \u03bd).", "Proof.", "intros H1 H2; red.", "by dio equiv (fun \u03bd => exists b c, \u03bd 0 = b + c /\\ b = r \u03bd\u2b73 /\\ c = t \u03bd\u2b73).", "abstract (intros v; split; [ exists (r v\u2b73), (t v\u2b73); auto | intros (? & ? & -> & -> & ->); auto ]).", "Defined.", "Fact dio_fun_mult r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bF (fun \u03bd => r \u03bd * t \u03bd).", "Proof.", "intros H1 H2; red.", "by dio equiv (fun \u03bd => exists b c, \u03bd 0 = b * c /\\ b = r \u03bd\u2b73 /\\ c = t \u03bd\u2b73).", "abstract (intros v; split; [ exists (r v\u2b73), (t v\u2b73); auto | intros (? & ? & -> & -> & ->); auto ]).", "Defined.", "Hint Resolve dio_fun_plus dio_fun_mult : dio_fun_db.", "Local Fact example_eq : \ud835\udd3bR (fun \u03bd => \u03bd 0 = \u03bd 0).", "Proof.", "dio auto.", "Defined.", "Section True_False.", "Hint Resolve dio_rel_cst dio_rel_add : dio_rel_db.", "Fact dio_rel_True : \ud835\udd3bR (fun _ => True).", "Proof.", "by dio equiv (fun _ => exists x, x = 0).", "abstract (split; try tauto; exists 0; auto).", "Defined.", "Fact dio_rel_False : \ud835\udd3bR (fun _ => False).", "Proof.", "by dio equiv (fun _ => exists x, x = 1 /\\ x = 0).", "abstract (split; try tauto; intros (? & ? & ?); lia).", "Defined.", "End True_False.", "Hint Resolve dio_rel_True dio_rel_False : dio_rel_db.", "Fact dio_rel_le_im x y : \ud835\udd3bR (fun \u03bd => \u03bd x <= \u03bd y).", "Proof.", "by dio equiv (fun \u03bd => exists a, \u03bd y = a + \u03bd x).", "abstract (intros v; split; [ intros H; exists (v y - v x); lia | intros (? & ->); lia ]).", "Defined.", "Fact dio_rel_lt_im x y : \ud835\udd3bR (fun \u03bd => \u03bd x < \u03bd y).", "Proof.", "by dio equiv (fun \u03bd => exists a b c, \u03bd y = c + \u03bd x /\\ b = 1 /\\ c = a + b).", "abstract (intros v; split; [ intros H; exists (v y - v x -1), 1, (v y - v x); lia | intros (? & ? & ? & -> & -> & ->); lia ]).", "Defined.", "Fact dio_rel_div_im x y : \ud835\udd3bR (fun \u03bd => divides (\u03bd x) (\u03bd y)).", "Proof.", "by dio equiv (fun \u03bd => exists a, \u03bd y = a * \u03bd x).", "unfold divides; tauto.", "Defined.", "Hint Resolve dio_rel_le_im dio_rel_lt_im dio_rel_div_im : dio_rel_im_db.", "Fact dio_rel_le r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => r \u03bd <= t \u03bd).", "Proof.", "intros H1 H2.", "by dio equiv (fun \u03bd => exists a b, a <= b /\\ a = r \u03bd /\\ b = t \u03bd).", "abstract (intros v; split; [ exists (r v), (t v) | intros (? & ? & ? & -> & ->) ]; auto).", "Defined.", "Fact dio_rel_lt r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => r \u03bd < t \u03bd).", "Proof.", "intros H1 H2.", "by dio equiv (fun \u03bd => exists a b, a < b /\\ a = r \u03bd /\\ b = t \u03bd).", "abstract (intros v; split; [ exists (r v), (t v) | intros (? & ? & ? & -> & ->) ]; auto).", "Defined.", "Hint Resolve dio_rel_lt dio_rel_le : dio_rel_db.", "Fact dio_rel_neq r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => r \u03bd <> t \u03bd).", "Proof.", "intros H1 H2.", "by dio equiv (fun v => exists a b, (a < b \\/ b < a) /\\ a = r v /\\ b = t v).", "abstract (intros v; split; [ exists (r v), (t v) | intros (? & ? & ?) ]; lia).", "Defined.", "Fact dio_rel_div r t : \ud835\udd3bF r -> \ud835\udd3bF t -> \ud835\udd3bR (fun \u03bd => divides (r \u03bd) (t \u03bd)).", "Proof.", "intros H1 H2.", "by dio equiv (fun v => exists a b, divides a b /\\ a = r v /\\ b = t v).", "abstract (intros v; split; [ exists (r v), (t v) | intros (? & ? & ? & -> & ->) ]; auto).", "Defined.", "Hint Resolve dio_rel_neq dio_rel_div : dio_rel_db.", "Local Fact example_le : \ud835\udd3bR (fun \u03bd => \u03bd 0 <= \u03bd 1).", "Proof.", "dio auto.", "Defined.", "Local Fact example_lt : \ud835\udd3bR (fun \u03bd => \u03bd 0 < \u03bd 1).", "Proof.", "dio auto.", "Defined.", "Local Fact example_div : \ud835\udd3bR (fun \u03bd => divides (\u03bd 0) (\u03bd 1)).", "Proof.", "dio auto.", "Defined.", "Section dio_fun_rem.", "Let rem_equiv p x r : r = rem x p <-> exists x' p', x' = x /\\ p' = p /\\ ( (p' = 0 /\\ x' = r) \\/ (p' <> 0 /\\ r < p' /\\ exists n, x' = n*p' + r) ).", "Proof.", "split.", "+", "intro; exists x, p; subst; msplit 2; auto.", "destruct (eq_nat_dec p 0) as [ Hp | Hp ].", "*", "left; split; auto; subst; rewrite rem_0; auto.", "*", "right; split; auto; split.", "-", "apply div_rem_spec2; auto.", "-", "exists (div x p);apply div_rem_spec1.", "+", "intros (? & ? & -> & -> & [ (H1 & H2) | (H1 & H2 & n & H3) ]).", "*", "subst; rewrite rem_0; auto.", "*", "symmetry; apply rem_prop with n; auto.", "Qed.", "Fact dio_fun_rem p x : \ud835\udd3bF p -> \ud835\udd3bF x -> \ud835\udd3bF (fun \u03bd => rem (x \u03bd) (p \u03bd)).", "Proof.", "dio by lemma (fun v => rem_equiv (p v\u2b73) (x v\u2b73) (v 0)).", "Defined.", "End dio_fun_rem.", "Hint Resolve dio_fun_rem : dio_fun_db.", "Local Fact dio_fun_rem_example : \ud835\udd3bF (fun \u03bd => rem (\u03bd 0) (\u03bd 1)).", "Proof.", "dio auto.", "Defined.", "Section dio_rel_ndivides.", "Let ndivides_eq x y : ~ (divides x y) <-> x = 0 /\\ y <> 0 \\/ exists a b, y = a*x+b /\\ 0 < b < x.", "Proof.", "split.", "+", "intros H.", "destruct x as [ | x ].", "*", "left; split; auto; contradict H; subst; apply divides_0.", "*", "right; exists (div y (S x)), (rem y (S x)); split.", "-", "apply div_rem_spec1.", "-", "rewrite divides_rem_eq in H.", "generalize (@div_rem_spec2 y (S x)); intros; lia.", "+", "intros [ (H1 & H2) | (a & b & H1 & H2) ].", "*", "subst; contradict H2; revert H2; apply divides_0_inv.", "*", "rewrite divides_rem_eq.", "rewrite (div_rem_spec1 y x) in H1.", "apply div_rem_uniq in H1; try lia.", "apply div_rem_spec2; lia.", "Qed.", "Fact dio_rel_ndivides x y : \ud835\udd3bF x -> \ud835\udd3bF y -> \ud835\udd3bR (fun \u03bd => ~ divides (x \u03bd) (y \u03bd)).", "Proof.", "dio by lemma (fun v => ndivides_eq (x v) (y v)).", "Defined.", "End dio_rel_ndivides.", "Local Fact dio_rel_ndiv_example : \ud835\udd3bR (fun \u03bd => ~ divides (\u03bd 0) (\u03bd 1)).", "Proof.", "apply dio_rel_ndivides; dio auto.", "Defined.", "Section dio_rel_not_divides.", "Let not_divides_eq p x : ~ divides p x <-> rem x p <> 0.", "Proof.", "rewrite divides_rem_eq; tauto.", "Qed.", "Lemma dio_rel_not_divides x p : \ud835\udd3bF x -> \ud835\udd3bF p -> \ud835\udd3bR (fun \u03bd => ~ divides (x \u03bd) (p \u03bd)).", "Proof.", "dio by lemma (fun v => not_divides_eq (x v) (p v)).", "Defined.", "End dio_rel_not_divides.", "Hint Resolve dio_rel_not_divides : dio_rel_db.", "Local Fact example_rem_strange : \ud835\udd3bR (fun \u03bd => rem (\u03bd 0) (\u03bd 1) = \u03bd 2 * \u03bd 3).", "Proof.", "dio auto.", "Defined.", "Section dio_rel_compose.", "Variable (f : (nat -> nat) -> nat) (R : nat -> (nat -> nat) -> Prop).", "Hypothesis (Hf : \ud835\udd3bF f) (HR : \ud835\udd3bR (fun \u03bd => R (\u03bd 0) \u03bd\u2b73)).", "Lemma dio_rel_compose : \ud835\udd3bR (fun \u03bd => R (f \u03bd) \u03bd).", "Proof using HR Hf.", "by dio equiv (fun v => exists y, y = f v /\\ R y v).", "abstract(intros v; split; [ exists (f v); auto | intros (? & -> & ?); auto ]).", "Defined.", "End dio_rel_compose.", "Section dio_fun_compose.", "Variable (f : (nat -> nat) -> nat) (Hf : \ud835\udd3bF f) (g : nat -> nat) (Hg : \ud835\udd3bF (fun \u03bd => g (\u03bd 0))).", "Lemma dio_fun_compose : \ud835\udd3bF (fun \u03bd => g (f \u03bd)).", "Proof using Hf Hg.", "red; by dio equiv (fun v => exists y, y = f v\u2b73 /\\ v 0 = g y).", "abstract(intros; split; [ exists (f \u03bd\u2b73); auto | intros (? & -> & ?); auto ]).", "Defined.", "End dio_fun_compose.", "Section multiple_exists.", "Fixpoint df_mexists n f := match n with | 0 => f | S n => df_mexists n (\u2203f) end.", "Fact df_mexists_size n f : df_size (df_mexists n f) = n + df_size f.", "Proof.", "induction n as [ | n IHn ] in f |- *; auto; simpl.", "rewrite IHn; simpl; lia.", "Qed.", "Fact df_mexists_size_Z n f : df_size_Z (df_mexists n f) = (Z.of_nat n + df_size_Z f)%Z.", "Proof.", "rewrite df_size_Z_spec, df_mexists_size, Nat2Z.inj_add, df_size_Z_spec; lia.", "Qed.", "Lemma df_mexists_spec n f \u03bd : \u27e6df_mexists n f\u27e7 \u03bd <-> exists \u03c0, \u27e6f\u27e7 (fun i => if le_lt_dec n i then \u03bd (i-n) else \u03c0 i).", "Proof.", "revert f \u03bd; induction n as [ | n IHn ]; intros f v.", "+", "simpl; split; [ intros H; exists (fun _ => 0) | intros (? & H) ]; revert H; apply df_pred_ext; intros; f_equal; lia.", "+", "simpl df_mexists; rewrite IHn; split; intros (pi & Hpi).", "*", "revert Hpi; rewrite df_pred_exst.", "intros (u & Hu).", "exists (fun i => match i with 0 => u | S i => pi i end).", "revert Hu; apply df_pred_ext.", "Opaque le_lt_dec.", "simpl; intros [ | i ].", "-", "replace (0-S n) with 0 by lia; auto.", "-", "replace (S i - S n) with (i-n) by lia.", "simpl; destruct (le_lt_dec (S n) (S i)); destruct (le_lt_dec n i); auto; lia.", "*", "exists (fun i => pi (S i)).", "rewrite df_pred_exst; exists (pi 0).", "revert Hpi; apply df_pred_ext.", "intros [ | i ].", "-", "replace (0-S n) with 0 by lia; simpl; auto.", "-", "replace (S i - S n) with (i-n) by lia.", "Opaque le_lt_dec.", "simpl; destruct (le_lt_dec (S n) (S i)); destruct (le_lt_dec n i); auto; lia.", "Qed.", "End multiple_exists.", "Section dio_rel_finite_conj.", "Notation \"\u2211\" := (msum plus 0).", "Definition df_true := proj1_sig dio_rel_True.", "Fact df_true_size : df_size df_true = 4.", "Proof.", "reflexivity.", "Qed.", "Fact df_true_spec \u03bd : df_pred df_true \u03bd <-> True.", "Proof.", "apply (proj2_sig dio_rel_True).", "Qed.", "Fixpoint df_mconj n f := match n with | 0 => df_true | S n => f 0 \u2227 df_mconj n f\u2b73 end.", "Fact df_mconj_size n f : df_size (df_mconj n f) = 4+n+\u2211 n (fun i => df_size (f i)).", "Proof.", "revert f; induction n as [ | n IHn ]; intros f; simpl; auto.", "rewrite IHn; ring.", "Qed.", "Fact df_mconj_spec n f \u03bd : df_pred (df_mconj n f) \u03bd <-> forall i, i < n -> df_pred (f i) \u03bd.", "Proof.", "revert f \u03bd; induction n as [ | n IHn ]; intros f v; simpl df_mconj.", "+", "rewrite df_true_spec; split; auto; intros; lia.", "+", "rewrite df_pred_conj, IHn; split.", "*", "intros (? & H2) [ | i ] ?; auto; apply H2; lia.", "*", "intros H; split; intros; apply H; lia.", "Qed.", "Lemma dio_rel_finite_conj n (R : nat -> (nat -> nat) -> Prop) : (forall i, i < n -> \ud835\udd3bR (R i)) -> \ud835\udd3bR (fun \u03bd => forall i, i < n -> R i \u03bd).", "Proof.", "intros H.", "apply fmap_reifier_t_default with (1 := df_true) in H.", "destruct H as (f & Hf).", "exists (df_mconj n f).", "abstract(intros v; rewrite df_mconj_spec; split; intros E i Hi; generalize (E _ Hi); apply Hf; trivial).", "Defined.", "End dio_rel_finite_conj."], "theorems": [{"name": "de_bruijn_ext_proj", "kind": "Fact", "begin": 7, "end": 10}, {"name": "de_bruijn_proj_ext", "kind": "Fact", "begin": 11, "end": 14}, {"name": "df_size_Z_spec", "kind": "Fact", "begin": 35, "end": 38}, {"name": "df_pred_cst", "kind": "Fact", "begin": 40, "end": 43}, {"name": "df_pred_eq", "kind": "Fact", "begin": 44, "end": 47}, {"name": "df_pred_add", "kind": "Fact", "begin": 48, "end": 51}, {"name": "df_pred_mul", "kind": "Fact", "begin": 52, "end": 55}, {"name": "df_pred_conj", "kind": "Fact", "begin": 56, "end": 59}, {"name": "df_pred_disj", "kind": "Fact", "begin": 60, "end": 63}, {"name": "df_pred_exst", "kind": "Fact", "begin": 64, "end": 67}, {"name": "df_pred_ext", "kind": "Fact", "begin": 68, "end": 74}, {"name": "df_ren_size", "kind": "Fact", "begin": 77, "end": 80}, {"name": "df_ren_size_Z", "kind": "Fact", "begin": 81, "end": 84}, {"name": "df_pred_ren", "kind": "Fact", "begin": 85, "end": 90}, {"name": "df_pred_lift", "kind": "Fact", "begin": 91, "end": 94}, {"name": "dio_rel_cst", "kind": "Fact", "begin": 102, "end": 105}, {"name": "dio_rel_eq", "kind": "Fact", "begin": 106, "end": 109}, {"name": "dio_rel_add", "kind": "Fact", "begin": 110, "end": 113}, {"name": "dio_rel_mul", "kind": "Fact", "begin": 114, "end": 117}, {"name": "dio_rel_conj", "kind": "Fact", "begin": 118, "end": 122}, {"name": "dio_rel_disj", "kind": "Fact", "begin": 123, "end": 127}, {"name": "dio_rel_exst", "kind": "Fact", "begin": 128, "end": 132}, {"name": "dio_rel_equiv", "kind": "Fact", "begin": 133, "end": 137}, {"name": "dio_rel_ren", "kind": "Fact", "begin": 138, "end": 142}, {"name": "dio_fun_var", "kind": "Fact", "begin": 146, "end": 149}, {"name": "dio_fun_cst", "kind": "Fact", "begin": 150, "end": 153}, {"name": "dio_fun_add_im", "kind": "Fact", "begin": 154, "end": 157}, {"name": "dio_fun_mul_im", "kind": "Fact", "begin": 158, "end": 161}, {"name": "dio_fun_equiv", "kind": "Fact", "begin": 162, "end": 166}, {"name": "dio_fun_ren", "kind": "Fact", "begin": 167, "end": 170}, {"name": "dio_rel_cst_sym", "kind": "Fact", "begin": 173, "end": 176}, {"name": "dio_rel_add_sym", "kind": "Fact", "begin": 177, "end": 180}, {"name": "dio_rel_mul_sym", "kind": "Fact", "begin": 181, "end": 184}, {"name": "dio_rel_fun", "kind": "Fact", "begin": 185, "end": 188}, {"name": "dio_rel_fun_sym", "kind": "Fact", "begin": 189, "end": 192}, {"name": "dio_rel_fun_eq", "kind": "Fact", "begin": 194, "end": 202}, {"name": "dio_fun_plus", "kind": "Fact", "begin": 216, "end": 221}, {"name": "dio_fun_mult", "kind": "Fact", "begin": 222, "end": 227}, {"name": "dio_rel_True", "kind": "Fact", "begin": 235, "end": 239}, {"name": "dio_rel_False", "kind": "Fact", "begin": 240, "end": 244}, {"name": "dio_rel_le_im", "kind": "Fact", "begin": 247, "end": 251}, {"name": "dio_rel_lt_im", "kind": "Fact", "begin": 252, "end": 256}, {"name": "dio_rel_div_im", "kind": "Fact", "begin": 257, "end": 261}, {"name": "dio_rel_le", "kind": "Fact", "begin": 263, "end": 268}, {"name": "dio_rel_lt", "kind": "Fact", "begin": 269, "end": 274}, {"name": "dio_rel_neq", "kind": "Fact", "begin": 276, "end": 281}, {"name": "dio_rel_div", "kind": "Fact", "begin": 282, "end": 287}, {"name": "rem_equiv", "kind": "Let", "begin": 302, "end": 322}, {"name": "dio_fun_rem", "kind": "Fact", "begin": 323, "end": 326}, {"name": "ndivides_eq", "kind": "Let", "begin": 334, "end": 358}, {"name": "dio_rel_ndivides", "kind": "Fact", "begin": 359, "end": 362}, {"name": "not_divides_eq", "kind": "Let", "begin": 369, "end": 372}, {"name": "dio_rel_not_divides", "kind": "Lemma", "begin": 373, "end": 376}, {"name": "dio_rel_compose", "kind": "Lemma", "begin": 386, "end": 390}, {"name": "dio_fun_compose", "kind": "Lemma", "begin": 394, "end": 398}, {"name": "df_mexists_size", "kind": "Fact", "begin": 402, "end": 406}, {"name": "df_mexists_size_Z", "kind": "Fact", "begin": 407, "end": 410}, {"name": "df_mexists_spec", "kind": "Lemma", "begin": 411, "end": 441}, {"name": "df_true_size", "kind": "Fact", "begin": 446, "end": 449}, {"name": "df_true_spec", "kind": "Fact", "begin": 450, "end": 453}, {"name": "df_mconj_size", "kind": "Fact", "begin": 455, "end": 459}, {"name": "df_mconj_spec", "kind": "Fact", "begin": 460, "end": 471}, {"name": "dio_rel_finite_conj", "kind": "Lemma", "begin": 472, "end": 479}]}