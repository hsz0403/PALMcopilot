{"code": ["Require Import Arith Lia ZArith List Permutation Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list gcd prime binomial sums php.", "From Undecidability.H10.ArithLibs Require Import matrix.", "Set Implicit Arguments.", "Set Default Proof Using \"Type\".", "Section le_pirr.", "Scheme le_indd := Induction for le Sort Prop.", "Fact le_pirr : forall x y (H1 H2 : x <= y), H1 = H2.", "Proof.", "simpl; intros n ? H1.", "induction H1 as [ | m H1 IH ] using le_indd; intro H2.", "change (le_n n) with (eq_rect _ (fun n0 => n <= n0) (le_n n) _ eq_refl).", "generalize (eq_refl n).", "pattern n at 2 4 6 10, H2.", "case H2; [intro E | intros m l E].", "rewrite UIP_dec with (p1 := E) (p2 := eq_refl); auto.", "apply eq_nat_dec.", "contradiction (le_Sn_n m); subst; auto.", "change (le_S n m H1) with (eq_rect _ (fun n0 => n <= n0) (le_S n m H1) _ eq_refl).", "generalize (eq_refl (S m)).", "pattern (S m) at 1 3 4 6, H2.", "case H2; [intro E | intros p H3 E].", "contradiction (le_Sn_n m); subst; auto.", "injection E; intro; subst.", "rewrite (IH H3).", "rewrite UIP_dec with (p1 := E) (p2 := eq_refl); auto.", "apply eq_nat_dec.", "Qed.", "End le_pirr.", "Fact lt_pirr x y (H1 H2 : x < y) : H1 = H2.", "Proof.", "apply le_pirr.", "Qed.", "Fact Zring : ring_theory 0%Z 1%Z Zplus Zmult Zminus Z.opp eq.", "Proof.", "exists; intros; ring.", "Qed.", "Hint Resolve Zring Zplus_monoid Zmult_monoid : core.", "Section Z_coprime.", "Open Scope Z_scope.", "Definition Z_pos_or_neg u : { 0 <= u } + { u < 0 }.", "Proof.", "destruct (Ztrichotomy_inf u 0) as [ [|] | ]; try (left; lia); tauto.", "Qed.", "Fact Z_coprime u v : (exists a b, a * Z.of_nat u + b*Z.of_nat v = 1) -> is_gcd u v 1%nat.", "Proof.", "intros (a & b & H).", "destruct (Z_pos_or_neg a) as [ Ha | Ha ]; destruct (Z_pos_or_neg b) as [ Hb | Hb ].", "+", "apply bezout_sc with (a:= Z.to_nat a) (b := Z.to_nat b) (m := 0%nat).", "2: left; apply divides_0.", "apply Nat2Z.inj.", "rewrite Nat2Z.inj_add.", "repeat rewrite Nat2Z.inj_mul.", "repeat rewrite Z2Nat.id; auto.", "+", "apply bezout_sc with (a:= Z.to_nat a) (b := 0%nat) (m := (Z.to_nat (-b)*v)%nat).", "2: right; apply divides_mult, divides_refl.", "apply Nat2Z.inj.", "repeat rewrite Nat2Z.inj_add.", "repeat rewrite Nat2Z.inj_mul.", "repeat rewrite Z2Nat.id; auto; lia.", "+", "apply bezout_sc with (b:= Z.to_nat b) (a := 0%nat) (m := (Z.to_nat (-a)*u)%nat).", "2: left; apply divides_mult, divides_refl.", "apply Nat2Z.inj.", "repeat rewrite Nat2Z.inj_add.", "repeat rewrite Nat2Z.inj_mul.", "repeat rewrite Z2Nat.id; auto; lia.", "+", "apply Z.lt_le_incl in Ha.", "apply Z.lt_le_incl in Hb.", "exfalso; revert H.", "generalize (Z.mul_nonpos_nonneg _ _ Ha (Nat2Z.is_nonneg u)).", "generalize (Z.mul_nonpos_nonneg _ _ Hb (Nat2Z.is_nonneg v)).", "intros; lia.", "Qed.", "End Z_coprime.", "Section Zp.", "Variable (p : nat) (Hp : p <> 0).", "Definition Z_Zp := { x | x < p }.", "Implicit Type x y : Z_Zp.", "Fact Zp_inj : forall x y, proj1_sig x = proj1_sig y -> x = y.", "Proof.", "intros (x & H1) (y & H2); simpl; intros; subst; f_equal; apply lt_pirr.", "Qed.", "Definition Zp_plus : Z_Zp -> Z_Zp -> Z_Zp.", "Proof using Hp.", "intros (x & Hx) (y & Hy).", "exists (rem (x+y) p).", "apply div_rem_spec2; trivial.", "Defined.", "Infix \"\u2295\" := Zp_plus (at level 50, left associativity).", "Definition Zp_zero : Z_Zp.", "Proof using Hp.", "exists 0; lia.", "Defined.", "Definition Zp_opp : Z_Zp -> Z_Zp.", "Proof using Hp.", "intros (x & Hx).", "exists (rem (p - x) p).", "apply div_rem_spec2; trivial.", "Defined.", "Notation \"\u2238\" := Zp_opp.", "Definition Zp_mult : Z_Zp -> Z_Zp -> Z_Zp.", "Proof using Hp.", "intros (x & Hx) (y & Hy).", "exists (rem (x*y) p).", "apply div_rem_spec2; trivial.", "Defined.", "Infix \"\u2297\" := Zp_mult (at level 40, left associativity).", "Definition Zp_one : Z_Zp.", "Proof using Hp.", "exists (rem 1 p); apply div_rem_spec2; trivial.", "Defined.", "Notation Zp := Zp_zero.", "Notation Op := Zp_one.", "Fact Zp_plus_zero : forall x, Zp \u2295 x = x.", "Proof.", "intros (x & Hx); apply Zp_inj; simpl.", "apply rem_prop with 0; simpl; auto.", "Qed.", "Fact Zp_plus_comm : forall x y, x \u2295 y = y \u2295 x.", "Proof.", "intros (x & ?) (y & ?); apply Zp_inj; simpl.", "f_equal; lia.", "Qed.", "Fact Zp_plus_assoc : forall x y z, x \u2295 (y \u2295 z) = x \u2295 y \u2295 z.", "Proof.", "intros (x & ?) (y & ?) (z & ?); apply Zp_inj; simpl.", "rewrite (plus_comm (rem _ _) z), rem_plus_rem, rem_plus_rem.", "f_equal; ring.", "Qed.", "Fact Zp_minus : forall x, x \u2295 \u2238 x = Zp.", "Proof.", "intros ([ | x ] & Hx); apply Zp_inj; simpl.", "+", "rewrite Nat.sub_0_r, rem_diag, rem_lt; auto.", "+", "rewrite rem_lt with (a := _ - _); try lia.", "replace (S (x+(p - S x))) with p by lia.", "apply rem_diag; auto.", "Qed.", "Fact Zp_mult_one : forall x, Op \u2297 x = x.", "Proof.", "intros (x & ?); apply Zp_inj; simpl proj1_sig.", "destruct p as [ | [ | q ] ].", "+", "destruct Hp; auto.", "+", "rewrite rem_diag; simpl; auto.", "rewrite rem_lt; lia.", "+", "rewrite rem_lt with (a := 1); try lia.", "rewrite Nat.mul_1_l, rem_lt; lia.", "Qed.", "Fact Zp_mult_comm : forall x y, x \u2297 y = y \u2297 x.", "Proof.", "intros (x & ?) (y & ?); apply Zp_inj; simpl.", "f_equal; ring.", "Qed.", "Fact Zp_mult_one_r x : x \u2297 Op = x.", "Proof.", "rewrite Zp_mult_comm, Zp_mult_one; auto.", "Qed.", "Fact Zp_mult_assoc : forall x y z, x \u2297 (y \u2297 z) = x \u2297 y \u2297 z.", "Proof.", "intros (x & ?) (y & ?) (z & ?); apply Zp_inj; simpl.", "rewrite (mult_comm (rem _ _) z), rem_mult_rem, rem_mult_rem.", "f_equal; ring.", "Qed.", "Fact Zp_mult_plus_distr_l : forall x y z, x \u2297 (y \u2295 z) = x \u2297 y \u2295 x \u2297 z.", "Proof.", "intros (x & ?) (y & ?) (z & ?); apply Zp_inj; simpl.", "rewrite <- rem_plus, <- rem_scal; f_equal; ring.", "Qed.", "Fact Zp_mult_plus_distr_r x y z : (y \u2295 z) \u2297 x = y \u2297 x \u2295 z \u2297 x.", "Proof.", "do 3 rewrite (Zp_mult_comm _ x); apply Zp_mult_plus_distr_l.", "Qed.", "Definition Zp_is_ring : @ring_theory _ Zp Op Zp_plus Zp_mult (fun x y => x \u2295 \u2238 y) Zp_opp eq.", "Proof.", "exists.", "+", "apply Zp_plus_zero.", "+", "apply Zp_plus_comm.", "+", "apply Zp_plus_assoc.", "+", "apply Zp_mult_one.", "+", "apply Zp_mult_comm.", "+", "apply Zp_mult_assoc.", "+", "intros; apply Zp_mult_plus_distr_r.", "+", "auto.", "+", "apply Zp_minus.", "Qed.", "Fact Zp_mult_invert : forall x, is_gcd p (proj1_sig x) 1 -> { i | i \u2297 x = Op }.", "Proof.", "intros (x & Hx); simpl; intros H.", "destruct (bezout_generalized p x) as (u & v & g & l & H1 & H2 & H3 & _).", "generalize (is_gcd_fun H H2); intro; subst g.", "exists (exist _ (rem v p) (@div_rem_spec2 v p Hp)).", "apply Zp_inj; simpl.", "rewrite mult_comm, <- rem_scal.", "destruct H3 as (k & H3).", "rewrite mult_comm.", "rewrite <- rem_erase with (n := u) (1 := eq_refl).", "rewrite <- rem_erase with (n := k) (r := 1) (1 := eq_refl).", "f_equal.", "rewrite H1,H3; ring.", "Qed.", "Fact Zp_mult_revert : forall x i, i \u2297 x = Op -> is_gcd p (proj1_sig x) 1.", "Proof.", "intros (x & Hx) (i & Hi) H; simpl.", "apply f_equal with (f := @proj1_sig _ _) in H; simpl in H.", "destruct (le_lt_dec p 1) as [ H' | H'].", "+", "replace p with 1 by lia.", "apply is_gcd_1l.", "+", "rewrite rem_lt with (a := 1) in H; try lia.", "generalize (div_rem_spec1 (i*x) p).", "rewrite H.", "generalize (div (i*x) p); clear H Hi; intros u Hu.", "apply bezout_sc with 1 i ((1+u)* p).", "*", "rewrite Hu; ring.", "*", "left; apply divides_mult, divides_refl.", "Qed.", "Definition Zp_invertible x := exists i, i \u2297 x = Op.", "Fact Zp_invertible_spec x : Zp_invertible x <-> is_gcd p (proj1_sig x) 1.", "Proof.", "split.", "+", "intros (i & Hi); revert Hi; apply Zp_mult_revert.", "+", "intros H; destruct (Zp_mult_invert _ H) as (i & ?); exists i; auto.", "Qed.", "Fact Zp_prime_invert : prime p -> forall x, x <> Zp -> { i | i \u2297 x = Op }.", "Proof.", "intros Hp' x Hx.", "apply Zp_mult_invert.", "destruct x; simpl in *.", "destruct (prime_gcd x Hp') as [ | H ]; auto.", "exfalso; apply Hx, Zp_inj; simpl.", "destruct H as ([ | k ] & Hk); simpl in Hk; auto.", "revert Hk; generalize (k* p); intros; lia.", "Qed.", "Add Ring Zp_ring : Zp_is_ring.", "Fact Zp_plus_monoid : monoid_theory Zp_plus Zp_zero.", "Proof.", "exists; intros; ring.", "Qed.", "Fact Zp_mult_monoid : monoid_theory Zp_mult Zp_one.", "Proof.", "exists; intros; ring.", "Qed.", "Fact Zp_one_invertible : Zp_invertible Op.", "Proof.", "exists Op; ring.", "Qed.", "Fact Zp_opp_invertible x : Zp_invertible x <-> Zp_invertible (\u2238 x).", "Proof.", "split; intros (i & Hi); exists (\u2238 i); rewrite <- Hi; ring.", "Qed.", "Fact Zp_mult_invertible x y : Zp_invertible x -> Zp_invertible y -> Zp_invertible (x \u2297 y).", "Proof.", "intros (u & H1) (v & H2); exists (u\u2297v); rewrite <- (Zp_mult_one Op).", "rewrite <- H1 at 1.", "rewrite <- H2; ring.", "Qed.", "Hint Resolve Zp_one_invertible Zp_opp_invertible Zp_mult_invertible : core.", "Fact Zp_expo_invertible n x : Zp_invertible x -> Zp_invertible (mscal Zp_mult Op n x).", "Proof.", "intros; induction n; [ rewrite mscal_0 | rewrite mscal_S ]; auto.", "Qed.", "Fact Zp_invertible_cancel_l x y z : Zp_invertible x -> x\u2297y = x\u2297z -> y = z.", "Proof.", "intros (i & Hi) H.", "rewrite <- (Zp_mult_one y), <- Hi, <- Zp_mult_assoc, H, Zp_mult_assoc, Hi, Zp_mult_one; auto.", "Qed.", "Fact Zp_opp_zero : \u2238 Zp = Zp.", "Proof.", "ring.", "Qed.", "Fact Zp_plus_inj_l x y z : x \u2295 y = x \u2295 z -> y = z.", "Proof.", "intros H.", "apply f_equal with (f := fun a => \u2238 x \u2295 a) in H.", "do 2 rewrite Zp_plus_assoc in H.", "rewrite (Zp_plus_comm _ x), Zp_minus in H.", "do 2 rewrite Zp_plus_zero in H; auto.", "Qed.", "Fact Zp_plus_zero_r x : x \u2295 Zp = x.", "Proof.", "ring.", "Qed.", "Fact Zp_opp_inv x : \u2238 (\u2238 x) = x.", "Proof.", "ring.", "Qed.", "Fact Zp_opp_inj x y : \u2238 x = \u2238 y -> x = y.", "Proof.", "intros H; rewrite <- (Zp_opp_inv x), H; ring.", "Qed.", "Fact Zp_opp_plus x y : \u2238 (x \u2295 y) = \u2238 x \u2295 \u2238 y.", "Proof.", "ring.", "Qed.", "Fact Zp_opp_plus_eq x y z : x \u2295 y = z <-> x = z \u2295 \u2238 y.", "Proof.", "split; intros; subst; ring.", "Qed.", "Fact Zp_mult_zero x : Zp \u2297 x = Zp.", "Proof.", "ring.", "Qed.", "Fact Zp_mult_minus_one x : (\u2238 Op) \u2297 x = \u2238 x.", "Proof.", "ring.", "Qed.", "Fact Zp_opp_mult x y : (\u2238 x) \u2297 y = \u2238 (x \u2297 y).", "Proof.", "ring.", "Qed.", "Fact Zp_invertible_eq_zero x y : Zp_invertible x -> x \u2297 y = Zp -> y = Zp.", "Proof.", "intros (i & Hi) H1.", "rewrite <- (Zp_mult_one y), <- Hi at 1.", "rewrite <- Zp_mult_assoc, H1; ring.", "Qed.", "Fact Zp_zero_is_one : Zp = Op <-> p = 1.", "Proof.", "split.", "+", "intros H; apply f_equal with (f := @proj1_sig _ _) in H; simpl in H.", "symmetry in H.", "apply divides_rem_eq, divides_1_inv in H; auto.", "+", "intros; apply Zp_inj; simpl; subst; rewrite rem_diag; auto.", "Qed.", "Fact Zp_eq_dec : forall x y : Z_Zp, { x = y } + { x <> y }.", "Proof.", "intros (x & Hx) (y & Hy).", "destruct (eq_nat_dec x y) as [ | H ].", "+", "left; apply Zp_inj; auto.", "+", "right; contradict H.", "apply f_equal with (f := @proj1_sig _ _) in H; auto.", "Qed.", "Section nat2Zp.", "Definition nat2Zp (u : nat) : Z_Zp.", "Proof using Hp.", "exists (rem u p); apply div_rem_spec2; trivial.", "Defined.", "Arguments nat2Zp u /.", "Notation \"\u301a x \u301b\" := (nat2Zp x).", "Fact nat2Zp_zero : \u301a0\u301b= Zp.", "Proof.", "apply Zp_inj; simpl.", "apply rem_prop with 0; lia.", "Qed.", "Fact nat2Zp_one : \u301a1\u301b= Op.", "Proof.", "apply Zp_inj; simpl; auto.", "Qed.", "Fact nat2Zp_invertible n : Zp_invertible \u301an\u301b <-> is_gcd p n 1.", "Proof.", "rewrite Zp_invertible_spec.", "symmetry; apply is_gcd_rem.", "Qed.", "Fact nat2Zp_p :\u301ap\u301b= Zp.", "Proof.", "apply Zp_inj; simpl.", "apply rem_diag; lia.", "Qed.", "Fact nat2Zp_inj u v : \u301au\u301b=\u301av\u301b <-> rem u p = rem v p.", "Proof.", "split; intros H.", "+", "apply f_equal with (f := @proj1_sig _ _) in H; auto.", "+", "apply Zp_inj; auto.", "Qed.", "Fact nat2Zp_surj u : { x | x < p /\\ u = \u301ax\u301b }.", "Proof.", "destruct u as (u & Hu); exists u; split; auto.", "apply Zp_inj; simpl.", "rewrite rem_prop with (n := 0) (2 := Hu); auto.", "Qed.", "Fact nat2Zp_plus u v : \u301au+v\u301b=\u301au\u301b\u2295\u301av\u301b.", "Proof.", "apply Zp_inj; simpl.", "rewrite rem_plus_rem, (plus_comm (rem _ _)), rem_plus_rem.", "f_equal; ring.", "Qed.", "Fact nat2Zp_minus u v : v <= u -> \u301au-v\u301b=\u301au\u301b\u2295 \u2238\u301av\u301b.", "Proof.", "intros; apply Zp_inj; simpl.", "rewrite rem_plus_rem, (plus_comm (rem _ _)), plus_comm.", "generalize (div u p) (div v p) (div_rem_spec1 u p) (div_rem_spec1 v p).", "intros a b H1 H2.", "assert (b <= a) as Hab.", "{", "destruct (le_lt_dec b a); auto.", "replace b with ((1+a) + (b-a-1)) in H2 by lia.", "generalize (div_rem_spec2 u Hp) (div_rem_spec2 v Hp); intros H3 H4.", "do 2 rewrite Nat.mul_add_distr_r in H2.", "contradict H; rewrite H1, H2, Nat.mul_1_l.", "generalize (a* p) ((b-a-1)* p); intros; lia.", "}", "destruct (eq_nat_dec a b) as [ | Ha ]; try subst b.", "+", "assert (rem v p <= rem u p) as H3.", "{", "rewrite H1, H2 in H; revert H; intros; lia.", "}", "symmetry; apply rem_erase with 1.", "rewrite H1 at 2.", "rewrite H2 at 2.", "generalize (a* p) (div_rem_spec2 v Hp); intros; lia.", "+", "apply rem_erase with (a-b-1).", "rewrite H2 at 1; rewrite H1 at 1.", "do 2 rewrite Nat.mul_sub_distr_r.", "rewrite Nat.mul_1_l.", "assert (b* p + p <= a* p) as E.", "{", "replace a with (1+b+(a-b-1)) by lia.", "do 2 rewrite Nat.mul_add_distr_r.", "generalize (b* p) ((a-b-1)* p); intros; lia.", "}", "revert E.", "generalize (a* p) (b* p) (div_rem_spec2 u Hp) (div_rem_spec2 v Hp); intros.", "lia.", "Qed.", "Fact nat2Zp_minus_one : \u301ap-1\u301b= \u2238Op.", "Proof.", "rewrite nat2Zp_minus; try lia.", "rewrite nat2Zp_p, nat2Zp_one; ring.", "Qed.", "Fact nat2Zp_mult u v :\u301au*v\u301b=\u301au\u301b\u2297\u301av\u301b.", "Proof.", "apply Zp_inj; simpl.", "rewrite rem_mult_rem, (mult_comm (rem _ _)), rem_mult_rem.", "f_equal; ring.", "Qed.", "Fact nat2Zp_expo n u : \u301amscal mult 1%nat n u\u301b = mscal Zp_mult Zp_one n \u301au\u301b.", "Proof.", "induction n as [ | n IHn ].", "+", "do 2 rewrite mscal_0; auto.", "+", "do 2 rewrite mscal_S.", "rewrite nat2Zp_mult, IHn; auto.", "Qed.", "Fact nat2Zp_divides u v :\u301au\u301b=\u301av\u301b-> divides p u -> divides p v.", "Proof.", "intros H.", "apply f_equal with (f := @proj1_sig _ _) in H; simpl in H.", "do 2 (rewrite divides_rem_eq; auto); lia.", "Qed.", "Fact divides_nat2Zp u : divides p u <-> \u301au\u301b= Zp.", "Proof.", "split.", "+", "intros (q & Hq); apply Zp_inj; simpl.", "apply rem_prop with q; lia.", "+", "intros H.", "apply f_equal with (f := @proj1_sig _ _) in H; simpl in H.", "exists (div u p).", "rewrite (div_rem_spec1 u p) at 1; lia.", "Qed.", "End nat2Zp.", "Arguments nat2Zp u /.", "Definition Zp_list := map nat2Zp (list_an 0 p).", "Fact Zp_list_spec x : In x Zp_list.", "Proof.", "destruct (nat2Zp_surj x) as (n & H1 & H2); subst.", "apply in_map_iff; exists n; split; auto.", "apply list_an_spec; lia.", "Qed.", "Fact Zp_list_length : length Zp_list = p.", "Proof.", "unfold Zp_list; rewrite map_length, list_an_length; auto.", "Qed.", "Fact Zp_invertible_prime x : prime p -> Zp_invertible x <-> x <> Zp.", "Proof.", "intros H.", "split.", "+", "intros (i & Hi) E.", "subst.", "rewrite Zp_mult_comm, Zp_mult_zero, Zp_zero_is_one in Hi.", "apply prime_ge_2 in H; lia.", "+", "intros Hx.", "destruct (nat2Zp_surj x) as (u & _ & Hu).", "rewrite Hu; apply nat2Zp_invertible.", "destruct (prime_gcd u H) as [ H1 | H1 ]; auto.", "destruct Hx.", "rewrite Hu; apply divides_nat2Zp; auto.", "Qed.", "Fact Zp_prime_integral x y : prime p -> x \u2297 y = Zp -> x = Zp \\/ y = Zp.", "Proof.", "intros H1 H2.", "destruct (Zp_eq_dec x Zp) as [ | H ]; auto; right.", "revert H2; apply Zp_invertible_eq_zero, Zp_invertible_prime; auto.", "Qed.", "Fact Zp_prime_square_eq_square x y : prime p -> x\u2297x = y\u2297y <-> x = y \\/ x = \u2238y.", "Proof.", "intros H1; split.", "+", "intros H2.", "assert ((x\u2295\u2238y)\u2297(x\u2295y) = Zp) as H3.", "{", "rewrite Zp_mult_plus_distr_l, Zp_mult_plus_distr_r, H2; ring.", "}", "apply Zp_prime_integral in H3; auto.", "destruct H3 as [ H3 | H3 ]; [ left | right ]; rewrite Zp_opp_plus_eq in H3; rewrite H3; ring.", "+", "intros [ | ]; subst x; ring.", "Qed.", "Fact Zp_prime_square_one x : prime p -> x\u2297x = Op <-> x = Op \\/ x = \u2238Op.", "Proof.", "rewrite <- (Zp_mult_one Op) at 1.", "apply Zp_prime_square_eq_square.", "Qed.", "Section Z2Zp.", "Open Scope Z_scope.", "Implicit Types u v w : Z.", "Definition Z2Zp u : Z_Zp.", "Proof using Hp.", "destruct (Z_pos_or_neg u) as [ H | H ].", "+", "apply nat2Zp, Z.to_nat; exact u.", "+", "apply Zp_opp, nat2Zp, Z.to_nat; exact (-u).", "Defined.", "Arguments Z2Zp u /.", "Notation \"\u3018 x \u3019\" := (Z2Zp x).", "Notation \"\u301a x \u301b\" := (nat2Zp x).", "Fact Z2Zp_pos u : 0 <= u -> \u3018u\u3019= \u301aZ.to_nat u\u301b.", "Proof.", "intros H.", "unfold Z2Zp.", "destruct (Z_pos_or_neg u); try lia; auto.", "Qed.", "Fact Z2Zp_of_nat n : \u3018Z.of_nat n\u3019 = \u301an\u301b.", "Proof.", "rewrite Z2Zp_pos, Nat2Z.id; auto.", "apply Zle_0_nat.", "Qed.", "Fact Z2Zp_zero : \u30180\u3019= Zp.", "Proof.", "rewrite Z2Zp_pos; try lia.", "rewrite Z2Nat.inj_0, nat2Zp_zero; auto.", "Qed.", "Fact Z2Zp_neg u : u <= 0 -> \u3018u\u3019 = \u2238\u3018-u\u3019.", "Proof.", "intros H.", "unfold Z2Zp at 1.", "destruct (Z_pos_or_neg u) as [ H' | H' ]; try lia; auto.", "replace u with 0 by lia.", "rewrite Z.opp_0, Z2Nat.inj_0, nat2Zp_zero, Z2Zp_zero; auto.", "symmetry; apply Zp_opp_zero.", "unfold Z2Zp.", "destruct (Z_pos_or_neg (-u)) as [ H'' | H'' ]; try lia; auto.", "Qed.", "Section Z2Zp_plus.", "Let Z2Zp_plus_loc u v : u <= 0 -> 0 <= v -> -u <= v -> \u3018u+v\u3019=\u3018u\u3019\u2295\u3018v\u3019.", "Proof.", "intros H1 H2 H3.", "rewrite Z2Zp_pos; try lia.", "rewrite Z2Zp_neg; try lia.", "do 2 (rewrite Z2Zp_pos; try lia).", "replace (u+v) with (v-(-u)) by lia.", "rewrite Z2Nat.inj_sub; try lia.", "rewrite nat2Zp_minus.", "+", "apply Zp_plus_comm.", "+", "rewrite <- Z2Nat.inj_le; lia.", "Qed.", "Let Z2Zp_plus_loc' u v : u <= 0 -> 0 <= v -> v <= -u -> \u3018u+v\u3019=\u3018u\u3019\u2295\u3018v\u3019.", "Proof.", "intros H1 H2 H3.", "rewrite Z2Zp_neg; try lia.", "rewrite Z2Zp_pos; try lia.", "rewrite Z2Zp_neg; try lia.", "do 2 (rewrite Z2Zp_pos; try lia).", "replace (-(u+v)) with (-u-v) by lia.", "rewrite Z2Nat.inj_sub; try lia.", "rewrite nat2Zp_minus; auto.", "+", "rewrite Zp_opp_plus, Zp_opp_inv; auto.", "+", "rewrite <- Z2Nat.inj_le; lia.", "Qed.", "Fact Z2Zp_plus u v : \u3018u+v\u3019=\u3018u\u3019\u2295\u3018v\u3019.", "Proof.", "destruct (Z_pos_or_neg u) as [ H1 | H1 ]; destruct (Z_pos_or_neg v) as [ H2 | H2 ].", "+", "do 3 (rewrite Z2Zp_pos; try lia).", "rewrite Z2Nat.inj_add; auto.", "apply nat2Zp_plus.", "+", "rewrite Z.add_comm, Zp_plus_comm.", "destruct (Z_pos_or_neg (u+v)).", "-", "apply Z2Zp_plus_loc; lia.", "-", "apply Z2Zp_plus_loc'; lia.", "+", "destruct (Z_pos_or_neg (u+v)).", "-", "apply Z2Zp_plus_loc; lia.", "-", "apply Z2Zp_plus_loc'; lia.", "+", "do 3 (rewrite Z2Zp_neg, Z2Zp_pos; try lia).", "rewrite <- Zp_opp_plus; f_equal.", "replace (-(u+v)) with ((-u)+(-v)) by lia.", "rewrite Z2Nat.inj_add; try lia.", "apply nat2Zp_plus.", "Qed.", "End Z2Zp_plus.", "Fact Z2Zp_opp u :\u3018-u\u3019= \u2238\u3018u\u3019.", "Proof.", "apply Zp_plus_inj_l with (Z2Zp u).", "rewrite Zp_minus, <- Z2Zp_plus, <- Z2Zp_zero.", "f_equal; lia.", "Qed.", "Fact Z2Zp_minus u v : \u3018u-v\u3019 = \u3018u\u3019\u2295 \u2238\u3018v\u3019.", "Proof.", "replace (u-v) with (u+(-v)) by lia.", "rewrite Z2Zp_plus; f_equal.", "apply Z2Zp_opp.", "Qed.", "Section Z2Zp_canon.", "Let Z2Zp_canon_pos u : 0 <= u -> { v | \u3018u\u3019=\u3018v\u3019 /\\ 0 <= v < Z.of_nat p }.", "Proof.", "intros H1.", "rewrite Z2Zp_pos; auto.", "exists (Z.of_nat (rem (Z.to_nat u) p)); split.", "rewrite Z2Zp_of_nat.", "apply nat2Zp_inj.", "rewrite rem_rem; auto.", "split.", "*", "apply Zle_0_nat.", "*", "apply inj_lt, div_rem_spec2; auto.", "Qed.", "Let Z2Zp_canon_neg u : u <= 0 -> { v | \u3018u\u3019=\u3018v\u3019 /\\ 0 <= v < Z.of_nat p }.", "Proof.", "intros H1.", "rewrite Z2Zp_neg; try lia.", "rewrite Z2Zp_opp, Zp_opp_inv.", "destruct (Zp_eq_dec (Z2Zp u) Zp_zero) as [ E | D ].", "+", "exists 0; split.", "*", "rewrite E, Z2Zp_zero; auto.", "*", "split; lia.", "+", "destruct Z2Zp_canon_pos with (u := -u) as (v & H2 & H3); try lia.", "exists (Z.of_nat p - v); split.", "*", "rewrite Z2Zp_minus, Z2Zp_of_nat, nat2Zp_p, <- H2, Z2Zp_opp; ring.", "*", "split; try lia.", "destruct (Z.eq_dec v 0) as [ E | ]; try lia.", "subst; destruct D.", "rewrite Z2Zp_opp in H2.", "rewrite <- (Zp_opp_inv \u3018 _ \u3019), H2, Z2Zp_zero; ring.", "Qed.", "Fact Z2Zp_repr_canon u : { v |\u3018u\u3019=\u3018v\u3019 /\\ 0 <= v < Z.of_nat p }.", "Proof.", "destruct (Z_pos_or_neg u); auto.", "apply Z2Zp_canon_neg; lia.", "Qed.", "End Z2Zp_canon.", "Fact Zp_repr_interval a b u : Z.of_nat p <= b-a -> { v |\u3018u\u3019=\u3018v\u3019/\\ a <= v < b }.", "Proof.", "intros Hab.", "destruct (Z2Zp_repr_canon (u-a)) as (v & H1 & H2).", "exists (a+v)%Z; split; try lia.", "rewrite Z2Zp_plus, <- H1, Z2Zp_minus; ring.", "Qed.", "Section Z2Zp_mult.", "Let Z2Zp_mult_loc u v : 0 <= u -> 0 <= v -> \u3018u*v\u3019=\u3018u\u3019\u2297\u3018v\u3019.", "Proof.", "intros H1 H2.", "rewrite Z2Zp_pos; try lia.", "do 2 (rewrite Z2Zp_pos; try lia).", "rewrite Z2Nat.inj_mul; auto.", "apply nat2Zp_mult.", "Qed.", "Fact Z2Zp_mult u v : \u3018u*v\u3019=\u3018u\u3019\u2297\u3018v\u3019.", "Proof.", "destruct (Z_pos_or_neg u) as [ H1 | H1 ]; destruct (Z_pos_or_neg v) as [ H2 | H2 ].", "+", "apply Z2Zp_mult_loc; auto.", "+", "replace (u*v) with (-(u*-v)); try ring.", "rewrite Z2Zp_opp, Z2Zp_mult_loc; try lia.", "rewrite Z2Zp_opp, Zp_mult_comm, Zp_opp_mult, Zp_opp_inv.", "apply Zp_mult_comm.", "+", "replace (u*v) with (- ((-u)*v)); try ring.", "rewrite Z2Zp_opp, Z2Zp_mult_loc; try lia.", "rewrite Z2Zp_opp, Zp_opp_mult, Zp_opp_inv; auto.", "+", "replace (u*v) with ((-u)*(-v)); try ring.", "rewrite Z2Zp_mult_loc; try lia.", "do 2 rewrite Z2Zp_opp.", "do 2 rewrite Zp_opp_mult, Zp_mult_comm.", "apply Zp_opp_inv.", "Qed.", "End Z2Zp_mult.", "Fact Z2Zp_one : \u30181\u3019 = Op.", "Proof.", "rewrite Z2Zp_pos; try lia.", "apply Zp_inj; simpl; f_equal; auto.", "Qed.", "Section Z2Zp_inj.", "Let Z2Zp_inj_loc u v : v <= u ->\u3018u\u3019=\u3018v\u3019-> exists i, u-v = i*Z.of_nat p.", "Proof.", "intros H2 H.", "assert (\u3018u-v\u3019= Zp) as H1.", "{", "rewrite Z2Zp_minus, H; ring.", "}", "rewrite Z2Zp_pos in H1; auto; try lia.", "rewrite <- nat2Zp_zero in H1.", "apply nat2Zp_inj in H1.", "rewrite rem_of_0 in H1.", "generalize (@div_rem_spec1 (Z.to_nat (u-v)) p); intros H3.", "rewrite H1 in H3.", "apply f_equal with (f := Z.of_nat) in H3.", "rewrite Z2Nat.id in H3; auto; try lia.", "rewrite H3.", "exists (Z.of_nat (div (Z.to_nat (u-v)) p)).", "rewrite Nat2Z.inj_add, Nat2Z.inj_mul; simpl; ring.", "Qed.", "Fact Z2Zp_inj u v :\u3018u\u3019=\u3018v\u3019<-> exists i, u-v = i*Z.of_nat p.", "Proof.", "split.", "+", "destruct (Z_pos_or_neg (u-v)) as [ H | H ].", "*", "apply Z2Zp_inj_loc; lia.", "*", "intros H'; symmetry in H'.", "apply Z2Zp_inj_loc in H'; try lia.", "destruct H' as (i & Hi).", "exists (-i).", "apply f_equal with (f := Z.opp) in Hi.", "ring_simplify in Hi.", "rewrite <- Hi; ring.", "+", "intros (i & Hi).", "replace u with (v+(u-v)) by lia.", "rewrite Hi, Z2Zp_plus, Z2Zp_mult, Z2Zp_of_nat, nat2Zp_p; ring.", "Qed.", "End Z2Zp_inj.", "Fact Z2Zp_zero_inv u : \u3018u\u3019= Zp_zero -> exists v, (u = Z.of_nat p * v)%Z.", "Proof.", "intros H.", "rewrite <- Z2Zp_zero in H.", "apply Z2Zp_inj in H.", "destruct H as (y & Hy); exists y.", "rewrite Zmult_comm, <- Hy; ring.", "Qed.", "Fact nat2Zp_choose : forall x, x = Zp \\/ x = Op \\/ x = \u2238 Op \\/ exists m, (1 < m < p-1)%nat /\\\u301am\u301b= x.", "Proof.", "intros (x & Hx).", "destruct x as [ | [ | x ] ].", "+", "left; apply Zp_inj; simpl; auto.", "+", "right; left; apply Zp_inj; simpl; rewrite rem_lt; auto.", "+", "destruct (eq_nat_dec (S (S x)) (p-1)) as [ H | H ].", "*", "do 2 right; left.", "rewrite <- nat2Zp_minus_one.", "apply Zp_inj; simpl; rewrite rem_lt; lia.", "*", "do 3 right; exists (S (S x)); split; try lia.", "apply Zp_inj; simpl; rewrite rem_lt; lia.", "Qed.", "Section prime.", "Hypothesis Hp' : prime p.", "Fact nat2Zp_invertible_prime n : (0 < n < p)%nat -> Zp_invertible \u301an\u301b.", "Proof using Hp'.", "intros Hn.", "apply Zp_invertible_prime; auto.", "intros H.", "apply divides_nat2Zp in H.", "destruct H as ([ | k ] & Hk).", "+", "simpl in Hk; lia.", "+", "revert Hn; rewrite Hk; simpl.", "generalize (k*p)%nat; intros; lia.", "Qed.", "Let Hp'' : (2 <= p)%nat.", "Proof.", "apply prime_ge_2; trivial.", "Qed.", "Let Hzero_one : Zp <> Op.", "Proof.", "intros H.", "apply Zp_zero_is_one in H.", "lia.", "Qed.", "Fact Zp_invertible_factorial n : (n < p)%nat -> Zp_invertible \u301afact n\u301b.", "Proof using Hp'.", "induction n as [ | n IHn ]; intros Hn.", "+", "rewrite fact_0; apply nat2Zp_invertible_prime; lia.", "+", "rewrite fact_S, nat2Zp_mult; apply Zp_mult_invertible.", "*", "apply nat2Zp_invertible_prime; lia.", "*", "apply IHn; lia.", "Qed.", "Section inv.", "Let Zp_invert_full x : { i | (x = Zp -> i = Zp) /\\ (x <> Zp -> i \u2297 x = Op) }.", "Proof.", "destruct (Zp_eq_dec x Zp) as [ Hx | Hx ].", "+", "exists Zp; split; auto; intros []; auto.", "+", "destruct Zp_prime_invert with (2 := Hx) as (i & Hi); trivial.", "exists i; split; auto; intros; destruct Hx; auto.", "Qed.", "Definition Zp_invert x := proj1_sig (Zp_invert_full x).", "Fact Zp_invert_spec1 : Zp_invert Zp = Zp.", "Proof.", "apply (proj2_sig (Zp_invert_full Zp)); trivial.", "Qed.", "Fact Zp_invert_spec2 x : x <> Zp -> Zp_invert x \u2297 x = Op.", "Proof.", "apply (proj2_sig (Zp_invert_full x)).", "Qed.", "End inv.", "Notation inv := Zp_invert.", "Fact Zp_invert_eq_not_zero x y : x <> Zp -> inv x = y <-> y \u2297 x = Op.", "Proof.", "intros H1.", "split.", "+", "intros H2; rewrite <- H2; apply Zp_invert_spec2; auto.", "+", "intros H2.", "apply Zp_invert_spec2 in H1.", "rewrite <- (Zp_mult_one (inv x)) , <- H2, <- Zp_mult_assoc, (Zp_mult_comm x), H1, Zp_mult_comm, Zp_mult_one.", "trivial.", "Qed.", "Fact Zp_invert_opp x : inv (\u2238x) = \u2238(inv x).", "Proof.", "destruct (Zp_eq_dec x Zp) as [ Hx | Hx ].", "+", "subst; rewrite Zp_opp_zero, Zp_invert_spec1, Zp_opp_zero; auto.", "+", "apply Zp_invert_eq_not_zero.", "*", "contradict Hx.", "rewrite <- (Zp_opp_inv x), Hx, Zp_opp_zero; trivial.", "*", "do 2 rewrite Zp_opp_mult, Zp_mult_comm.", "rewrite Zp_opp_inv, Zp_invert_spec2; auto.", "Qed.", "Fact Zp_invert_one : inv Op = Op.", "Proof.", "rewrite Zp_invert_eq_not_zero; auto.", "rewrite Zp_mult_one; auto.", "Qed.", "Fact Zp_invert_minus_one : inv (\u2238 Op) = \u2238 Op.", "Proof.", "rewrite Zp_invert_opp, Zp_invert_one; auto.", "Qed.", "Fact Zp_invert_fix x : inv x = x <-> x = Zp \\/ x = Op \\/ x = \u2238 Op.", "Proof.", "split.", "+", "intros H.", "destruct (Zp_eq_dec x Zp) as [ Hx | Hx ]; auto.", "apply Zp_invert_spec2 in Hx.", "rewrite H in Hx.", "apply Zp_prime_square_one in Hx; auto.", "+", "intros [ | [|]]; subst.", "*", "apply Zp_invert_spec1.", "*", "apply Zp_invert_eq_not_zero; try ring.", "intros H; symmetry in H; revert H; rewrite Zp_zero_is_one; lia.", "*", "apply Zp_invert_eq_not_zero; try ring.", "intros H.", "rewrite <- Zp_opp_zero in H.", "symmetry in H; apply Zp_opp_inj in H.", "revert H; rewrite Zp_zero_is_one; lia.", "Qed.", "Fact Zp_invert_involutive x : inv (inv x) = x.", "Proof.", "destruct (Zp_eq_dec x Zp) as [ Hx | Hx ]; subst.", "+", "do 2 rewrite Zp_invert_spec1; auto.", "+", "apply Zp_invert_eq_not_zero.", "*", "intros H.", "apply Zp_invert_spec2 in Hx.", "rewrite H, Zp_mult_zero in Hx.", "apply Zp_zero_is_one in Hx; lia.", "*", "rewrite Zp_mult_comm; apply Zp_invert_spec2; auto.", "Qed.", "Fact Zp_invert_not_fix n : (1 < n < p-1)%nat -> inv\u301an\u301b<>\u301an\u301b.", "Proof.", "intros H1 H2.", "apply Zp_invert_fix in H2.", "destruct H2 as [ H2 | [ H2 | H2 ] ].", "+", "rewrite <- nat2Zp_zero in H2.", "apply nat2Zp_inj in H2.", "rewrite rem_lt, rem_lt in H2; lia.", "+", "rewrite <- nat2Zp_one in H2.", "apply nat2Zp_inj in H2.", "rewrite rem_lt, rem_lt in H2; lia.", "+", "rewrite <- nat2Zp_minus_one in H2.", "apply nat2Zp_inj in H2.", "rewrite rem_lt, rem_lt in H2; lia.", "Qed.", "Fact Zp_invert_stable n : (1 < n < p-1)%nat -> exists m, (1 < m < p-1)%nat /\\\u301am\u301b= inv\u301an\u301b.", "Proof.", "intros Hn.", "destruct (nat2Zp_choose (inv \u301an\u301b)) as [ H | [ H | [ H | H ] ] ]; auto; exfalso; apply f_equal with (f := inv) in H; rewrite Zp_invert_involutive in H; symmetry in H.", "+", "rewrite Zp_invert_spec1 in H.", "rewrite <- nat2Zp_zero, nat2Zp_inj in H.", "rewrite rem_lt, rem_lt in H; lia.", "+", "rewrite Zp_invert_one, <- nat2Zp_one in H.", "rewrite nat2Zp_inj, rem_lt, rem_lt in H; lia.", "+", "rewrite Zp_invert_minus_one, <- nat2Zp_minus_one in H.", "rewrite nat2Zp_inj, rem_lt, rem_lt in H; lia.", "Qed.", "Definition Zp_lprod := fold_right Zp_mult Zp_one.", "Fact Zp_lprod_nil : Zp_lprod nil = Op.", "Proof.", "trivial.", "Qed.", "Fact Zp_lprod_cons x l : Zp_lprod (x::l) = x \u2297 Zp_lprod l.", "Proof.", "trivial.", "Qed.", "Fact Zp_lprod_app l m : Zp_lprod (l++m) = Zp_lprod l \u2297 Zp_lprod m.", "Proof.", "induction l as [ | x l IHl ].", "+", "rewrite Zp_lprod_nil, Zp_mult_one; auto.", "+", "simpl app; do 2 rewrite Zp_lprod_cons.", "rewrite IHl; ring.", "Qed.", "Theorem Zp_mult_autoinv l : ~ list_has_dup l -> (forall x, In x l -> x <> Zp /\\ inv x <> x /\\ In (inv x) l) -> Zp_lprod l = Op.", "Proof.", "induction on l as IHl with measure (length l); intros H0 Hl.", "destruct l as [ | x l ].", "+", "rewrite Zp_lprod_nil; auto.", "+", "destruct (Hl x) as (H1 & H2 & [H3 | H3]); try (simpl; auto; fail).", "1: destruct H2; auto.", "destruct in_split with (1 := H3) as (u & v & ?); subst.", "rewrite Zp_lprod_cons, Zp_lprod_app, Zp_lprod_cons.", "rewrite (Zp_mult_assoc _ (inv x)), (Zp_mult_comm _ (inv x)).", "repeat rewrite Zp_mult_assoc.", "rewrite (Zp_mult_comm _ (inv x)), Zp_invert_spec2; auto.", "rewrite Zp_mult_one, <- Zp_lprod_app.", "apply IHl.", "*", "simpl; do 2 rewrite app_length; simpl; lia.", "*", "contradict H0.", "constructor 2.", "apply perm_list_has_dup with (inv x::u++v).", "-", "apply Permutation_cons_app; auto.", "-", "constructor 2; auto.", "*", "intros y Hy.", "destruct (Hl y) as (G1 & G2 & G3).", "-", "apply in_app_or in Hy; right; apply in_or_app; simpl; tauto.", "-", "repeat (split; auto).", "destruct G3 as [ G3 | G3 ].", "++", "destruct H0; rewrite G3 at 2.", "rewrite Zp_invert_involutive.", "constructor 2.", "apply perm_list_has_dup with (y::u++v).", "**", "apply Permutation_cons_app; auto.", "**", "constructor 1; auto.", "++", "apply in_or_app.", "apply in_app_or in G3.", "destruct G3 as [ | [ G3 | ] ]; try tauto.", "exfalso.", "apply f_equal with (f := inv) in G3.", "do 2 rewrite Zp_invert_involutive in G3.", "destruct H0.", "apply perm_list_has_dup with (inv x::(x::u)++v).", "**", "apply Permutation_cons_app with (l1 := x::u); auto.", "**", "simpl; constructor 2; constructor 1; subst; auto.", "Qed.", "Fact Zp_lprod_fact n : \u301afact (S n)\u301b= Zp_lprod (map nat2Zp (list_an 2 n)).", "Proof using Hp'.", "induction n as [ | n IHn ].", "+", "apply Zp_inj; simpl; auto.", "+", "rewrite fact_S, nat2Zp_mult.", "replace (S n)%nat with (n+1)%nat by lia.", "rewrite list_an_plus, map_app, Zp_lprod_app, <- IHn, Zp_mult_comm.", "f_equal.", "*", "do 2 f_equal; lia.", "*", "simpl list_an; unfold map.", "rewrite Zp_lprod_cons, Zp_mult_comm, Zp_mult_one.", "f_equal; lia.", "Qed.", "Theorem Wilson_thm_1 :\u301afact (p-1)\u301b= \u2238Op.", "Proof using Hp'.", "replace (p-1)%nat with (S (p-2))%nat by lia.", "rewrite Zp_lprod_fact.", "destruct (eq_nat_dec p 2) as [ H1 | H1 ].", "+", "rewrite H1; simpl map; rewrite Zp_lprod_nil.", "rewrite <- nat2Zp_minus_one; apply nat2Zp_inj.", "rewrite H1; auto.", "+", "replace (p-2)%nat with (p-3+1)%nat by lia.", "rewrite list_an_plus, map_app, Zp_lprod_app.", "replace (p-3+2)%nat with (p-1)%nat by lia.", "simpl list_an at 2; unfold map at 2.", "rewrite Zp_lprod_cons, Zp_lprod_nil.", "rewrite Zp_mult_autoinv.", "*", "rewrite nat2Zp_minus_one; ring.", "*", "intros H.", "apply list_has_dup_map_inv in H.", "-", "revert H; apply not_list_an_has_dup.", "-", "intros x y; do 2 rewrite list_an_spec.", "intros Hx Hy.", "rewrite nat2Zp_inj, rem_lt, rem_lt; auto; lia.", "*", "intros x; rewrite in_map_iff.", "intros (n & ? & Hn); subst.", "rewrite list_an_spec in Hn.", "split; [ | split ].", "-", "intros H.", "rewrite <- nat2Zp_zero in H.", "apply nat2Zp_inj in H.", "rewrite rem_of_0, rem_lt in H; lia.", "-", "apply Zp_invert_not_fix; lia.", "-", "destruct Zp_invert_stable with n as (m & G1 & G2); try lia.", "apply in_map_iff.", "exists m; split; auto.", "apply list_an_spec; lia.", "Qed.", "End prime.", "Fact Zp_divides_and_invertible d k n i : (d * k = n)%nat ->\u301ai\u301b\u2297\u301ad\u301b= Op ->\u301ak\u301b=\u301ai\u301b\u2297\u301an\u301b.", "Proof.", "intros H1 H2.", "rewrite <- H1, nat2Zp_mult, Zp_mult_assoc, H2; ring.", "Qed.", "End Z2Zp.", "End Zp.", "Fact divides_not_0_interval p q : q <> 0 -> divides p q -> 1 <= p <= q.", "Proof.", "intros Hq ([ | k ] & Hk); try lia.", "Qed.", "Fact divides_fact_lt q n : 1 <= q <= n -> divides q (fact n).", "Proof.", "revert q; induction n as [ | n IHn ].", "+", "intros; rewrite fact_0; lia.", "+", "intros q Hq; rewrite fact_S.", "destruct (eq_nat_dec q (S n)).", "-", "subst; exists (fact n); ring.", "-", "apply divides_mult, IHn; lia.", "Qed.", "Theorem Wilson_theorem p : 2 <= p -> prime p <-> divides p (fact (p-1)+1).", "Proof.", "intros H1; split.", "+", "intros H2.", "assert (Hp : p <> 0) by lia.", "rewrite divides_nat2Zp with (Hp := Hp).", "rewrite nat2Zp_plus, Wilson_thm_1; auto.", "rewrite nat2Zp_one, Zp_plus_comm, Zp_minus; auto.", "+", "intros H2; split; try lia.", "intros q Hq.", "destruct (eq_nat_dec q p) as [ Hp | Hp ]; auto.", "generalize (divides_trans Hq H2); intros H3.", "apply divides_plus_inv in H3.", "-", "apply divides_1_inv in H3; auto.", "-", "apply divides_fact_lt.", "apply divides_not_0_interval in Hq; lia.", "Qed.", "Section Z2Zp_morphishm.", "Variable (p : nat) (Hp : p <> 0).", "Fact Z2Zp_morphishm : ring_morphism 0%Z 1%Z Zplus Zmult Z.opp (Zp_zero Hp) (Zp_one Hp) (Zp_plus Hp) (Zp_mult Hp) (Zp_opp Hp) (Z2Zp Hp).", "Proof.", "exists.", "+", "apply Z2Zp_zero.", "+", "apply Z2Zp_one.", "+", "apply Z2Zp_plus.", "+", "apply Z2Zp_mult.", "+", "apply Z2Zp_opp.", "Qed.", "End Z2Zp_morphishm."], "theorems": [{"name": "le_pirr", "kind": "Fact", "begin": 7, "end": 27}, {"name": "lt_pirr", "kind": "Fact", "begin": 29, "end": 32}, {"name": "Zring", "kind": "Fact", "begin": 33, "end": 36}, {"name": "Z_pos_or_neg", "kind": "Definition", "begin": 40, "end": 43}, {"name": "Z_coprime", "kind": "Fact", "begin": 44, "end": 76}, {"name": "Zp_inj", "kind": "Fact", "begin": 82, "end": 85}, {"name": "Zp_plus", "kind": "Definition", "begin": 86, "end": 91}, {"name": "Zp_zero", "kind": "Definition", "begin": 93, "end": 96}, {"name": "Zp_opp", "kind": "Definition", "begin": 97, "end": 102}, {"name": "Zp_mult", "kind": "Definition", "begin": 104, "end": 109}, {"name": "Zp_one", "kind": "Definition", "begin": 111, "end": 114}, {"name": "Zp_plus_zero", "kind": "Fact", "begin": 117, "end": 121}, {"name": "Zp_plus_comm", "kind": "Fact", "begin": 122, "end": 126}, {"name": "Zp_plus_assoc", "kind": "Fact", "begin": 127, "end": 132}, {"name": "Zp_minus", "kind": "Fact", "begin": 133, "end": 142}, {"name": "Zp_mult_one", "kind": "Fact", "begin": 143, "end": 155}, {"name": "Zp_mult_comm", "kind": "Fact", "begin": 156, "end": 160}, {"name": "Zp_mult_one_r", "kind": "Fact", "begin": 161, "end": 164}, {"name": "Zp_mult_assoc", "kind": "Fact", "begin": 165, "end": 170}, {"name": "Zp_mult_plus_distr_l", "kind": "Fact", "begin": 171, "end": 175}, {"name": "Zp_mult_plus_distr_r", "kind": "Fact", "begin": 176, "end": 179}, {"name": "Zp_is_ring", "kind": "Definition", "begin": 180, "end": 201}, {"name": "Zp_mult_invert", "kind": "Fact", "begin": 202, "end": 216}, {"name": "Zp_mult_revert", "kind": "Fact", "begin": 217, "end": 235}, {"name": "Zp_invertible_spec", "kind": "Fact", "begin": 237, "end": 244}, {"name": "Zp_prime_invert", "kind": "Fact", "begin": 245, "end": 254}, {"name": "Zp_plus_monoid", "kind": "Fact", "begin": 256, "end": 259}, {"name": "Zp_mult_monoid", "kind": "Fact", "begin": 260, "end": 263}, {"name": "Zp_one_invertible", "kind": "Fact", "begin": 264, "end": 267}, {"name": "Zp_opp_invertible", "kind": "Fact", "begin": 268, "end": 271}, {"name": "Zp_mult_invertible", "kind": "Fact", "begin": 272, "end": 277}, {"name": "Zp_expo_invertible", "kind": "Fact", "begin": 279, "end": 282}, {"name": "Zp_invertible_cancel_l", "kind": "Fact", "begin": 283, "end": 287}, {"name": "Zp_opp_zero", "kind": "Fact", "begin": 288, "end": 291}, {"name": "Zp_plus_inj_l", "kind": "Fact", "begin": 292, "end": 299}, {"name": "Zp_plus_zero_r", "kind": "Fact", "begin": 300, "end": 303}, {"name": "Zp_opp_inv", "kind": "Fact", "begin": 304, "end": 307}, {"name": "Zp_opp_inj", "kind": "Fact", "begin": 308, "end": 311}, {"name": "Zp_opp_plus", "kind": "Fact", "begin": 312, "end": 315}, {"name": "Zp_opp_plus_eq", "kind": "Fact", "begin": 316, "end": 319}, {"name": "Zp_mult_zero", "kind": "Fact", "begin": 320, "end": 323}, {"name": "Zp_mult_minus_one", "kind": "Fact", "begin": 324, "end": 327}, {"name": "Zp_opp_mult", "kind": "Fact", "begin": 328, "end": 331}, {"name": "Zp_invertible_eq_zero", "kind": "Fact", "begin": 332, "end": 337}, {"name": "Zp_zero_is_one", "kind": "Fact", "begin": 338, "end": 347}, {"name": "Zp_eq_dec", "kind": "Fact", "begin": 348, "end": 357}, {"name": "nat2Zp", "kind": "Definition", "begin": 359, "end": 362}, {"name": "nat2Zp_zero", "kind": "Fact", "begin": 365, "end": 369}, {"name": "nat2Zp_one", "kind": "Fact", "begin": 370, "end": 373}, {"name": "nat2Zp_invertible", "kind": "Fact", "begin": 374, "end": 378}, {"name": "nat2Zp_p", "kind": "Fact", "begin": 379, "end": 383}, {"name": "nat2Zp_inj", "kind": "Fact", "begin": 384, "end": 391}, {"name": "nat2Zp_surj", "kind": "Fact", "begin": 392, "end": 397}, {"name": "nat2Zp_plus", "kind": "Fact", "begin": 398, "end": 403}, {"name": "nat2Zp_minus", "kind": "Fact", "begin": 404, "end": 443}, {"name": "nat2Zp_minus_one", "kind": "Fact", "begin": 444, "end": 448}, {"name": "nat2Zp_mult", "kind": "Fact", "begin": 449, "end": 454}, {"name": "nat2Zp_expo", "kind": "Fact", "begin": 455, "end": 463}, {"name": "nat2Zp_divides", "kind": "Fact", "begin": 464, "end": 469}, {"name": "divides_nat2Zp", "kind": "Fact", "begin": 470, "end": 481}, {"name": "Zp_list_spec", "kind": "Fact", "begin": 485, "end": 490}, {"name": "Zp_list_length", "kind": "Fact", "begin": 491, "end": 494}, {"name": "Zp_invertible_prime", "kind": "Fact", "begin": 495, "end": 511}, {"name": "Zp_prime_integral", "kind": "Fact", "begin": 512, "end": 517}, {"name": "Zp_prime_square_eq_square", "kind": "Fact", "begin": 518, "end": 531}, {"name": "Zp_prime_square_one", "kind": "Fact", "begin": 532, "end": 536}, {"name": "Z2Zp", "kind": "Definition", "begin": 540, "end": 547}, {"name": "Z2Zp_pos", "kind": "Fact", "begin": 551, "end": 556}, {"name": "Z2Zp_of_nat", "kind": "Fact", "begin": 557, "end": 561}, {"name": "Z2Zp_zero", "kind": "Fact", "begin": 562, "end": 566}, {"name": "Z2Zp_neg", "kind": "Fact", "begin": 567, "end": 577}, {"name": "Z2Zp_plus_loc", "kind": "Let", "begin": 579, "end": 592}, {"name": "Z2Zp_plus_loc'", "kind": "Let", "begin": 593, "end": 607}, {"name": "Z2Zp_plus", "kind": "Fact", "begin": 608, "end": 634}, {"name": "Z2Zp_opp", "kind": "Fact", "begin": 636, "end": 641}, {"name": "Z2Zp_minus", "kind": "Fact", "begin": 642, "end": 647}, {"name": "Z2Zp_canon_pos", "kind": "Let", "begin": 649, "end": 662}, {"name": "Z2Zp_canon_neg", "kind": "Let", "begin": 663, "end": 686}, {"name": "Z2Zp_repr_canon", "kind": "Fact", "begin": 687, "end": 691}, {"name": "Zp_repr_interval", "kind": "Fact", "begin": 693, "end": 699}, {"name": "Z2Zp_mult_loc", "kind": "Let", "begin": 701, "end": 708}, {"name": "Z2Zp_mult", "kind": "Fact", "begin": 709, "end": 729}, {"name": "Z2Zp_one", "kind": "Fact", "begin": 731, "end": 735}, {"name": "Z2Zp_inj_loc", "kind": "Let", "begin": 737, "end": 755}, {"name": "Z2Zp_inj", "kind": "Fact", "begin": 756, "end": 775}, {"name": "Z2Zp_zero_inv", "kind": "Fact", "begin": 777, "end": 784}, {"name": "nat2Zp_choose", "kind": "Fact", "begin": 785, "end": 802}, {"name": "nat2Zp_invertible_prime", "kind": "Fact", "begin": 805, "end": 817}, {"name": "Hp''", "kind": "Let", "begin": 818, "end": 821}, {"name": "Hzero_one", "kind": "Let", "begin": 822, "end": 827}, {"name": "Zp_invertible_factorial", "kind": "Fact", "begin": 828, "end": 839}, {"name": "Zp_invert_full", "kind": "Let", "begin": 841, "end": 849}, {"name": "Zp_invert_spec1", "kind": "Fact", "begin": 851, "end": 854}, {"name": "Zp_invert_spec2", "kind": "Fact", "begin": 855, "end": 858}, {"name": "Zp_invert_eq_not_zero", "kind": "Fact", "begin": 861, "end": 872}, {"name": "Zp_invert_opp", "kind": "Fact", "begin": 873, "end": 886}, {"name": "Zp_invert_one", "kind": "Fact", "begin": 887, "end": 891}, {"name": "Zp_invert_minus_one", "kind": "Fact", "begin": 892, "end": 895}, {"name": "Zp_invert_fix", "kind": "Fact", "begin": 896, "end": 918}, {"name": "Zp_invert_involutive", "kind": "Fact", "begin": 919, "end": 933}, {"name": "Zp_invert_not_fix", "kind": "Fact", "begin": 934, "end": 951}, {"name": "Zp_invert_stable", "kind": "Fact", "begin": 952, "end": 966}, {"name": "Zp_lprod_nil", "kind": "Fact", "begin": 968, "end": 971}, {"name": "Zp_lprod_cons", "kind": "Fact", "begin": 972, "end": 975}, {"name": "Zp_lprod_app", "kind": "Fact", "begin": 976, "end": 984}, {"name": "Zp_mult_autoinv", "kind": "Theorem", "begin": 985, "end": 1041}, {"name": "Zp_lprod_fact", "kind": "Fact", "begin": 1042, "end": 1058}, {"name": "Wilson_thm_1", "kind": "Theorem", "begin": 1059, "end": 1103}, {"name": "Zp_divides_and_invertible", "kind": "Fact", "begin": 1105, "end": 1109}, {"name": "divides_not_0_interval", "kind": "Fact", "begin": 1112, "end": 1115}, {"name": "divides_fact_lt", "kind": "Fact", "begin": 1116, "end": 1128}, {"name": "Wilson_theorem", "kind": "Theorem", "begin": 1129, "end": 1149}, {"name": "Z2Zp_morphishm", "kind": "Fact", "begin": 1152, "end": 1165}]}