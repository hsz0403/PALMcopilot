{"code": ["Require Import Arith ZArith Lia List.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list gcd prime php utils_nat.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.H10.Dio Require Import dio_logic dio_single.", "From Undecidability.H10.ArithLibs Require Import Zp lagrange.", "Set Implicit Arguments.", "Section diophantine_polynomial.", "Variable (V P : Set).", "Inductive dio_polynomial : Set := | dp_cnst : Z -> dio_polynomial (* integer constant *) | dp_var : V -> dio_polynomial (* existentially quantified variable *) | dp_par : P -> dio_polynomial (* parameter *) | dp_comp : dio_op -> dio_polynomial -> dio_polynomial -> dio_polynomial.", "Notation dp_add := (dp_comp do_add).", "Notation dp_mul := (dp_comp do_mul).", "Fixpoint dp_var_list p := match p with | dp_cnst _ => nil | dp_var v => v::nil | dp_par _ => nil | dp_comp _ p q => dp_var_list p ++ dp_var_list q end.", "Fixpoint dp_par_list p := match p with | dp_cnst _ => nil | dp_var _ => nil | dp_par x => x::nil | dp_comp _ p q => dp_par_list p ++ dp_par_list q end.", "Fixpoint dp_eval \u03c6 \u03bd p := match p with | dp_cnst n => n | dp_var v => \u03c6 v | dp_par i => \u03bd i | dp_comp do_add p q => dp_eval \u03c6 \u03bd p + dp_eval \u03c6 \u03bd q | dp_comp do_mul p q => dp_eval \u03c6 \u03bd p * dp_eval \u03c6 \u03bd q end % Z.", "Fact dp_eval_ext \u03c6 \u03bd \u03c6' \u03bd' p : (forall v, In v (dp_var_list p) -> \u03c6 v = \u03c6' v) -> (forall i, In i (dp_par_list p) -> \u03bd i = \u03bd' i) -> dp_eval \u03c6 \u03bd p = dp_eval \u03c6' \u03bd' p.", "Proof.", "induction p as [ | | | [] p Hp q Hq ]; simpl; intros H1 H2; f_equal; auto; ((apply Hp || apply Hq); intros; [ apply H1 | apply H2 ]; apply in_or_app; auto).", "Qed.", "Fact dp_eval_fix_add \u03c6 \u03bd p q : dp_eval \u03c6 \u03bd (dp_add p q) = (dp_eval \u03c6 \u03bd p + dp_eval \u03c6 \u03bd q) % Z.", "Proof.", "trivial.", "Qed.", "Fact dp_eval_fix_mul \u03c6 \u03bd p q : dp_eval \u03c6 \u03bd (dp_mul p q) = (dp_eval \u03c6 \u03bd p * dp_eval \u03c6 \u03bd q) % Z.", "Proof.", "trivial.", "Qed.", "Fixpoint dp_size p := match p with | dp_cnst n => 1 | dp_var v => 1 | dp_par i => 1 | dp_comp _ p q => 1 + dp_size p + dp_size q end.", "Fact dp_size_fix_comp o p q : dp_size (dp_comp o p q) = 1 + dp_size p + dp_size q.", "Proof.", "auto.", "Qed.", "Definition dio_single := (dio_polynomial * dio_polynomial)%type.", "Definition dio_single_size (e : dio_single) := dp_size (fst e) + dp_size (snd e).", "Definition dio_single_pred e \u03bd := exists \u03c6, dp_eval \u03c6 \u03bd (fst e) = dp_eval \u03c6 \u03bd (snd e).", "End diophantine_polynomial.", "Arguments dp_cnst {V P}.", "Arguments dp_var {V P}.", "Arguments dp_par {V P}.", "Arguments dp_comp {V P}.", "Notation dp_add := (dp_comp do_add).", "Notation dp_mul := (dp_comp do_mul).", "Definition H10Z_PROBLEM := { n : nat & dio_polynomial (pos n) (pos 0) }.", "Definition H10Z : H10Z_PROBLEM -> Prop.", "Proof.", "intros (n & p).", "exact (exists \u03a6, dp_eval \u03a6 (fun _ => 0%Z) p = 0%Z).", "Defined."], "theorems": [{"name": "dp_eval_ext", "kind": "Fact", "begin": 14, "end": 17}, {"name": "dp_eval_fix_add", "kind": "Fact", "begin": 18, "end": 21}, {"name": "dp_eval_fix_mul", "kind": "Fact", "begin": 22, "end": 25}, {"name": "dp_size_fix_comp", "kind": "Fact", "begin": 27, "end": 30}, {"name": "H10Z", "kind": "Definition", "begin": 42, "end": 46}]}