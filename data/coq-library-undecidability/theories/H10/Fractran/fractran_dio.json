{"code": ["Require Import List Arith.", "From Undecidability.Shared.Libs Require Import utils_tac utils_list sums rel_iter gcd pos vec.", "From Undecidability.FRACTRAN Require Import FRACTRAN fractran_utils prime_seq.", "From Undecidability.H10.Dio Require Import dio_logic dio_bounded dio_rt_closure dio_single.", "Set Implicit Arguments.", "Set Default Proof Using \"Type\".", "Section fractran_dio.", "Notation \"l /F/ x \u2192 y\" := (fractran_step l x y) (at level 70, no associativity).", "Lemma dio_rel_fractran_step l x y : \ud835\udd3bF x -> \ud835\udd3bF y -> \ud835\udd3bR (fun \u03bd => l /F/ x \u03bd \u2192 y \u03bd).", "Proof.", "intros Hx Hy.", "induction l as [ | (p,q) l IHl ].", "+", "by dio equiv (fun _ => False).", "abstract (intros v; rewrite fractran_step_nil_inv; split; tauto).", "+", "dio by lemma (fun v => fractran_step_cons_inv p q l (x v) (y v)).", "Defined.", "Hint Resolve dio_rel_fractran_step : dio_rel_db.", "Corollary dio_rel_fractran_rt l x y : \ud835\udd3bF x -> \ud835\udd3bF y -> \ud835\udd3bR (fun \u03bd => fractran_compute l (x \u03bd) (y \u03bd)).", "Proof.", "intros; apply dio_rel_rt; dio auto.", "Defined.", "Lemma dio_rel_fractran_stop l x : \ud835\udd3bF x -> \ud835\udd3bR (fun \u03bd => fractran_stop l (x \u03bd)).", "Proof.", "intros Hx.", "induction l as [ | (p,q) l IHl ].", "+", "by dio equiv (fun _ => True).", "abstract(intro v; split; auto; intros _ ?; rewrite fractran_step_nil_inv; auto).", "+", "dio by lemma (fun v => fractan_stop_cons_inv p q l (x v)).", "Defined.", "Hint Resolve dio_rel_fractran_rt dio_rel_fractran_stop : dio_rel_db.", "Theorem FRACTRAN_HALTING_on_diophantine ll x : \ud835\udd3bF x -> \ud835\udd3bR (fun \u03bd => FRACTRAN_HALTING (ll,x \u03bd)).", "Proof.", "intros; dio auto.", "Defined.", "End fractran_dio.", "Corollary FRACTRAN_HALTING_diophantine_0 ll : \ud835\udd3bR (fun \u03bd => FRACTRAN_HALTING (ll,\u03bd 0)).", "Proof.", "intros; apply FRACTRAN_HALTING_on_diophantine; dio auto.", "Defined.", "Corollary FRACTRAN_HALTING_diophantine l x : \ud835\udd3bR (fun _ => FRACTRAN_HALTING (l,x)).", "Proof.", "apply FRACTRAN_HALTING_on_diophantine; dio auto.", "Defined.", "Section exp_diophantine.", "Notation power := (mscal mult 1).", "Fact power_expo x y : power x y = y^x.", "Proof.", "induction x as [ | x IHx ]; simpl.", "+", "rewrite power_0; auto.", "+", "rewrite power_S; f_equal; auto.", "Qed.", "Let exp_dio n i j : \ud835\udd3bF (fun v => exp i (fun2vec j n v)).", "Proof.", "revert j i; induction n as [ | n IHn ]; intros j i.", "+", "simpl; dio auto.", "+", "by dio equiv (fun v => power (v j) (qs i) * exp (S i) (fun2vec (S j) n v)).", "abstract (intros v; simpl fun2vec; rewrite exp_cons, power_expo; auto).", "Defined.", "Fact fractran_exp_diophantine n : \ud835\udd3bF (fun \u03bd => ps 1 * exp 1 (fun2vec 0 n \u03bd)).", "Proof.", "dio auto.", "Defined.", "End exp_diophantine.", "Hint Resolve fractran_exp_diophantine : dio_fun_db.", "Theorem FRACTRAN_HALTING_on_exp_diophantine n l : \ud835\udd3bR (fun \u03bd => l /F/ ps 1 * exp 1 (fun2vec 0 n \u03bd) \u2193).", "Proof.", "apply dio_rel_compose with (R := fun x v => l /F/ x \u2193); [ dio auto | ].", "apply FRACTRAN_HALTING_on_diophantine; dio auto.", "Qed.", "Theorem FRACTRAN_HALTING_dio_single E l x : { e : dio_single nat E | l /F/ x \u2193 <-> dio_single_pred e (fun _ => 0) }.", "Proof.", "generalize (@FRACTRAN_HALTING_on_diophantine l (fun _ => x)); intros H1.", "spec in H1; dio_rel_auto.", "destruct dio_rel_single with (1 := H1) as ((p,q) & He).", "unfold FRACTRAN_HALTING in He.", "exists (dp_inst_par E (fun _ => 0) p, dp_inst_par E (fun _ => 0) q).", "rewrite He with (\u03bd := fun _ => 0).", "unfold dio_single_pred; simpl.", "split; intros (phi & Hphi); exists phi; revert Hphi; repeat rewrite dp_inst_par_eval; auto.", "Qed."], "theorems": [{"name": "dio_rel_fractran_step", "kind": "Lemma", "begin": 8, "end": 17}, {"name": "dio_rel_fractran_rt", "kind": "Corollary", "begin": 19, "end": 22}, {"name": "dio_rel_fractran_stop", "kind": "Lemma", "begin": 23, "end": 32}, {"name": "FRACTRAN_HALTING_on_diophantine", "kind": "Theorem", "begin": 34, "end": 37}, {"name": "FRACTRAN_HALTING_diophantine_0", "kind": "Corollary", "begin": 39, "end": 42}, {"name": "FRACTRAN_HALTING_diophantine", "kind": "Corollary", "begin": 43, "end": 46}, {"name": "power_expo", "kind": "Fact", "begin": 49, "end": 56}, {"name": "exp_dio", "kind": "Let", "begin": 57, "end": 65}, {"name": "fractran_exp_diophantine", "kind": "Fact", "begin": 66, "end": 69}, {"name": "FRACTRAN_HALTING_on_exp_diophantine", "kind": "Theorem", "begin": 72, "end": 76}, {"name": "FRACTRAN_HALTING_dio_single", "kind": "Theorem", "begin": 77, "end": 87}]}