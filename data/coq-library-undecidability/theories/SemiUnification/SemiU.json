{"code": ["Require Import List.", "Inductive term : Set := | atom : nat -> term | arr : term -> term -> term.", "Definition valuation : Set := nat -> term.", "Fixpoint substitute (f: valuation) (t: term) : term := match t with | atom n => f n | arr s t => arr (substitute f s) (substitute f t) end.", "Definition constraint : Set := ((bool * nat) * (nat * bool)).", "Definition models (\u03c6 \u03c80 \u03c81: valuation) : constraint -> Prop := fun '((a, x), (y, b)) => match \u03c6 y with | atom _ => False | arr s t => (if b then t else s) = substitute (if a then \u03c81 else \u03c80) (\u03c6 x) end.", "Definition SSemiU (p : list constraint) := exists (\u03c6 \u03c80 \u03c81: valuation), forall (c : constraint), In c p -> models \u03c6 \u03c80 \u03c81 c.", "Definition inequality : Set := (term * term).", "Definition solution (\u03c6 : valuation) : inequality -> Prop := fun '(s, t) => exists (\u03c8 : valuation), substitute \u03c8 (substitute \u03c6 s) = substitute \u03c6 t.", "Definition SemiU (p: list inequality) := exists (\u03c6: valuation), forall (c: inequality), In c p -> solution \u03c6 c.", "Definition RU2SemiU : term * term * term -> Prop := fun '(s0, s1, t) => exists (\u03c6 \u03c80 \u03c81: valuation), substitute \u03c80 (substitute \u03c6 s0) = substitute \u03c6 t /\\ substitute \u03c81 (substitute \u03c6 s1) = substitute \u03c6 t.", "Definition LU2SemiU : term * term * term -> Prop := fun '(s, t0, t1) => exists (\u03c6 \u03c80 \u03c81: valuation), substitute \u03c80 (substitute \u03c6 s) = substitute \u03c6 t0 /\\ substitute \u03c81 (substitute \u03c6 s) = substitute \u03c6 t1."], "theorems": []}