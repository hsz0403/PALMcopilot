{"code": ["Require Import List.", "Require Import Undecidability.SemiUnification.SemiU.", "From Undecidability.SemiUnification.Util Require Import Facts Enumerable.", "Require Import ssreflect ssrfun ssrbool.", "Set Default Proof Using \"Type\".", "Set Default Goal Selector \"!\".", "Module Argument.", "Definition embed_var (x: nat) := atom (to_nat (x, 0)).", "Definition \u03c1 (i a b: bool) (x y: nat) := match i, a, b with | false, true, _ => atom (to_nat (y, 1)) | true, false, _ => atom (to_nat (y, 1)) | _, _, false => arr (embed_var x) (atom (to_nat (y, 2))) | _, _, true => arr (atom (to_nat (y, 3))) (embed_var x) end.", "Definition \u03c3 (i: bool) (p: list constraint) : term := fold_right (fun '((a, x), (y, b)) s => arr (\u03c1 i a b x y) s) (atom (to_nat (0, 4))) p.", "Definition \u03c4 (p: list constraint) : term := fold_right (fun '((a, x), (y, b)) t => arr (embed_var y) t) (atom (to_nat (0, 4))) p.", "Definition src (t: term) := if t is arr s t then s else atom 0.", "Definition tgt (t: term) := if t is arr s t then t else atom 0.", "Definition \u03c6 (\u03c6' : valuation) : valuation := fun x => match of_nat x with | (x, 0) => substitute embed_var (\u03c6' x) | _ => atom x end.", "Definition \u03c8 (\u03c6' \u03c8' : valuation) : valuation := fun x => match of_nat x with | (x, 0) => substitute embed_var (\u03c8' x) | (x, 1) => substitute embed_var (\u03c6' x) | (x, 2) => substitute embed_var (tgt (\u03c6' x)) | (x, 3) => substitute embed_var (src (\u03c6' x)) | _ => atom x end.", "Lemma substitute_\u03c8P {\u03c6' \u03c8': valuation} {t: term} : substitute (\u03c8 \u03c6' \u03c8') (substitute embed_var t) = substitute embed_var (substitute \u03c8' t).", "Proof.", "elim: t => [x | *] /=; [by rewrite /\u03c8 ?enumP | by f_equal].", "Qed.", "Lemma transport {p: list constraint} : SSemiU p -> RU2SemiU (\u03c3 false p, \u03c3 true p, \u03c4 p).", "Proof.", "move=> [\u03c6'] [\u03c80'] [\u03c81'] /Forall_forall Hp.", "exists (\u03c6 \u03c6'), (\u03c8 \u03c6' \u03c80'), (\u03c8 \u03c6' \u03c81').", "suff: forall i, substitute (\u03c8 \u03c6' (if i then \u03c81' else \u03c80')) (substitute (\u03c6 \u03c6') (\u03c3 i p)) = substitute (\u03c6 \u03c6') (\u03c4 p) by (move=> H; rewrite (H false) (H true)).", "move=> i.", "elim: p Hp.", "-", "by move: i => [|] _ /=; rewrite /\u03c6 ?enumP /= /\u03c8 ?enumP /=.", "-", "move=> [[a x] [y b]] p IH /=.", "rewrite Forall_norm /=.", "move => [+ /IH <-].", "move H\u03c6'y: (\u03c6' y) => \u03c6'y.", "case: \u03c6'y H\u03c6'y; first done.", "move=> s t H\u03c6'y Hst {IH}.", "move: i a b Hst H\u03c6'y => [|] [|] [|] -> H\u03c6'y; by rewrite /= /\u03c6 ?enumP /= /\u03c8 ?enumP /= H\u03c6'y ?substitute_\u03c8P.", "Qed.", "Lemma reflection {p: list constraint} : RU2SemiU (\u03c3 false p, \u03c3 true p, \u03c4 p) -> SSemiU p.", "Proof.", "move=> [\u03c6] [\u03c80] [\u03c81] [H\u03c80 H\u03c81].", "exists (fun x => \u03c6 (to_nat (x, 0))), \u03c80, \u03c81.", "rewrite -Forall_forall.", "elim: p H\u03c80 H\u03c81; first done.", "move=> [[a x] [y b]] p IH /= [H\u03c80 ?] [H\u03c81 ?].", "rewrite Forall_norm /=.", "constructor; [| by apply: IH].", "by move: a H\u03c80 H\u03c81 => [_ <-| <- _]; move: b => [|].", "Qed.", "End Argument.", "Require Import Undecidability.Synthetic.Definitions.", "Theorem reduction : SSemiU \u2aaf RU2SemiU.", "Proof.", "exists (fun p => (Argument.\u03c3 false p, Argument.\u03c3 true p, Argument.\u03c4 p)).", "intro p.", "constructor.", "-", "exact Argument.transport.", "-", "exact Argument.reflection.", "Qed."], "theorems": [{"name": "substitute_\u03c8P", "kind": "Lemma", "begin": 15, "end": 18}, {"name": "transport", "kind": "Lemma", "begin": 19, "end": 36}, {"name": "reflection", "kind": "Lemma", "begin": 37, "end": 47}, {"name": "reduction", "kind": "Theorem", "begin": 50, "end": 59}]}