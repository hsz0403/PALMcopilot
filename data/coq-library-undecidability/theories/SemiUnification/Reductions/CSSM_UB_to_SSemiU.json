{"code": ["Require Import List PeanoNat Lia.", "Import ListNotations.", "Require Import Relations.Relation_Operators Relations.Operators_Properties.", "From Undecidability.StackMachines Require Import SSM.", "From Undecidability.StackMachines.Util Require Import CSSM_facts.", "Require Import Undecidability.SemiUnification.SemiU.", "From Undecidability.SemiUnification.Util Require Import Facts Enumerable.", "Require Import ssreflect ssrfun ssrbool.", "Set Default Proof Using \"Type\".", "Set Default Goal Selector \"!\".", "Module Argument.", "Definition embed : config -> nat := to_nat.", "Definition unembed : nat -> config := of_nat.", "Definition embedP {X: config} : (unembed (embed X) = X) := enumP.", "Definition SM_to_SUcs (M: ssm) : list constraint := map (fun '(x, y, a, b, d) => if d then ((a, embed ([], [], x)), (embed ([], [], y), b)) (* ax -> yb *) else ((b, embed ([], [], y)), (embed ([], [], x), a)) (* xa -> by *) ) M.", "Lemma arr_eqI {s t: bool -> term} : (forall (a: bool), s a = t a) -> arr (s false) (s true) = arr (t false) (t true).", "Proof.", "move=> H.", "by rewrite ? H.", "Qed.", "Section SM.", "Context {M : ssm}.", "Variable confluent_M : confluent M.", "Notation equiv := (@equiv M).", "Notation equiv_dec := (@equiv_dec M).", "Notation narrow_dec := (@narrow_dec M).", "Notation bounded' := (@bounded' M).", "Fixpoint nf_aux (i: nat) (X: config) : config := match i with | 0 => X | S i => if equiv_dec (unembed i) X then nf_aux i (unembed i) else nf_aux i X end.", "Definition nf (X: config) : config := nf_aux (embed X) X.", "Lemma nf_equiv (X: config) : equiv X (nf X).", "Proof using confluent_M.", "rewrite /nf.", "move: (embed X) => i.", "elim: i X.", "{", "move=> X /=.", "by apply: equiv_refl.", "}", "move=> i IH X /=.", "case: (equiv_dec (unembed i) X).", "{", "move=> /equiv_sym H /=.", "apply: (equiv_trans confluent_M H).", "by apply: IH.", "}", "move=> /= _.", "by apply: IH.", "Qed.", "Lemma nf_equiv_eq_ind (X Y: config) (j: nat) : equiv X Y -> embed X < j -> nf_aux j Y = nf_aux (embed X) X.", "Proof using confluent_M.", "elim: j X Y; first by lia.", "move=> i IH X Y HXY HXi /=.", "case: (equiv_dec (unembed i) Y)=> /=.", "{", "move=> /equiv_sym HYi.", "have [/copy [/(f_equal unembed) + ->] | ?]: (embed X = i \\/ embed X < i) by lia.", "-", "rewrite embedP.", "by move=> ->.", "-", "apply: IH; [ apply: equiv_trans; by eassumption | done].", "}", "move=> HiY.", "have [/(f_equal unembed) | ?]: (embed X = i \\/ embed X < i) by lia.", "-", "rewrite embedP.", "move=> ?.", "by subst X.", "-", "by apply: IH.", "Qed.", "Lemma nf_equiv_eq (X Y: config) : equiv X Y -> nf X = nf Y.", "Proof using confluent_M.", "have: (embed X = embed Y \\/ embed X < embed Y \\/ embed Y < embed X) by lia.", "case; [|case].", "-", "move /(f_equal unembed).", "rewrite ? embedP.", "by move=> ->.", "-", "move=> + H.", "move /nf_equiv_eq_ind.", "by move /(_ _ H).", "-", "move=> + /equiv_sym H.", "move /nf_equiv_eq_ind.", "by move /(_ _ H).", "Qed.", "Fixpoint \u03b6 (n: nat) (X: config) : term := match n with | 0 => atom (embed (nf X)) | S n => match X with | (A, B, x) => if narrow_dec (A, B, x) then arr (\u03b6 n (A, B++[false], x)) (\u03b6 n (A, B++[true], x)) else atom (embed (nf X)) end end.", "Definition \u03c8 (a: bool) (n: nat) (i: nat): term := match unembed i with | (A, B, x) => \u03b6 (n - length B) (A++[a], B, x) end.", "Lemma \u03b6_nilP {n: nat} {x: state} : \u03b6 (S n) ([], [], x) = arr (\u03b6 n ([], [false], x)) (\u03b6 n ([], [true], x)).", "Proof.", "move=> /=.", "case: (narrow_dec ([], [], x)); first done.", "move=> H.", "exfalso.", "apply: H.", "exists x, [].", "by apply: equiv_refl.", "Qed.", "Lemma \u03b6_0P {X: config} : \u03b6 0 X = atom (embed (nf X)).", "Proof.", "done.", "Qed.", "Lemma \u03b6_SnP {n: nat} {x: state} {A B: stack} : \u03b6 (S n) (A, B, x) = if narrow_dec (A, B, x) then arr (\u03b6 n (A, B++[false], x)) (\u03b6 n (A, B++[true], x)) else atom (embed (nf (A, B, x))).", "Proof.", "done.", "Qed.", "Lemma SM_to_SUcsP {x y: state} {a b: symbol} : In (a, x, (y, b)) (SM_to_SUcs M) -> exists x' y', x = (embed ([], [], x')) /\\ y = (embed ([], [], y')) /\\ equiv ([a], [], x') ([], [b], y').", "Proof.", "rewrite /SM_to_SUcs in_map_iff.", "move=> [[[[[x' y'] a'] b'] d]].", "case: d.", "-", "case.", "case=> <- <- <- <- H.", "exists x', y'.", "constructor; first done.", "constructor; first done.", "exists ([], [b'], y').", "constructor; [apply: rt_step; by apply: step_l | by apply: rt_refl].", "-", "case.", "case=> <- <- <- <- H.", "exists y', x'.", "constructor; first done.", "constructor; first done.", "exists ([b'], [], y').", "constructor; [by apply: rt_refl | apply: rt_step; by apply: step_r].", "Qed.", "Lemma \u03b6_equivP {n: nat} {x x': state} {A B A' B': stack} : bounded' n -> equiv (A, B, x) (A', B', x') -> \u03b6 (S n - length B) (A, B, x) = \u03b6 (S n - length B') (A', B', x').", "Proof using confluent_M.", "move /(extend_bounded' confluent_M) => Hn.", "move Hm: (S n - length B)=> m.", "elim: m A B A' B' Hm.", "-", "move=> A B A' B' HnB Hxx'.", "have [-> | HnB']: (S n - length B' = 0 \\/ S n - length B' = (S (n - length B'))) by lia.", "{", "rewrite ? \u03b6_0P.", "do 2 f_equal.", "by apply: nf_equiv_eq.", "}", "rewrite HnB' \u03b6_0P \u03b6_SnP.", "case: (narrow_dec (A', B', x')) => /=; first last.", "{", "move=> _.", "do 2 f_equal.", "by apply: nf_equiv_eq.", "}", "move /equiv_sym in Hxx'.", "move /(narrow_equiv confluent_M Hxx') /Hn => /=.", "by lia.", "-", "move=> m IH A B A' B' Hm Hxx'.", "have [HnB' | ->]: (S n - length B' = 0 \\/ S n - length B' = S (n - length B')) by lia.", "{", "rewrite HnB' \u03b6_0P \u03b6_SnP.", "case: (narrow_dec (A, B, x)) => /=; first last.", "-", "move=> _.", "do 2 f_equal.", "by apply: nf_equiv_eq.", "-", "move /(narrow_equiv confluent_M Hxx') /Hn => /=.", "by lia.", "}", "rewrite ?\u03b6_SnP.", "case: (narrow_dec (A, B, x)); case: (narrow_dec (A', B', x'))=> /=.", "+", "move=> _ _.", "apply: (arr_eqI (s := fun=> \u03b6 _ _) (t := fun=> \u03b6 _ _)).", "move=> b.", "have -> : n - length B' = S n - length (B' ++ [b]) by (rewrite app_length /length; lia).", "apply: IH; [ rewrite app_length /length -/(length _); by lia | by apply: equiv_appR].", "+", "by move=> + /(narrow_equiv confluent_M Hxx').", "+", "by move=> /(narrow_equiv confluent_M ((iffLR equiv_sym) Hxx')).", "+", "move=> _ _.", "do 2 f_equal.", "by apply: nf_equiv_eq.", "Qed.", "Lemma \u03c8P {a: bool} {n: nat} {X: config} : \u03c8 a n (embed X) = match X with | (A, B, x) => \u03b6 (n - length B) (A++[a], B, x) end.", "Proof.", "by rewrite /\u03c8 embedP.", "Qed.", "Lemma \u03c8\u03b6P {n: nat} {x: state} {A B: stack} {a: bool} : bounded' n -> \u03b6 (S n - length B) (A ++ [a], B, x) = substitute (\u03c8 a (S n)) (\u03b6 (S n - length B) (A, B, x)).", "Proof using confluent_M.", "move=> Hn.", "move Hm: (S n - length B)=> m.", "elim: m x A B Hm.", "-", "move=> x A B Hm.", "rewrite ? \u03b6_0P /= \u03c8P.", "move HAxB: (nf (A, B, x)) => [[A' B'] x'].", "have [-> | ?]: S n - length B' = 0 \\/ S n - length B' > 0 by lia.", "{", "rewrite \u03b6_0P.", "f_equal.", "f_equal.", "apply: nf_equiv_eq.", "apply: equiv_appL.", "rewrite -HAxB.", "by apply: nf_equiv.", "}", "have Hxx': equiv (A' ++ [a], B', x') (A ++ [a], B, x).", "{", "apply: equiv_appL.", "rewrite equiv_sym -HAxB.", "by apply: nf_equiv.", "}", "by rewrite (\u03b6_equivP Hn Hxx') Hm \u03b6_0P.", "-", "move=> m IH x A B Hm.", "rewrite ? \u03b6_SnP.", "case: (narrow_dec (A, B, x)).", "+", "move=> /= /(narrow_appL (a := a)) => ?.", "case: (narrow_dec (A ++ [a], B, x)); last done.", "move=> _ /=.", "apply: (arr_eqI (s := fun => \u03b6 _ _) (t := fun => substitute _ _)).", "move=> b.", "apply: IH.", "rewrite app_length /length -/(length _).", "by lia.", "+", "move=> _ /=.", "rewrite -(\u03b6_SnP (A := A ++ [a])).", "rewrite \u03c8P.", "move HAxB: (nf (A, B, x)) => [[A' B'] x'].", "rewrite -Hm.", "have Hxx': equiv (A ++ [a], B, x) (A' ++ [a], B', x').", "{", "apply: equiv_appL.", "rewrite -HAxB.", "by apply: nf_equiv.", "}", "by rewrite (\u03b6_equivP Hn Hxx').", "Qed.", "End SM.", "Lemma soundness {M: cssm} : CSSM_UB M -> SSemiU (SM_to_SUcs (proj1_sig M)).", "Proof.", "Opaque \u03b6 \u03c8.", "case: M=> M confluent_M.", "rewrite /CSSM_UB /SSemiU.", "move /(boundedP confluent_M) => /= [n HnM].", "exists (fun i => @\u03b6 M (S n) (unembed i)), (@\u03c8 M false (S n)), (@\u03c8 M true (S n)).", "move=> [[a x]] => [[y b]] /=.", "move /SM_to_SUcsP => [x' [y' [-> [->]]]] /equiv_sym Hxy.", "rewrite ?embedP \u03b6_nilP (itebP (P := fun _ => \u03b6 _ _)).", "have /= := \u03b6_equivP confluent_M HnM Hxy.", "have ->: n - 0 = n by lia.", "move=> ->.", "rewrite (itebP (P := fun=> \u03c8 _ _)).", "by apply: (\u03c8\u03b6P _ HnM (A := []) (B := [])).", "Qed.", "Fixpoint term_depth_bound (t: term) : nat := match t with | atom _ => 1 | arr s t => 1 + (term_depth_bound s) + (term_depth_bound t) end.", "Fixpoint depth_bound (\u03c6: valuation) (xs: list state) : nat := match xs with | [] => 1 | x :: xs => 1 + term_depth_bound (\u03c6 x) + depth_bound \u03c6 xs end.", "Lemma depth_boundP {\u03c6: valuation} {x: state} {xs: list state} : In x xs -> term_depth_bound (\u03c6 x) <= depth_bound \u03c6 xs.", "Proof.", "elim: xs; first done.", "move=> y xs IH /= [-> | /IH]; by lia.", "Qed.", "Fixpoint descend (t: term) (B: stack) {struct B} : option term := match B with | [] => Some t | b :: B => match t with | atom _ => None | arr s t => descend (if b then t else s) B end end.", "Fixpoint ascend (\u03c80 \u03c81: valuation) (t: term) (A: stack) : term := match A with | [] => t | a :: A => ascend \u03c80 \u03c81 (substitute (if a then \u03c81 else \u03c80) t) A end.", "Lemma ascend_arr {\u03c80 \u03c81: valuation} {s t: term} {A: stack} : ascend \u03c80 \u03c81 (arr s t) A = arr (ascend \u03c80 \u03c81 s A) (ascend \u03c80 \u03c81 t A).", "Proof.", "elim: A s t; first done.", "move=> a A IH s t /=.", "by rewrite IH.", "Qed.", "Definition interpret (\u03c6 \u03c80 \u03c81: valuation) (X: config) : option term := match X with | (A, B, x) => descend (ascend \u03c80 \u03c81 (\u03c6 (embed ([], [], x))) A) B end.", "Lemma interpretP {M: ssm} {X Y: config} {\u03c6 \u03c80 \u03c81: valuation} : Forall (models \u03c6 \u03c80 \u03c81) (SM_to_SUcs M) -> reachable M X Y -> interpret \u03c6 \u03c80 \u03c81 X = interpret \u03c6 \u03c80 \u03c81 Y.", "Proof.", "move=> HM.", "elim; [| done | by move=> > ? ->].", "move=> {}X {}Y [|] x y a b A B.", "-", "move: HM.", "rewrite /SM_to_SUcs Forall_mapP Forall_forall => HM.", "move /HM.", "rewrite /models /interpret.", "case: (\u03c6 (embed ([], [], y))); first done.", "move: a b => [|] [|] ? ? -> /=; by rewrite ascend_arr.", "-", "move: HM.", "rewrite /SM_to_SUcs Forall_mapP Forall_forall => HM.", "move /HM.", "rewrite /models /interpret.", "case: (\u03c6 (embed ([], [], x))); first done.", "move: a b => [|] [|] ? ? -> /=; by rewrite ascend_arr.", "Qed.", "Lemma descendP {s t: term} {B: list symbol} : descend s B = Some t -> length B <= term_depth_bound s.", "Proof.", "elim: B s t; first by (move=> /= *; lia).", "move=> b B IH [ /= | > /IH]; [done | case: b => /=; by lia].", "Qed.", "Lemma completeness {M: cssm}: SSemiU (SM_to_SUcs (proj1_sig M)) -> CSSM_UB M.", "Proof.", "case: M=> M confluent_M /=.", "move=> [\u03c6 [\u03c80 [\u03c81]]].", "rewrite -Forall_forall => H\u03c6.", "pose f x := embed (([], [], x) : config).", "apply: (bounded_of_bounded' confluent_M (n := depth_bound \u03c6 (map f (enum_states M)))).", "move=> /= Z x y A B Hx Hy.", "case: (In_dec _ y (enum_states M)); first by decide equality.", "{", "move=> /(in_map f) /depth_boundP => /(_ \u03c6) Hfy.", "move: Hy => /(interpretP H\u03c6).", "move: Hx => /(interpretP H\u03c6) <- /= /descendP.", "rewrite -/(f y).", "move: (length B) => ?.", "by lia.", "}", "move: (Hy) Hx => /enum_states_reachable [<- /enum_states_reachable | ]; last by by move=> [+].", "case; last by move=> [+].", "case=> *.", "subst=> /=.", "by lia.", "Qed.", "End Argument.", "Require Import Undecidability.Synthetic.Definitions.", "Theorem reduction : CSSM_UB \u2aaf SSemiU.", "Proof.", "exists (fun dM => Argument.SM_to_SUcs (proj1_sig dM)).", "intros [M HM].", "constructor.", "-", "exact Argument.soundness.", "-", "exact Argument.completeness.", "Qed."], "theorems": [{"name": "arr_eqI", "kind": "Lemma", "begin": 15, "end": 19}, {"name": "nf_equiv", "kind": "Lemma", "begin": 29, "end": 47}, {"name": "nf_equiv_eq_ind", "kind": "Lemma", "begin": 48, "end": 70}, {"name": "nf_equiv_eq", "kind": "Lemma", "begin": 71, "end": 87}, {"name": "\u03b6_nilP", "kind": "Lemma", "begin": 90, "end": 99}, {"name": "\u03b6_0P", "kind": "Lemma", "begin": 100, "end": 103}, {"name": "\u03b6_SnP", "kind": "Lemma", "begin": 104, "end": 107}, {"name": "SM_to_SUcsP", "kind": "Lemma", "begin": 108, "end": 129}, {"name": "\u03b6_equivP", "kind": "Lemma", "begin": 130, "end": 183}, {"name": "\u03c8P", "kind": "Lemma", "begin": 184, "end": 187}, {"name": "\u03c8\u03b6P", "kind": "Lemma", "begin": 188, "end": 240}, {"name": "soundness", "kind": "Lemma", "begin": 242, "end": 257}, {"name": "depth_boundP", "kind": "Lemma", "begin": 260, "end": 264}, {"name": "ascend_arr", "kind": "Lemma", "begin": 267, "end": 272}, {"name": "interpretP", "kind": "Lemma", "begin": 274, "end": 293}, {"name": "descendP", "kind": "Lemma", "begin": 294, "end": 298}, {"name": "completeness", "kind": "Lemma", "begin": 299, "end": 321}, {"name": "reduction", "kind": "Theorem", "begin": 324, "end": 333}]}