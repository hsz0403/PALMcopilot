{"code": ["Require Import Undecidability.FOL.Util.Syntax_facts.", "Require Export Undecidability.FOL.Util.FullTarski.", "From Undecidability Require Import Shared.ListAutomation.", "Import ListAutomationNotations.", "Require Import Vector.", "Local Set Implicit Arguments.", "Local Unset Strict Implicit.", "Local Notation vec := Vector.t.", "Section fixb.", "Context {\u03a3_funcs : funcs_signature}.", "Context {\u03a3_preds : preds_signature}.", "Context {ff : falsity_flag}.", "Fixpoint impl (A : list form) phi := match A with | [] => phi | psi :: A => bin Impl psi (impl A phi) end.", "End fixb.", "Notation \"A ==> phi\" := (impl A phi) (right associativity, at level 55).", "Section Tarski.", "Context {\u03a3_funcs : funcs_signature}.", "Context {\u03a3_preds : preds_signature}.", "Section Substs.", "Variable D : Type.", "Variable I : interp D.", "Lemma eval_ext rho xi t : (forall x, rho x = xi x) -> eval rho t = eval xi t.", "Proof.", "intros H.", "induction t; cbn.", "-", "now apply H.", "-", "f_equal.", "apply map_ext_in.", "now apply IH.", "Qed.", "Lemma eval_comp rho xi t : eval rho (subst_term xi t) = eval (xi >> eval rho) t.", "Proof.", "induction t; cbn.", "-", "reflexivity.", "-", "f_equal.", "rewrite map_map.", "apply map_ext_in, IH.", "Qed.", "Lemma sat_ext {ff : falsity_flag} rho xi phi : (forall x, rho x = xi x) -> rho \u22a8 phi <-> xi \u22a8 phi.", "Proof.", "induction phi as [ | b P v | | ] in rho, xi |- *; cbn; intros H.", "-", "reflexivity.", "-", "erewrite map_ext; try reflexivity.", "intros t.", "now apply eval_ext.", "-", "specialize (IHphi1 rho xi).", "specialize (IHphi2 rho xi).", "destruct b0; intuition.", "-", "destruct q.", "+", "split; intros H' d; eapply IHphi; try apply (H' d).", "1,2: intros []; cbn; intuition.", "+", "split; intros [d H']; exists d; eapply IHphi; try apply H'.", "1,2: intros []; cbn; intuition.", "Qed.", "Lemma sat_ext' {ff : falsity_flag} rho xi phi : (forall x, rho x = xi x) -> rho \u22a8 phi -> xi \u22a8 phi.", "Proof.", "intros Hext H.", "rewrite sat_ext.", "exact H.", "intros x.", "now rewrite (Hext x).", "Qed.", "Lemma sat_comp {ff : falsity_flag} rho xi phi : rho \u22a8 (subst_form xi phi) <-> (xi >> eval rho) \u22a8 phi.", "Proof.", "induction phi as [ | b P v | | ] in rho, xi |- *; cbn.", "-", "reflexivity.", "-", "erewrite map_map, map_ext; try reflexivity.", "intros t.", "apply eval_comp.", "-", "specialize (IHphi1 rho xi).", "specialize (IHphi2 rho xi).", "destruct b0; intuition.", "-", "destruct q.", "+", "setoid_rewrite IHphi.", "split; intros H d; eapply sat_ext.", "2, 4: apply (H d).", "all: intros []; cbn; trivial; now setoid_rewrite eval_comp.", "+", "setoid_rewrite IHphi.", "split; intros [d H]; exists d; eapply sat_ext.", "2, 4: apply H.", "all: intros []; cbn; trivial; now setoid_rewrite eval_comp.", "Qed.", "Lemma sat_subst {ff : falsity_flag} rho sigma phi : (forall x, eval rho (sigma x) = rho x) -> rho \u22a8 phi <-> rho \u22a8 (subst_form sigma phi).", "Proof.", "intros H.", "rewrite sat_comp.", "apply sat_ext.", "intros x.", "now rewrite <- H.", "Qed.", "Lemma sat_single {ff : falsity_flag} (rho : nat -> D) (Phi : form) (t : term) : (eval rho t .: rho) \u22a8 Phi <-> rho \u22a8 subst_form (t..) Phi.", "Proof.", "rewrite sat_comp.", "apply sat_ext.", "now intros [].", "Qed.", "Lemma impl_sat {ff : falsity_flag} A rho phi : sat rho (A ==> phi) <-> ((forall psi, psi el A -> sat rho psi) -> sat rho phi).", "Proof.", "induction A; cbn; firstorder congruence.", "Qed.", "Lemma impl_sat' {ff : falsity_flag} A rho phi : sat rho (A ==> phi) -> ((forall psi, psi el A -> sat rho psi) -> sat rho phi).", "Proof.", "eapply impl_sat.", "Qed.", "End Substs.", "End Tarski.", "Section TM.", "Context {\u03a3_funcs : funcs_signature}.", "Context {\u03a3_preds : preds_signature}.", "Instance TM : interp unit := {| i_func := fun _ _ => tt; i_atom := fun _ _ => True; |}.", "Fact TM_sat (rho : nat -> unit) (phi : form falsity_off) : rho \u22a8 phi.", "Proof.", "revert rho.", "remember falsity_off as ff.", "induction phi; cbn; trivial.", "-", "discriminate.", "-", "destruct b0; auto.", "-", "destruct q; firstorder.", "exact tt.", "Qed.", "End TM."], "theorems": [{"name": "eval_ext", "kind": "Lemma", "begin": 21, "end": 31}, {"name": "eval_comp", "kind": "Lemma", "begin": 32, "end": 41}, {"name": "sat_ext", "kind": "Lemma", "begin": 42, "end": 63}, {"name": "sat_ext'", "kind": "Lemma", "begin": 64, "end": 71}, {"name": "sat_comp", "kind": "Lemma", "begin": 72, "end": 97}, {"name": "sat_subst", "kind": "Lemma", "begin": 98, "end": 105}, {"name": "sat_single", "kind": "Lemma", "begin": 106, "end": 111}, {"name": "impl_sat", "kind": "Lemma", "begin": 112, "end": 115}, {"name": "impl_sat'", "kind": "Lemma", "begin": 116, "end": 119}, {"name": "TM_sat", "kind": "Fact", "begin": 126, "end": 138}]}