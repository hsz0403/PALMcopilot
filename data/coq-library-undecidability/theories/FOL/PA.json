{"code": ["Require Import Undecidability.FOL.Util.Syntax.", "Require Import Undecidability.FOL.Util.FullTarski.", "Require Import Undecidability.FOL.Util.FullDeduction.", "Import Vector.VectorNotations.", "Require Import List.", "Existing Instance falsity_on.", "Inductive PA_funcs : Type := Zero : PA_funcs | Succ : PA_funcs | Plus : PA_funcs | Mult : PA_funcs.", "Definition PA_funcs_ar (f : PA_funcs ) := match f with | Zero => 0 | Succ => 1 | Plus => 2 | Mult => 2 end.", "Inductive PA_preds : Type := Eq : PA_preds.", "Definition PA_preds_ar (P : PA_preds) := match P with | Eq => 2 end.", "Instance PA_funcs_signature : funcs_signature := {| syms := PA_funcs ; ar_syms := PA_funcs_ar |}.", "Instance PA_preds_signature : preds_signature := {| preds := PA_preds ; ar_preds := PA_preds_ar |}.", "Declare Scope PA_Notation.", "Open Scope PA_Notation.", "Notation \"'zero'\" := (@func PA_funcs_signature Zero ([])) (at level 1) : PA_Notation.", "Notation \"'\u03c3' x\" := (@func PA_funcs_signature Succ ([x])) (at level 37) : PA_Notation.", "Notation \"x '\u2295' y\" := (@func PA_funcs_signature Plus ([x ; y]) ) (at level 39) : PA_Notation.", "Notation \"x '\u2297' y\" := (@func PA_funcs_signature Mult ([x ; y]) ) (at level 38) : PA_Notation.", "Notation \"x '==' y\" := (@atom PA_funcs_signature PA_preds_signature _ _ Eq ([x ; y])) (at level 40) : PA_Notation.", "Notation \"x '\u29c0' y\" := (\u2203 (x[\u2191] \u2295 \u03c3 $0) == y) (at level 42) : PA_Notation.", "Definition ax_zero_succ := \u2200 (zero == \u03c3 var 0 ~> falsity).", "Definition ax_succ_inj := \u2200\u2200 (\u03c3 $1 == \u03c3 $0 ~> $1 == $0).", "Definition ax_add_zero := \u2200 (zero \u2295 $0 == $0).", "Definition ax_add_rec := \u2200\u2200 ((\u03c3 $0) \u2295 $1 == \u03c3 ($0 \u2295 $1)).", "Definition ax_mult_zero := \u2200 (zero \u2297 $0 == zero).", "Definition ax_mult_rec := \u2200\u2200 (\u03c3 $1 \u2297 $0 == $0 \u2295 $1 \u2297 $0).", "Definition ax_induction (phi : form) := phi[zero..] ~> (\u2200 phi ~> phi[\u03c3 $0 .: S >> var]) ~> \u2200 phi.", "Definition FA := ax_add_zero :: ax_add_rec :: ax_mult_zero :: ax_mult_rec :: nil.", "Inductive PA : form -> Prop := PA_FA phi : In phi FA -> PA phi | PA_discr : PA ax_zero_succ | PA_inj : PA ax_succ_inj | PA_induction phi : PA (ax_induction phi).", "Definition ax_refl := \u2200 $0 == $0.", "Definition ax_sym := \u2200\u2200 $1 == $0 ~> $0 == $1.", "Definition ax_trans := \u2200\u2200\u2200 $2 == $1 ~> $1 == $0 ~> $2 == $0.", "Definition ax_succ_congr := \u2200\u2200 $0 == $1 ~> \u03c3 $0 == \u03c3 $1.", "Definition ax_add_congr := \u2200\u2200\u2200\u2200 $0 == $1 ~> $2 == $3 ~> $0 \u2295 $2 == $1 \u2295 $3.", "Definition ax_mult_congr := \u2200\u2200\u2200\u2200 $0 == $1 ~> $2 == $3 ~> $0 \u2297 $2 == $1 \u2297 $3.", "Definition EQ := ax_refl :: ax_sym :: ax_trans :: ax_succ_congr :: ax_add_congr :: ax_mult_congr :: nil.", "Definition FAeq := EQ ++ FA.", "Inductive PAeq : form -> Prop := PAeq_FA phi : In phi FAeq -> PAeq phi | PAeq_discr : PAeq ax_zero_succ | PAeq_inj : PAeq ax_succ_inj | PAeq_induction phi : PAeq (ax_induction phi).", "Notation extensional M := (forall x y, @i_atom _ _ _ M Eq ([x ; y]) <-> x = y).", "Definition ext_entailment_PA phi := forall D (I : interp D) rho, extensional I -> (forall psi rho, PA psi -> rho \u22a8 psi) -> rho \u22a8 phi.", "Definition entailment_FA phi := valid_ctx FAeq phi.", "Definition entailment_PA phi := forall D (I : interp D) rho, (forall psi rho, PAeq psi -> rho \u22a8 psi) -> rho \u22a8 phi.", "Definition deduction_FA phi := FAeq \u22a2I phi.", "Definition deduction_PA phi := PAeq \u22a2TI phi."], "theorems": []}