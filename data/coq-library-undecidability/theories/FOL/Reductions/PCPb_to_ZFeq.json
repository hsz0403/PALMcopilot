{"code": ["Require Import Undecidability.FOL.Util.Syntax.", "Require Import Undecidability.FOL.Util.FullTarski_facts.", "Require Import Undecidability.FOL.ZF.", "Require Import Undecidability.FOL.Reductions.PCPb_to_ZF.", "Require Import Lia.", "From Undecidability.PCP Require Import PCP Util.PCP_facts Reductions.PCPb_iff_dPCPb.", "From Undecidability Require Import Shared.ListAutomation.", "Import ListAutomationNotations.", "Local Set Implicit Arguments.", "Local Unset Strict Implicit.", "Require Import Morphisms.", "Section ZF.", "Context { V : Type }.", "Context { M : interp V }.", "Hypothesis M_ZF : forall rho, rho \u22ab ZFeq'.", "Definition set_equiv x y := x \u2261 y.", "Notation \"x \u2261' y\" := (set_equiv x y) (at level 35).", "Definition set_elem x y := x \u2208 y.", "Notation \"x \u2208' y\" := (set_elem x y) (at level 35).", "Definition set_sub x y := forall z, z \u2208' x -> z \u2208' y.", "Notation \"x \u2286' y\" := (set_sub x y) (at level 35).", "Instance set_equiv_equiv : Equivalence set_equiv.", "Proof.", "split.", "-", "apply (@M_ZF (fun _ => \u2205) ax_refl).", "cbn; tauto.", "-", "apply (@M_ZF (fun _ => \u2205) ax_sym).", "cbn; tauto.", "-", "apply (@M_ZF (fun _ => \u2205) ax_trans).", "cbn; tauto.", "Qed.", "Instance set_equiv_elem : Proper (set_equiv ==> set_equiv ==> iff) set_elem.", "Proof.", "intros x x' Hx y y' Hy.", "split.", "-", "apply (@M_ZF (fun _ => \u2205) ax_eq_elem); cbn; tauto.", "-", "symmetry in Hx, Hy.", "apply (@M_ZF (fun _ => \u2205) ax_eq_elem); cbn; tauto.", "Qed.", "Instance set_equiv_sub : Proper (set_equiv ==> set_equiv ==> iff) set_sub.", "Proof.", "intros x x' Hx y y' Hy.", "unfold set_sub.", "setoid_rewrite Hx.", "setoid_rewrite Hy.", "tauto.", "Qed.", "Lemma set_equiv_refl' x : x \u2261' x.", "Proof.", "apply set_equiv_equiv.", "Qed.", "Lemma set_equiv_refl x : x \u2261 x.", "Proof.", "apply set_equiv_equiv.", "Qed.", "Hint Resolve set_equiv_refl set_equiv_refl' : core.", "Lemma M_ext x y : x \u2286' y -> y \u2286' x -> x \u2261' y.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_ext).", "cbn; tauto.", "Qed.", "Lemma M_eset x : ~ x \u2208' \u2205.", "Proof.", "refine (@M_ZF (fun _ => \u2205) ax_eset _ x).", "cbn; tauto.", "Qed.", "Lemma M_pair x y z : x \u2208' {y; z} <-> x \u2261' y \\/ x \u2261' z.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_pair).", "cbn; tauto.", "Qed.", "Definition pair x y := {x; y}.", "Instance set_equiv_pair : Proper (set_equiv ==> set_equiv ==> set_equiv) pair.", "Proof.", "intros x x' Hx y y' Hy.", "unfold pair.", "apply M_ext; unfold set_sub.", "all: setoid_rewrite M_pair.", "all: setoid_rewrite Hx; setoid_rewrite Hy; tauto.", "Qed.", "Instance set_equiv_opair : Proper (set_equiv ==> set_equiv ==> set_equiv) M_opair.", "Proof.", "intros x x' Hx y y' Hy.", "unfold M_opair.", "change ({pair x x; pair x y} \u2261' {pair x' x'; pair x' y'}).", "apply M_ext; unfold set_sub.", "all: setoid_rewrite M_pair.", "all: setoid_rewrite Hx; setoid_rewrite Hy; tauto.", "Qed.", "Lemma M_union x y : x \u2208' \u22c3 y <-> exists z, z \u2208' y /\\ x \u2208' z.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_union).", "cbn; tauto.", "Qed.", "Definition union x := \u22c3 x.", "Instance equiv_union : Proper (set_equiv ==> set_equiv) union.", "Proof.", "intros x x' Hx.", "unfold union.", "apply M_ext; unfold set_sub.", "all: setoid_rewrite M_union.", "all: setoid_rewrite Hx; tauto.", "Qed.", "Lemma M_power x y : x \u2208' PP y <-> x \u2286' y.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_power).", "cbn; tauto.", "Qed.", "Definition power x := PP x.", "Instance equiv_power : Proper (set_equiv ==> set_equiv) power.", "Proof.", "intros x x' Hx.", "unfold power.", "apply M_ext; unfold set_sub.", "all: setoid_rewrite M_power.", "all: setoid_rewrite Hx; tauto.", "Qed.", "Lemma M_om1 : M_inductive \u03c9.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_om1).", "cbn; tauto.", "Qed.", "Lemma M_om2 x : M_inductive x -> \u03c9 \u2286 x.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_om2).", "cbn; tauto.", "Qed.", "Definition M_binunion x y := \u22c3 {x; y}.", "Notation \"x \u222a' y\" := (M_binunion x y) (at level 32).", "Lemma binunion_el x y z : x \u2208' y \u222a z <-> x \u2208' y \\/ x \u2208' z.", "Proof.", "split.", "-", "intros [u [H1 H2]] % M_union.", "apply M_pair in H1 as [<-| <-]; auto.", "-", "intros [H|H].", "+", "apply M_union.", "exists y.", "rewrite M_pair.", "auto.", "+", "apply M_union.", "exists z.", "rewrite M_pair.", "auto.", "Qed.", "Instance equiv_bunion : Proper (set_equiv ==> set_equiv ==> set_equiv) M_binunion.", "Proof.", "intros x x' Hx y y' Hy.", "unfold M_binunion.", "apply M_ext; unfold set_sub.", "all: setoid_rewrite binunion_el.", "all: setoid_rewrite Hx; setoid_rewrite Hy; tauto.", "Qed.", "Lemma sing_el x y : x \u2208' M_sing y <-> x \u2261' y.", "Proof.", "split.", "-", "now intros [H|H] % M_pair.", "-", "intros ->.", "apply M_pair.", "now left.", "Qed.", "Lemma M_pair1 x y : x \u2208' {x; y}.", "Proof.", "apply M_pair.", "now left.", "Qed.", "Lemma M_pair2 x y : y \u2208' {x; y}.", "Proof.", "apply M_pair.", "now right.", "Qed.", "Lemma sing_pair x y z : {x; x} \u2261' {y; z} -> x \u2261' y /\\ x \u2261' z.", "Proof.", "intros He.", "split.", "-", "assert (H : y \u2208' {y; z}) by apply M_pair1.", "rewrite <- He in H.", "apply M_pair in H.", "intuition.", "-", "assert (H : z \u2208' {y; z}) by apply M_pair2.", "rewrite <- He in H.", "apply M_pair in H.", "intuition.", "Qed.", "Lemma opair_inj1 x x' y y' : M_opair x y \u2261' M_opair x' y' -> x \u2261' x'.", "Proof.", "intros He.", "assert (H : {x; x} \u2208' M_opair x y) by apply M_pair1.", "rewrite He in H.", "apply M_pair in H as [H|H]; apply (sing_pair H).", "Qed.", "Lemma opair_inj2 x x' y y' : M_opair x y \u2261' M_opair x' y' -> y \u2261' y'.", "Proof.", "intros He.", "assert (y \u2261' x' \\/ y \u2261' y') as [Hy | Hy]; trivial.", "-", "assert (H : {x; y} \u2208' M_opair x y) by apply M_pair2.", "rewrite He in H.", "apply M_pair in H as [H|H].", "+", "symmetry in H.", "apply sing_pair in H.", "intuition.", "+", "assert (H' : y \u2208' {x; y}) by apply M_pair2.", "rewrite H in H'.", "now apply M_pair in H'.", "-", "assert (Hx : x \u2261' x') by now apply opair_inj1 in He.", "rewrite Hx, Hy in He.", "rewrite Hy.", "assert (H : {x'; y'} \u2208' M_opair x' y') by apply M_pair2.", "rewrite <- He in H.", "apply M_pair in H as [H|H]; symmetry in H; now apply sing_pair in H.", "Qed.", "Lemma opair_inj x x' y y' : M_opair x y \u2261' M_opair x' y' -> x \u2261' x' /\\ y \u2261' y'.", "Proof.", "intros H.", "split.", "-", "eapply opair_inj1; eassumption.", "-", "eapply opair_inj2; eassumption.", "Qed.", "Lemma sigma_el x y : x \u2208' \u03c3 y <-> x \u2208' y \\/ x \u2261' y.", "Proof.", "split.", "-", "intros [H|H] % binunion_el; auto.", "apply sing_el in H.", "now right.", "-", "intros [H| ->]; apply binunion_el; auto.", "right.", "now apply sing_el.", "Qed.", "Lemma binunion_eset x : x \u2261' \u2205 \u222a x.", "Proof.", "apply M_ext.", "-", "intros y H.", "apply binunion_el.", "now right.", "-", "intros y [H|H] % binunion_el.", "+", "now apply M_eset in H.", "+", "assumption.", "Qed.", "Lemma pair_com x y : {x; y} \u2261' {y; x}.", "Proof.", "apply M_ext; intros z; rewrite !M_pair; tauto.", "Qed.", "Lemma binunion_com x y : x \u222a' y \u2261' y \u222a' x.", "Proof.", "apply equiv_union, pair_com.", "Qed.", "Lemma binunionl a x y : a \u2208' x -> a \u2208' x \u222a' y.", "Proof.", "intros H.", "apply binunion_el.", "now left.", "Qed.", "Lemma binunionr a x y : a \u2208' y -> a \u2208' x \u222a' y.", "Proof.", "intros H.", "apply binunion_el.", "now right.", "Qed.", "Hint Resolve binunionl binunionr : core.", "Lemma binunion_assoc x y z : (x \u222a' y) \u222a' z \u2261' x \u222a' (y \u222a' z).", "Proof.", "apply M_ext; intros a [H|H] % binunion_el; eauto.", "-", "apply binunion_el in H as [H|H]; eauto.", "-", "apply binunion_el in H as [H|H]; eauto.", "Qed.", "Lemma numeral_lt k l : k < l -> numeral k \u2208 numeral l.", "Proof.", "induction 1; cbn; apply sigma_el; auto.", "Qed.", "Lemma enc_bool_inj b c : M_enc_bool b \u2261' M_enc_bool c -> b = c.", "Proof.", "destruct b, c; trivial; cbn.", "-", "intros H.", "contradiction (@M_eset \u2205).", "rewrite <- H at 2.", "apply M_pair; auto.", "-", "intros H.", "contradiction (@M_eset \u2205).", "rewrite H at 2.", "apply M_pair; auto.", "Qed.", "Lemma enc_string_inj s t : M_enc_string s \u2261' M_enc_string t -> s = t.", "Proof.", "induction s in t|-*; destruct t as [|b t]; cbn; trivial.", "-", "intros H.", "contradiction (M_eset (x:=M_sing (M_enc_bool b))).", "rewrite H.", "apply M_pair.", "now left.", "-", "intros H.", "contradiction (M_eset (x:=M_sing (M_enc_bool a))).", "rewrite <- H.", "apply M_pair.", "now left.", "-", "intros [H1 H2] % opair_inj.", "apply IHs in H2 as ->.", "apply enc_bool_inj in H1 as ->.", "reflexivity.", "Qed.", "Instance equiv_prep : Proper (eq ==> set_equiv ==> set_equiv) M_prep_string.", "Proof.", "intros s s' <- x x' Hx.", "induction s; cbn; trivial.", "now rewrite IHs.", "Qed.", "Lemma M_enc_stack_app A B : M_enc_stack (A ++ B) \u2261' M_enc_stack A \u222a' M_enc_stack B.", "Proof.", "induction A as [|[s t] A IH]; cbn.", "-", "apply binunion_eset.", "-", "change (M_enc_stack (A ++ B) \u222a' M_sing (M_enc_card s t) \u2261' (M_enc_stack A \u222a' M_sing (M_enc_card s t)) \u222a' M_enc_stack B).", "rewrite IH.", "rewrite !binunion_assoc.", "now rewrite (binunion_com (M_enc_stack B) (M_sing (M_enc_card s t))).", "Qed.", "Lemma enc_stack_el' x A : x \u2208 M_enc_stack A -> exists s t, (s, t) el A /\\ x \u2261' M_enc_card s t.", "Proof.", "induction A as [|[s t] A IH]; cbn.", "-", "now intros H % M_eset.", "-", "intros [H|H] % binunion_el.", "+", "destruct (IH H) as (u&v&H1&H2).", "exists u, v.", "intuition.", "+", "apply sing_el in H.", "exists s, t.", "intuition.", "Qed.", "Lemma enc_stack_el B s t : (s, t) el B -> M_enc_card s t \u2208 M_enc_stack B.", "Proof.", "induction B as [|[u b] B IH]; cbn; auto.", "intros [H|H]; apply binunion_el.", "-", "right.", "apply sing_el.", "injection H.", "now intros -> ->.", "-", "left.", "apply IH, H.", "Qed.", "Definition M_comb_rel s t := fun u v => exists u1 u2, u \u2261' M_opair u1 u2 /\\ v \u2261' M_opair (M_prep_string s u1) (M_prep_string t u2).", "Fixpoint M_combinations B x y := match B with | nil => y = \u2205 | (s,t)::B => exists y1 y2, y \u2261' y2 \u222a y1 /\\ M_combinations B x y1 /\\ M_is_rep (M_comb_rel s t) x y2 end.", "Lemma M_combinations_spec B rho x y a b : M_combinations B x y -> eval rho a = x -> eval rho b = y -> rho \u22a8 combinations B a b.", "Proof.", "induction B in y,a,b,rho|-*; cbn.", "-", "now intros -> _ ->.", "-", "destruct a0 as [s t].", "intros (y1&y2&H1&H2&H3) Ha Hb.", "exists y1, y2.", "repeat split.", "+", "cbn.", "erewrite !eval_comp.", "unfold funcomp.", "cbn.", "change (eval rho b \u2261' y2 \u222a y1).", "now rewrite Hb, H1.", "+", "eapply (IHB _ y1); trivial.", "erewrite !eval_comp.", "unfold funcomp.", "cbn.", "change (eval (fun x => rho x) a) with (eval rho a).", "now rewrite Ha.", "+", "intros (u & Hu & c & d' & H) % H3.", "exists u.", "split.", "*", "cbn.", "erewrite !eval_comp.", "erewrite eval_ext, Ha; trivial.", "*", "exists d', c.", "cbn.", "rewrite !eval_prep_string.", "apply H.", "+", "intros (u & Hu & c & d' & H).", "apply H3.", "exists u.", "split.", "*", "cbn in Hu.", "erewrite !eval_comp in Hu.", "rewrite <- Ha.", "apply Hu.", "*", "exists d', c.", "cbn in H.", "rewrite !eval_prep_string in H.", "apply H.", "Qed.", "Definition M_solutions B f n := M_opair \u2205 (M_enc_stack B) \u2208' f /\\ forall k x y, k \u2208' n -> M_opair k x \u2208' f -> M_combinations B x y -> M_opair (\u03c3 k) y \u2208' f.", "Instance equiv_solutions : Proper (eq ==> eq ==> set_equiv ==> iff) M_solutions.", "Proof.", "intros B B' <- f f' <- x x' Hx.", "unfold M_solutions.", "setoid_rewrite Hx.", "tauto.", "Qed.", "Lemma comb_rel_rep C s t : M_is_rep (M_comb_rel s t) (M_enc_stack C) (M_enc_stack (append_all C (s, t))).", "Proof.", "intros y.", "split.", "-", "intros (u&v&H&H') % enc_stack_el'.", "unfold append_all in H.", "apply in_map_iff in H as [[a b][H1 H2]].", "cbn in H1.", "exists (M_enc_card a b).", "split; try now apply enc_stack_el.", "exists (M_enc_string a), (M_enc_string b).", "split; trivial.", "assert (u = s++a) as -> by congruence.", "assert (v = t++b) as -> by congruence.", "now rewrite !M_prep_enc.", "-", "intros (u&H&a&b&H3&H4).", "apply enc_stack_el' in H as [u'[v[H1 H2]]].", "rewrite H3 in H2.", "apply opair_inj in H2 as [H2 H2'].", "change (y \u2208' M_enc_stack (append_all C (s, t))).", "rewrite H4, H2, H2', !M_prep_enc.", "apply enc_stack_el.", "apply in_map_iff.", "now exists (u', v).", "Qed.", "Lemma M_combinations_step B C : M_combinations B (M_enc_stack C) (M_enc_stack (derivation_step B C)).", "Proof.", "induction B as [|[s t] B IH]; cbn; trivial.", "exists (M_enc_stack (derivation_step B C)), (M_enc_stack (append_all C (s, t))).", "rewrite M_enc_stack_app.", "split; trivial.", "split; trivial.", "apply comb_rel_rep.", "Qed.", "Lemma solutions_derivations B f n k : M_solutions B f (numeral n) -> k <= n -> M_opair (numeral k) (M_enc_stack (derivations B k)) \u2208 f.", "Proof.", "intros H Hk; induction k; cbn.", "-", "apply H.", "-", "assert (Hk' : k <= n) by lia.", "specialize (IHk Hk').", "destruct H as [_ H].", "eapply H in IHk; eauto.", "+", "now apply numeral_lt.", "+", "apply M_combinations_step.", "Qed.", "Definition M_function f := forall x y y', M_opair x y \u2208 f -> M_opair x y' \u2208 f -> y \u2261' y'.", "Lemma M_solutions_el B f k X p : standard M -> k \u2208 \u03c9 -> M_function f -> M_solutions B f k -> M_opair k X \u2208' f -> p \u2208' X -> exists u v, p \u2261' M_enc_card u v /\\ derivable B u v.", "Proof.", "intros HS HO Hf Hk HX Hp.", "destruct (HS k HO) as [n Hn].", "change (k \u2261' numeral n) in Hn.", "rewrite Hn in Hk.", "rewrite Hn in HX.", "pose proof (H := solutions_derivations Hk (le_n n)).", "rewrite (Hf _ _ _ HX H) in Hp.", "apply enc_stack_el' in Hp as (s&t&H'&Hp).", "exists s, t.", "split; trivial.", "eapply derivations_derivable; eauto.", "Qed.", "Theorem PCP_ZF2 B rho : standard M -> rho \u22a8 solvable B -> exists s, derivable B s s.", "Proof.", "intros VIN (n & f & s & X & [[[[H1 H2] H3] H4] H5]).", "assert (H1' : n \u2208 \u03c9) by apply H1.", "clear H1.", "assert (H4' : M_opair n X \u2208 f) by apply H4.", "clear H4.", "assert (H5' : M_opair s s \u2208 X) by apply H5.", "clear H5.", "assert (H2' : M_function f).", "{", "intros x y y' H H'.", "eapply H2.", "apply H.", "apply H'.", "}", "clear H2.", "assert (H3' : M_opair \u2205 (M_enc_stack B) \u2208 f).", "{", "erewrite <- eval_enc_stack.", "apply H3.", "}", "destruct H3 as [_ H3].", "assert (H3'' : forall k x y, k \u2208 n -> M_opair k x \u2208 f -> M_combinations B x y -> M_opair (\u03c3 k) y \u2208 f).", "{", "intros k x y Hn Hk Hy.", "apply (H3 k x y); auto.", "fold sat.", "eapply M_combinations_spec; eauto.", "}", "clear H3.", "destruct (@M_solutions_el B f n X (M_opair s s)) as (u&v&H1&H2); trivial.", "now split.", "exists u.", "apply opair_inj in H1 as [H H1].", "rewrite H1 in H.", "apply enc_string_inj in H as ->.", "apply H2.", "Qed.", "End ZF.", "Theorem PCP_ZFeq' B : (exists V (M : interp V), standard M /\\ forall rho, rho \u22ab ZFeq') -> entailment_ZFeq' (solvable B) -> PCPb B.", "Proof.", "intros (M & H1 & H2 & H3) H.", "rewrite PCPb_iff_dPCPb.", "specialize (H M H1 (fun _ => @i_func _ _ _ _ eset Vector.nil) H3).", "apply PCP_ZF2 in H as [s Hs]; trivial.", "now exists s.", "Qed."], "theorems": [{"name": "set_equiv_equiv", "kind": "Instance", "begin": 21, "end": 33}, {"name": "set_equiv_elem", "kind": "Instance", "begin": 34, "end": 43}, {"name": "set_equiv_sub", "kind": "Instance", "begin": 44, "end": 51}, {"name": "set_equiv_refl'", "kind": "Lemma", "begin": 52, "end": 55}, {"name": "set_equiv_refl", "kind": "Lemma", "begin": 56, "end": 59}, {"name": "M_ext", "kind": "Lemma", "begin": 61, "end": 65}, {"name": "M_eset", "kind": "Lemma", "begin": 66, "end": 70}, {"name": "M_pair", "kind": "Lemma", "begin": 71, "end": 75}, {"name": "set_equiv_pair", "kind": "Instance", "begin": 77, "end": 84}, {"name": "set_equiv_opair", "kind": "Instance", "begin": 85, "end": 93}, {"name": "M_union", "kind": "Lemma", "begin": 94, "end": 98}, {"name": "equiv_union", "kind": "Instance", "begin": 100, "end": 107}, {"name": "M_power", "kind": "Lemma", "begin": 108, "end": 112}, {"name": "equiv_power", "kind": "Instance", "begin": 114, "end": 121}, {"name": "M_om1", "kind": "Lemma", "begin": 122, "end": 126}, {"name": "M_om2", "kind": "Lemma", "begin": 127, "end": 131}, {"name": "binunion_el", "kind": "Lemma", "begin": 134, "end": 152}, {"name": "equiv_bunion", "kind": "Instance", "begin": 153, "end": 160}, {"name": "sing_el", "kind": "Lemma", "begin": 161, "end": 170}, {"name": "M_pair1", "kind": "Lemma", "begin": 171, "end": 175}, {"name": "M_pair2", "kind": "Lemma", "begin": 176, "end": 180}, {"name": "sing_pair", "kind": "Lemma", "begin": 181, "end": 195}, {"name": "opair_inj1", "kind": "Lemma", "begin": 196, "end": 202}, {"name": "opair_inj2", "kind": "Lemma", "begin": 203, "end": 226}, {"name": "opair_inj", "kind": "Lemma", "begin": 227, "end": 235}, {"name": "sigma_el", "kind": "Lemma", "begin": 236, "end": 247}, {"name": "binunion_eset", "kind": "Lemma", "begin": 248, "end": 261}, {"name": "pair_com", "kind": "Lemma", "begin": 262, "end": 265}, {"name": "binunion_com", "kind": "Lemma", "begin": 266, "end": 269}, {"name": "binunionl", "kind": "Lemma", "begin": 270, "end": 275}, {"name": "binunionr", "kind": "Lemma", "begin": 276, "end": 281}, {"name": "binunion_assoc", "kind": "Lemma", "begin": 283, "end": 290}, {"name": "numeral_lt", "kind": "Lemma", "begin": 291, "end": 294}, {"name": "enc_bool_inj", "kind": "Lemma", "begin": 295, "end": 308}, {"name": "enc_string_inj", "kind": "Lemma", "begin": 309, "end": 329}, {"name": "equiv_prep", "kind": "Instance", "begin": 330, "end": 335}, {"name": "M_enc_stack_app", "kind": "Lemma", "begin": 336, "end": 346}, {"name": "enc_stack_el'", "kind": "Lemma", "begin": 347, "end": 362}, {"name": "enc_stack_el", "kind": "Lemma", "begin": 363, "end": 375}, {"name": "M_combinations_spec", "kind": "Lemma", "begin": 378, "end": 430}, {"name": "equiv_solutions", "kind": "Instance", "begin": 432, "end": 438}, {"name": "comb_rel_rep", "kind": "Lemma", "begin": 439, "end": 465}, {"name": "M_combinations_step", "kind": "Lemma", "begin": 466, "end": 474}, {"name": "solutions_derivations", "kind": "Lemma", "begin": 475, "end": 489}, {"name": "M_solutions_el", "kind": "Lemma", "begin": 491, "end": 504}, {"name": "PCP_ZF2", "kind": "Theorem", "begin": 505, "end": 543}, {"name": "PCP_ZFeq'", "kind": "Theorem", "begin": 545, "end": 552}]}