{"code": ["Require Import Undecidability.FOL.Util.Syntax.", "Require Import Undecidability.FOL.Util.FullTarski_facts.", "Require Import Undecidability.FOL.ZF.", "Require Import Lia.", "From Undecidability.PCP Require Import PCP Util.PCP_facts Reductions.PCPb_iff_dPCPb.", "From Undecidability Require Import Shared.ListAutomation.", "Import ListAutomationNotations.", "Local Set Implicit Arguments.", "Local Unset Strict Implicit.", "Local Definition BSRS := list(card bool).", "Fixpoint shift n x := match n with | O => x | S n => subst_term \u2191 (shift n x) end.", "Definition sing a := {a; a}.", "Definition opair a b := {{a; a}; {a; b}}.", "Definition pairing f A := \u2200 $0 \u2208 shift 1 f ~> \u2203 \u2203 $1 \u2208 shift 3 A \u2227 $2 \u2261 opair $1 $0.", "Definition function' f A := pairing f A \u2227 \u2200 \u2203 $0 \u2208 shift 2 A \u2227 opair $0 $1 \u2208 shift 2 f \u2227 \u2200 opair $1 $0 \u2208 shift 2f ~> $2 \u2261 $0.", "Definition function f := \u2200 \u2200 \u2200 opair $2 $1 \u2208 shift 3 f ~> opair $2 $0 \u2208 shift 3 f ~> $1 \u2261 $0.", "Definition enc_bool (x : bool) := if x then {\u2205; \u2205} else \u2205.", "Fixpoint prep_string (s : string bool) a := match s with | nil => a | b::s => opair (enc_bool b) (prep_string s a) end.", "Definition enc_string (s : string bool) := prep_string s \u2205.", "Fixpoint enc_stack (B : BSRS) := match B with | nil => \u2205 | (s,t)::B => enc_stack B \u222a sing (opair (enc_string s) (enc_string t)) end.", "Definition is_rep phi a b := \u2200 $0 \u2208 shift 1 b <~> \u2203 $0 \u2208 shift 2 a \u2227 phi.", "Definition comb_rel s t := \u2203 \u2203 $2 \u2261 opair $0 $1 \u2227 $3 \u2261 opair (prep_string s $0) (prep_string t $1).", "Fixpoint combinations (B : BSRS) a b := match B with | nil => b \u2261 \u2205 | (s,t)::B => \u2203 \u2203 shift 2 b \u2261 $0 \u222a $1 \u2227 combinations B (shift 2 a) $1 \u2227 is_rep (comb_rel s t) (shift 2 a) $0 end.", "Definition solutions (B : BSRS) f n := opair \u2205 (enc_stack B) \u2208 f \u2227 \u2200 \u2200 \u2200 $2 \u2208 shift 3 n ~> opair $2 $1 \u2208 shift 3 f ~> combinations B $1 $0 ~> opair (\u03c3 $2) $0 \u2208 shift 3 f.", "Definition solvable (B : BSRS) := \u2203 \u2203 \u2203 \u2203 $3 \u2208 \u03c9 \u2227 function $2 \u2227 solutions B $2 $3 \u2227 opair $3 $0 \u2208 $2 \u2227 opair $1 $1 \u2208 $0.", "Declare Scope sem.", "Open Scope sem.", "Arguments Vector.nil {_}, _.", "Arguments Vector.cons {_} _ {_} _, _ _ _ _.", "Notation \"x \u2208 y\" := (@i_atom _ _ _ _ elem (Vector.cons x (Vector.cons y Vector.nil))) (at level 35) : sem.", "Notation \"x \u2261 y\" := (@i_atom _ _ _ _ equal (Vector.cons x (Vector.cons y Vector.nil))) (at level 35) : sem.", "Notation \"x \u2286 y\" := (forall z, z \u2208 x -> z \u2208 y) (at level 34) : sem.", "Notation \"\u2205\" := (@i_func ZF_func_sig ZF_pred_sig _ _ eset Vector.nil) : sem.", "Notation \"'\u03c9'\" := (@i_func ZF_func_sig _ _ _ om Vector.nil) : sem.", "Notation \"{ x ; y }\" := (@i_func ZF_func_sig _ _ _ pair (Vector.cons x (Vector.cons y Vector.nil))) (at level 31) : sem.", "Notation \"\u22c3 x\" := (@i_func ZF_func_sig _ _ _ union (Vector.cons x Vector.nil)) (at level 32) : sem.", "Notation \"'PP' x\" := (@i_func ZF_func_sig _ _ _ power (Vector.cons x Vector.nil)) (at level 31) : sem.", "Notation \"x \u222a y\" := (\u22c3 {x; y}) (at level 32) : sem.", "Notation \"'\u03c3' x\" := (x \u222a {x; x}) (at level 32) : sem.", "Section ZF.", "Context { V : Type }.", "Context { M : interp V }.", "Hypothesis M_ZF : forall rho, rho \u22ab ZF'.", "Hypothesis VIEQ : extensional M.", "Lemma M_ext x y : x \u2286 y -> y \u2286 x -> x = y.", "Proof.", "rewrite <- VIEQ.", "apply (@M_ZF (fun _ => \u2205) ax_ext).", "cbn; tauto.", "Qed.", "Lemma M_eset x : ~ x \u2208 \u2205.", "Proof.", "refine (@M_ZF (fun _ => \u2205) ax_eset _ x).", "cbn; tauto.", "Qed.", "Lemma M_pair x y z : x \u2208 {y; z} <-> x = y \\/ x = z.", "Proof.", "rewrite <- !VIEQ.", "apply (@M_ZF (fun _ => \u2205) ax_pair).", "cbn; tauto.", "Qed.", "Lemma M_union x y : x \u2208 \u22c3 y <-> exists z, z \u2208 y /\\ x \u2208 z.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_union).", "cbn; tauto.", "Qed.", "Lemma M_power x y : x \u2208 PP y <-> x \u2286 y.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_power).", "cbn; tauto.", "Qed.", "Definition M_inductive x := \u2205 \u2208 x /\\ forall y, y \u2208 x -> \u03c3 y \u2208 x.", "Lemma M_om1 : M_inductive \u03c9.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_om1).", "cbn; tauto.", "Qed.", "Lemma M_om2 x : M_inductive x -> \u03c9 \u2286 x.", "Proof.", "apply (@M_ZF (fun _ => \u2205) ax_om2).", "cbn; tauto.", "Qed.", "Definition agrees_fun phi (P : V -> Prop) := forall x rho, P x <-> (x.:rho) \u22a8 phi.", "Definition def_pred (P : V -> Prop) := exists phi rho, forall d, P d <-> (d.:rho) \u22a8 phi.", "Lemma M_sep P x : (forall phi rho, rho \u22a8 ax_sep phi) -> def_pred P -> exists y, forall z, z \u2208 y <-> z \u2208 x /\\ P z.", "Proof.", "cbn.", "intros H [phi [rho Hp]].", "destruct (H phi rho x) as [y H']; clear H.", "exists y.", "intros z.", "specialize (H' z).", "setoid_rewrite sat_comp in H'.", "rewrite (sat_ext _ _ (xi:=z.:rho)) in H'; try now intros [].", "firstorder.", "Qed.", "Definition M_is_rep R x y := forall v, v \u2208 y <-> exists u, u \u2208 x /\\ R u v.", "Lemma is_rep_unique R x y y' : M_is_rep R x y -> M_is_rep R x y' -> y = y'.", "Proof.", "intros H1 H2.", "apply M_ext; intros v.", "-", "intros H % H1.", "now apply H2.", "-", "intros H % H2.", "now apply H1.", "Qed.", "Definition functional (R : V -> V -> Prop) := forall x y y', R x y -> R x y' -> y = y'.", "Definition def_rel (R : V -> V -> Prop) := exists phi rho, forall x y, R x y <-> (x.:y.:rho) \u22a8 phi.", "Lemma M_rep R x : (forall phi rho, rho \u22a8 ax_rep phi) -> def_rel R -> functional R -> exists y, M_is_rep R x y.", "Proof.", "intros H1 [phi [rho Hp]].", "intros H2.", "cbn in H1.", "specialize (H1 phi rho).", "destruct H1 with x as [y Hy].", "-", "intros a b b'.", "setoid_rewrite sat_comp.", "erewrite sat_ext.", "rewrite <- (Hp a b).", "2: now intros [|[]].", "erewrite sat_ext.", "rewrite <- (Hp a b').", "2: now intros [|[]].", "rewrite VIEQ.", "apply H2.", "-", "exists y.", "intros v.", "split.", "+", "intros [u[U1 U2]] % Hy.", "exists u.", "split; trivial.", "setoid_rewrite sat_comp in U2.", "rewrite sat_ext in U2.", "rewrite (Hp u v).", "apply U2.", "now intros [|[]]; cbn.", "+", "intros [u[U1 U2]].", "apply Hy.", "exists u.", "split; trivial.", "setoid_rewrite sat_comp.", "rewrite sat_ext.", "rewrite <- (Hp u v).", "apply U2.", "now intros [|[]]; cbn.", "Qed.", "Definition M_sing x := {x; x}.", "Definition M_opair x y := ({{x; x}; {x; y}}).", "Lemma binunion_el x y z : x \u2208 y \u222a z <-> x \u2208 y \\/ x \u2208 z.", "Proof.", "split.", "-", "intros [u [H1 H2]] % M_union.", "apply M_pair in H1 as [->| ->]; auto.", "-", "intros [H|H].", "+", "apply M_union.", "exists y.", "rewrite M_pair.", "auto.", "+", "apply M_union.", "exists z.", "rewrite M_pair.", "auto.", "Qed.", "Lemma sing_el x y : x \u2208 M_sing y <-> x = y.", "Proof.", "split.", "-", "now intros [H|H] % M_pair.", "-", "intros ->.", "apply M_pair.", "now left.", "Qed.", "Lemma M_pair1 x y : x \u2208 {x; y}.", "Proof.", "apply M_pair.", "now left.", "Qed.", "Lemma M_pair2 x y : y \u2208 {x; y}.", "Proof.", "apply M_pair.", "now right.", "Qed.", "Lemma sing_pair x y z : {x; x} = {y; z} -> x = y /\\ x = z.", "Proof.", "intros He.", "split.", "-", "assert (H : y \u2208 {y; z}) by apply M_pair1.", "rewrite <- He in H.", "apply M_pair in H.", "intuition.", "-", "assert (H : z \u2208 {y; z}) by apply M_pair2.", "rewrite <- He in H.", "apply M_pair in H.", "intuition.", "Qed.", "Lemma opair_inj1 x x' y y' : M_opair x y = M_opair x' y' -> x = x'.", "Proof.", "intros He.", "assert (H : {x; x} \u2208 M_opair x y) by apply M_pair1.", "rewrite He in H.", "apply M_pair in H as [H|H]; apply (sing_pair H).", "Qed.", "Lemma opair_inj2 x x' y y' : M_opair x y = M_opair x' y' -> y = y'.", "Proof.", "intros He.", "assert (y = x' \\/ y = y') as [->| ->]; trivial.", "-", "assert (H : {x; y} \u2208 M_opair x y) by apply M_pair2.", "rewrite He in H.", "apply M_pair in H as [H|H].", "+", "symmetry in H.", "apply sing_pair in H.", "intuition.", "+", "assert (H' : y \u2208 {x; y}) by apply M_pair2.", "rewrite H in H'.", "now apply M_pair in H'.", "-", "assert (x = x') as -> by now apply opair_inj1 in He.", "assert (H : {x'; y'} \u2208 M_opair x' y') by apply M_pair2.", "rewrite <- He in H.", "apply M_pair in H as [H|H]; apply (sing_pair (eq_sym H)).", "Qed.", "Lemma opair_inj x x' y y' : M_opair x y = M_opair x' y' -> x = x' /\\ y = y'.", "Proof.", "intros H.", "split.", "-", "eapply opair_inj1; eassumption.", "-", "eapply opair_inj2; eassumption.", "Qed.", "Lemma sigma_el x y : x \u2208 \u03c3 y <-> x \u2208 y \\/ x = y.", "Proof.", "split.", "-", "intros [H|H] % binunion_el; auto.", "apply sing_el in H.", "now right.", "-", "intros [H| ->]; apply binunion_el; auto.", "right.", "now apply sing_el.", "Qed.", "Lemma sigma_eq x : x \u2208 \u03c3 x.", "Proof.", "apply sigma_el.", "now right.", "Qed.", "Lemma sigma_sub x : x \u2286 \u03c3 x.", "Proof.", "intros y H.", "apply sigma_el.", "now left.", "Qed.", "Lemma binunion_eset x : x = \u2205 \u222a x.", "Proof.", "apply M_ext.", "-", "intros y H.", "apply binunion_el.", "now right.", "-", "intros y [H|H] % binunion_el.", "+", "now apply M_eset in H.", "+", "assumption.", "Qed.", "Lemma pair_com x y : {x; y} = {y; x}.", "Proof.", "apply M_ext; intros z [->| ->] % M_pair; apply M_pair; auto.", "Qed.", "Lemma binunion_com x y : x \u222a y = y \u222a x.", "Proof.", "now rewrite pair_com.", "Qed.", "Lemma binunionl a x y : a \u2208 x -> a \u2208 x \u222a y.", "Proof.", "intros H.", "apply binunion_el.", "now left.", "Qed.", "Lemma binunionr a x y : a \u2208 y -> a \u2208 x \u222a y.", "Proof.", "intros H.", "apply binunion_el.", "now right.", "Qed.", "Hint Resolve binunionl binunionr : core.", "Lemma binunion_assoc x y z : (x \u222a y) \u222a z = x \u222a (y \u222a z).", "Proof.", "apply M_ext; intros a [H|H] % binunion_el; eauto.", "-", "apply binunion_el in H as [H|H]; eauto.", "-", "apply binunion_el in H as [H|H]; eauto.", "Qed.", "Fixpoint numeral n := match n with | O => \u2205 | S n => \u03c3 (numeral n) end.", "Lemma numeral_omega n : numeral n \u2208 \u03c9.", "Proof.", "induction n; cbn; now apply M_om1.", "Qed.", "Definition trans x := forall y, y \u2208 x -> y \u2286 x.", "Lemma numeral_trans n : trans (numeral n).", "Proof.", "induction n; cbn.", "-", "intros x H.", "now apply M_eset in H.", "-", "intros x [H| ->] % sigma_el; try apply sigma_sub.", "apply IHn in H.", "intuition eauto using sigma_sub.", "Qed.", "Lemma numeral_wf n : ~ numeral n \u2208 numeral n.", "Proof.", "induction n.", "-", "apply M_eset.", "-", "intros [H|H] % sigma_el; fold numeral in *.", "+", "apply IHn.", "eapply numeral_trans; eauto.", "apply sigma_eq.", "+", "assert (numeral n \u2208 numeral (S n)) by apply sigma_eq.", "now rewrite H in H0.", "Qed.", "Lemma numeral_lt k l : k < l -> numeral k \u2208 numeral l.", "Proof.", "induction 1; cbn; apply sigma_el; auto.", "Qed.", "Lemma numeral_inj k l : numeral k = numeral l -> k = l.", "Proof.", "intros Hk.", "assert (k = l \\/ k < l \\/ l < k) as [H|[H|H]] by lia; trivial.", "all: apply numeral_lt in H; rewrite Hk in H; now apply numeral_wf in H.", "Qed.", "Definition M_enc_bool (x : bool) := if x then {\u2205; \u2205} else \u2205.", "Fixpoint M_prep_string (s : string bool) x := match s with | nil => x | b::s => M_opair (M_enc_bool b) (M_prep_string s x) end.", "Definition M_enc_string (s : string bool) := M_prep_string s \u2205.", "Definition M_enc_card s t := M_opair (M_enc_string s) (M_enc_string t).", "Fixpoint M_enc_stack (B : BSRS) := match B with | nil => \u2205 | (s,t)::B => M_enc_stack B \u222a M_sing (M_enc_card s t) end.", "Lemma enc_bool_inj b c : M_enc_bool b = M_enc_bool c -> b = c.", "Proof.", "destruct b, c; trivial; cbn.", "-", "intros H.", "contradiction (@M_eset \u2205).", "pattern \u2205 at 2.", "rewrite <- H.", "apply M_pair; auto.", "-", "intros H.", "contradiction (@M_eset \u2205).", "pattern \u2205 at 2.", "rewrite H.", "apply M_pair; auto.", "Qed.", "Lemma enc_string_inj s t : M_enc_string s = M_enc_string t -> s = t.", "Proof.", "induction s in t|-*; destruct t as [|b t]; cbn; trivial.", "-", "intros H.", "contradiction (M_eset (x:=M_sing (M_enc_bool b))).", "rewrite H.", "apply M_pair.", "now left.", "-", "intros H.", "contradiction (M_eset (x:=M_sing (M_enc_bool a))).", "rewrite <- H.", "apply M_pair.", "now left.", "-", "intros [H1 H2] % opair_inj.", "apply IHs in H2 as ->.", "apply enc_bool_inj in H1 as ->.", "reflexivity.", "Qed.", "Lemma eval_opair rho x y : eval rho (opair x y) = M_opair (eval rho x) (eval rho y).", "Proof.", "reflexivity.", "Qed.", "Lemma eval_enc_bool rho b : eval rho (enc_bool b) = M_enc_bool b.", "Proof.", "destruct b; reflexivity.", "Qed.", "Lemma eval_prep_string rho s x : eval rho (prep_string s x) = M_prep_string s (eval rho x).", "Proof.", "induction s; trivial.", "cbn [prep_string].", "now rewrite eval_opair, IHs, eval_enc_bool.", "Qed.", "Lemma eval_enc_string rho s : eval rho (enc_string s) = M_enc_string s.", "Proof.", "unfold enc_string.", "now rewrite eval_prep_string.", "Qed.", "Lemma eval_enc_stack rho B : eval rho (enc_stack B) = M_enc_stack B.", "Proof.", "induction B; cbn; trivial.", "destruct a.", "unfold M_enc_card.", "now rewrite <- IHB, <- !eval_enc_string with (rho:=rho), <- eval_opair.", "Qed.", "Lemma M_enc_stack_app A B : M_enc_stack (A ++ B) = M_enc_stack A \u222a M_enc_stack B.", "Proof.", "induction A as [|[s t] A IH]; cbn.", "-", "apply binunion_eset.", "-", "rewrite IH.", "rewrite !binunion_assoc.", "now rewrite (binunion_com (M_enc_stack B) (M_sing (M_enc_card s t))).", "Qed.", "Lemma enc_stack_el' x A : x \u2208 M_enc_stack A -> exists s t, (s, t) el A /\\ x = M_enc_card s t.", "Proof.", "induction A as [|[s t] A IH]; cbn.", "-", "now intros H % M_eset.", "-", "intros [H|H] % binunion_el.", "+", "destruct (IH H) as (u&v&H'&->).", "exists u, v.", "intuition.", "+", "apply sing_el in H as ->.", "exists s, t.", "intuition.", "Qed.", "Lemma enc_stack_el B s t : (s, t) el B -> M_enc_card s t \u2208 M_enc_stack B.", "Proof.", "induction B as [|[u b] B IH]; cbn; auto.", "intros [H|H]; apply binunion_el.", "-", "right.", "apply sing_el.", "congruence.", "-", "left.", "apply IH, H.", "Qed.", "Lemma M_prep_enc s s' : M_prep_string s (M_enc_string s') = M_enc_string (s ++ s').", "Proof.", "induction s; cbn; trivial.", "now rewrite IHs.", "Qed.", "Definition append_all A (c : card bool) := map (fun p => (fst c ++ fst p, snd c ++ snd p)) A.", "Definition derivation_step B C := flat_map (append_all C) B.", "Fixpoint derivations B n := match n with | O => B | S n => derivation_step B (derivations B n) end.", "Lemma derivable_derivations B s t : derivable B s t -> exists n, (s, t) el derivations B n.", "Proof.", "induction 1.", "-", "exists 0.", "apply H.", "-", "destruct IHderivable as [n Hn].", "exists (S n).", "apply in_flat_map.", "exists (x, y).", "split; trivial.", "apply in_map_iff.", "exists (u,v).", "cbn.", "split; trivial.", "Qed.", "Fixpoint M_enc_derivations B n := match n with | O => M_sing (M_opair \u2205 (M_enc_stack B)) | S n => M_enc_derivations B n \u222a M_sing (M_opair (numeral (S n)) (M_enc_stack (derivations B (S n)))) end.", "Lemma enc_derivations_base B n : M_opair \u2205 (M_enc_stack B) \u2208 M_enc_derivations B n.", "Proof.", "induction n; cbn.", "-", "now apply sing_el.", "-", "apply binunion_el.", "now left.", "Qed.", "Lemma enc_derivations_bound B n k x : M_opair k x \u2208 M_enc_derivations B n -> k \u2208 \u03c3 (numeral n).", "Proof.", "induction n; cbn.", "-", "intros H % sing_el.", "apply opair_inj in H as [-> _].", "apply sigma_el.", "now right.", "-", "intros [H|H] % binunion_el.", "+", "apply sigma_el.", "left.", "apply IHn, H.", "+", "apply sing_el in H.", "apply opair_inj in H as [-> _].", "apply sigma_eq.", "Qed.", "Lemma enc_derivations_fun B n : forall k x y, M_opair k x \u2208 M_enc_derivations B n -> M_opair k y \u2208 M_enc_derivations B n -> x = y.", "Proof.", "induction n; cbn -[derivations]; intros k x y.", "-", "intros H1 % sing_el H2 % sing_el.", "rewrite <- H2 in H1.", "now apply opair_inj in H1.", "-", "intros [H1|H1 % sing_el] % binunion_el [H2|H2 % sing_el] % binunion_el.", "+", "now apply (IHn k x y).", "+", "exfalso.", "apply enc_derivations_bound in H1.", "destruct (opair_inj H2) as [-> _].", "now apply (@numeral_wf (S n)).", "+", "exfalso.", "apply enc_derivations_bound in H2.", "destruct (opair_inj H1) as [-> _].", "now apply (@numeral_wf (S n)).", "+", "rewrite <- H2 in H1.", "now apply opair_inj in H1.", "Qed.", "Lemma enc_derivations_el B n k x : M_opair k x \u2208 M_enc_derivations B n -> exists l, k = numeral l /\\ x = M_enc_stack (derivations B l).", "Proof.", "induction n; cbn.", "-", "intros H % sing_el.", "exists 0.", "apply (opair_inj H).", "-", "intros [H|H] % binunion_el.", "+", "apply IHn, H.", "+", "apply sing_el in H.", "exists (S n).", "apply (opair_inj H).", "Qed.", "Lemma enc_derivations_step B n l : numeral l \u2208 numeral n -> M_opair (\u03c3 (numeral l)) (M_enc_stack (derivations B (S l))) \u2208 M_enc_derivations B n.", "Proof.", "induction n; cbn -[derivations].", "-", "now intros H % M_eset.", "-", "intros [H|H % sing_el] % binunion_el; apply binunion_el.", "+", "left.", "apply IHn, H.", "+", "right.", "apply numeral_inj in H as ->.", "now apply sing_el.", "Qed.", "Lemma enc_stack_combinations B rho C x X Y : rho \u22a8 combinations B X Y -> eval rho X = M_enc_stack C -> eval rho Y = x -> x = M_enc_stack (derivation_step B C).", "Proof.", "induction B as [|[s t] B IH] in rho,C,x,X,Y |-*.", "-", "cbn.", "rewrite VIEQ.", "now intros -> _ <-.", "-", "intros [x1[x2[[H1 H2]H3]]] R1 R2; fold sat in *.", "assert (x = x2 \u222a x1) as ->.", "{", "rewrite <- R2.", "cbn in H1.", "rewrite !eval_comp in H1.", "apply VIEQ, H1.", "}", "clear H1.", "cbn.", "fold (derivation_step B C).", "rewrite M_enc_stack_app.", "enough (x1 = M_enc_stack (derivation_step B C)) as E1.", "+", "enough (x2 = M_enc_stack (append_all C (s, t))) as E2 by now rewrite E1, E2.", "apply M_ext; intros u Hu.", "*", "apply H3 in Hu as [v [Hv[a [b Ha]]]].", "cbn in Hv.", "erewrite !eval_comp, eval_ext, R1 in Hv; trivial.", "apply enc_stack_el' in Hv as (s'&t'&H&H').", "enough (u = M_enc_card (s++s') (t++t')) as ->.", "{", "apply enc_stack_el.", "apply in_map_iff.", "now exists (s', t').", "}", "cbn in Ha.", "rewrite !VIEQ in Ha.", "destruct Ha as [D1 D2].", "rewrite D1 in H'.", "unfold M_enc_card in H'.", "apply opair_inj in H' as [-> ->].", "rewrite D2; unfold M_enc_card, M_opair; repeat f_equal.", "all: rewrite eval_prep_string; cbn.", "all: apply M_prep_enc.", "*", "apply enc_stack_el' in Hu as (s'&t'&H&->).", "unfold append_all in H.", "eapply in_map_iff in H as [[a b][H H']].", "cbn in H.", "apply H3.", "exists (M_enc_card a b).", "split.", "{", "cbn.", "erewrite !eval_comp, eval_ext, R1; trivial.", "now apply enc_stack_el.", "}", "exists (M_enc_string b), (M_enc_string a).", "split.", "--", "cbn.", "apply VIEQ.", "reflexivity.", "--", "cbn.", "apply VIEQ.", "rewrite !eval_prep_string.", "cbn.", "rewrite !M_prep_enc.", "injection H.", "intros -> ->.", "reflexivity.", "+", "eapply IH; eauto.", "unfold shift.", "now erewrite !eval_comp, eval_ext, R1.", "Qed.", "Lemma enc_derivations_solutions B n rho a b : (a .: b .: M_enc_derivations B n .: numeral n .: rho) \u22a8 solutions B $2 $3.", "Proof.", "cbn.", "split.", "-", "rewrite eval_enc_stack.", "apply enc_derivations_base.", "-", "intros k x x' H1 H2 H3.", "destruct (enc_derivations_el H2) as [l[-> ->]].", "specialize (enc_derivations_step B H1).", "replace (M_enc_stack (derivations B (S l))) with x'; trivial.", "apply (enc_stack_combinations H3); trivial.", "Qed.", "Lemma derivations_enc_derivations B n : M_opair (numeral n) (M_enc_stack (derivations B n)) \u2208 M_enc_derivations B n.", "Proof.", "induction n; cbn -[derivations].", "-", "now apply sing_el.", "-", "apply binunion_el.", "right.", "now apply sing_el.", "Qed.", "Lemma derivations_el B n s t : (s, t) el derivations B n -> M_enc_card s t \u2208 M_enc_stack (derivations B n).", "Proof.", "apply enc_stack_el.", "Qed.", "Theorem PCP_ZF1 B s : derivable B s s -> forall rho, rho \u22a8 solvable B.", "Proof.", "intros H rho.", "destruct (derivable_derivations H) as [n Hn].", "unfold solvable.", "exists (numeral n), (M_enc_derivations B n), (M_enc_string s), (M_enc_stack (derivations B n)).", "split; [split; [split; [split |] |] |].", "-", "apply numeral_omega.", "-", "unfold function'.", "intros k x y H1 H2.", "apply VIEQ.", "apply (enc_derivations_fun H1 H2).", "-", "apply enc_derivations_solutions.", "-", "cbn.", "apply derivations_enc_derivations.", "-", "now apply enc_stack_el.", "Qed.", "Definition M_comb_rel s t := fun u v => exists u1 u2, u = M_opair u1 u2 /\\ v = M_opair (M_prep_string s u1) (M_prep_string t u2).", "Fixpoint M_combinations B x y := match B with | nil => y = \u2205 | (s,t)::B => exists y1 y2, y = y2 \u222a y1 /\\ M_combinations B x y1 /\\ M_is_rep (M_comb_rel s t) x y2 end.", "Lemma M_combinations_spec B rho x y a b : M_combinations B x y -> eval rho a = x -> eval rho b = y -> rho \u22a8 combinations B a b.", "Proof.", "induction B in y,a,b,rho|-*; cbn.", "-", "rewrite VIEQ.", "now intros -> _ ->.", "-", "destruct a0 as [s t].", "intros (y1&y2&H1&H2&H3) Ha Hb.", "exists y1, y2.", "repeat split.", "+", "cbn.", "apply VIEQ.", "erewrite !eval_comp.", "unfold funcomp.", "cbn.", "change (eval (fun x => rho x) b) with (eval rho b).", "now rewrite Hb.", "+", "eapply (IHB _ y1); trivial.", "erewrite !eval_comp.", "unfold funcomp.", "cbn.", "change (eval (fun x => rho x) a) with (eval rho a).", "now rewrite Ha.", "+", "intros (u & Hu & c & d' & H) % H3.", "exists u.", "split.", "*", "cbn.", "erewrite !eval_comp.", "erewrite eval_ext, Ha; trivial.", "*", "exists d', c.", "cbn.", "rewrite !VIEQ, !eval_prep_string.", "apply H.", "+", "intros (u & Hu & c & d' & H).", "apply H3.", "exists u.", "split.", "*", "cbn in Hu.", "erewrite !eval_comp in Hu.", "rewrite <- Ha.", "apply Hu.", "*", "exists d', c.", "cbn in H.", "rewrite !VIEQ, !eval_prep_string in H.", "apply H.", "Qed.", "Definition M_solutions B f n := M_opair \u2205 (M_enc_stack B) \u2208 f /\\ forall k x y, k \u2208 n -> M_opair k x \u2208 f -> M_combinations B x y -> M_opair (\u03c3 k) y \u2208 f.", "Lemma comb_rel_rep C s t : M_is_rep (M_comb_rel s t) (M_enc_stack C) (M_enc_stack (append_all C (s, t))).", "Proof.", "intros y.", "split.", "-", "intros (u&v&H&->) % enc_stack_el'.", "unfold append_all in H.", "apply in_map_iff in H as [[a b][H1 H2]].", "cbn in H1.", "exists (M_enc_card a b).", "split; try now apply enc_stack_el.", "exists (M_enc_string a), (M_enc_string b).", "split; trivial.", "assert (u = s++a) as -> by congruence.", "assert (v = t++b) as -> by congruence.", "now rewrite !M_prep_enc.", "-", "intros (u&H&a&b&->&->).", "apply enc_stack_el' in H as [u[v[H1 H2]]].", "apply opair_inj in H2 as [-> ->].", "rewrite !M_prep_enc.", "apply enc_stack_el.", "apply in_map_iff.", "now exists (u, v).", "Qed.", "Lemma M_combinations_step B C : M_combinations B (M_enc_stack C) (M_enc_stack (derivation_step B C)).", "Proof.", "induction B as [|[s t] B IH]; cbn; trivial.", "exists (M_enc_stack (derivation_step B C)), (M_enc_stack (append_all C (s, t))).", "rewrite M_enc_stack_app.", "split; trivial.", "split; trivial.", "apply comb_rel_rep.", "Qed.", "Lemma solutions_derivations B f n k : M_solutions B f (numeral n) -> k <= n -> M_opair (numeral k) (M_enc_stack (derivations B k)) \u2208 f.", "Proof.", "intros H Hk; induction k; cbn.", "-", "apply H.", "-", "assert (Hk' : k <= n) by lia.", "specialize (IHk Hk').", "destruct H as [_ H].", "eapply H in IHk; eauto.", "+", "now apply numeral_lt.", "+", "apply M_combinations_step.", "Qed.", "Lemma derivations_derivable B n s t : (s, t) el derivations B n -> derivable B s t.", "Proof.", "induction n in s,t|-*; cbn.", "-", "now constructor.", "-", "unfold derivation_step.", "intros [[u v][H1 H2]] % in_flat_map.", "unfold append_all in H2.", "apply in_map_iff in H2 as [[a b][H2 H3]].", "cbn in H2.", "assert (s = u++a) as -> by congruence.", "assert (t = v++b) as -> by congruence.", "constructor 2; trivial.", "apply IHn, H3.", "Qed.", "Definition M_function f := forall x y y', M_opair x y \u2208 f -> M_opair x y' \u2208 f -> y = y'.", "Definition standard := forall x, x \u2208 \u03c9 -> exists n, x \u2261 numeral n.", "Lemma M_solutions_el B f k X p : standard -> k \u2208 \u03c9 -> M_function f -> M_solutions B f k -> M_opair k X \u2208 f -> p \u2208 X -> exists u v, p = M_enc_card u v /\\ derivable B u v.", "Proof.", "intros HS HO Hf Hk HX Hp.", "destruct (HS k HO) as [n -> % VIEQ].", "pose proof (H := solutions_derivations Hk (le_n n)).", "rewrite (Hf _ _ _ HX H) in Hp.", "apply enc_stack_el' in Hp as (s&t&H'&->).", "exists s, t.", "split; trivial.", "eapply derivations_derivable; eauto.", "Qed.", "Theorem PCP_ZF2 B rho : standard -> rho \u22a8 solvable B -> exists s, derivable B s s.", "Proof.", "intros VIN (n & f & s & X & [[[[H1 H2] H3] H4] H5]).", "assert (H1' : n \u2208 \u03c9) by apply H1.", "clear H1.", "assert (H4' : M_opair n X \u2208 f) by apply H4.", "clear H4.", "assert (H5' : M_opair s s \u2208 X) by apply H5.", "clear H5.", "assert (H2' : M_function f).", "{", "intros x y y' H H'.", "apply VIEQ.", "eapply H2.", "apply H.", "apply H'.", "}", "clear H2.", "assert (H3' : M_opair \u2205 (M_enc_stack B) \u2208 f).", "{", "erewrite <- eval_enc_stack.", "apply H3.", "}", "destruct H3 as [_ H3].", "assert (H3'' : forall k x y, k \u2208 n -> M_opair k x \u2208 f -> M_combinations B x y -> M_opair (\u03c3 k) y \u2208 f).", "{", "intros k x y Hn Hk Hy.", "apply (H3 k x y); auto.", "fold sat.", "eapply M_combinations_spec; eauto.", "}", "clear H3.", "destruct (@M_solutions_el B f n X (M_opair s s)) as (u&v&H1&H2); trivial.", "now split.", "exists u.", "apply opair_inj in H1 as [H ->].", "apply enc_string_inj in H as ->.", "apply H2.", "Qed.", "End ZF.", "Arguments standard {_} _.", "Theorem PCP_ZF' B : (exists V (M : interp V), extensional M /\\ standard M /\\ forall rho, rho \u22ab ZF') -> PCPb B <-> entailment_ZF' (solvable B).", "Proof.", "intros HZF.", "rewrite PCPb_iff_dPCPb.", "split; intros H.", "-", "clear HZF.", "destruct H as [s H].", "intros M HM rho H1 H2.", "eapply PCP_ZF1; eauto.", "-", "destruct HZF as (M & H1 & H2 & H3 & H4).", "specialize (H M H1 (fun _ => @i_func _ _ _ _ eset Vector.nil) H2 H4).", "apply PCP_ZF2 in H as [s Hs]; trivial.", "now exists s.", "Qed.", "Theorem PCP_ZF B : (exists V (M : interp V), extensional M /\\ standard M /\\ forall rho psi, ZF psi -> rho \u22a8 psi) -> PCPb B <-> entailment_ZF (solvable B).", "Proof.", "intros HZF.", "rewrite PCPb_iff_dPCPb.", "split; intros H.", "-", "clear HZF.", "destruct H as [s H].", "intros M HM rho H1 H2.", "eapply PCP_ZF1; eauto.", "intros sigma phi HP.", "apply H2.", "now constructor.", "-", "destruct HZF as (M & H1 & H2 & H3 & H4).", "specialize (H M H1 (fun _ => @i_func _ _ _ _ eset Vector.nil) H2 H4).", "apply PCP_ZF2 in H as [s Hs]; trivial; try now exists s.", "intros sigma phi HP.", "apply H4.", "now constructor.", "Qed.", "Lemma extensional_eq V (M : interp V) rho : extensional M -> rho \u22ab ZF' -> rho \u22ab ZFeq'.", "Proof.", "intros H1 H2 phi [<-|[<-|[<-|[<-|H]]]]; try now apply H2.", "all: cbn; intros; rewrite !H1 in *; congruence.", "Qed."], "theorems": [{"name": "M_ext", "kind": "Lemma", "begin": 44, "end": 49}, {"name": "M_eset", "kind": "Lemma", "begin": 50, "end": 54}, {"name": "M_pair", "kind": "Lemma", "begin": 55, "end": 60}, {"name": "M_union", "kind": "Lemma", "begin": 61, "end": 65}, {"name": "M_power", "kind": "Lemma", "begin": 66, "end": 70}, {"name": "M_om1", "kind": "Lemma", "begin": 72, "end": 76}, {"name": "M_om2", "kind": "Lemma", "begin": 77, "end": 81}, {"name": "M_sep", "kind": "Lemma", "begin": 84, "end": 95}, {"name": "is_rep_unique", "kind": "Lemma", "begin": 97, "end": 107}, {"name": "M_rep", "kind": "Lemma", "begin": 110, "end": 151}, {"name": "binunion_el", "kind": "Lemma", "begin": 154, "end": 172}, {"name": "sing_el", "kind": "Lemma", "begin": 173, "end": 182}, {"name": "M_pair1", "kind": "Lemma", "begin": 183, "end": 187}, {"name": "M_pair2", "kind": "Lemma", "begin": 188, "end": 192}, {"name": "sing_pair", "kind": "Lemma", "begin": 193, "end": 207}, {"name": "opair_inj1", "kind": "Lemma", "begin": 208, "end": 214}, {"name": "opair_inj2", "kind": "Lemma", "begin": 215, "end": 236}, {"name": "opair_inj", "kind": "Lemma", "begin": 237, "end": 245}, {"name": "sigma_el", "kind": "Lemma", "begin": 246, "end": 257}, {"name": "sigma_eq", "kind": "Lemma", "begin": 258, "end": 262}, {"name": "sigma_sub", "kind": "Lemma", "begin": 263, "end": 268}, {"name": "binunion_eset", "kind": "Lemma", "begin": 269, "end": 282}, {"name": "pair_com", "kind": "Lemma", "begin": 283, "end": 286}, {"name": "binunion_com", "kind": "Lemma", "begin": 287, "end": 290}, {"name": "binunionl", "kind": "Lemma", "begin": 291, "end": 296}, {"name": "binunionr", "kind": "Lemma", "begin": 297, "end": 302}, {"name": "binunion_assoc", "kind": "Lemma", "begin": 304, "end": 311}, {"name": "numeral_omega", "kind": "Lemma", "begin": 313, "end": 316}, {"name": "numeral_trans", "kind": "Lemma", "begin": 318, "end": 328}, {"name": "numeral_wf", "kind": "Lemma", "begin": 329, "end": 343}, {"name": "numeral_lt", "kind": "Lemma", "begin": 344, "end": 347}, {"name": "numeral_inj", "kind": "Lemma", "begin": 348, "end": 353}, {"name": "enc_bool_inj", "kind": "Lemma", "begin": 359, "end": 374}, {"name": "enc_string_inj", "kind": "Lemma", "begin": 375, "end": 395}, {"name": "eval_opair", "kind": "Lemma", "begin": 396, "end": 399}, {"name": "eval_enc_bool", "kind": "Lemma", "begin": 400, "end": 403}, {"name": "eval_prep_string", "kind": "Lemma", "begin": 404, "end": 409}, {"name": "eval_enc_string", "kind": "Lemma", "begin": 410, "end": 414}, {"name": "eval_enc_stack", "kind": "Lemma", "begin": 415, "end": 421}, {"name": "M_enc_stack_app", "kind": "Lemma", "begin": 422, "end": 431}, {"name": "enc_stack_el'", "kind": "Lemma", "begin": 432, "end": 447}, {"name": "enc_stack_el", "kind": "Lemma", "begin": 448, "end": 459}, {"name": "M_prep_enc", "kind": "Lemma", "begin": 460, "end": 464}, {"name": "derivable_derivations", "kind": "Lemma", "begin": 468, "end": 484}, {"name": "enc_derivations_base", "kind": "Lemma", "begin": 486, "end": 494}, {"name": "enc_derivations_bound", "kind": "Lemma", "begin": 495, "end": 513}, {"name": "enc_derivations_fun", "kind": "Lemma", "begin": 514, "end": 538}, {"name": "enc_derivations_el", "kind": "Lemma", "begin": 539, "end": 554}, {"name": "enc_derivations_step", "kind": "Lemma", "begin": 555, "end": 569}, {"name": "enc_stack_combinations", "kind": "Lemma", "begin": 570, "end": 646}, {"name": "enc_derivations_solutions", "kind": "Lemma", "begin": 647, "end": 660}, {"name": "derivations_enc_derivations", "kind": "Lemma", "begin": 661, "end": 670}, {"name": "derivations_el", "kind": "Lemma", "begin": 671, "end": 674}, {"name": "PCP_ZF1", "kind": "Theorem", "begin": 675, "end": 696}, {"name": "M_combinations_spec", "kind": "Lemma", "begin": 699, "end": 753}, {"name": "comb_rel_rep", "kind": "Lemma", "begin": 755, "end": 779}, {"name": "M_combinations_step", "kind": "Lemma", "begin": 780, "end": 788}, {"name": "solutions_derivations", "kind": "Lemma", "begin": 789, "end": 803}, {"name": "derivations_derivable", "kind": "Lemma", "begin": 804, "end": 819}, {"name": "M_solutions_el", "kind": "Lemma", "begin": 822, "end": 832}, {"name": "PCP_ZF2", "kind": "Theorem", "begin": 833, "end": 871}, {"name": "PCP_ZF'", "kind": "Theorem", "begin": 874, "end": 889}, {"name": "PCP_ZF", "kind": "Theorem", "begin": 890, "end": 910}, {"name": "extensional_eq", "kind": "Lemma", "begin": 911, "end": 915}]}