{"code": ["Require Import List Arith.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_decidable utils_nat.", "From Undecidability.DiophantineConstraints Require Import H10C.", "Set Implicit Arguments.", "Local Notation \"\u301a c \u301b\" := (h10c_sem c).", "Local Notation \" '\u27ea' c '\u27eb' \" := (fun \u03c6 => h10uc_sem \u03c6 c).", "Section decidability_of_validity.", "Let plus_swap (P Q : Prop) : { P } + { Q } -> { Q } + { P }.", "Proof.", "tauto.", "Qed.", "Fact h10c_sem_dec c \u03c6 : {\u301ac\u301b\u03c6 } + { ~\u301ac\u301b\u03c6 }.", "Proof.", "destruct c; apply eq_nat_dec.", "Qed.", "Fact h10lc_sem_dec l \u03c6 : { c | In c l /\\ ~\u301ac\u301b\u03c6 } + { forall c, In c l ->\u301ac\u301b\u03c6 }.", "Proof.", "apply list_choose_dep.", "intros c _; apply plus_swap, h10c_sem_dec.", "Qed.", "Fact h10luc_sem_dec l \u03c6 : { c | In c l /\\ ~ \u27eac\u27eb \u03c6 } + { forall c, In c l -> \u27eac\u27eb \u03c6 }.", "Proof.", "apply list_choose_dep.", "intros c _; apply plus_swap.", "destruct c as ((?,?),?); apply eq_nat_dec.", "Qed.", "End decidability_of_validity.", "Section h10c_vars_bound.", "Definition h10c_vars c := match c with | h10c_one x => x::nil | h10c_plus x y z => x::y::z::nil | h10c_mult x y z => x::y::z::nil end.", "Definition h10uc_vars (c : h10uc) := match c with (x,y,z) => x::y::z::nil end.", "Fact h10c_vars_equiv c phi psy : (forall x, In x (h10c_vars c) -> phi x = psy x) -> \u301ac\u301bphi <->\u301ac\u301bpsy.", "Proof.", "destruct c; simpl; intros H; repeat rewrite H; tauto.", "Qed.", "Fact h10uc_vars_equiv c phi psy : (forall x, In x (h10uc_vars c) -> phi x = psy x) -> \u27eac\u27eb phi <-> \u27eac\u27eb psy.", "Proof.", "destruct c as ((?,?),?); simpl; intros H; repeat rewrite H; tauto.", "Qed.", "Definition h10lc_vars := flat_map h10c_vars.", "Definition h10luc_vars := flat_map h10uc_vars.", "Fact h10lc_vars_equiv l phi psy : (forall x, In x (h10lc_vars l) -> phi x = psy x) -> forall c, In c l ->\u301ac\u301bphi <->\u301ac\u301bpsy.", "Proof.", "intros H c Hc.", "apply h10c_vars_equiv.", "intros x Hx; apply H, in_flat_map.", "exists c; auto.", "Qed.", "Fact h10luc_vars_equiv l phi psy : (forall x, In x (h10luc_vars l) -> phi x = psy x) -> forall c, In c l -> \u27eac\u27eb phi <-> \u27eac\u27eb psy.", "Proof.", "intros H c Hc.", "apply h10uc_vars_equiv.", "intros x Hx; apply H, in_flat_map.", "exists c; auto.", "Qed.", "Definition h10lc_bound l := S (lmax (h10lc_vars l)).", "Definition h10luc_bound l := S (lmax (h10luc_vars l)).", "Fact h10lc_bound_prop l phi psy : (forall x, x < h10lc_bound l -> phi x = psy x) -> forall c, In c l ->\u301ac\u301bphi <->\u301ac\u301bpsy.", "Proof.", "intros H; apply h10lc_vars_equiv.", "intros x Hc; apply H, le_n_S, lmax_prop; auto.", "Qed.", "Fact h10luc_bound_prop l phi psy : (forall x, x < h10luc_bound l -> phi x = psy x) -> forall c, In c l -> \u27eac\u27eb phi <-> \u27eac\u27eb psy.", "Proof.", "intros H; apply h10luc_vars_equiv.", "intros x Hc; apply H, le_n_S, lmax_prop; auto.", "Qed.", "End h10c_vars_bound."], "theorems": [{"name": "plus_swap", "kind": "Let", "begin": 7, "end": 10}, {"name": "h10c_sem_dec", "kind": "Fact", "begin": 11, "end": 14}, {"name": "h10lc_sem_dec", "kind": "Fact", "begin": 15, "end": 19}, {"name": "h10luc_sem_dec", "kind": "Fact", "begin": 20, "end": 25}, {"name": "h10c_vars_equiv", "kind": "Fact", "begin": 30, "end": 33}, {"name": "h10uc_vars_equiv", "kind": "Fact", "begin": 34, "end": 37}, {"name": "h10lc_vars_equiv", "kind": "Fact", "begin": 40, "end": 46}, {"name": "h10luc_vars_equiv", "kind": "Fact", "begin": 47, "end": 53}, {"name": "h10lc_bound_prop", "kind": "Fact", "begin": 56, "end": 60}, {"name": "h10luc_bound_prop", "kind": "Fact", "begin": 61, "end": 65}]}