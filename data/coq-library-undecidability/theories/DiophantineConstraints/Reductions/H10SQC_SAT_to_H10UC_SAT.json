{"code": ["Require Import List Lia.", "Import ListNotations.", "Require Import Undecidability.DiophantineConstraints.H10C.", "Require Import ssreflect ssrbool ssrfun.", "Set Default Proof Using \"Type\".", "Set Default Goal Selector \"!\".", "Module Argument.", "Definition encode '(x, y) : nat := y + (nat_rec _ 0 (fun i m => (S i) + m) (y + x)).", "Definition decode (n : nat) : nat * nat := nat_rec _ (0, 0) (fun _ '(x, y) => if x is S x then (x, S y) else (S y, 0)) n.", "Lemma decode_encode {xy: nat * nat} : decode (encode xy) = xy.", "Proof.", "move Hn: (encode xy) => n.", "elim: n xy Hn.", "{", "by move=> [[|?] [|?]].", "}", "move=> n IH [x [|y [H]]] /=.", "{", "move: x => [|x [H]] /=; first done.", "by rewrite (IH (0, x)) /= -?H ?PeanoNat.Nat.add_0_r.", "}", "by rewrite (IH (S x, y)) /= -?H ?PeanoNat.Nat.add_succ_r.", "Qed.", "Opaque encode decode.", "Lemma ForallE {X : Type} {P : X -> Prop} {l} : Forall P l -> if l is x :: l then P x /\\ Forall P l else True.", "Proof.", "by case.", "Qed.", "Lemma Forall_flat_map_iff {T U: Type} {P : T -> Prop} {ds : list U} {f : U -> list T} : Forall P (flat_map f ds) <-> Forall (fun d => Forall P (f d)) ds.", "Proof.", "elim: ds; first by (constructor=> /=).", "move=> a l IH /=.", "rewrite Forall_app.", "constructor.", "-", "move=> [? ?].", "constructor; [done | by apply /IH].", "-", "by move=> /ForallE [? /IH ?].", "Qed.", "Section Reduction.", "Context (sqcs: list h10sqc).", "Definition \u03b6 (x t: nat) := encode (1 + x, encode (0, t)).", "Definition \u03b8 (x y t: nat) := encode (1 + x, encode (1 + y, t)).", "Definition v (t: nat) := encode (0, t).", "Definition v012 := [(v 0, v 1, v 2); (v 1, v 0, v 2); (v 0, v 0, v 1)].", "Definition h10sqc_to_h10ucs (c : h10sqc) : list h10uc := match c with | h10sqc_one x => [(v 0, v 0, \u03b6 x 0)] | h10sqc_sq x y => [(v 0, \u03b6 x 0, \u03b6 y 1); (\u03b6 y 0, v 0, \u03b6 y 1)] | h10sqc_plus x y z => [ (\u03b6 x 0, v 0, \u03b6 x 1); (v 0, \u03b6 x 1, \u03b6 x 2); (\u03b6 x 3, \u03b6 x 0, \u03b6 x 2); (\u03b6 y 0, v 0, \u03b6 y 1); (\u03b6 x 3, \u03b6 y 1, \u03b8 x y 0); (\u03b8 x y 1, \u03b6 y 0, \u03b8 x y 0); (\u03b6 z 0, v 0, \u03b6 z 1); (v 1, \u03b6 z 1, \u03b8 x y 2); (\u03b8 x y 1, \u03b6 z 0, \u03b8 x y 2)] end.", "Definition ucs := v012 ++ flat_map h10sqc_to_h10ucs sqcs.", "Section Transport.", "Context (\u03c6 : nat -> nat) (H\u03c6: forall c, In c sqcs -> h10sqc_sem \u03c6 c).", "Definition \u03c6' (n: nat) := match decode n with | (0, 0) => 0 | (0, 1) => 1 | (0, 2) => 2 | (0, _) => 0 | (S x, m) => match decode m with | (0, 0) => (\u03c6 x) | (0, 1) => 1 + (\u03c6 x) | (0, 2) => 1 + (1 + (\u03c6 x)) * (1 + (\u03c6 x)) | (0, 3) => 1 + (\u03c6 x) + (\u03c6 x) | (S y, 0) => 2 + (\u03c6 x) + (\u03c6 x) + (1 + (\u03c6 y)) * (1 + (\u03c6 y)) | (S y, 1) => 2 + (\u03c6 x) + (\u03c6 x) + (\u03c6 y) + (\u03c6 y) | (S y, 2) => 2 + (1 + (\u03c6 x) + (\u03c6 y)) * (1 + (\u03c6 x) + (\u03c6 y)) | (_, _) => 0 end end.", "Lemma h10sqc_to_h10ucs_spec {c} : h10sqc_sem \u03c6 c -> Forall (h10uc_sem \u03c6') (h10sqc_to_h10ucs c).", "Proof.", "case: c => /=.", "-", "move=> x ?.", "constructor; last done.", "rewrite /= /\u03b6 /\u03c6' /v ?decode_encode /=.", "by lia.", "-", "move=> x y z ?.", "(do ? constructor); rewrite /= /\u03b6 /\u03c6' /\u03b8 ?decode_encode /=; by nia.", "-", "move=> x y ?.", "(do ? constructor); rewrite /= /\u03b6 /\u03c6' ?decode_encode /=; by nia.", "Qed.", "End Transport.", "Lemma transport : H10SQC_SAT sqcs -> H10UC_SAT ucs.", "Proof.", "move=> [\u03c6 H\u03c6].", "exists (\u03c6' \u03c6).", "move: H\u03c6.", "rewrite -?Forall_forall /ucs Forall_app Forall_flat_map_iff.", "move=> H.", "constructor.", "-", "by do ? constructor.", "-", "apply: Forall_impl H => ?.", "by move /h10sqc_to_h10ucs_spec.", "Qed.", "Section InverseTransport.", "Context (\u03c6' : nat -> nat) (H\u03c6': forall c, In c ucs -> h10uc_sem \u03c6' c).", "Definition \u03c6 (x: nat) := \u03c6' (\u03b6 x 0).", "Lemma v_spec : \u03c6' (v 0) = 0 /\\ \u03c6' (v 1) = 1.", "Proof using H\u03c6'.", "move: (H\u03c6').", "rewrite -Forall_forall /ucs Forall_app /v012.", "move=> [/ForallE [+]] /ForallE [+] /ForallE [+] _ _ => /=.", "by lia.", "Qed.", "Lemma h10sqc_of_h10ucs_spec {c} : Forall (h10uc_sem \u03c6') (h10sqc_to_h10ucs c) -> h10sqc_sem \u03c6 c.", "Proof using H\u03c6'.", "case: c => /=.", "-", "move=> x /ForallE [].", "rewrite /= ?(proj1 v_spec) /\u03c6.", "by lia.", "-", "move=> x y z.", "do 9 (move=> /ForallE /and_comm []).", "rewrite /= ?(proj1 v_spec) ?(proj2 v_spec) /\u03c6.", "by lia.", "-", "move=> x y /ForallE [+] /ForallE [+ _].", "rewrite /= ?(proj1 v_spec) /\u03c6.", "by lia.", "Qed.", "End InverseTransport.", "Lemma inverse_transport : H10UC_SAT ucs -> H10SQC_SAT sqcs.", "Proof.", "move=> [\u03c6' H\u03c6'].", "exists (\u03c6 \u03c6').", "move: (H\u03c6').", "rewrite -?Forall_forall /ucs Forall_app Forall_flat_map_iff.", "move=> [?].", "apply: Forall_impl => ?.", "by apply: h10sqc_of_h10ucs_spec.", "Qed.", "End Reduction.", "End Argument.", "Require Import Undecidability.Synthetic.Definitions.", "Theorem reduction : H10SQC_SAT \u2aaf H10UC_SAT.", "Proof.", "exists (fun sqcs => Argument.ucs sqcs) => sqcs.", "constructor.", "-", "exact: Argument.transport.", "-", "exact: Argument.inverse_transport.", "Qed."], "theorems": [{"name": "decode_encode", "kind": "Lemma", "begin": 9, "end": 22}, {"name": "ForallE", "kind": "Lemma", "begin": 24, "end": 27}, {"name": "Forall_flat_map_iff", "kind": "Lemma", "begin": 28, "end": 39}, {"name": "h10sqc_to_h10ucs_spec", "kind": "Lemma", "begin": 51, "end": 65}, {"name": "transport", "kind": "Lemma", "begin": 67, "end": 80}, {"name": "v_spec", "kind": "Lemma", "begin": 84, "end": 90}, {"name": "h10sqc_of_h10ucs_spec", "kind": "Lemma", "begin": 91, "end": 107}, {"name": "inverse_transport", "kind": "Lemma", "begin": 109, "end": 118}, {"name": "reduction", "kind": "Theorem", "begin": 122, "end": 130}]}