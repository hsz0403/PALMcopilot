{"code": ["Require Import List Lia.", "Import ListNotations.", "Require Import Undecidability.DiophantineConstraints.H10C.", "Require Import ssreflect ssrbool ssrfun.", "Set Default Proof Using \"Type\".", "Set Default Goal Selector \"!\".", "Module Argument.", "Definition encode '(x, y) : nat := y + (nat_rec _ 0 (fun i m => (S i) + m) (y + x)).", "Definition decode (n : nat) : nat * nat := nat_rec _ (0, 0) (fun _ '(x, y) => if x is S x then (x, S y) else (S y, 0)) n.", "Lemma decode_encode {xy: nat * nat} : decode (encode xy) = xy.", "Proof.", "move Hn: (encode xy) => n.", "elim: n xy Hn.", "{", "by move=> [[|?] [|?]].", "}", "move=> n IH [x [|y [H]]] /=.", "{", "move: x => [|x [H]] /=; first done.", "by rewrite (IH (0, x)) /= -?H ?PeanoNat.Nat.add_0_r.", "}", "by rewrite (IH (S x, y)) /= -?H ?PeanoNat.Nat.add_succ_r.", "Qed.", "Opaque encode decode.", "Lemma ForallE {X : Type} {P : X -> Prop} {l} : Forall P l -> if l is x :: l then P x /\\ Forall P l else True.", "Proof.", "by case.", "Qed.", "Lemma Forall_flat_map_iff {T U: Type} {P : T -> Prop} {ds : list U} {f : U -> list T} : Forall P (flat_map f ds) <-> Forall (fun d => Forall P (f d)) ds.", "Proof.", "elim: ds; first by (constructor=> /=).", "move=> a l IH /=.", "rewrite Forall_app.", "constructor.", "-", "move=> [? ?].", "constructor; [done | by apply /IH].", "-", "by move=> /ForallE [? /IH ?].", "Qed.", "Section Reduction.", "Context (cs: list h10c).", "Definition \u03b6 (x: nat) := encode (x, 0).", "Definition \u03b8 (x y t: nat) := encode (x, 1 + encode (y, t)).", "Definition h10c_to_h10sqcs (c : h10c) : list h10sqc := match c with | h10c_one x => [h10sqc_one (\u03b6 x)] | h10c_plus x y z => [h10sqc_plus (\u03b6 x) (\u03b6 y) (\u03b6 z)] | h10c_mult x y z => [ h10sqc_sq (\u03b6 x) (\u03b8 x y 0); h10sqc_sq (\u03b6 y) (\u03b8 x y 1); h10sqc_plus (\u03b8 x y 0) (\u03b8 x y 1) (\u03b8 x y 2); h10sqc_plus (\u03b6 x) (\u03b6 y) (\u03b8 x y 3); h10sqc_sq (\u03b8 x y 3) (\u03b8 x y 4); h10sqc_plus (\u03b6 z) (\u03b6 z) (\u03b8 x y 5); h10sqc_plus (\u03b8 x y 2) (\u03b8 x y 5) (\u03b8 x y 4)] end.", "Definition sqcs := flat_map h10c_to_h10sqcs cs.", "Section Transport.", "Context (\u03c6 : nat -> nat) (H\u03c6: forall c, In c cs -> h10c_sem c \u03c6).", "Definition \u03c6' (n: nat) := match decode n with | (x, 0) => \u03c6 x | (x, S m) => match decode m with | (y, 0) => (\u03c6 x) * (\u03c6 x) | (y, 1) => (\u03c6 y) * (\u03c6 y) | (y, 2) => (\u03c6 x) * (\u03c6 x) + (\u03c6 y) * (\u03c6 y) | (y, 3) => (\u03c6 x) + (\u03c6 y) | (y, 4) => ((\u03c6 x) + (\u03c6 y)) * ((\u03c6 x) + (\u03c6 y)) | (y, 5) => (\u03c6 x) * (\u03c6 y) + (\u03c6 x) * (\u03c6 y) | (_, _) => 0 end end.", "Lemma h10c_to_h10sqcs_spec {c} : h10c_sem c \u03c6 -> Forall (h10sqc_sem \u03c6') (h10c_to_h10sqcs c).", "Proof.", "case: c => /=.", "-", "move=> x ?.", "constructor; last done.", "by rewrite /= /\u03b6 /\u03c6' decode_encode.", "-", "move=> x y z ?.", "constructor; last done.", "by rewrite /= /\u03b6 /\u03c6' ?decode_encode.", "-", "move=> x y z ?.", "(do ? constructor); rewrite /= /\u03b6 /\u03c6' ?decode_encode /= ?decode_encode; by nia.", "Qed.", "End Transport.", "Lemma transport : H10C_SAT cs -> H10SQC_SAT sqcs.", "Proof.", "move=> [\u03c6 H\u03c6].", "exists (\u03c6' \u03c6).", "move: H\u03c6.", "rewrite -?Forall_forall /sqcs Forall_flat_map_iff.", "apply: Forall_impl => ?.", "by move /h10c_to_h10sqcs_spec.", "Qed.", "Section InverseTransport.", "Context (\u03c6' : nat -> nat) (H\u03c6': forall c, In c sqcs -> h10sqc_sem \u03c6' c).", "Definition \u03c6 (x: nat) := \u03c6' (\u03b6 x).", "Lemma h10c_of_h10sqcs_spec {c} : Forall (h10sqc_sem \u03c6') (h10c_to_h10sqcs c) -> h10c_sem c \u03c6.", "Proof.", "case: c => /=.", "-", "by move=> x /ForallE [].", "-", "by move=> x y z /ForallE [].", "-", "move=> x y z.", "do 7 (move=> /ForallE /and_comm []).", "rewrite /= /\u03c6.", "by nia.", "Qed.", "End InverseTransport.", "Lemma inverse_transport : H10SQC_SAT sqcs -> H10C_SAT cs.", "Proof.", "move=> [\u03c6' H\u03c6'].", "exists (\u03c6 \u03c6').", "move: H\u03c6'.", "rewrite -?Forall_forall /sqcs Forall_flat_map_iff.", "apply: Forall_impl => ?.", "by move=> /h10c_of_h10sqcs_spec.", "Qed.", "End Reduction.", "End Argument.", "Require Import Undecidability.Synthetic.Definitions.", "Theorem reduction : H10C_SAT \u2aaf H10SQC_SAT.", "Proof.", "exists (fun cs => Argument.sqcs cs) => cs.", "constructor.", "-", "exact: Argument.transport.", "-", "exact: Argument.inverse_transport.", "Qed."], "theorems": [{"name": "decode_encode", "kind": "Lemma", "begin": 9, "end": 22}, {"name": "ForallE", "kind": "Lemma", "begin": 24, "end": 27}, {"name": "Forall_flat_map_iff", "kind": "Lemma", "begin": 28, "end": 39}, {"name": "h10c_to_h10sqcs_spec", "kind": "Lemma", "begin": 49, "end": 63}, {"name": "transport", "kind": "Lemma", "begin": 65, "end": 73}, {"name": "h10c_of_h10sqcs_spec", "kind": "Lemma", "begin": 77, "end": 89}, {"name": "inverse_transport", "kind": "Lemma", "begin": 91, "end": 99}, {"name": "reduction", "kind": "Theorem", "begin": 103, "end": 111}]}