{"code": ["Require Import List PeanoNat Lia.", "Import ListNotations.", "Require Undecidability.CounterMachines.CM2.", "Require Undecidability.CounterMachines.CM1.", "Import CM2 (CM2_HALT).", "Import CM1 (CM1_HALT).", "From Undecidability.CounterMachines.Util Require Import Nat_facts List_facts.", "From Undecidability.CounterMachines.Util Require CM1_facts CM2_facts.", "Require Import ssreflect ssrbool ssrfun.", "Set Default Proof Using \"Type\".", "Set Default Goal Selector \"!\".", "Module Argument.", "Import CM2 (Cm2).", "Import CM1 (Cm1).", "Section MM2_CM1.", "Variable (P: Cm2).", "Definition fs (i: nat) : CM1.State := i*6.", "Definition encode_instruction : CM2.Instruction * nat -> list CM1.Instruction := fun '(cm2i, i) => let p := fs i in match cm2i with | CM2.inc false => [(fs (1+i), 0)] ++ (* 2/1, goto i+1 *) [(0, 0); (0, 0); (0, 0); (0, 0); (0, 0)] (* filler *) | CM2.inc true => [(1+p, 0); (fs (1+i), 1)] ++ (* 2/1; 3/2, goto i+1 *) [(0, 0); (0, 0); (0, 0); (0, 0)] (* filler *) | CM2.dec false j => [(4+p, 1)] ++ (* 3/2 *) [(2+p, 0); (3+p, 0); (fs (1+i), 3)] ++ (* fail: 2/1; 2/1; 5/4 goto i+1 *) [(5+p, 2); (fs j, 3)] (* success: 4/3; 5/4 goto j *) | CM2.dec true j => [(4+p, 2)] ++ (* 4/3 *) [(2+p, 0); (3+p, 0); (fs (1+i), 3)] ++ (* fail: 2/1; 2/1; 5/4 goto i+1 *) [(fs j, 3)] ++ (* success: 5/4 goto j *) [(0, 0)] (* filler *) end.", "Local Arguments encode_instruction : simpl never.", "Definition M : list CM1.Instruction := flat_map encode_instruction (combine P (seq 0 (length P))).", "Lemma M_capped : Forall (fun '(_, n) => n < 4) M.", "Proof.", "apply /Forall_flat_map_iff /Forall_forall.", "move=> [[]] [] > _ /=; by (do ? constructor).", "Qed.", "Definition \u03ba (a b c: nat) : nat := 2 ^ a * 3 ^ b * 5 ^ c.", "Definition encodes_config (x: CM2.Config) (y: CM1.Config) : Prop := CM1.state y = fs (CM2.state x) /\\ exists n, CM1.value y = \u03ba (CM2.value1 x) (CM2.value2 x) n.", "Local Arguments encodes_config !x !y /.", "Lemma encodes_config_init : encodes_config {| CM2.state := 0; CM2.value1 := 0; CM2.value2 := 0 |} {| CM1.state := 0; CM1.value := 1 |}.", "Proof.", "constructor; [done | by exists 0].", "Qed.", "Lemma length_encode_instruction {cm2i: CM2.Instruction} {i: nat} : length (encode_instruction (cm2i, i)) = 6.", "Proof.", "by move: cm2i => [] [].", "Qed.", "Lemma length_M : length M = (length P) * 6.", "Proof.", "rewrite /M.", "elim: (P) (n in seq n _); first done.", "move=> ? ? IH n.", "rewrite /= app_length (IH (S n)) length_encode_instruction.", "by lia.", "Qed.", "Lemma seek_M n {i} : nth_error M (n + fs i) = match n with | 0 | 1 | 2 | 3 | 4 | 5 => obind (fun cm2i => nth_error (encode_instruction (cm2i, i)) n) (nth_error P i) | _ => nth_error M (n + fs i) end.", "Proof.", "rewrite /M.", "suff : n < 6 -> forall k, nth_error (flat_map encode_instruction (combine P (seq k (length P)))) (n + fs i) = obind (fun cm2i : CM2.Instruction => nth_error (encode_instruction (cm2i, k + i)) n) (nth_error P i).", "{", "move: n => [|[|[|[|[|[|?]]]]]]; last done.", "all: apply; by lia.", "}", "move=> Hn.", "elim: (P) i; first by move: n {Hn} => [|?] [|?] /=.", "move=> cm2i P' IH [|i] k /=.", "-", "by rewrite /fs ?Nat.add_0_r nth_error_app1 ?length_encode_instruction.", "-", "rewrite nth_error_app2 ?length_encode_instruction; first by (rewrite /fs; lia).", "have ->: n + fs (S i) - 6 = n + fs i by (rewrite /fs; lia).", "rewrite IH.", "move: (nth_error P' i) => [? /= |]; last done.", "by have ->: S (k + i) = k + S i by lia.", "Qed.", "Arguments nth_error : simpl never.", "Arguments Nat.div : simpl never.", "Arguments Nat.modulo : simpl never.", "Lemma \u03ba_pos {X: Type} {x y: X} {a b c: nat} : match \u03ba a b c with | 0 => x | S _ => y end = y.", "Proof.", "rewrite /\u03ba.", "have ? := Nat.pow_nonzero 2 a ltac:(lia).", "have ? := Nat.pow_nonzero 3 b ltac:(lia).", "have ? := Nat.pow_nonzero 5 c ltac:(lia).", "by have -> : let n := 2 ^ a * 3 ^ b * 5 ^ c in n = S (n - 1) by nia.", "Qed.", "Lemma \u03ba_pos' {a b c: nat} : \u03ba a b c = 1 + (\u03ba a b c - 1).", "Proof.", "have := @\u03ba_pos _ false true a b c.", "case: (\u03ba a b c); [done | by lia].", "Qed.", "Lemma \u03ba_21 {a b c: nat} : \u03ba a b c * 2 / 1 = \u03ba (1+a) b c.", "Proof.", "rewrite /\u03ba /= Nat.div_1_r.", "by lia.", "Qed.", "Lemma \u03ba_32 {a b c: nat} : \u03ba (1+a) b c * 3 / 2 = \u03ba a (1+b) c.", "Proof.", "have -> : \u03ba (1+a) b c * 3 = (3 * \u03ba a b c) * 2 by (rewrite /\u03ba /=; lia).", "by rewrite /\u03ba Nat.div_mul /=; lia.", "Qed.", "Lemma \u03ba_43 {a b c: nat} : \u03ba a (1+b) c * 4 / 3 = \u03ba (2+a) b c.", "Proof.", "have -> : \u03ba a (1+b) c * 4 = (4 * \u03ba a b c) * 3 by (rewrite /\u03ba /=; lia).", "by rewrite /\u03ba Nat.div_mul /=; lia.", "Qed.", "Lemma \u03ba_54 {a b c: nat} : \u03ba (2+a) b c * 5 / 4 = \u03ba a b (1+c).", "Proof.", "have -> : \u03ba (2+a) b c * 5 = (5 * \u03ba a b c) * 4 by (rewrite /\u03ba /=; lia).", "by rewrite /\u03ba Nat.div_mul /=; lia.", "Qed.", "Lemma \u03ba_mod2 {a b c: nat} : \u03ba a b c mod 2 = if a is 0 then 1 else 0.", "Proof.", "rewrite /\u03ba.", "rewrite [(_ * 5^_) mod 2]Nat.mul_mod; first by lia.", "rewrite [(_ * 3^_) mod 2]Nat.mul_mod; first by lia.", "rewrite pow_3_mod_2 pow_5_mod_2.", "move: a => [|a]; first done.", "have -> : 2 ^ S a = 2 * 2 ^ a by move=> /=; lia.", "by rewrite [(2 * _) mod 2]Nat.mul_mod; first by lia.", "Qed.", "Lemma \u03ba_mod3 {a b c: nat} : \u03ba a b c mod 3 = if b is 0 then (S (locked (\u03ba a b c) mod 3 - 1)) else 0.", "Proof.", "rewrite /\u03ba -lock.", "rewrite [(_ * 5^_) mod 3]Nat.mul_mod; first by lia.", "rewrite [(_ * 3^_) mod 3]Nat.mul_mod; first by lia.", "move: b => [|b].", "{", "by case: (pow_2_mod_3 a); case: (pow_5_mod_3 c); move=> -> ->.", "}", "have -> : 3 ^ S b = 3 * 3 ^ b by move=> /=; lia.", "rewrite [(3 * _) mod 3]Nat.mul_mod; first by lia.", "by rewrite ?((@Nat.mod_same 3 ltac:(lia)), (@Nat.mod_0_l 3 ltac:(lia)), Nat.mul_0_r).", "Qed.", "Lemma \u03ba_mod4 {a b c: nat} : \u03ba (2+a) b c mod 4 = 0.", "Proof.", "apply /Nat.div_exact; first by lia.", "have -> : \u03ba (2+a) b c = (\u03ba a b c) * 4 by (rewrite /\u03ba /=; lia).", "by rewrite /\u03ba Nat.div_mul /=; lia.", "Qed.", "Definition \u03ba_norm := (@\u03ba_pos, @\u03ba_21, @\u03ba_32, @\u03ba_43, @\u03ba_54, @\u03ba_mod2, @\u03ba_mod3, @\u03ba_mod4).", "Lemma \u03ba_inj1 {a1 b1 c1 a2 b2 c2: nat} : \u03ba a1 b1 c1 = \u03ba a2 b2 c2 -> a1 = a2.", "Proof.", "elim: a1 a2 b1 b2.", "{", "move=> [|a2] >; first done.", "move /(f_equal (fun x => x mod 2)).", "by rewrite ?\u03ba_mod2.", "}", "move=> a1 IH [|a2] >.", "{", "move /(f_equal (fun x => x mod 2)).", "by rewrite ?\u03ba_mod2.", "}", "move /(f_equal (fun x => x * 3 / 2)).", "rewrite ?\u03ba_32.", "by move /IH => ->.", "Qed.", "Lemma \u03ba_inj2 {a1 b1 c1 a2 b2 c2: nat} : \u03ba a1 b1 c1 = \u03ba a2 b2 c2 -> b1 = b2.", "Proof.", "elim: b1 b2 a1 a2.", "{", "move=> [|b2] >; first done.", "move /(f_equal (fun x => x mod 3)).", "by rewrite ?\u03ba_mod3.", "}", "move=> b1 IH [|b2] >.", "{", "move /(f_equal (fun x => x mod 3)).", "by rewrite ?\u03ba_mod3.", "}", "move /(f_equal (fun x => x * 4 / 3)).", "rewrite ?\u03ba_43.", "by move /IH => ->.", "Qed.", "Lemma fs_inj {i j: nat} : fs i = fs j -> i = j.", "Proof.", "rewrite /fs.", "by lia.", "Qed.", "Lemma P_to_M_step {x: CM2.Config} {x': CM1.Config} : encodes_config x x' -> exists n, encodes_config (CM2.step P x) (Nat.iter n (CM1.step M) x').", "Proof.", "move: x x' => [i a b] [p c] /= [->] [k ->].", "move Hoi: (nth_error P i) => oi.", "move: oi Hoi => [cm2i|] /=; first last.", "{", "move=> Hi.", "exists 0.", "constructor; [done | by eexists ].", "}", "move: cm2i => [] [] > Hi.", "-", "exists 2 => /=.", "rewrite (seek_M 0) Hi ?\u03ba_norm /=.", "rewrite (seek_M 1) Hi ?\u03ba_norm /=.", "constructor; [done | by eexists ].", "-", "exists 1 => /=.", "rewrite (seek_M 0) Hi ?\u03ba_norm /=.", "constructor; [done | by eexists ].", "-", "move: b => [|b].", "+", "exists 4 => /=.", "rewrite (seek_M 0) Hi ?\u03ba_norm /=.", "rewrite (seek_M 1) Hi ?\u03ba_norm /=.", "rewrite (seek_M 2) Hi ?\u03ba_norm /=.", "rewrite (seek_M 3) Hi ?\u03ba_norm /=.", "constructor; [done | by eexists ].", "+", "exists 2 => /=.", "rewrite (seek_M 0) Hi ?\u03ba_norm /=.", "rewrite (seek_M 4) Hi ?\u03ba_norm /=.", "constructor; [done | by eexists ].", "-", "move: a => [|a].", "+", "exists 4 => /=.", "rewrite (seek_M 0) Hi ?\u03ba_norm /=.", "rewrite (seek_M 1) Hi ?\u03ba_norm /=.", "rewrite (seek_M 2) Hi ?\u03ba_norm /=.", "rewrite (seek_M 3) Hi ?\u03ba_norm /=.", "constructor; [done | by eexists ].", "+", "exists 3 => /=.", "rewrite (seek_M 0) Hi ?\u03ba_norm /=.", "rewrite (seek_M 4) Hi ?\u03ba_norm /=.", "rewrite (seek_M 5) Hi ?\u03ba_norm /=.", "constructor; [done | by eexists ].", "Qed.", "Lemma P_to_M {n} {x: CM2.Config} {x': CM1.Config} : encodes_config x x' -> exists m, encodes_config (Nat.iter n (CM2.step P) x) (Nat.iter m (CM1.step M) x').", "Proof.", "elim: n x x'; first by exists 0.", "move=> n IH x x' /P_to_M_step [m1] /IH [m2].", "rewrite (ltac:(lia) : S n = 1 + n) iter_plus /=.", "exists (m1 + m2).", "by rewrite iter_plus.", "Qed.", "Lemma P_iff_M_halting (x: CM2.Config) (x': CM1.Config) : encodes_config x x' -> (CM2.halting P x <-> CM1.halting M x').", "Proof.", "rewrite CM1_facts.haltingP CM2_facts.haltingP.", "move: x x' => [i a b] [? ?] /= [->] [k] ->.", "rewrite /fs length_M \u03ba_pos'.", "by lia.", "Qed.", "Lemma M_terminating_to_P_terminates (x: CM2.Config) (x': CM1.Config) {n: nat}: encodes_config x x' -> CM1.halting M (Nat.iter n (CM1.step M) x') -> exists m, CM2.halting P (Nat.iter m (CM2.step P) x).", "Proof.", "elim /(measure_ind id) : n x x' => n IH x.", "have : CM2.halting P x \\/ not (CM2.halting P x) by (rewrite CM2_facts.haltingP; lia).", "case; first by (move=> *; exists 0).", "move=> Hx x' /copy [H1xx'] /P_to_M_step [m Hm].", "have ? : m > 0.", "{", "suff: not (m = 0) by lia.", "move=> ?.", "subst m.", "apply: Hx.", "rewrite /CM2.halting.", "move: x' x (CM2.step P x) H1xx' Hm.", "move=> [? ?] [? ? ?] [? ? ?] /= [->] [? ->] [+] [?].", "by move=> /fs_inj -> /copy [/\u03ba_inj1 ->] /\u03ba_inj2 ->.", "}", "have [?|Hn] : n <= m \\/ m < n by lia.", "-", "move: Hm => /P_iff_M_halting HPM.", "move=> /(CM1_facts.halting_monotone (m := m)) => /(_ ltac:(done)).", "move=> /HPM ?.", "by exists 1.", "-", "have ->: n = m + (n - m) by lia.", "rewrite iter_plus.", "move: Hm => /IH {}IH /IH => /(_ ltac:(lia)) [m' ?].", "exists (1+m').", "by rewrite iter_plus.", "Qed.", "End MM2_CM1.", "End Argument.", "Require Import Undecidability.Synthetic.Definitions.", "Theorem reduction : CM2_HALT \u2aaf CM1_HALT.", "Proof.", "exists (fun P => exist _ (Argument.M P) (Argument.M_capped P)).", "move=> P.", "constructor.", "-", "move=> [n].", "have := Argument.encodes_config_init.", "move=> /(Argument.P_to_M P (n := n)) [m].", "move=> /Argument.P_iff_M_halting H /H {}?.", "by exists m.", "-", "move=> [n].", "have := Argument.encodes_config_init.", "by move=> /Argument.M_terminating_to_P_terminates H /H.", "Qed."], "theorems": [{"name": "M_capped", "kind": "Lemma", "begin": 20, "end": 24}, {"name": "encodes_config_init", "kind": "Lemma", "begin": 28, "end": 31}, {"name": "length_encode_instruction", "kind": "Lemma", "begin": 32, "end": 35}, {"name": "length_M", "kind": "Lemma", "begin": 36, "end": 43}, {"name": "seek_M", "kind": "Lemma", "begin": 44, "end": 63}, {"name": "\u03ba_pos", "kind": "Lemma", "begin": 67, "end": 74}, {"name": "\u03ba_pos'", "kind": "Lemma", "begin": 75, "end": 79}, {"name": "\u03ba_21", "kind": "Lemma", "begin": 80, "end": 84}, {"name": "\u03ba_32", "kind": "Lemma", "begin": 85, "end": 89}, {"name": "\u03ba_43", "kind": "Lemma", "begin": 90, "end": 94}, {"name": "\u03ba_54", "kind": "Lemma", "begin": 95, "end": 99}, {"name": "\u03ba_mod2", "kind": "Lemma", "begin": 100, "end": 109}, {"name": "\u03ba_mod3", "kind": "Lemma", "begin": 110, "end": 122}, {"name": "\u03ba_mod4", "kind": "Lemma", "begin": 123, "end": 128}, {"name": "\u03ba_inj1", "kind": "Lemma", "begin": 130, "end": 146}, {"name": "\u03ba_inj2", "kind": "Lemma", "begin": 147, "end": 163}, {"name": "fs_inj", "kind": "Lemma", "begin": 164, "end": 168}, {"name": "P_to_M_step", "kind": "Lemma", "begin": 169, "end": 218}, {"name": "P_to_M", "kind": "Lemma", "begin": 219, "end": 226}, {"name": "P_iff_M_halting", "kind": "Lemma", "begin": 227, "end": 233}, {"name": "M_terminating_to_P_terminates", "kind": "Lemma", "begin": 234, "end": 263}, {"name": "reduction", "kind": "Theorem", "begin": 267, "end": 282}]}