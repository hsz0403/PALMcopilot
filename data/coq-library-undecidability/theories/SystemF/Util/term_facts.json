{"code": ["Require Import List Lia.", "Import ListNotations.", "Require Import Undecidability.SystemF.SysF Undecidability.SystemF.Autosubst.syntax Undecidability.SystemF.Autosubst.unscoped.", "Import UnscopedNotations.", "From Undecidability.SystemF.Util Require Import Facts poly_type_facts pure_term_facts.", "Require Import ssreflect ssrbool ssrfun.", "Set Default Goal Selector \"!\".", "Lemma subst_term_up_term_term_var {\u03c3 t}: subst_term \u03c3 (up_term_term var) t = subst_term \u03c3 var t.", "Proof.", "apply: ext_term; [done | by case].", "Qed.", "Lemma subst_term_up_term_poly_type {\u03c3 \u03c4 t}: subst_term (up_term_poly_type \u03c3) \u03c4 t = subst_term \u03c3 \u03c4 t.", "Proof.", "apply: ext_term; last done.", "move=> ?.", "by rewrite /up_term_poly_type /funcomp /= ren_poly_type_id.", "Qed.", "Lemma subst_term_up_poly_type_term_var {\u03c3 t}: subst_term \u03c3 (up_poly_type_term var) t = subst_term \u03c3 var t.", "Proof.", "apply: ext_term; [done | by case].", "Qed.", "Lemma subst_term_poly_var_var {P} : subst_term poly_var var P = P.", "Proof.", "by apply: idSubst_term.", "Qed.", "Lemma subst_term_ren_term {\u03c3 \u03c3' \u03be \u03be' P} : subst_term \u03c3 \u03c3' (ren_term \u03be \u03be' P) = subst_term (\u03be >> \u03c3) (\u03be' >> \u03c3') P.", "Proof.", "by apply: compRenSubst_term.", "Qed.", "Definition term_norm := (@subst_term_up_term_term_var, @subst_term_up_term_poly_type, @subst_term_up_poly_type_term_var, @subst_term_ren_term).", "Inductive head_form : term -> Prop := | head_form_var {x} : head_form (var x) | head_form_app {P Q} : head_form P -> normal_form Q -> head_form (app P Q) | head_form_ty_app {P t} : head_form P -> head_form (ty_app P t) with normal_form : term -> Prop := | normal_form_head_form {P} : head_form P -> normal_form P | normal_form_abs {s P} : normal_form P -> normal_form (abs s P) | normal_form_ty_abs {P} : normal_form P -> normal_form (ty_abs P).", "Scheme normal_form_ind' := Induction for normal_form Sort Prop with head_form_ind' := Induction for head_form Sort Prop.", "Fact normal_form_ren_term {\u03b6 \u03be P} : normal_form P -> normal_form (ren_term \u03b6 \u03be P).", "Proof.", "move=> H.", "move: P H \u03b6 \u03be.", "apply: (normal_form_ind' (fun P _ => forall \u03b6 \u03be, normal_form (ren_term \u03b6 \u03be P)) (fun P _ => forall \u03b6 \u03be, head_form (ren_term \u03b6 \u03be P))); by eauto using normal_form, head_form.", "Qed.", "Fact head_form_ren_term {\u03b6 \u03be P} : head_form P -> head_form (ren_term \u03b6 \u03be P).", "Proof.", "move=> H.", "move: P H \u03b6 \u03be.", "apply: (head_form_ind' (fun P _ => forall \u03b6 \u03be, normal_form (ren_term \u03b6 \u03be P)) (fun P _ => forall \u03b6 \u03be, head_form (ren_term \u03b6 \u03be P))); by eauto using normal_form, head_form.", "Qed.", "Fixpoint erase (P: term) : pure_term := match P with | var x => pure_var x | app P Q => pure_app (erase P) (erase Q) | abs _ P => pure_abs (erase P) | ty_app P _ => erase P | ty_abs P => erase P end.", "Fact erase_subst_term_var {P \u03c3} : erase (subst_term \u03c3 var P) = erase P.", "Proof.", "elim: P \u03c3; move=> /= *; rewrite ?subst_term_up_term_term_var ?subst_term_up_poly_type_term_var; by congruence.", "Qed.", "Definition many_app (P: term) (Qs: list term) := fold_left app Qs P.", "Definition many_ty_app (P: term) (ts: list poly_type) := fold_left ty_app ts P.", "Definition many_ty_abs (n: nat) (P: term) := Nat.iter n ty_abs P.", "Fact many_app_app {P Qs Qs'} : many_app P (Qs ++ Qs') = many_app (many_app P Qs) Qs'.", "Proof.", "by rewrite /many_app fold_left_app.", "Qed.", "Fact many_ty_app_app {P ts ts'} : many_ty_app P (ts ++ ts') = many_ty_app (many_ty_app P ts) ts'.", "Proof.", "by rewrite /many_ty_app fold_left_app.", "Qed.", "Definition many_pure_app (M: pure_term) (Ns: list pure_term) := fold_left pure_app Ns M.", "Fact many_pure_app_app {M Ns Ns'} : many_pure_app M (Ns ++ Ns') = many_pure_app (many_pure_app M Ns) Ns'.", "Proof.", "by rewrite /many_pure_app fold_left_app.", "Qed.", "Definition many_pure_term_abs (n: nat) (M: pure_term) := Nat.iter n pure_abs M.", "Inductive argument : Type := | argument_term : term -> argument | argument_poly_type : poly_type -> argument.", "Definition many_argument_app (P: term) (As: list argument) := fold_left (fun P A => match A with | argument_term Q => app P Q | argument_poly_type t => ty_app P t end) As P.", "Fact many_argument_app_app {P As As'} : many_argument_app P (As ++ As') = many_argument_app (many_argument_app P As) As'.", "Proof.", "by rewrite /many_argument_app fold_left_app.", "Qed.", "Lemma many_argument_appI {P} : head_form P -> exists x As, P = many_argument_app (var x) As /\\ Forall (fun A => if A is argument_term Q then normal_form Q else True) As.", "Proof.", "elim.", "-", "move=> x.", "by exists x, [].", "-", "move=> {}P Q _ [x] [As] [-> HAs] ?.", "exists x, (As ++ [argument_term Q]).", "constructor; first by rewrite many_argument_app_app.", "rewrite Forall_app.", "constructor; [done | by constructor].", "-", "move=> {}P t _ [x] [As] [-> HAs].", "exists x, (As ++ [argument_poly_type t]).", "constructor; first by rewrite many_argument_app_app.", "rewrite Forall_app.", "constructor; [done | by constructor].", "Qed.", "Fact erase_many_ty_abs {n P} : erase (many_ty_abs n P) = erase P.", "Proof.", "elim: n => /= *; by congruence.", "Qed.", "Fact erase_many_ty_app {ts P} : erase (many_ty_app P ts) = erase P.", "Proof.", "elim: ts P; [done | by move=> > + ? /= => ->].", "Qed.", "Lemma erase_ren_term_id {\u03be P} : erase (ren_term \u03be id P) = erase P.", "Proof.", "elim: P \u03be.", "-", "done.", "-", "by move=> ? + ? + ? /= => -> ->.", "-", "move=> ? ? IH ? /=.", "under extRen_term => [? | ?] do [| rewrite /upRen_term_term up_ren_id].", "by rewrite IH.", "-", "by move=> ? + ? ? /= => ->.", "-", "by move=> ? + ? /= => ->.", "Qed.", "Fixpoint term_size (P: term) := match P with | var _ => 1 | app P Q => 1 + term_size P + term_size Q | abs _ P => 1 + term_size P | ty_app P _ => 1 + term_size P | ty_abs P => 1 + term_size P end.", "Lemma term_size_pos (P: term) : term_size P = S (term_size P - 1).", "Proof.", "case: P => /= *; by lia.", "Qed.", "Fact term_size_ren_term {\u03b6 \u03be P} : term_size (ren_term \u03b6 \u03be P) = term_size P.", "Proof.", "elim: P \u03b6 \u03be => /=; by congruence.", "Qed.", "Lemma term_size_many_app_le P Qs : term_size P <= term_size (many_app P Qs).", "Proof.", "elim: Qs P; first by move=> /=; lia.", "move=> Q Qs + P => /(_ (app P Q)) /=.", "by lia.", "Qed.", "Lemma many_argument_app_map_argument_poly_type {P ts} : many_argument_app P (map argument_poly_type ts) = many_ty_app P ts.", "Proof.", "elim: ts P; [done | move=> /= *; by congruence].", "Qed.", "Lemma many_argument_app_map_argument_term {P Qs} : many_argument_app P (map argument_term Qs) = many_app P Qs.", "Proof.", "elim: Qs P; [done | move=> /= *; by congruence].", "Qed.", "Lemma normal_form_many_app {P Qs} : normal_form (many_app P Qs) -> normal_form P /\\ Forall normal_form Qs.", "Proof.", "elim /rev_ind: Qs P; first by (move=> *; constructor).", "move=> Q Qs IH P.", "rewrite many_app_app /=.", "move H1P': (app _ _) => P' H2P'.", "case: H2P' H1P'; [|done|done].", "move=> ? []; [done| |done].", "move=> ? ? /normal_form_head_form + + [? ?].", "subst.", "move=> /IH [? ?] ?.", "constructor; first done.", "apply /Forall_appP.", "constructor; first done.", "by constructor.", "Qed.", "Fixpoint allfv_term (p: nat -> Prop) (P: term) := match P with | var x => p x | app P Q => allfv_term p P /\\ allfv_term p Q | abs _ P => allfv_term (scons True p) P | ty_app P _ => allfv_term p P | ty_abs P => allfv_term p P end.", "Lemma allfv_term_impl {p1 p2: nat -> Prop} {P}: (forall x, p1 x -> p2 x) -> allfv_term p1 P -> allfv_term p2 P.", "Proof.", "elim: P p1 p2.", "-", "move=> >.", "by apply.", "-", "by move=> ? IH1 ? IH2 > /= /copy [/IH1 {}IH1 /IH2 {}IH2] [/IH1 ? /IH2 ?].", "-", "move=> > IH > H /=.", "apply: IH.", "by case.", "-", "move=> > IH > H /=.", "by apply: IH.", "-", "move=> > IH > H /=.", "by apply: IH.", "Qed.", "Lemma allfv_pure_term_erase {p P}: allfv_pure_term p (erase P) -> allfv_term p P.", "Proof.", "elim: P p; [ done | | | done | done ].", "-", "by move=> ? IH1 ? IH2 > /= [/IH1 ? /IH2 ?].", "-", "by move=> > IH > /= /IH.", "Qed.", "Lemma erase_ren_term {\u03be \u03c3 P} : erase (ren_term \u03c3 \u03be P) = ren_pure_term \u03be (erase P).", "Proof.", "elim: P \u03be \u03c3.", "-", "done.", "-", "by move=> ? + ? + ? ? /= => -> ->.", "-", "by move=> ? ? + ? ? /= => ->.", "-", "done.", "-", "by move=> ? + ? ? /= => ->.", "Qed."], "theorems": [{"name": "subst_term_up_term_term_var", "kind": "Lemma", "begin": 7, "end": 10}, {"name": "subst_term_up_term_poly_type", "kind": "Lemma", "begin": 11, "end": 16}, {"name": "subst_term_up_poly_type_term_var", "kind": "Lemma", "begin": 17, "end": 20}, {"name": "subst_term_poly_var_var", "kind": "Lemma", "begin": 21, "end": 24}, {"name": "subst_term_ren_term", "kind": "Lemma", "begin": 25, "end": 28}, {"name": "normal_form_ren_term", "kind": "Fact", "begin": 32, "end": 37}, {"name": "head_form_ren_term", "kind": "Fact", "begin": 38, "end": 43}, {"name": "erase_subst_term_var", "kind": "Fact", "begin": 45, "end": 48}, {"name": "many_app_app", "kind": "Fact", "begin": 52, "end": 55}, {"name": "many_ty_app_app", "kind": "Fact", "begin": 56, "end": 59}, {"name": "many_pure_app_app", "kind": "Fact", "begin": 61, "end": 64}, {"name": "many_argument_app_app", "kind": "Fact", "begin": 68, "end": 71}, {"name": "many_argument_appI", "kind": "Lemma", "begin": 72, "end": 90}, {"name": "erase_many_ty_abs", "kind": "Fact", "begin": 91, "end": 94}, {"name": "erase_many_ty_app", "kind": "Fact", "begin": 95, "end": 98}, {"name": "erase_ren_term_id", "kind": "Lemma", "begin": 99, "end": 114}, {"name": "term_size_pos", "kind": "Lemma", "begin": 116, "end": 119}, {"name": "term_size_ren_term", "kind": "Fact", "begin": 120, "end": 123}, {"name": "term_size_many_app_le", "kind": "Lemma", "begin": 124, "end": 129}, {"name": "many_argument_app_map_argument_poly_type", "kind": "Lemma", "begin": 130, "end": 133}, {"name": "many_argument_app_map_argument_term", "kind": "Lemma", "begin": 134, "end": 137}, {"name": "normal_form_many_app", "kind": "Lemma", "begin": 138, "end": 153}, {"name": "allfv_term_impl", "kind": "Lemma", "begin": 155, "end": 173}, {"name": "allfv_pure_term_erase", "kind": "Lemma", "begin": 174, "end": 181}, {"name": "erase_ren_term", "kind": "Lemma", "begin": 182, "end": 195}]}