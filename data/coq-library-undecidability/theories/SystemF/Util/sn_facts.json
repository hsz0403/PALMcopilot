{"code": ["Require Import Undecidability.SystemF.SysF Undecidability.SystemF.Autosubst.syntax Undecidability.SystemF.Autosubst.unscoped.", "Import UnscopedNotations.", "From Undecidability.SystemF.Util Require Import typing_facts term_facts step.", "Require Import Setoid Morphisms.", "Set Default Proof Using \"Type\".", "Definition pw_iff {X} p q := (forall x : X, p x <-> q x).", "Notation \"p == q\" := (pw_iff p q) (at level 70).", "Instance Equiv_pw_iff {X} : Equivalence (@pw_iff X).", "Proof.", "firstorder.", "Qed.", "Lemma pw {X : Type} P Q : (forall x : X, P x <-> Q x) -> (forall x, P x) <-> (forall x, Q x).", "Proof.", "firstorder.", "Qed.", "Ltac pw := repeat (apply pw; intros).", "Definition active P := match P with | abs _ _ | ty_abs _ => true | _ => false end.", "Definition tpred := term -> Prop.", "Definition M (p : tpred) : tpred := fun P => forall \u03be1 \u03be2, p (ren_term \u03be1 \u03be2 P).", "Inductive R (p : tpred) P : Prop := | RI : (active P = true -> M p P) -> (forall Q, step P Q -> R p Q) -> R p P.", "Instance R_ext : Proper (pw_iff ==> eq ==> iff) R.", "Proof.", "intros p1 p2 Heq P ? ->.", "split; induction 1 as [P H H1 H2].", "-", "econstructor.", "intros H3 \u03be1 \u03be2.", "eapply Heq.", "now eapply H.", "eauto.", "-", "econstructor.", "intros H3 \u03be1 \u03be2.", "eapply Heq.", "now eapply H.", "eauto.", "Qed.", "Record model := mk_model { Var : tpred -> tpred ; Arr : tpred -> tpred -> tpred ; All : (tpred -> tpred) -> tpred ; Var_ext : Proper (pw_iff ==> pw_iff) Var ; Arr_ext : Proper (pw_iff ==> pw_iff ==> pw_iff) Arr ; All_ext : Proper (pointwise_relation _ pw_iff ==> pw_iff) All }.", "Existing Instances Var_ext Arr_ext All_ext.", "Section Evaluation.", "Variable (M : model).", "Fixpoint eval (\u03c1 : nat -> tpred) (s : poly_type) : tpred := match s with | poly_var n => Var M (\u03c1 n) | poly_arr s t => Arr M (eval \u03c1 s) (eval \u03c1 t) | poly_abs s => All M (fun d => eval (d .: \u03c1) s) end.", "Instance eval_ext : Proper (pointwise_relation _ pw_iff ==> eq ==> pw_iff) eval.", "Proof.", "intros \u03c11 \u03c12 Heq s ? <-.", "induction s in \u03c11, \u03c12, Heq |- *; cbn.", "-", "now rewrite (Heq n).", "-", "now rewrite IHs1, IHs2.", "-", "eapply All_ext.", "intros d.", "eapply IHs.", "intros []; cbn; intuition.", "Qed.", "Lemma eval_ren \u03be s \u03c1 : eval \u03c1 (ren_poly_type \u03be s) == eval (\u03be >> \u03c1) s.", "Proof.", "induction s in \u03be, \u03c1 |- *; cbn.", "-", "reflexivity.", "-", "now rewrite IHs1, IHs2.", "-", "eapply All_ext.", "intros d.", "rewrite IHs.", "eapply eval_ext.", "now intros [].", "reflexivity.", "Qed.", "Lemma eval_weaken s \u03c1 d : eval (d .: \u03c1) (ren_poly_type shift s) == eval \u03c1 s.", "Proof.", "now rewrite eval_ren.", "Qed.", "Definition lift : model.", "Proof using M.", "refine (mk_model id (Arr M) (fun F => All M (Var M >> F)) _ _ _).", "abstract firstorder.", "abstract (intros p1 p2 H; eapply All_ext; intros P; eapply H).", "Defined.", "End Evaluation.", "Lemma eval_subst (M : model) \u03c3 s \u03c1 : eval M \u03c1 (subst_poly_type \u03c3 s) == eval (lift M) (\u03c3 >> eval M \u03c1) s.", "Proof.", "induction s in \u03c3, \u03c1 |- *; cbn.", "-", "reflexivity.", "-", "now rewrite IHs1, IHs2.", "-", "eapply All_ext.", "intros d.", "rewrite IHs.", "asimpl.", "eapply eval_ext; try reflexivity.", "intros [].", "reflexivity.", "eapply eval_weaken.", "Qed.", "Lemma eval_beta (M : model) s t \u03c1 : eval M \u03c1 (subst_poly_type (t .: poly_var) s) == eval (lift M) (eval M \u03c1 t .: \u03c1 >> Var M) s.", "Proof.", "rewrite eval_subst.", "eapply eval_ext.", "now intros [].", "reflexivity.", "Qed.", "Definition D : model.", "Proof.", "refine {| Var := id ; Arr := fun p q P => match P with abs s P => forall Q, R p Q -> R q (subst_term poly_var (Q .: var) P) | _ => False end ; All := fun F P => match P with ty_abs P => forall p s, R (F p) (subst_term (s .: poly_var) var P) | _ => False end |}.", "-", "abstract firstorder.", "-", "abstract (intros p1 p2 Heq1 p1' p2' Heq2 []; cbn; try tauto; pw; now rewrite Heq1, Heq2).", "-", "abstract (intros F1 F2 Heq []; cbn; try tauto; pw; now rewrite (Heq x)).", "Defined.", "Notation V s \u03c1 := (eval D \u03c1 s).", "Notation K s \u03c1 := (M (V s \u03c1)).", "Notation E s \u03c1 := (R (V s \u03c1)).", "Lemma R_sn p P : R p P -> sn P.", "Proof.", "induction 1.", "eauto using sn.", "Qed.", "Lemma R_step p P Q : step P Q -> R p P -> R p Q.", "Proof.", "intros ? [].", "eauto.", "Qed.", "Lemma R_var p n : R p (var n).", "Proof.", "econstructor.", "intros [=].", "intros Q H.", "inversion H.", "Qed.", "Lemma R_ren \u03be1 \u03be2 p P : R p P -> R p (ren_term \u03be1 \u03be2 P).", "Proof.", "induction 1 as [P H H0 H1].", "econstructor.", "-", "intros HnP \u03be'1 \u03be'2.", "asimpl.", "eapply H.", "now destruct P.", "-", "intros Q.", "erewrite rinst_inst_term; try reflexivity.", "intros (P' & H2 & <-) % step_subst_inv.", "erewrite <- rinst_inst_term; try reflexivity.", "eauto.", "Qed.", "Lemma K_var n \u03c1 P : K (poly_var n) \u03c1 P = forall \u03be1 \u03be2, \u03c1 n (ren_term \u03be1 \u03be2 P).", "Proof.", "reflexivity.", "Qed.", "Lemma K_arr s t \u03c1 u P : K (poly_arr s t) \u03c1 (abs u P) <-> forall \u03be1 \u03be2 Q, E s \u03c1 Q -> E t \u03c1 (subst_term (\u03be1 >> poly_var) (Q .: \u03be2 >> var) P).", "Proof.", "unfold M.", "cbn.", "pw.", "asimpl.", "eapply R_ext.", "reflexivity.", "now_asimpl.", "Qed.", "Lemma K_all s \u03c1 P : K (poly_abs s) \u03c1 (ty_abs P) <-> forall \u03be p t, E s (p .: \u03c1) (subst_term (t .: \u03be >> poly_var) var P).", "Proof.", "unfold M.", "split.", "-", "intros H \u03be p t.", "specialize (H \u03be id p t).", "fold ren_term in H.", "eapply R_ext.", "3:eapply H.", "reflexivity.", "now_asimpl.", "-", "intros H \u03be1 \u03be2 p t.", "specialize (H \u03be1 p t).", "pose proof (Hren := R_ren id \u03be2 _ _ H).", "asimpl in Hren.", "eapply R_ext.", "3:eapply Hren.", "reflexivity.", "now_asimpl.", "Qed.", "Lemma V_weaken s \u03c1 p : V (ren_poly_type shift s) (p .: \u03c1) == V s \u03c1.", "Proof.", "now rewrite eval_weaken.", "Qed.", "Lemma K_weaken s \u03c1 p : K (ren_poly_type shift s) (p .: \u03c1) == K s \u03c1.", "Proof.", "intros P.", "pw.", "eapply V_weaken.", "Qed.", "Lemma E_weaken s \u03c1 p : E (ren_poly_type shift s) (p .: \u03c1) == E s \u03c1.", "Proof.", "intros P.", "eapply R_ext.", "eapply V_weaken.", "reflexivity.", "Qed.", "Lemma V_beta s t \u03c1 : V (subst_poly_type (t .: poly_var) s) \u03c1 == V s (V t \u03c1 .: \u03c1).", "Proof.", "now rewrite eval_beta.", "Qed.", "Lemma E_beta s t \u03c1 : E (subst_poly_type (t .: poly_var) s) \u03c1 == E s (V t \u03c1 .: \u03c1).", "Proof.", "intros P.", "now rewrite eval_beta.", "Qed.", "Definition C (\u0393 : nat -> poly_type) (\u03c1 : nat -> tpred) : (nat -> term) -> Prop := fun \u03c3 => forall n, E (\u0393 n) \u03c1 (\u03c3 n).", "Lemma C_ext : Proper (pointwise_relation _ eq ==> eq ==> eq ==> iff) C.", "Proof.", "split; repeat intros ?; subst.", "now rewrite <- H.", "now rewrite H.", "Qed.", "Lemma C_scons s \u0393 \u03c1 \u03c3 P : E s \u03c1 P -> C \u0393 \u03c1 \u03c3 -> C (s .: \u0393) \u03c1 (P .: \u03c3).", "Proof.", "intros HE HC.", "hnf.", "intros [].", "eassumption.", "eapply HC.", "Qed.", "Lemma C_rename \u0393 \u03c1 \u03c3 \u03be1 \u03be2 : C \u0393 \u03c1 \u03c3 -> C \u0393 \u03c1 (\u03c3 >> ren_term \u03be1 \u03be2).", "Proof.", "intros H ?.", "eapply R_ren, H.", "Qed.", "Lemma C_up s \u0393 \u03c1 \u03c3 : C \u0393 \u03c1 \u03c3 -> C (s .: \u0393) \u03c1 (up_term_term \u03c3).", "Proof.", "intros H.", "eapply C_scons.", "eapply R_var.", "now eapply C_rename.", "Qed.", "Lemma E2_ind s t \u03c11 \u03c12 p : (forall P Q, E s \u03c11 P -> E t \u03c12 Q -> (forall P', step P P' -> p P' Q) -> (forall Q', step Q Q' -> p P Q') -> p P Q) -> forall P Q, E s \u03c11 P -> E t \u03c12 Q -> p P Q.", "Proof.", "intros H P Q.", "induction 1 in Q |- *.", "induction 1.", "eapply H; eauto using R.", "Qed.", "Lemma E_app s t P Q \u03c1 : E (poly_arr s t) \u03c1 P -> E s \u03c1 Q -> E t \u03c1 (app P Q).", "Proof.", "revert P Q.", "eapply E2_ind.", "intros P Q nP nQ IHP IHQ.", "econstructor.", "inversion 1.", "intros R Hst.", "inv Hst; eauto.", "destruct nP.", "rewrite K_arr in H; eauto.", "Qed.", "Lemma E_lam s t s' \u03c1 P : sn P -> (forall \u03be1 \u03be2 Q, E s \u03c1 Q -> E t \u03c1 (subst_term (\u03be1 >> poly_var) (Q .: \u03be2 >> var) P)) -> E (poly_arr s t) \u03c1 (abs s' P).", "Proof.", "induction 1 as [P _ IH].", "intros H.", "econstructor.", "-", "intros _.", "rewrite K_arr.", "eauto.", "-", "intros Q Hst.", "inv Hst.", "eapply IH; eauto.", "intros.", "eapply R_step; eauto using step_subst.", "Qed.", "Lemma E_tapp s t \u03c1 P r : E (poly_abs s) \u03c1 P -> E (subst_poly_type (t .: poly_var) s) \u03c1 (ty_app P r).", "Proof.", "induction 1 as [P H IH H2].", "eapply E_beta.", "econstructor.", "inversion 1.", "intros Q Hst.", "inv Hst.", "-", "specialize (H eq_refl).", "rewrite K_all in H.", "eauto.", "-", "eapply H2 in H4.", "now eapply E_beta in H4.", "Qed.", "Lemma E_tlam s \u03c1 P : sn P -> (forall \u03be p t, E s (p .: \u03c1) (subst_term (t .: \u03be >> poly_var) var P)) -> E (poly_abs s) \u03c1 (ty_abs P).", "Proof.", "induction 1 as [P _ IH].", "intros H.", "econstructor.", "-", "rewrite K_all.", "intros _.", "eapply H.", "-", "intros Q Hst.", "inv Hst.", "eapply IH.", "eauto.", "intros \u03be p t.", "eapply R_step; eauto using step_subst.", "Qed.", "Lemma fundamental {\u0393 s P} : typing \u0393 P s -> forall \u03c3 \u03c4 \u03c1, C (fun n => match List.nth_error \u0393 n with Some x => x | _ => poly_abs (poly_var 0) end) \u03c1 \u03c4 -> E s \u03c1 (subst_term \u03c3 \u03c4 P).", "Proof.", "induction 1 as [\u0393 n s H | | \u0393 | | ]; intros \u03c3 \u03c4 \u03c1 HC.", "-", "specialize (HC n).", "cbn in HC.", "rewrite H in HC.", "eapply HC.", "-", "cbn.", "eapply E_app; eauto.", "-", "eapply E_lam; fold subst_term.", "+", "eapply R_sn.", "eapply IHtyping.", "eapply C_ext.", "4:{", "eapply C_up, HC.", "}", "all: try reflexivity.", "now intros [].", "+", "intros \u03be1 \u03be2 Q HQ.", "match goal with [ |- E _ _ ?R] => replace R with (subst_term (\u03c3 >> ren_poly_type \u03be1) (Q .: \u03c4 >> ren_term \u03be1 \u03be2) P) end.", "*", "eapply IHtyping.", "eapply C_ext.", "4:{", "eapply C_scons.", "eauto.", "eapply C_rename, HC.", "}", "all: try reflexivity.", "intros []; cbn; try reflexivity.", "*", "asimpl.", "eapply ext_term.", "intros.", "asimpl.", "--", "erewrite rinst_inst_poly_type; reflexivity.", "--", "intros [].", "reflexivity.", "asimpl.", "erewrite rinst_inst_term; try reflexivity.", "now asimpl.", "-", "cbn.", "eapply E_tapp; eauto.", "-", "cbn.", "eapply E_tlam.", "+", "specialize (IHtyping (up_poly_type_poly_type \u03c3) (\u03c4 >> ren_term shift id) ((fun _ => False) .: \u03c1)).", "eapply R_sn.", "refine (IHtyping _).", "intros n.", "rewrite Facts.nth_error_map.", "destruct List.nth_error eqn:Eq.", "*", "cbn.", "asimpl.", "eapply E_weaken.", "specialize (HC n).", "cbn in HC.", "rewrite Eq in HC.", "eapply R_ren, HC.", "*", "unfold ssrfun.Option.map, ssrfun.Option.bind, ssrfun.Option.apply.", "eapply R_ren.", "specialize (HC n).", "cbn in HC.", "rewrite Eq in HC.", "eapply HC.", "+", "intros \u03be p t.", "asimpl.", "eapply IHtyping.", "intros n.", "asimpl.", "eapply R_ext.", "2:reflexivity.", "2:{", "eapply E_weaken.", "erewrite <- rinst_inst_term; try reflexivity.", "eapply R_ren.", "eapply HC.", "}", "*", "f_equal.", "rewrite Facts.nth_error_map.", "now destruct List.nth_error eqn:Eq.", "Qed.", "Lemma SN {Gamma P t} : typing Gamma P t -> sn P.", "Proof.", "intros Htp.", "pose proof (fundamental Htp poly_var var (fun _ _ => False)).", "asimpl in H.", "eapply R_sn, H.", "intros n.", "eapply R_var.", "Qed.", "Lemma typing_normal_form {Gamma P t} : typing Gamma P t -> exists Q, normal_form Q /\\ typing Gamma Q t.", "Proof.", "intros H.", "destruct (sn_normal _ _ _ H (SN H)) as (Q & H1 & H2).", "exists Q.", "split.", "eassumption.", "eapply preservation_star; eauto.", "Qed."], "theorems": [{"name": "Equiv_pw_iff", "kind": "Instance", "begin": 7, "end": 10}, {"name": "pw", "kind": "Lemma", "begin": 11, "end": 14}, {"name": "R_ext", "kind": "Instance", "begin": 20, "end": 36}, {"name": "eval_ext", "kind": "Instance", "begin": 42, "end": 55}, {"name": "eval_ren", "kind": "Lemma", "begin": 56, "end": 70}, {"name": "eval_weaken", "kind": "Lemma", "begin": 71, "end": 74}, {"name": "lift", "kind": "Definition", "begin": 75, "end": 80}, {"name": "eval_subst", "kind": "Lemma", "begin": 82, "end": 98}, {"name": "eval_beta", "kind": "Lemma", "begin": 99, "end": 105}, {"name": "D", "kind": "Definition", "begin": 106, "end": 115}, {"name": "R_sn", "kind": "Lemma", "begin": 119, "end": 123}, {"name": "R_step", "kind": "Lemma", "begin": 124, "end": 128}, {"name": "R_var", "kind": "Lemma", "begin": 129, "end": 135}, {"name": "R_ren", "kind": "Lemma", "begin": 136, "end": 151}, {"name": "K_var", "kind": "Lemma", "begin": 152, "end": 155}, {"name": "K_arr", "kind": "Lemma", "begin": 156, "end": 165}, {"name": "K_all", "kind": "Lemma", "begin": 166, "end": 187}, {"name": "V_weaken", "kind": "Lemma", "begin": 188, "end": 191}, {"name": "K_weaken", "kind": "Lemma", "begin": 192, "end": 197}, {"name": "E_weaken", "kind": "Lemma", "begin": 198, "end": 204}, {"name": "V_beta", "kind": "Lemma", "begin": 205, "end": 208}, {"name": "E_beta", "kind": "Lemma", "begin": 209, "end": 213}, {"name": "C_ext", "kind": "Lemma", "begin": 215, "end": 220}, {"name": "C_scons", "kind": "Lemma", "begin": 221, "end": 228}, {"name": "C_rename", "kind": "Lemma", "begin": 229, "end": 233}, {"name": "C_up", "kind": "Lemma", "begin": 234, "end": 240}, {"name": "E2_ind", "kind": "Lemma", "begin": 241, "end": 247}, {"name": "E_app", "kind": "Lemma", "begin": 248, "end": 259}, {"name": "E_lam", "kind": "Lemma", "begin": 260, "end": 275}, {"name": "E_tapp", "kind": "Lemma", "begin": 276, "end": 291}, {"name": "E_tlam", "kind": "Lemma", "begin": 292, "end": 308}, {"name": "fundamental", "kind": "Lemma", "begin": 309, "end": 403}, {"name": "SN", "kind": "Lemma", "begin": 404, "end": 412}, {"name": "typing_normal_form", "kind": "Lemma", "begin": 413, "end": 421}]}