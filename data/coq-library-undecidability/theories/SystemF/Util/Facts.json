{"code": ["Require Import List Lia.", "Import ListNotations.", "Require Import ssreflect ssrbool ssrfun.", "Set Default Proof Using \"Type\".", "Set Default Goal Selector \"!\".", "Fact copy {A : Type} : A -> A * A.", "Proof.", "done.", "Qed.", "Lemma unnest : forall (A B C : Type), A -> (B -> C) -> (A -> B) -> C.", "Proof.", "auto.", "Qed.", "Lemma iter_plus {X: Type} {f: X -> X} {x: X} {n m: nat} : Nat.iter n f (Nat.iter m f x) = Nat.iter (n + m) f x.", "Proof.", "elim: n; [done | by move=> n /= ->].", "Qed.", "Fact iter_last {X: Type} {f: X -> X} {n x} : Nat.iter n f (f x) = Nat.iter (1+n) f x.", "Proof.", "elim: n x; [done | by move=> n /= + x => ->].", "Qed.", "Lemma measure_ind {X : Type} (f : X -> nat) (P : X -> Prop) : (forall x, (forall y, f y < f x -> P y) -> P x) -> forall (x : X), P x.", "Proof.", "apply : well_founded_ind.", "apply : Wf_nat.well_founded_lt_compat.", "move => *.", "by eassumption.", "Qed.", "Arguments measure_ind {X}.", "Section ForallNorm.", "Variable T : Type.", "Variable P : T -> Prop.", "Lemma Forall_nilP : Forall P [] <-> True.", "Proof.", "by constructor.", "Qed.", "Lemma Forall_consP {a A} : Forall P (a :: A) <-> P a /\\ Forall P A.", "Proof.", "constructor=> [H | [? ?]]; [by inversion H | by constructor].", "Qed.", "Lemma Forall_singletonP {a} : Forall P [a] <-> P a.", "Proof.", "rewrite Forall_consP Forall_nilP.", "by constructor=> [[? ?] | ?].", "Qed.", "Lemma Forall_appP {A B}: Forall P (A ++ B) <-> Forall P A /\\ Forall P B.", "Proof.", "elim: A; first by (constructor; by [|case]).", "move=> ? ? IH /=.", "by rewrite ?Forall_consP IH and_assoc.", "Qed.", "Definition Forall_norm := (@Forall_appP, @Forall_singletonP, @Forall_consP, @Forall_nilP).", "Lemma Forall_appI {A B}: Forall P A -> Forall P B -> Forall P (A ++ B).", "Proof.", "move=> ? ?.", "apply /Forall_appP.", "by constructor.", "Qed.", "End ForallNorm.", "Lemma nth_error_map {X Y: Type} {f: X -> Y} {l: list X} {n: nat} : nth_error (map f l) n = omap f (nth_error l n).", "Proof.", "elim: n l; first by case.", "move=> n IH.", "case; first done.", "move=> x l /=.", "by rewrite /nth_error -?/(nth_error _ _).", "Qed.", "Lemma incl_nth_error {X: Type} {Gamma Gamma': list X} : incl Gamma Gamma' -> exists \u03be, forall x, nth_error Gamma x = nth_error Gamma' (\u03be x).", "Proof.", "elim: Gamma Gamma'.", "-", "move=> Gamma' _.", "exists (fun x => length Gamma').", "move=> [|x] /=; apply /esym; by apply /nth_error_None.", "-", "move=> x Gamma IH Gamma'.", "rewrite /incl -Forall_forall Forall_norm Forall_forall.", "move=> [/(@In_nth_error _ _ _) [nx] Hnx /IH] [\u03be H\u03be].", "exists (fun y => if y is S y then \u03be y else nx).", "by case.", "Qed.", "Lemma Forall_mapP {X Y : Type} {P : Y -> Prop} {f : X -> Y} {l : list X} : Forall P (map f l) <-> Forall (fun x => P (f x)) l.", "Proof.", "elim: l.", "-", "move=> /=.", "by constructor.", "-", "move=> a l IH /=.", "by rewrite ? Forall_norm IH.", "Qed.", "Lemma Forall_seqP {P : nat -> Prop} {m n: nat} : Forall P (seq m n) <-> (forall i, m <= i < m + n -> P i).", "Proof.", "rewrite Forall_forall.", "constructor; move=> H ? ?; apply H; by apply /in_seq.", "Qed.", "Lemma Forall2_consE {X Y: Type} {R: X -> Y -> Prop} {x y l1 l2} : Forall2 R (x :: l1) (y :: l2) -> R x y /\\ Forall2 R l1 l2.", "Proof.", "move=> H.", "by inversion H.", "Qed.", "Lemma Forall2_length_eq {X Y: Type} {R: X -> Y -> Prop} {l1 l2} : Forall2 R l1 l2 -> length l1 = length l2.", "Proof.", "elim: l1 l2.", "-", "move=> [| ? ?] H; first done.", "by inversion H.", "-", "move=> ? ? IH [| ? ?] /= H; inversion H.", "congr S.", "by apply: IH.", "Qed.", "Lemma in_app_l {X: Type} {x: X} {l1 l2: list X} : In x l1 -> In x (l1 ++ l2).", "Proof.", "move=> ?.", "apply /in_app_iff.", "by left.", "Qed.", "Lemma in_app_r {X: Type} {x: X} {l1 l2: list X} : In x l2 -> In x (l1 ++ l2).", "Proof.", "move=> ?.", "apply /in_app_iff.", "by right.", "Qed.", "Lemma list_choice {P : nat -> nat -> Prop} {l: list nat} : Forall (fun i : nat => exists n : nat, P i n) l -> exists \u03c6, Forall (fun i : nat => P i (\u03c6 i)) l.", "Proof.", "elim /rev_ind: l.", "-", "move=> ?.", "exists id.", "by constructor.", "-", "move=> k l IH.", "rewrite Forall_app.", "move=> [/IH [\u03c6 H\u03c6]] /(@Forall_inv _ _ _) [n Hn].", "exists (fun i => if PeanoNat.Nat.eq_dec i k then n else \u03c6 i).", "rewrite Forall_app.", "constructor.", "+", "move: H\u03c6.", "rewrite ?Forall_forall => H i.", "case: (PeanoNat.Nat.eq_dec _ _); [by move=> /= -> | by move=> *; apply: H].", "+", "constructor; last done.", "by case: (PeanoNat.Nat.eq_dec _ _).", "Qed.", "Lemma repeat_appP {X: Type} {x: X} {n m: nat} : repeat x n ++ repeat x m = repeat x (n+m).", "Proof.", "by elim: n; [| move=> ? /= ->].", "Qed.", "Lemma map_id' {X: Type} {f: X -> X} {l: list X} : (forall x, f x = x) -> map f l = l.", "Proof.", "move=> ?.", "rewrite -[RHS]map_id.", "by apply: map_ext => ?.", "Qed.", "Lemma is_trueP {b1 b2: bool} : (is_true b1 <-> is_true b2) <-> b1 = b2.", "Proof.", "case: b1; case: b2; rewrite /is_true; firstorder done.", "Qed."], "theorems": [{"name": "copy", "kind": "Fact", "begin": 5, "end": 8}, {"name": "unnest", "kind": "Lemma", "begin": 9, "end": 12}, {"name": "iter_plus", "kind": "Lemma", "begin": 13, "end": 16}, {"name": "iter_last", "kind": "Fact", "begin": 17, "end": 20}, {"name": "measure_ind", "kind": "Lemma", "begin": 21, "end": 27}, {"name": "Forall_nilP", "kind": "Lemma", "begin": 32, "end": 35}, {"name": "Forall_consP", "kind": "Lemma", "begin": 36, "end": 39}, {"name": "Forall_singletonP", "kind": "Lemma", "begin": 40, "end": 44}, {"name": "Forall_appP", "kind": "Lemma", "begin": 45, "end": 50}, {"name": "Forall_appI", "kind": "Lemma", "begin": 52, "end": 57}, {"name": "nth_error_map", "kind": "Lemma", "begin": 59, "end": 66}, {"name": "incl_nth_error", "kind": "Lemma", "begin": 67, "end": 80}, {"name": "Forall_mapP", "kind": "Lemma", "begin": 81, "end": 90}, {"name": "Forall_seqP", "kind": "Lemma", "begin": 91, "end": 95}, {"name": "Forall2_consE", "kind": "Lemma", "begin": 96, "end": 100}, {"name": "Forall2_length_eq", "kind": "Lemma", "begin": 101, "end": 111}, {"name": "in_app_l", "kind": "Lemma", "begin": 112, "end": 117}, {"name": "in_app_r", "kind": "Lemma", "begin": 118, "end": 123}, {"name": "list_choice", "kind": "Lemma", "begin": 124, "end": 145}, {"name": "repeat_appP", "kind": "Lemma", "begin": 146, "end": 149}, {"name": "map_id'", "kind": "Lemma", "begin": 150, "end": 155}, {"name": "is_trueP", "kind": "Lemma", "begin": 156, "end": 159}]}