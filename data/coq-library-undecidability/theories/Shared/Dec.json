{"code": ["Set Implicit Arguments.", "Hint Extern 4 => exact _ : core.", "Ltac inv H := inversion H; subst; clear H.", "Definition dec (X: Prop) : Type := {X} + {~ X}.", "Coercion dec2bool P (d: dec P) := if d then true else false.", "Definition is_true (b : bool) := b = true.", "Existing Class dec.", "Definition Dec (X: Prop) (d: dec X) : dec X := d.", "Arguments Dec X {d}.", "Lemma Dec_reflect (X: Prop) (d: dec X) : is_true (Dec X) <-> X.", "Proof.", "destruct d as [A|A]; cbv in *; intuition congruence.", "Qed.", "Lemma Dec_auto (X: Prop) (d: dec X) : X -> is_true (Dec X).", "Proof.", "destruct d as [A|A]; cbn; intuition congruence.", "Qed.", "Hint Extern 4 => (* Improves type class inference *) match goal with | [ |- dec ((fun _ => _) _) ] => cbn end : typeclass_instances.", "Tactic Notation \"decide\" constr(p) := destruct (Dec p).", "Tactic Notation \"decide\" constr(p) \"as\" simple_intropattern(i) := destruct (Dec p) as i.", "Tactic Notation \"decide\" \"_\" := destruct (Dec _).", "Lemma Dec_true P {H : dec P} : dec2bool (Dec P) = true -> P.", "Proof.", "decide P; cbv in *; firstorder.", "congruence.", "Qed.", "Lemma Dec_false P {H : dec P} : dec2bool (Dec P) = false -> ~P.", "Proof.", "decide P; cbv in *; firstorder.", "congruence.", "Qed.", "Hint Extern 4 => match goal with [ H : dec2bool (Dec ?P) = true |- _ ] => apply Dec_true in H | [ H : dec2bool (Dec ?P) = true |- _ ] => apply Dec_false in H end : core.", "Lemma dec_DN X : dec X -> ~~ X -> X.", "Proof.", "unfold dec; tauto.", "Qed.", "Lemma dec_DM_and X Y : dec X -> dec Y -> ~ (X /\\ Y) -> ~ X \\/ ~ Y.", "Proof.", "unfold dec; tauto.", "Qed.", "Lemma dec_DM_impl X Y : dec X -> dec Y -> ~ (X -> Y) -> X /\\ ~ Y.", "Proof.", "unfold dec; tauto.", "Qed.", "Fact dec_transfer P Q : P <-> Q -> dec P -> dec Q.", "Proof.", "unfold dec.", "tauto.", "Qed.", "Instance True_dec : dec True.", "Proof.", "unfold dec; tauto.", "Qed.", "Instance False_dec : dec False.", "Proof.", "unfold dec; tauto.", "Qed.", "Instance impl_dec (X Y : Prop) : dec X -> dec Y -> dec (X -> Y).", "Proof.", "unfold dec; tauto.", "Qed.", "Instance and_dec (X Y : Prop) : dec X -> dec Y -> dec (X /\\ Y).", "Proof.", "unfold dec; tauto.", "Qed.", "Instance or_dec (X Y : Prop) : dec X -> dec Y -> dec (X \\/ Y).", "Proof.", "unfold dec; tauto.", "Qed.", "Instance not_dec (X : Prop) : dec X -> dec (~ X).", "Proof.", "unfold not.", "auto.", "Qed.", "Instance iff_dec (X Y : Prop) : dec X -> dec Y -> dec (X <-> Y).", "Proof.", "unfold iff.", "auto.", "Qed.", "Notation \"'eq_dec' X\" := (forall x y : X, dec (x=y)) (at level 70).", "Structure eqType := EqType { eqType_X :> Type; eqType_dec : eq_dec eqType_X }.", "Arguments EqType X {_} : rename.", "Canonical Structure eqType_CS X (A: eq_dec X) := EqType X.", "Existing Instance eqType_dec.", "Instance unit_eq_dec : eq_dec unit.", "Proof.", "unfold dec.", "decide equality.", "Qed.", "Instance bool_eq_dec : eq_dec bool.", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance nat_eq_dec : eq_dec nat.", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance prod_eq_dec X Y : eq_dec X -> eq_dec Y -> eq_dec (X * Y).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance list_eq_dec X : eq_dec X -> eq_dec (list X).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance sum_eq_dec X Y : eq_dec X -> eq_dec Y -> eq_dec (X + Y).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance option_eq_dec X : eq_dec X -> eq_dec (option X).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance Empty_set_eq_dec: eq_dec Empty_set.", "Proof.", "unfold dec.", "decide equality.", "Qed.", "Instance True_eq_dec: eq_dec True.", "Proof.", "intros x y.", "destruct x,y.", "now left.", "Qed.", "Instance False_eq_dec: eq_dec False.", "Proof.", "intros [].", "Qed."], "theorems": [{"name": "Dec_reflect", "kind": "Lemma", "begin": 9, "end": 12}, {"name": "Dec_auto", "kind": "Lemma", "begin": 13, "end": 16}, {"name": "Dec_true", "kind": "Lemma", "begin": 21, "end": 25}, {"name": "Dec_false", "kind": "Lemma", "begin": 26, "end": 30}, {"name": "dec_DN", "kind": "Lemma", "begin": 32, "end": 35}, {"name": "dec_DM_and", "kind": "Lemma", "begin": 36, "end": 39}, {"name": "dec_DM_impl", "kind": "Lemma", "begin": 40, "end": 43}, {"name": "dec_transfer", "kind": "Fact", "begin": 44, "end": 48}, {"name": "True_dec", "kind": "Instance", "begin": 49, "end": 52}, {"name": "False_dec", "kind": "Instance", "begin": 53, "end": 56}, {"name": "impl_dec", "kind": "Instance", "begin": 57, "end": 60}, {"name": "and_dec", "kind": "Instance", "begin": 61, "end": 64}, {"name": "or_dec", "kind": "Instance", "begin": 65, "end": 68}, {"name": "not_dec", "kind": "Instance", "begin": 69, "end": 73}, {"name": "iff_dec", "kind": "Instance", "begin": 74, "end": 78}, {"name": "unit_eq_dec", "kind": "Instance", "begin": 84, "end": 88}, {"name": "bool_eq_dec", "kind": "Instance", "begin": 89, "end": 93}, {"name": "nat_eq_dec", "kind": "Instance", "begin": 94, "end": 98}, {"name": "prod_eq_dec", "kind": "Instance", "begin": 99, "end": 103}, {"name": "list_eq_dec", "kind": "Instance", "begin": 104, "end": 108}, {"name": "sum_eq_dec", "kind": "Instance", "begin": 109, "end": 113}, {"name": "option_eq_dec", "kind": "Instance", "begin": 114, "end": 118}, {"name": "Empty_set_eq_dec", "kind": "Instance", "begin": 119, "end": 123}, {"name": "True_eq_dec", "kind": "Instance", "begin": 124, "end": 129}, {"name": "False_eq_dec", "kind": "Instance", "begin": 130, "end": 133}]}