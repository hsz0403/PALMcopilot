{"code": ["Require Import Arith Lia List Permutation.", "From Undecidability.Shared.Libs.DLW.Utils Require Import php.", "From Undecidability.Shared.Libs.DLW.Wf Require Import measure_ind.", "Set Implicit Arguments.", "Reserved Notation \"x \u2261 y\" (at level 70, no associativity).", "Reserved Notation \"x \u2286 y\" (at level 70, no associativity).", "Local Infix \"~p\" := (@Permutation _) (at level 70, no associativity).", "Section seteq.", "Variable X : Type.", "Inductive seteq : list X -> list X -> Prop := | seteq_nil : nil \u2261 nil | seteq_skip : forall x l m, l \u2261 m -> x::l \u2261 x::m | seteq_swap : forall x y l, x::y::l \u2261 y::x::l | seteq_dup : forall x l, x::x::l \u2261 x::l | seteq_sym : forall l m, l \u2261 m -> m \u2261 l | seteq_trans : forall l m k, l \u2261 m -> m \u2261 k -> l \u2261 k where \"l \u2261 m\" := (seteq l m).", "Hint Constructors seteq : core.", "Fact perm_seteq l m : l ~p m -> l \u2261 m.", "Proof.", "induction 1; eauto.", "Qed.", "Notation \"l \u2286 m\" := (incl l m).", "Fact incl_cons_mono (x : X) l m : l \u2286 m -> x::l \u2286 x::m.", "Proof.", "intros ? ? [ -> | ]; simpl; auto.", "Qed.", "Fact incl_swap (x y : X) l : x::y::l \u2286 y::x::l.", "Proof.", "intros ? [ -> | [ -> | ] ]; simpl; auto.", "Qed.", "Fact incl_cntr (x : X) l : x::x::l \u2286 x::l.", "Proof.", "intros ? [ -> | [ -> | ] ]; simpl; auto.", "Qed.", "Hint Resolve incl_refl incl_cons_mono incl_swap incl_cntr incl_tl : core.", "Fact seqeq_incl l m : l \u2261 m -> l \u2286 m /\\ m \u2286 l.", "Proof.", "induction 1 as [ | x l m H [] | x y l | x l | l m H [] | l m k H1 IH1 H2 IH2 ]; auto.", "split; apply incl_tran with m; tauto.", "Qed.", "Lemma list_has_dup_seteq l : list_has_dup l -> exists m, m \u2261 l /\\ length m < length l.", "Proof.", "induction 1 as [ l x H | l x H (m & H1 & H2) ].", "+", "induction l as [ | y l IHl ].", "*", "exfalso; destruct H.", "*", "destruct H as [ -> | H ].", "-", "exists (x::l); simpl; split; auto; lia.", "-", "destruct (IHl H) as (m & H1 & H2).", "exists (y::m); simpl in *; split; try lia.", "apply seteq_trans with (y::x::l); auto.", "+", "exists (x::m); simpl; split; auto; lia.", "Qed.", "Lemma incl_seteq l m : l \u2286 m -> m \u2286 l -> l \u2261 m.", "Proof.", "induction on l m as IH with measure (length l + length m).", "intros H1 H2.", "destruct (le_lt_dec (length l) (length m)) as [ H3 | H3 ]; [ destruct length_le_and_incl_implies_dup_or_perm with (1 := H3) as [ H4 | H4 ]; auto | ].", "+", "destruct list_has_dup_seteq with (1 := H4) as (m' & H5 & H6).", "apply seteq_trans with m'; auto.", "apply seqeq_incl in H5; destruct H5.", "apply IH; try lia; apply incl_tran with m; auto.", "+", "apply seteq_sym, perm_seteq; auto.", "+", "generalize (finite_php_dup H3 H1); intros H4.", "destruct list_has_dup_seteq with (1 := H4) as (m' & H5 & H6).", "apply seteq_trans with m'; auto.", "apply seqeq_incl in H5; destruct H5.", "apply IH; try lia; apply incl_tran with l; auto.", "Qed.", "Hint Resolve seqeq_incl incl_seteq : core.", "Theorem seteq_bi_incl l m : l \u2261 m <-> l \u2286 m /\\ m \u2286 l.", "Proof.", "split; auto; intros []; auto.", "Qed.", "End seteq.", "Local Infix \"\u2261\" := seteq.", "Local Infix \"\u2286\" := incl."], "theorems": [{"name": "perm_seteq", "kind": "Fact", "begin": 11, "end": 14}, {"name": "incl_cons_mono", "kind": "Fact", "begin": 16, "end": 19}, {"name": "incl_swap", "kind": "Fact", "begin": 20, "end": 23}, {"name": "incl_cntr", "kind": "Fact", "begin": 24, "end": 27}, {"name": "seqeq_incl", "kind": "Fact", "begin": 29, "end": 33}, {"name": "list_has_dup_seteq", "kind": "Lemma", "begin": 34, "end": 51}, {"name": "incl_seteq", "kind": "Lemma", "begin": 52, "end": 70}, {"name": "seteq_bi_incl", "kind": "Theorem", "begin": 72, "end": 75}]}