{"code": ["From Undecidability.Shared.Libs.PSL Require Import Prelim.", "Definition dec (X: Prop) : Type := {X} + {~ X}.", "Coercion dec2bool P (d: dec P) := if d then true else false.", "Existing Class dec.", "Definition Dec (X: Prop) (d: dec X) : dec X := d.", "Arguments Dec X {d}.", "Lemma Dec_reflect (X: Prop) (d: dec X) : Dec X <-> X.", "Proof.", "destruct d as [A|A]; cbv; firstorder congruence.", "Qed.", "Notation Decb X := (dec2bool (Dec X)).", "Lemma Dec_reflect_eq (X Y: Prop) (d: dec X) (e: dec Y) : Decb X = Decb Y <-> (X <-> Y).", "Proof.", "destruct d as [D|D], e as [E|E]; cbn; intuition congruence.", "Qed.", "Lemma Dec_auto (X: Prop) (d: dec X) : X -> Dec X.", "Proof.", "destruct d as [A|A]; cbn; intuition congruence.", "Qed.", "Lemma Dec_auto_not (X: Prop) (d: dec X) : ~ X -> ~ Dec X.", "Proof.", "destruct d as [A|A]; cbn; intuition congruence.", "Qed.", "Hint Resolve Dec_auto Dec_auto_not : core.", "Hint Extern 4 => (* Improves type class inference *) match goal with | [ |- dec ((fun _ => _) _) ] => cbn end : typeclass_instances.", "Tactic Notation \"decide\" constr(p) := destruct (Dec p).", "Tactic Notation \"decide\" constr(p) \"as\" simple_intropattern(i) := destruct (Dec p) as i.", "Tactic Notation \"decide\" \"_\" := destruct (Dec _).", "Tactic Notation \"have\" constr(E) := let X := fresh \"E\" in decide E as [X|X]; subst; try congruence; try lia; clear X.", "Lemma Dec_true P {H : dec P} : dec2bool (Dec P) = true -> P.", "Proof.", "decide P; cbv in *; firstorder.", "Qed.", "Lemma Dec_false P {H : dec P} : dec2bool (Dec P) = false -> ~P.", "Proof.", "decide P; cbv in *; firstorder.", "Qed.", "Lemma Dec_true' (P : Prop) (d : dec P) : P -> Decb P = true.", "Proof.", "intros H.", "decide P; cbn; tauto.", "Qed.", "Lemma Dec_false' (P : Prop) (d : dec P) : (~ P) -> Decb P = false.", "Proof.", "intros H.", "decide P; cbn; tauto.", "Qed.", "Hint Extern 4 => match goal with [ H : dec2bool (Dec ?P) = true |- _ ] => apply Dec_true in H | [ H : dec2bool (Dec ?P) = false |- _ ] => apply Dec_false in H | [ |- dec2bool (Dec ?P) = true] => apply Dec_true' | [ |- dec2bool (Dec ?P) = false] => apply Dec_false' end : core.", "Lemma dec_DN X : dec X -> ~~ X -> X.", "Proof.", "unfold dec; tauto.", "Qed.", "Lemma dec_DM_and X Y : dec X -> dec Y -> ~ (X /\\ Y) -> ~ X \\/ ~ Y.", "Proof.", "unfold dec; tauto.", "Qed.", "Lemma dec_DM_impl X Y : dec X -> dec Y -> ~ (X -> Y) -> X /\\ ~ Y.", "Proof.", "unfold dec; tauto.", "Qed.", "Fact dec_transfer P Q : P <-> Q -> dec P -> dec Q.", "Proof.", "unfold dec.", "tauto.", "Defined.", "Instance bool_dec (b: bool) : dec b.", "Proof.", "unfold dec.", "destruct b; cbn; auto.", "Defined.", "Instance True_dec : dec True.", "Proof.", "unfold dec; tauto.", "Defined.", "Instance False_dec : dec False.", "Proof.", "unfold dec; tauto.", "Defined.", "Instance impl_dec (X Y : Prop) : dec X -> dec Y -> dec (X -> Y).", "Proof.", "unfold dec; tauto.", "Defined.", "Instance and_dec (X Y : Prop) : dec X -> dec Y -> dec (X /\\ Y).", "Proof.", "unfold dec; tauto.", "Defined.", "Instance or_dec (X Y : Prop) : dec X -> dec Y -> dec (X \\/ Y).", "Proof.", "unfold dec; tauto.", "Defined.", "Instance not_dec (X : Prop) : dec X -> dec (~ X).", "Proof.", "unfold not.", "auto.", "Defined.", "Instance iff_dec (X Y : Prop) : dec X -> dec Y -> dec (X <-> Y).", "Proof.", "unfold iff.", "auto.", "Defined.", "Notation \"'eq_dec' X\" := (forall x y : X, dec (x=y)) (at level 70).", "Structure eqType := EqType { eqType_X :> Type; eqType_dec : eq_dec eqType_X }.", "Arguments EqType X {_} : rename.", "Canonical Structure eqType_CS X (A: eq_dec X) := EqType X.", "Existing Instance eqType_dec.", "Arguments eqType_CS (X) {_}.", "Instance unit_eq_dec : eq_dec unit.", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance bool_eq_dec : eq_dec bool.", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance nat_eq_dec : eq_dec nat.", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance prod_eq_dec X Y : eq_dec X -> eq_dec Y -> eq_dec (X * Y).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance list_eq_dec X : eq_dec X -> eq_dec (list X).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance sum_eq_dec X Y : eq_dec X -> eq_dec Y -> eq_dec (X + Y).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance option_eq_dec X : eq_dec X -> eq_dec (option X).", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance Empty_set_eq_dec: eq_dec Empty_set.", "Proof.", "unfold dec.", "decide equality.", "Defined.", "Instance True_eq_dec: eq_dec True.", "Proof.", "intros x y.", "destruct x,y.", "now left.", "Defined.", "Instance False_eq_dec: eq_dec False.", "Proof.", "intros [].", "Defined."], "theorems": [{"name": "Dec_reflect", "kind": "Lemma", "begin": 6, "end": 9}, {"name": "Dec_reflect_eq", "kind": "Lemma", "begin": 11, "end": 14}, {"name": "Dec_auto", "kind": "Lemma", "begin": 15, "end": 18}, {"name": "Dec_auto_not", "kind": "Lemma", "begin": 19, "end": 22}, {"name": "Dec_true", "kind": "Lemma", "begin": 29, "end": 32}, {"name": "Dec_false", "kind": "Lemma", "begin": 33, "end": 36}, {"name": "Dec_true'", "kind": "Lemma", "begin": 37, "end": 41}, {"name": "Dec_false'", "kind": "Lemma", "begin": 42, "end": 46}, {"name": "dec_DN", "kind": "Lemma", "begin": 48, "end": 51}, {"name": "dec_DM_and", "kind": "Lemma", "begin": 52, "end": 55}, {"name": "dec_DM_impl", "kind": "Lemma", "begin": 56, "end": 59}, {"name": "dec_transfer", "kind": "Fact", "begin": 60, "end": 64}, {"name": "bool_dec", "kind": "Instance", "begin": 65, "end": 69}, {"name": "True_dec", "kind": "Instance", "begin": 70, "end": 73}, {"name": "False_dec", "kind": "Instance", "begin": 74, "end": 77}, {"name": "impl_dec", "kind": "Instance", "begin": 78, "end": 81}, {"name": "and_dec", "kind": "Instance", "begin": 82, "end": 85}, {"name": "or_dec", "kind": "Instance", "begin": 86, "end": 89}, {"name": "not_dec", "kind": "Instance", "begin": 90, "end": 94}, {"name": "iff_dec", "kind": "Instance", "begin": 95, "end": 99}, {"name": "unit_eq_dec", "kind": "Instance", "begin": 106, "end": 110}, {"name": "bool_eq_dec", "kind": "Instance", "begin": 111, "end": 115}, {"name": "nat_eq_dec", "kind": "Instance", "begin": 116, "end": 120}, {"name": "prod_eq_dec", "kind": "Instance", "begin": 121, "end": 125}, {"name": "list_eq_dec", "kind": "Instance", "begin": 126, "end": 130}, {"name": "sum_eq_dec", "kind": "Instance", "begin": 131, "end": 135}, {"name": "option_eq_dec", "kind": "Instance", "begin": 136, "end": 140}, {"name": "Empty_set_eq_dec", "kind": "Instance", "begin": 141, "end": 145}, {"name": "True_eq_dec", "kind": "Instance", "begin": 146, "end": 151}, {"name": "False_eq_dec", "kind": "Instance", "begin": 152, "end": 155}]}