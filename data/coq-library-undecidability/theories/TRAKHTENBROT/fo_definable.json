{"code": ["Require Import List Arith Lia.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic.", "Set Implicit Arguments.", "Notation \u00f8 := vec_nil.", "Opaque fo_term_subst fo_term_map fo_term_sem.", "Section fo_definability.", "Variable (\u03a3 : fo_signature) (ls : list (syms \u03a3)) (lr : list (rels \u03a3)) (X : Type) (M : fo_model \u03a3 X).", "Definition fot_definable (f : (nat -> X) -> X) := { t | incl (fo_term_syms t) ls /\\ forall \u03c6, fo_term_sem M \u03c6 t = f \u03c6 }.", "Definition fol_definable (R : (nat -> X) -> Prop) := { A | incl (fol_syms A) ls /\\ incl (fol_rels A) lr /\\ forall \u03c6, fol_sem M \u03c6 A <-> R \u03c6 }.", "Fact fot_def_ext t : fot_definable t -> forall \u03c6 \u03c8, (forall n, \u03c6 n = \u03c8 n) -> t \u03c6 = t \u03c8.", "Proof.", "intros (k & _ & Hk) phi psi H.", "rewrite <- Hk, <- Hk; apply fo_term_sem_ext; auto.", "Qed.", "Fact fol_def_ext R : fol_definable R -> forall \u03c6 \u03c8, (forall n, \u03c6 n = \u03c8 n) -> R \u03c6 <-> R \u03c8.", "Proof.", "intros (A & _ & _ & HA) phi psi H.", "rewrite <- HA, <- HA; apply fol_sem_ext.", "intros; auto.", "Qed.", "Fact fot_def_proj n : fot_definable (fun \u03c6 => \u03c6 n).", "Proof.", "exists (\u00a3 n); intros; split; rew fot; auto; intros _ [].", "Qed.", "Fact fot_def_map (f : nat -> nat) t : fot_definable t -> fot_definable (fun \u03c6 => t (fun n => \u03c6 (f n))).", "Proof.", "intros H; generalize (fot_def_ext H); revert H.", "intros (k & H1 & H2) H3.", "exists (fo_term_map f k); split.", "+", "rewrite fo_term_syms_map; auto.", "+", "intro phi; rewrite <- fo_term_subst_map; rew fot.", "rewrite H2; apply H3; intro; rew fot; auto.", "Qed.", "Fact fot_def_comp s v : In s ls -> (forall p, fot_definable (fun \u03c6 => vec_pos (v \u03c6) p)) -> fot_definable (fun \u03c6 => fom_syms M s (v \u03c6)).", "Proof.", "intros H0 H; apply vec_reif_t in H.", "destruct H as (w & Hw).", "exists (in_fot _ w); split; rew fot.", "+", "intros x [ -> | H ]; auto; revert H.", "rewrite in_flat_map.", "intros (t & H1 & H2).", "apply in_vec_list, in_vec_inv in H1.", "destruct H1 as (p & <- ).", "revert H2; apply Hw.", "+", "intros phi; rew fot; f_equal.", "apply vec_pos_ext; intros p.", "rewrite vec_pos_map.", "apply Hw; auto.", "Qed.", "Fact fot_def_equiv f g : (forall \u03c6, f \u03c6 = g \u03c6) -> fot_definable f -> fot_definable g.", "Proof.", "intros E (t & H1 & H2); exists t; split; auto; intro; rewrite H2; auto.", "Qed.", "Fact fol_def_atom r v : In r lr -> (forall p, fot_definable (fun \u03c6 => vec_pos (v \u03c6) p)) -> fol_definable (fun \u03c6 => fom_rels M r (v \u03c6)).", "Proof.", "intros H0 H; apply vec_reif_t in H.", "destruct H as (w & Hw).", "exists (@fol_atom _ _ w); msplit 2.", "+", "simpl; intro s; rewrite in_flat_map.", "intros (t & H1 & H2).", "apply in_vec_list, in_vec_inv in H1.", "destruct H1 as (p & <- ).", "revert H2; apply Hw.", "+", "simpl; intros ? [ -> | [] ]; auto.", "+", "intros phi; simpl.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p.", "rewrite vec_pos_map; apply Hw; auto.", "Qed.", "Fact fol_def_True : fol_definable (fun _ => True).", "Proof.", "exists (\u22a5\u2911\u22a5); intros; simpl; msplit 2; try red; simpl; tauto.", "Qed.", "Fact fol_def_False : fol_definable (fun _ => False).", "Proof.", "exists \u22a5; intros; simpl; msplit 2; try red; simpl; tauto.", "Qed.", "Fact fol_def_equiv R T : (forall \u03c6, R \u03c6 <-> T \u03c6) -> fol_definable R -> fol_definable T.", "Proof.", "intros H (A & H1 & H2 & H3); exists A; msplit 2; auto; intro; rewrite <- H; auto.", "Qed.", "Fact fol_def_conj R T : fol_definable R -> fol_definable T -> fol_definable (fun \u03c6 => R \u03c6 /\\ T \u03c6).", "Proof.", "intros (A & H1 & H2 & H3) (B & HH4 & H5 & H6); exists (fol_bin fol_conj A B); msplit 2.", "1,2: simpl; intro; rewrite in_app_iff; intros []; auto.", "intro; simpl; rewrite H3, H6; tauto.", "Qed.", "Fact fol_def_disj R T : fol_definable R -> fol_definable T -> fol_definable (fun \u03c6 => R \u03c6 \\/ T \u03c6).", "Proof.", "intros (A & H1 & H2 & H3) (B & HH4 & H5 & H6); exists (fol_bin fol_disj A B); msplit 2.", "1,2: simpl; intro; rewrite in_app_iff; intros []; auto.", "intro; simpl; rewrite H3, H6; tauto.", "Qed.", "Fact fol_def_imp R T : fol_definable R -> fol_definable T -> fol_definable (fun \u03c6 => R \u03c6 -> T \u03c6).", "Proof.", "intros (A & H1 & H2 & H3) (B & HH4 & H5 & H6); exists (fol_bin fol_imp A B); msplit 2.", "1,2: simpl; intro; rewrite in_app_iff; intros []; auto.", "intro; simpl; rewrite H3, H6; tauto.", "Qed.", "Fact fol_def_fa (R : X -> (nat -> X) -> Prop) : fol_definable (fun \u03c6 => R (\u03c6 0) (fun n => \u03c6 (S n))) -> fol_definable (fun \u03c6 => forall x, R x \u03c6).", "Proof.", "intros (A & H1 & H2 & H3); exists (fol_quant fol_fa A); msplit 2; auto.", "intro; simpl; apply forall_equiv.", "intro; rewrite H3; simpl; tauto.", "Qed.", "Fact fol_def_ex (R : X -> (nat -> X) -> Prop) : fol_definable (fun \u03c6 => R (\u03c6 0) (fun n => \u03c6 (S n))) -> fol_definable (fun \u03c6 => exists x, R x \u03c6).", "Proof.", "intros (A & H1 & H2 & H3); exists (fol_quant fol_ex A); msplit 2; auto.", "intro; simpl; apply exists_equiv.", "intro; rewrite H3; simpl; tauto.", "Qed.", "Fact fol_def_list_fa K l (R : K -> (nat -> X) -> Prop) : (forall k, In k l -> fol_definable (R k)) -> fol_definable (fun \u03c6 => forall k, In k l -> R k \u03c6).", "Proof.", "intros H.", "set (f := fun k Hk => proj1_sig (H k Hk)).", "exists (fol_lconj (list_in_map l f)); msplit 2.", "+", "rewrite fol_syms_bigop.", "intros s; simpl; rewrite <- app_nil_end.", "rewrite in_flat_map.", "intros (A & H1 & H2).", "apply In_list_in_map_inv in H1.", "destruct H1 as (k & Hk & ->).", "revert H2; apply (proj2_sig (H k Hk)); auto.", "+", "rewrite fol_rels_bigop.", "intros s; simpl; rewrite <- app_nil_end.", "rewrite in_flat_map.", "intros (A & H1 & H2).", "apply In_list_in_map_inv in H1.", "destruct H1 as (k & Hk & ->).", "revert H2; apply (proj2_sig (H k Hk)); auto.", "+", "intros phi.", "rewrite fol_sem_lconj; split.", "*", "intros H1 k Hk; apply (proj2_sig (H k Hk)), H1.", "change (In (f k Hk) (list_in_map l f)).", "apply In_list_in_map.", "*", "intros H1 A H2.", "apply In_list_in_map_inv in H2.", "destruct H2 as (k & Hk & ->).", "apply (proj2_sig (H k Hk)); auto.", "Qed.", "Fact fol_def_bounded_fa m (R : nat -> (nat -> X) -> Prop) : (forall n, n < m -> fol_definable (R n)) -> fol_definable (fun \u03c6 => forall n, n < m -> R n \u03c6).", "Proof.", "intros H.", "apply fol_def_equiv with (R := fun \u03c6 => forall n, In n (list_an 0 m) -> R n \u03c6).", "+", "intros phi; apply forall_equiv; intro; rewrite list_an_spec; simpl; split; try tauto.", "intros H1 ?; apply H1; lia.", "+", "apply fol_def_list_fa.", "intros n Hn; apply H; revert Hn; rewrite list_an_spec; lia.", "Qed.", "Fact fol_def_list_ex K l (R : K -> (nat -> X) -> Prop) : (forall k, In k l -> fol_definable (R k)) -> fol_definable (fun \u03c6 => exists k, In k l /\\ R k \u03c6).", "Proof.", "intros H.", "set (f := fun k Hk => proj1_sig (H k Hk)).", "exists (fol_ldisj (list_in_map l f)); msplit 2.", "+", "rewrite fol_syms_bigop.", "intros s; simpl; rewrite <- app_nil_end.", "rewrite in_flat_map.", "intros (A & H1 & H2).", "apply In_list_in_map_inv in H1.", "destruct H1 as (k & Hk & ->).", "revert H2; apply (proj2_sig (H k Hk)); auto.", "+", "rewrite fol_rels_bigop.", "intros s; simpl; rewrite <- app_nil_end.", "rewrite in_flat_map.", "intros (A & H1 & H2).", "apply In_list_in_map_inv in H1.", "destruct H1 as (k & Hk & ->).", "revert H2; apply (proj2_sig (H k Hk)); auto.", "+", "intros phi.", "rewrite fol_sem_ldisj; split.", "*", "intros (A & H1 & HA).", "apply In_list_in_map_inv in H1.", "destruct H1 as (k & Hk & ->).", "exists k; split; auto.", "apply (proj2_sig (H k Hk)); auto.", "*", "intros (k & Hk & H1).", "exists (f k Hk); split.", "-", "apply In_list_in_map.", "-", "apply (proj2_sig (H k Hk)); auto.", "Qed.", "Fact fol_def_subst (R : (nat -> X) -> Prop) (f : nat -> (nat -> X) -> X) : (forall n, fot_definable (f n)) -> fol_definable R -> fol_definable (fun \u03c6 => R (fun n => f n \u03c6)).", "Proof.", "intros H1 H2.", "generalize (fol_def_ext H2); intros H3.", "destruct H2 as (A & G1 & G2 & HA).", "set (rho := fun n => proj1_sig (H1 n)).", "exists (fol_subst rho A); msplit 2.", "+", "red; apply Forall_forall; apply fol_syms_subst.", "*", "intros n Hn; rewrite Forall_forall.", "intro; apply (fun n => proj2_sig (H1 n)).", "*", "apply Forall_forall, G1.", "+", "rewrite fol_rels_subst; auto.", "+", "intros phi.", "rewrite fol_sem_subst, HA.", "apply H3; intro; unfold rho; rew fot.", "apply (fun n => proj2_sig (H1 n)).", "Qed.", "End fo_definability.", "Create HintDb fol_def_db.", "Hint Resolve fot_def_proj fot_def_map fot_def_comp fol_def_True fol_def_False : fol_def_db.", "Tactic Notation \"fol\" \"def\" := repeat (( apply fol_def_conj || apply fol_def_disj || apply fol_def_imp || apply fol_def_ex || apply fol_def_fa || (apply fol_def_atom; intro) || apply fol_def_subst); auto with fol_def_db); auto with fol_def_db.", "Section extra.", "Variable (\u03a3 : fo_signature) (ls : list (syms \u03a3)) (lr : list (rels \u03a3)) (X : Type) (M : fo_model \u03a3 X).", "Fact fol_def_iff R T : fol_definable ls lr M R -> fol_definable ls lr M T -> fol_definable ls lr M (fun \u03c6 => R \u03c6 <-> T \u03c6).", "Proof.", "intros; fol def.", "Qed.", "Fact fol_def_subst2 R t1 t2 : fol_definable ls lr M (fun \u03c6 => R (\u03c6 0) (\u03c6 1)) -> fot_definable ls M t1 -> fot_definable ls M t2 -> fol_definable ls lr M (fun \u03c6 => R (t1 \u03c6) (t2 \u03c6)).", "Proof.", "intros H1 H2 H3.", "set (f n := match n with | 0 => t1 | 1 => t2 | _ => fun \u03c6 => \u03c6 0 end).", "change (fol_definable ls lr M (fun \u03c6 => R (f 0 \u03c6) (f 1 \u03c6))).", "apply fol_def_subst with (2 := H1) (f := f).", "intros [ | [ | n ] ]; simpl; fol def.", "Qed.", "Let env_vec (\u03c6 : nat -> X) n := vec_set_pos (fun p => \u03c6 (@pos2nat n p)).", "Let env_env (\u03c6 : nat -> X) n k := \u03c6 (n+k).", "Fact fol_def_vec_fa n (R : vec X n -> (nat -> X) -> Prop) : (fol_definable ls lr M (fun \u03c6 => R (env_vec \u03c6 n) (env_env \u03c6 n))) -> fol_definable ls lr M (fun \u03c6 => forall v, R v \u03c6).", "Proof.", "revert R; induction n as [ | n IHn ]; intros R HR.", "+", "revert HR; apply fol_def_equiv; intros phi; simpl.", "split; auto; intros ? v; vec nil v; auto.", "+", "set (T \u03c6 := forall v x, R (x##v) \u03c6).", "apply fol_def_equiv with (R := T).", "*", "intros phi; unfold T; split.", "-", "intros H v; vec split v with x; auto.", "-", "intros H ? ?; apply (H (_##_)).", "*", "unfold T; apply IHn, fol_def_fa, HR.", "Qed.", "Fact fol_def_vec_ex n (R : vec X n -> (nat -> X) -> Prop) : (fol_definable ls lr M (fun \u03c6 => R (env_vec \u03c6 n) (env_env \u03c6 n))) -> fol_definable ls lr M (fun \u03c6 => exists v, R v \u03c6).", "Proof.", "revert R; induction n as [ | n IHn ]; intros R HR.", "+", "revert HR; apply fol_def_equiv; intros phi; simpl.", "split.", "*", "exists vec_nil; auto.", "*", "intros (v & Hv); revert Hv; vec nil v; auto.", "+", "set (T \u03c6 := exists v x, R (x##v) \u03c6).", "apply fol_def_equiv with (R := T).", "*", "intros phi; unfold T; split.", "-", "intros (v & x & Hv); exists (x##v); auto.", "-", "intros (v & Hv); revert Hv; vec split v with x; exists v, x; auto.", "*", "unfold T; apply IHn, fol_def_ex, HR.", "Qed.", "Fact fol_def_finite_fa I (R : I -> (nat -> X) -> Prop) : finite_t I -> (forall i, fol_definable ls lr M (R i)) -> fol_definable ls lr M (fun \u03c6 => forall i : I, R i \u03c6).", "Proof.", "intros (l & Hl) H.", "apply fol_def_equiv with (R := fun \u03c6 => forall i, In i l -> R i \u03c6).", "+", "intros phi; apply forall_equiv; intro; split; auto.", "+", "apply fol_def_list_fa; auto.", "Qed.", "Fact fol_def_finite_ex I (R : I -> (nat -> X) -> Prop) : finite_t I -> (forall i, fol_definable ls lr M (R i)) -> fol_definable ls lr M (fun \u03c6 => exists i : I, R i \u03c6).", "Proof.", "intros (l & Hl) H.", "apply fol_def_equiv with (R := fun \u03c6 => exists i, In i l /\\ R i \u03c6).", "+", "intros phi; apply exists_equiv; intro; split; auto; tauto.", "+", "apply fol_def_list_ex; auto.", "Qed.", "End extra."], "theorems": [{"name": "fot_def_ext", "kind": "Fact", "begin": 11, "end": 15}, {"name": "fol_def_ext", "kind": "Fact", "begin": 16, "end": 21}, {"name": "fot_def_proj", "kind": "Fact", "begin": 22, "end": 25}, {"name": "fot_def_map", "kind": "Fact", "begin": 26, "end": 36}, {"name": "fot_def_comp", "kind": "Fact", "begin": 37, "end": 54}, {"name": "fot_def_equiv", "kind": "Fact", "begin": 55, "end": 58}, {"name": "fol_def_atom", "kind": "Fact", "begin": 59, "end": 77}, {"name": "fol_def_True", "kind": "Fact", "begin": 78, "end": 81}, {"name": "fol_def_False", "kind": "Fact", "begin": 82, "end": 85}, {"name": "fol_def_equiv", "kind": "Fact", "begin": 86, "end": 89}, {"name": "fol_def_conj", "kind": "Fact", "begin": 90, "end": 95}, {"name": "fol_def_disj", "kind": "Fact", "begin": 96, "end": 101}, {"name": "fol_def_imp", "kind": "Fact", "begin": 102, "end": 107}, {"name": "fol_def_fa", "kind": "Fact", "begin": 108, "end": 113}, {"name": "fol_def_ex", "kind": "Fact", "begin": 114, "end": 119}, {"name": "fol_def_list_fa", "kind": "Fact", "begin": 120, "end": 153}, {"name": "fol_def_bounded_fa", "kind": "Fact", "begin": 154, "end": 164}, {"name": "fol_def_list_ex", "kind": "Fact", "begin": 165, "end": 202}, {"name": "fol_def_subst", "kind": "Fact", "begin": 203, "end": 224}, {"name": "fol_def_iff", "kind": "Fact", "begin": 231, "end": 234}, {"name": "fol_def_subst2", "kind": "Fact", "begin": 235, "end": 242}, {"name": "fol_def_vec_fa", "kind": "Fact", "begin": 245, "end": 262}, {"name": "fol_def_vec_ex", "kind": "Fact", "begin": 263, "end": 284}, {"name": "fol_def_finite_fa", "kind": "Fact", "begin": 285, "end": 293}, {"name": "fol_def_finite_ex", "kind": "Fact", "begin": 294, "end": 302}]}