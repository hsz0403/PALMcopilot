{"code": ["Require Import List Arith Bool Lia.", "From Undecidability.PCP Require Import PCP.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.Shared.Libs.DLW.Wf Require Import wf_finite.", "From Undecidability.TRAKHTENBROT Require Import notations utils bpcp fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Local Notation \u00f8 := vec_nil.", "Section BPCP_FIN_DEC_EQ_SAT.", "Variable lc : list (list bool * list bool).", "Notation \ud835\udd4b := (fol_term \u03a3bpcp).", "Notation \ud835\udd3d := (fol_form \u03a3bpcp).", "Notation e := (@in_fot _ (ar_syms \u03a3bpcp) \u03a3bpcp_unit \u00f8).", "Notation \"\u2217\" := (@in_fot _ (ar_syms \u03a3bpcp) \u03a3bpcp_undef \u00f8).", "Notation \"b \u291a x\" := (@in_fot _ (ar_syms \u03a3bpcp) (\u03a3bpcp_bool b) (x##\u00f8)) (at level 51, right associativity, format \"b \u291a x\").", "Notation \"\u00ac x\" := (x \u2911 \u22a5) (at level 59).", "Notation \"x \u29d3 y\" := (@fol_atom \u03a3bpcp \u03a3bpcp_hand (x##y##\u00f8)) (at level 58).", "Notation \"x \u227a y\" := (@fol_atom \u03a3bpcp \u03a3bpcp_ssfx (x##y##\u00f8)) (at level 58).", "Notation \"x \u2261 y\" := (@fol_atom \u03a3bpcp \u03a3bpcp_eq (x##y##\u00f8)) (at level 58).", "Notation \"x \u2262 y\" := (x \u2261 y \u2911 \u22a5) (at level 58).", "Local Definition lb_app l t := fold_right (fun b x => b \u291a x) t l.", "Notation \"l \u291c x\" := (lb_app l x) (at level 51, right associativity, format \"l \u291c x\").", "Local Fact lb_app_app l m t : (l++m)\u291ct = l\u291cm\u291ct.", "Proof.", "apply fold_right_app.", "Qed.", "Local Fact fot_vars_lb_app l t : fo_term_vars (l\u291ct) = fo_term_vars t.", "Proof.", "induction l as [ | x l IHl ]; simpl; rew fot; auto.", "simpl; rewrite <- app_nil_end; auto.", "Qed.", "Notation lb2term := (fun l => l\u291ce).", "Local Definition phi_P := \u2200\u2200 \u00a31 \u29d3 \u00a30 \u2911 \u00a31 \u2262 \u2217 \u27d1 \u00a30 \u2262 \u2217.", "Local Definition lt_irrefl := \u2200 \u00ac \u00a30 \u227a \u00a30.", "Local Definition lt_trans := \u2200\u2200\u2200 \u00a32 \u227a \u00a31 \u2911 \u00a31 \u227a \u00a30 \u2911 \u00a32 \u227a \u00a30.", "Local Definition phi_lt := lt_irrefl \u27d1 lt_trans.", "Local Definition eq_neq b := \u2200 b\u291a\u00a30 \u2262 e.", "Local Definition eq_inj b := \u2200\u2200 b\u291a\u00a31 \u2262 \u2217 \u2911 b\u291a\u00a31 \u2261 b\u291a \u00a30\u2911 \u00a31 \u2261 \u00a30.", "Local Definition eq_real := \u2200\u2200 true\u291a\u00a31 \u2261 false\u291a\u00a30 \u2911 true\u291a\u00a31 \u2261 \u2217 \u27d1 false\u291a\u00a30 \u2261 \u2217.", "Local Definition eq_undef b := b\u291a\u2217 \u2261 \u2217.", "Local Definition phi_eq := eq_neq true \u27d1 eq_neq false \u27d1 eq_inj true \u27d1 eq_inj false \u27d1 eq_undef true \u27d1 eq_undef false \u27d1 eq_real.", "Local Definition lt_pair u v x y := (u \u227a x \u27d1 v \u2261 y) \u27c7 (v \u227a y \u27d1 u \u2261 x) \u27c7 (u \u227a x \u27d1 v \u227a y).", "Local Definition lt_simul '(s,t) := \u00a31 \u2261 s\u291ce \u27d1 \u00a30 \u2261 t\u291ce \u27c7 \u2203\u2203 \u00a31 \u29d3 \u00a30 \u27d1 \u00a33 \u2261 s\u291c\u00a31 \u27d1 \u00a32 \u2261 t\u291c\u00a30 \u27d1 lt_pair (\u00a31) (\u00a30) (\u00a33) (\u00a32).", "Local Definition phi_simul := \u2200\u2200 \u00a31 \u29d3 \u00a30 \u2911 fol_ldisj (map lt_simul lc).", "Definition \u03a3bpcp_encode := phi_P \u27d1 phi_lt \u27d1 phi_eq \u27d1 phi_simul \u27d1 \u2203 \u00a30 \u29d3 \u00a30.", "Section soundness.", "Variable (l : list bool) (Hl : lc \u22b3 l\u2215l).", "Let n := length l.", "Let X := option { m : list bool | length m < S n }.", "Fact \u03a3bpcp_model_finite : finite_t X.", "Proof.", "apply finite_t_option, finite_t_list, finite_t_bool.", "Qed.", "Hint Resolve \u03a3bpcp_model_finite : core.", "Definition \u03a3bpcp_model : fo_model \u03a3bpcp X.", "Proof.", "exists.", "+", "intros []; simpl.", "*", "intros v.", "case_eq (vec_head v).", "-", "intros (m & Hm) H.", "destruct (le_lt_dec n (length m)) as [ | H1 ].", "++", "right.", "++", "left; exists (b::m); apply lt_n_S, H1.", "-", "right.", "*", "left; exists nil; apply lt_0_Sn.", "*", "right.", "+", "intros []; simpl; intros v.", "*", "destruct (vec_head v) as [ (s & _) | ].", "2: exact False.", "destruct (vec_head (vec_tail v)) as [ (t & _) | ].", "2: exact False.", "exact (lc \u22b3 s\u2215t).", "*", "destruct (vec_head v) as [ (s & _) | ].", "2: exact False.", "destruct (vec_head (vec_tail v)) as [ (t & _) | ].", "2: exact False.", "exact (s <> t /\\ exists u, u++s = t).", "*", "exact (vec_head v = vec_head (vec_tail v)).", "Defined.", "Lemma \u03a3bpcp_model_dec : fo_model_dec \u03a3bpcp_model.", "Proof.", "intros []; simpl; intros v; vec split v with x; vec split v with y; vec nil v; clear v; simpl; revert x y; intros [ (x & Hx) | ] [ (y & Hy) | ]; simpl; try tauto.", "+", "apply bpcp_hand_dec.", "+", "destruct (list_eq_dec bool_dec x y); destruct (is_a_tail_dec bool_dec y x); tauto.", "+", "destruct (list_eq_dec bool_dec x y) as [ | C ]; [ left | right ].", "*", "subst; repeat f_equal; apply lt_pirr.", "*", "contradict C; inversion C; auto.", "+", "right; discriminate.", "+", "right; discriminate.", "Qed.", "Lemma \u03a3bpcp_model_interpreted x y : fom_rels \u03a3bpcp_model \u03a3bpcp_eq (x##y##\u00f8) <-> x = y.", "Proof.", "reflexivity.", "Qed.", "Hint Resolve \u03a3bpcp_model_dec : core.", "Notation sem_sym := (fom_syms \u03a3bpcp_model).", "Notation sem_pred := (fom_rels \u03a3bpcp_model).", "Notation \"\u27e6 t \u27e7\" := (fun \u03c6 => fo_term_sem \u03a3bpcp_model \u03c6 t).", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem \u03a3bpcp_model \u03c6 A).", "Let fot_sem_lb_app lb t \u03c6 : match \u27e6 t \u27e7 \u03c6 with | Some (exist _ m Hm) => match le_lt_dec (S n) (length lb + length m) with | left _ => \u27e6 lb_app lb t \u27e7 \u03c6 = None | right _ => exists H, \u27e6 lb_app lb t \u27e7 \u03c6 = Some (exist _ (lb++m) H) end | None => \u27e6 lb_app lb t \u27e7 \u03c6 = None end.", "Proof.", "induction lb as [ | x lb IH ]; simpl lb_app.", "+", "destruct (\u27e6 t \u27e7 \u03c6) as [ (m & Hm) | ]; auto.", "simpl plus; solve ite; simpl; exists Hm; auto.", "+", "destruct (\u27e6 t \u27e7 \u03c6) as [ (m & Hm) | ]; auto.", "2: {", "rew fot; unfold vec_map.", "simpl in IH |- *; rewrite IH; auto.", "}", "simpl plus.", "destruct (le_lt_dec (S n) (length lb + length m)) as [ H1 | H1 ].", "*", "destruct (le_lt_dec (S n) (S (length lb+length m))) as [ H2 | H2 ].", "2: exfalso; lia.", "rew fot; unfold vec_map.", "simpl in IH |- *; rewrite IH; auto.", "*", "destruct IH as (H2 & IH).", "destruct (le_lt_dec (S n) (S (length lb+length m))) as [ H3 | H3 ].", "-", "rew fot; unfold vec_map; simpl in IH |- *; rewrite IH; simpl.", "destruct (le_lt_dec n (length (lb++m))) as [ | C ]; auto.", "exfalso; rewrite app_length in C; lia.", "-", "assert (length ((x::lb)++m) < S n) as H4.", "{", "simpl; rewrite app_length; auto.", "}", "exists H4; rew fot; unfold vec_map.", "simpl in IH |- *; rewrite IH; simpl.", "destruct (le_lt_dec n (length (lb++m))) as [ H5 | H5 ].", "++", "exfalso; rewrite app_length in H5; lia.", "++", "do 2 f_equal; apply lt_pirr.", "Qed.", "Let fot_sem_lb_app_Some lb t \u03c6 lt Ht (H : length (lb++lt) < S n) : \u27e6t\u27e7 \u03c6 = Some (exist _ lt Ht) -> \u27e6lb\u291ct\u27e7 \u03c6 = Some (exist _ (lb++lt) H).", "Proof.", "intros H1.", "generalize (fot_sem_lb_app lb t \u03c6); rew fot; simpl vec_map; rewrite H1.", "rewrite <- app_length; solve ite.", "intros (G & ->); do 2 f_equal; apply lt_pirr.", "Qed.", "Let fot_sem_lb_app_e lb \u03c6 (H : length lb < S n) : \u27e6lb\u291ce\u27e7 \u03c6 = Some (exist _ lb H).", "Proof.", "revert H.", "rewrite (app_nil_end lb); intros H.", "rewrite <- app_nil_end at 1.", "apply fot_sem_lb_app_Some with (Ht := lt_0_Sn _).", "rew fot; simpl; auto.", "Qed.", "Let sem_fol_dec A \u03c6 : { \u27eaA\u27eb \u03c6 } + { ~ \u27eaA\u27eb \u03c6 }.", "Proof.", "apply fol_sem_dec; auto.", "Qed.", "Let \u03c60 : nat -> X := fun _ => None.", "Let sem_phi_P : \u27ea phi_P \u27eb \u03c60.", "Proof.", "simpl; intros [ (x & Hx) | ] [ (y & Hy) | ]; simpl; rew fot; unfold sem_sym in |- *; simpl; try tauto.", "intros _; split; intros ?; discriminate.", "Qed.", "Let sem_phi_lt : \u27ea phi_lt \u27eb \u03c60.", "Proof.", "simpl; split; rew fot; simpl.", "+", "intros [ (x & Hx) | ]; simpl; auto.", "intros ( [] & _ ); auto.", "+", "intros [ (x & Hx) | ] [ (y & Hy) | ] [ (z & Hz) | ]; rew fot; simpl; try tauto.", "intros (H1 & H2) (H3 & H4); split; repeat (rew fot; simpl); auto.", "*", "intros ->.", "destruct H2 as (a & <-).", "destruct H4 as (b & H4).", "destruct b as [ | u b ].", "-", "destruct a as [ | v a ].", "++", "destruct H3; auto.", "++", "apply f_equal with (f := @length _) in H4.", "simpl in H4; rewrite app_length in H4; lia.", "-", "apply f_equal with (f := @length _) in H4.", "simpl in H4; do 2 rewrite app_length in H4; lia.", "*", "clear H1 H3; revert H2 H4.", "intros (a & <-) (b & <-).", "exists (b++a); rewrite app_ass; auto.", "Qed.", "Let sem_phi_eq : \u27ea phi_eq \u27eb \u03c60.", "Proof.", "msplit 6; rew fot.", "1,2: intros [ (x & Hx) | ]; repeat (rew fot; simpl); try discriminate; destruct (le_lt_dec n (length x)) as [ | ]; try discriminate.", "1,2: intros [ (x & Hx) | ] [ (y & Hy) | ]; repeat (rew fot; simpl); auto; try destruct (le_lt_dec n (length x)) as [ | ]; try destruct (le_lt_dec n (length y)) as [ | ]; try discriminate; try tauto; inversion 2; subst; repeat f_equal; apply lt_pirr.", "1,2: repeat (rew fot; simpl); auto.", "intros [ (x & Hx) | ] [ (y & Hy) | ]; repeat (rew fot; simpl); auto; try destruct (le_lt_dec n (length x)) as [ | ]; try destruct (le_lt_dec n (length y)) as [ | ]; try discriminate; try tauto.", "Qed.", "Opaque le_lt_dec.", "Let sem_phi_simul : \u27ea phi_simul \u27eb \u03c60.", "Proof.", "intros x y H; rewrite fol_sem_ldisj; revert x y H.", "intros [ (x' & Hx) | ] [ (y' & Hy) | ]; repeat (rew fot; simpl); try tauto.", "intros H.", "apply pcp_hand_inv in H.", "destruct H as [ H | (x & y & p & q & H1 & H2 & -> & -> & H) ].", "+", "exists (lt_simul (x',y')); split.", "*", "apply in_map_iff; exists (x',y'); auto.", "*", "unfold lt_simul; simpl; left; split.", "-", "rew fot.", "rewrite fot_sem_lb_app_e with (H := Hx).", "simpl; auto.", "-", "rew fot.", "rewrite fot_sem_lb_app_e with (H := Hy).", "simpl; auto.", "+", "exists (lt_simul (x,y)); split.", "*", "apply in_map_iff; exists (x,y); split; auto.", "*", "unfold lt_simul; right.", "exists (\u27e6p\u291ce\u27e7 \u03c60), (\u27e6q\u291ce\u27e7 \u03c60).", "assert (length p < S n) as H5 by (rewrite app_length in Hx; lia).", "assert (length q < S n) as H6 by (rewrite app_length in Hy; lia).", "rewrite fot_sem_lb_app_e with (H := H5).", "rewrite fot_sem_lb_app_e with (H := H6).", "simpl; msplit 3; simpl; auto.", "-", "rew fot.", "rewrite fot_sem_lb_app_Some with (lt0 := p) (Ht := H5) (H := Hx).", "++", "simpl; auto.", "++", "rew fot; simpl; auto.", "-", "rew fot.", "rewrite fot_sem_lb_app_Some with (lt0 := q) (Ht := H6) (H := Hy).", "++", "simpl; auto.", "++", "rew fot; simpl; auto.", "-", "destruct H as [ (G1 & G2) | [ (G1 & G2) | (G1 & G2) ] ].", "++", "left; split.", "**", "split.", "--", "revert G1; apply list_app_head_not_nil.", "--", "exists x; auto.", "**", "rew fot; simpl; subst; do 2 f_equal; apply lt_pirr.", "++", "right; left; split.", "**", "split.", "--", "revert G2; apply list_app_head_not_nil.", "--", "exists y; auto.", "**", "rew fot; simpl; subst; do 2 f_equal; apply lt_pirr.", "++", "do 2 right; split.", "**", "split.", "--", "revert G1; apply list_app_head_not_nil.", "--", "exists x; auto.", "**", "split.", "--", "revert G2; apply list_app_head_not_nil.", "--", "exists y; auto.", "Qed.", "Let sem_phi_solvable : \u27ea \u2203 \u00a30 \u29d3 \u00a30 \u27eb \u03c60.", "Proof.", "exists (Some (exist _ l (lt_n_Sn _))); simpl; auto.", "Qed.", "Theorem Sig_bpcp_encode_sound : @fo_form_fin_dec_eq_SAT \u03a3bpcp \u03a3bpcp_eq eq_refl \u03a3bpcp_encode.", "Proof.", "exists X, \u03a3bpcp_model, \u03a3bpcp_model_finite, \u03a3bpcp_model_dec, \u03a3bpcp_model_interpreted, \u03c60; split; auto.", "unfold \u03a3bpcp_encode; repeat (split; auto).", "Qed.", "End soundness.", "Section completeness.", "Variable (X : Type) (M : fo_model \u03a3bpcp X) (HM : finite X) (He : forall x y, fom_rels M \u03a3bpcp_eq (x##y##\u00f8) <-> x = y) .", "Notation sem_sym := (fom_syms M).", "Notation sem_pred := (fom_rels M).", "Notation \"\u27e6 t \u27e7\" := (fun \u03c6 => fo_term_sem M \u03c6 t).", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem M \u03c6 A).", "Let fot_sem_lb_app l t \u03c6 : \u27e6l\u291ct\u27e7 \u03c6 = \u27e6l\u291c\u00a30\u27e7 (\u27e6t\u27e7\u03c6)\u00b7\u03c6.", "Proof.", "revert \u03c6; induction l as [ | b l IHl ]; intros phi; simpl.", "+", "rew fot; auto.", "+", "rew fot; f_equal; simpl; f_equal; auto.", "Qed.", "Variable (\u03c6 : nat -> X) (model : \u27ea \u03a3bpcp_encode \u27eb \u03c6).", "Notation \u03b5 := (@sem_sym \u03a3bpcp_unit \u00f8).", "Notation \"\u22c7\" := (@sem_sym \u03a3bpcp_undef \u00f8).", "Let f b x := (@sem_sym (\u03a3bpcp_bool b) (x##\u00f8)).", "Let P x y := @sem_pred \u03a3bpcp_hand (x##y##\u00f8).", "Notation \"x \u2aa1 y\" := (@sem_pred \u03a3bpcp_ssfx (x##y##\u00f8)) (at level 70).", "Notation \"x \u2245 y\" := (@sem_pred \u03a3bpcp_eq (x##y##\u00f8)) (at level 70).", "Let lt_pair u v x y := ( u \u2aa1 x /\\ v \u2245 y \\/ v \u2aa1 y /\\ u \u2245 x \\/ u \u2aa1 x /\\ v \u2aa1 y ).", "Let HP x y : P x y -> x <> \u22c7 /\\ y <> \u22c7.", "Proof.", "do 2 rewrite <- He; apply model.", "Qed.", "Let Hfb_1 b x : f b x <> \u03b5.", "Proof.", "rewrite <- He; destruct b; apply model.", "Qed.", "Let Hfb_2 b x y : f b x <> \u22c7 -> f b x = f b y -> x = y.", "Proof.", "do 3 rewrite <- He; destruct b; revert x y; apply model.", "Qed.", "Let Hfb_3 x y : f true x = f false y -> f true x = \u22c7 /\\ f false y = \u22c7.", "Proof.", "do 3 rewrite <- He; apply model.", "Qed.", "Let Hfb_4 b : f b \u22c7 = \u22c7.", "Proof.", "rewrite <- He.", "destruct model as (_ & _ & H & _).", "destruct H as (_ & _ & _ & _ & H1 & H2 & _ ).", "destruct b; auto.", "Qed.", "Let Hlt_irrefl x : ~ x \u2aa1 x.", "Proof.", "apply model.", "Qed.", "Let Hlt_trans x y z : x \u2aa1 y -> y \u2aa1 z -> x \u2aa1 z.", "Proof.", "apply model.", "Qed.", "Let sb_app l x := \u27e6l\u291c\u00a30\u27e7 x\u00b7\u03c6.", "Let Hsimul x y : P x y -> exists s t, In (s,t) lc /\\ ( x = sb_app s \u03b5 /\\ y = sb_app t \u03b5 \\/ exists u v, P u v /\\ x = sb_app s u /\\ y = sb_app t v /\\ lt_pair u v x y ).", "Proof.", "intros H.", "destruct model as (_ & _ & _ & Hmodel & _).", "unfold phi_simul in Hmodel; simpl in Hmodel.", "apply Hmodel in H.", "apply fol_sem_ldisj in H.", "destruct H as (c & Hc & H).", "rewrite in_map_iff in Hc.", "destruct Hc as ((s,t) & <- & Hst).", "exists s, t; split; auto.", "unfold sb_app; simpl; rew fot.", "destruct H as [ (H1 & H2) | (u & v & H1 & H2 & H3 & H4) ].", "+", "apply He in H1; apply He in H2; simpl in H1, H2.", "left; split.", "*", "rewrite H1; do 2 rewrite fot_sem_lb_app; simpl.", "apply fo_term_sem_ext.", "rewrite fot_vars_lb_app; simpl.", "intros ? [ <- | [] ]; auto.", "*", "rewrite H2; do 2 rewrite fot_sem_lb_app; simpl.", "apply fo_term_sem_ext.", "rewrite fot_vars_lb_app; simpl.", "intros ? [ <- | [] ]; auto.", "+", "apply He in H2; apply He in H3; simpl in H2, H3.", "right; exists u, v; msplit 3.", "*", "apply H1.", "*", "rewrite H2; do 2 rewrite fot_sem_lb_app; simpl.", "apply fo_term_sem_ext.", "rewrite fot_vars_lb_app; simpl.", "intros ? [ <- | [] ]; auto.", "*", "rewrite H3; do 2 rewrite fot_sem_lb_app; simpl.", "apply fo_term_sem_ext.", "rewrite fot_vars_lb_app; simpl.", "intros ? [ <- | [] ]; auto.", "*", "apply H4.", "Qed.", "Let P_refl : exists x, P x x.", "Proof.", "apply model.", "Qed.", "Let sb_app_fb b l x : sb_app (b::l) x = f b (sb_app l x).", "Proof.", "auto.", "Qed.", "Let sb_app_nil x : sb_app nil x = x.", "Proof.", "auto.", "Qed.", "Let sb_app_inj l m : sb_app l \u03b5 <> \u22c7 -> sb_app l \u03b5 = sb_app m \u03b5 -> l = m.", "Proof.", "revert m; induction l as [ | [] l IH ]; intros [ | [] m ] H E; auto.", "+", "rewrite sb_app_fb, sb_app_nil in E.", "apply eq_sym, Hfb_1 in E; tauto.", "+", "rewrite sb_app_fb, sb_app_nil in E.", "apply eq_sym, Hfb_1 in E; tauto.", "+", "rewrite sb_app_fb, sb_app_nil in E.", "apply Hfb_1 in E; tauto.", "+", "do 2 rewrite sb_app_fb in E.", "apply Hfb_2 in E.", "*", "f_equal; apply IH; auto.", "contradict H.", "rewrite sb_app_fb, H, Hfb_4; auto.", "*", "intros C; apply H.", "rewrite sb_app_fb; auto.", "+", "do 2 rewrite sb_app_fb in E.", "apply Hfb_3 in E.", "destruct H.", "rewrite sb_app_fb; tauto.", "+", "rewrite sb_app_fb, sb_app_nil in E.", "apply Hfb_1 in E; tauto.", "+", "do 2 rewrite sb_app_fb in E.", "apply eq_sym, Hfb_3 in E; tauto.", "+", "do 2 rewrite sb_app_fb in E.", "apply Hfb_2 in E.", "*", "f_equal; apply IH; auto.", "contradict H.", "rewrite sb_app_fb, H, Hfb_4; auto.", "*", "intros C; apply H.", "rewrite sb_app_fb; auto.", "Qed.", "Let sb_app_congr l m x y z : x = sb_app l y -> y = sb_app m z -> x = sb_app (l++m) z.", "Proof.", "intros H1 H2.", "unfold sb_app.", "rewrite lb_app_app, fot_sem_lb_app.", "subst; simpl.", "apply fo_term_sem_ext.", "intros n; rewrite fot_vars_lb_app; simpl.", "intros [ <- | [] ]; simpl; auto.", "Qed.", "Ltac mysolve := match goal with | H1 : ?x \u2aa1 ?y, H2 : ?y \u2aa1 ?z |- ?x \u2aa1 ?z => revert H2; apply Hlt_trans | H1 : ?x = ?y, H2 : ?y \u2aa1 ?z |- ?x \u2aa1 ?z => rewrite H1; apply H2 | H1 : ?x \u2aa1 ?y, H2 : ?y = ?z |- ?x \u2aa1 ?z => rewrite <- H2; apply H1 | H1 : ?x = ?y, H2 : ?y = ?z |- ?x = ?z => rewrite H1; apply H2 end; auto.", "Let Hlt_wf : well_founded (fun p q => match p, q with (u,v), (x,y) => lt_pair u v x y end).", "Proof.", "apply wf_strict_order_finite; auto.", "+", "apply finite_prod; auto.", "+", "intros (x,y) [ (H1 & H2) | [ (H1 & H2) | (H1 & H2) ] ].", "all: revert H1; apply Hlt_irrefl.", "+", "intros (x1,x2) (y1,y2) (z1,z2); unfold lt_pair; simpl; rewrite !He.", "intros [ (H1 & H2) | [ (H1 & H2) | (H1 & H2) ] ] [ (G1 & G2) | [ (G1 & G2) | (G1 & G2) ] ].", "1: left; split; mysolve.", "4: right; left; split; mysolve.", "all: right; right; split; mysolve.", "Qed.", "Let P_implies_pcp_hand (c : X*X) : let (x,y) := c in P x y -> exists s t, x = sb_app s \u03b5 /\\ y = sb_app t \u03b5 /\\ lc \u22b3 s\u2215t.", "Proof.", "induction c as [ (x,y) IH ] using (well_founded_induction Hlt_wf).", "intros Hxy.", "apply Hsimul in Hxy.", "destruct Hxy as (s & t & Hst & [ (H1 & H2) | H ]).", "+", "exists s, t; msplit 2; auto; constructor 1; auto.", "+", "destruct H as (u & v & H1 & H2 & H3 & H4).", "destruct (IH (u,v)) with (2 := H1) as (s' & t' & G1 & G2 & G3); auto.", "exists (s++s'), (t++t'); msplit 2.", "*", "apply sb_app_congr with (1 := H2); auto.", "*", "apply sb_app_congr with (1 := H3); auto.", "*", "constructor 2; auto.", "Qed.", "Local Theorem completeness : exists s, lc \u22b3 s\u2215s.", "Proof.", "destruct P_refl as (x & Hx).", "destruct (P_implies_pcp_hand (x,x)) with (1 := Hx) as (s & t & H1 & H2 & H3).", "apply HP in Hx.", "replace t with s in H3.", "+", "exists s; auto.", "+", "apply sb_app_inj; auto.", "*", "intros H; destruct Hx as [ [] _ ]; subst; auto.", "*", "rewrite <- H1; auto.", "Qed.", "End completeness.", "Hint Resolve finite_t_finite : core.", "Theorem Sig_bpcp_encode_complete : @fo_form_fin_dec_eq_SAT \u03a3bpcp \u03a3bpcp_eq eq_refl \u03a3bpcp_encode -> exists l, lc \u22b3 l\u2215l.", "Proof.", "intros (X & M & fM & dM & He & phi & Hphi).", "apply completeness with (M := M) (\u03c6 := phi); auto.", "Qed.", "End BPCP_FIN_DEC_EQ_SAT."], "theorems": [{"name": "\u03a3bpcp_model_finite", "kind": "Fact", "begin": 49, "end": 52}, {"name": "\u03a3bpcp_model", "kind": "Definition", "begin": 54, "end": 91}, {"name": "\u03a3bpcp_model_dec", "kind": "Lemma", "begin": 92, "end": 109}, {"name": "\u03a3bpcp_model_interpreted", "kind": "Lemma", "begin": 110, "end": 113}, {"name": "fot_sem_lb_app", "kind": "Let", "begin": 119, "end": 157}, {"name": "fot_sem_lb_app_Some", "kind": "Let", "begin": 158, "end": 164}, {"name": "fot_sem_lb_app_e", "kind": "Let", "begin": 165, "end": 172}, {"name": "sem_fol_dec", "kind": "Let", "begin": 173, "end": 176}, {"name": "sem_phi_P", "kind": "Let", "begin": 178, "end": 182}, {"name": "sem_phi_lt", "kind": "Let", "begin": 183, "end": 211}, {"name": "sem_phi_eq", "kind": "Let", "begin": 212, "end": 219}, {"name": "sem_phi_simul", "kind": "Let", "begin": 221, "end": 304}, {"name": "sem_phi_solvable", "kind": "Let", "begin": 305, "end": 308}, {"name": "Sig_bpcp_encode_sound", "kind": "Theorem", "begin": 309, "end": 313}, {"name": "fot_sem_lb_app", "kind": "Let", "begin": 321, "end": 328}, {"name": "HP", "kind": "Let", "begin": 337, "end": 340}, {"name": "Hfb_1", "kind": "Let", "begin": 341, "end": 344}, {"name": "Hfb_2", "kind": "Let", "begin": 345, "end": 348}, {"name": "Hfb_3", "kind": "Let", "begin": 349, "end": 352}, {"name": "Hfb_4", "kind": "Let", "begin": 353, "end": 359}, {"name": "Hlt_irrefl", "kind": "Let", "begin": 360, "end": 363}, {"name": "Hlt_trans", "kind": "Let", "begin": 364, "end": 367}, {"name": "Hsimul", "kind": "Let", "begin": 369, "end": 412}, {"name": "P_refl", "kind": "Let", "begin": 413, "end": 416}, {"name": "sb_app_fb", "kind": "Let", "begin": 417, "end": 420}, {"name": "sb_app_nil", "kind": "Let", "begin": 421, "end": 424}, {"name": "sb_app_inj", "kind": "Let", "begin": 425, "end": 468}, {"name": "sb_app_congr", "kind": "Let", "begin": 469, "end": 478}, {"name": "Hlt_wf", "kind": "Let", "begin": 480, "end": 494}, {"name": "P_implies_pcp_hand", "kind": "Let", "begin": 495, "end": 513}, {"name": "Sig_bpcp_encode_complete", "kind": "Theorem", "begin": 531, "end": 535}]}