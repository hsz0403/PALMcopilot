{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils decidable fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Local Reserved Notation \"\u27ea A \u27eb'\" (at level 1, format \"\u27ea A \u27eb'\").", "Local Notation \u00f8 := vec_nil.", "Section remove_constants.", "Variable (\u03a3 : fo_signature) (H\u03a3 : forall s, ar_syms \u03a3 s = 0) (ls : list (syms \u03a3)).", "Definition \u03a3rem_cst : fo_signature.", "Proof.", "exists Empty_set (rels \u03a3).", "+", "intros [].", "+", "apply ar_rels.", "Defined.", "Notation \u03a3' := \u03a3rem_cst.", "Notation \ud835\udd4b := (fol_term \u03a3).", "Notation \ud835\udd3d := (fol_form \u03a3).", "Notation \ud835\udd4b' := (fol_term \u03a3').", "Notation \ud835\udd3d' := (fol_form \u03a3').", "Implicit Type \u03c3 : syms \u03a3 -> nat.", "Let convert_t \u03c3 (t : \ud835\udd4b) : \ud835\udd4b' := match t with | in_var n => in_var n | in_fot s _ => in_var (\u03c3 s) end.", "Local Fixpoint encode \u03c3 (A : \ud835\udd3d) : \ud835\udd3d' := match A with | \u22a5 => \u22a5 | fol_atom r v => @fol_atom \u03a3' r (vec_map (convert_t \u03c3) v) | fol_bin b A B => fol_bin b (encode \u03c3 A) (encode \u03c3 B) | fol_quant q A => fol_quant q (encode (fun s => S (\u03c3 s)) A) end.", "Section soundness.", "Variable (X : Type) (M : fo_model \u03a3 X).", "Definition \u03a3rem_cst_model : fo_model \u03a3' X.", "Proof.", "split.", "+", "intros [].", "+", "apply (fom_rels M).", "Defined.", "Notation M' := \u03a3rem_cst_model.", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem M \u03c6 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c8 => fol_sem M' \u03c8 A).", "Local Fact soundness \u03c3 (A : \ud835\udd3d) \u03c6 \u03c8 : (forall s, In s ls -> In (\u03c3 s) (fol_vars A) -> False) -> (forall n, In n (fol_vars A) -> \u03c6 n = \u03c8 n) -> (forall s, In s ls -> \u03c8 (\u03c3 s) = fom_syms M s (cast \u00f8 (eq_sym (H\u03a3 s)))) -> incl (fol_syms A) ls -> \u27eaA\u27eb \u03c6 <-> \u27eaencode \u03c3 A\u27eb' \u03c8.", "Proof.", "induction A as [ | r v | b A HA B HB | q A HA ] in \u03c3, \u03c6, \u03c8 |- *; intros H1 H2 H3 H4; simpl; try tauto.", "+", "rewrite vec_map_map.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intro p; rew vec.", "cut (incl (fo_term_syms (vec_pos v p)) ls).", "2:{", "intros s Hs; apply H4; simpl; apply in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "}", "cut (forall n, In n (fo_term_vars (vec_pos v p)) -> \u03c6 n = \u03c8 n).", "2:{", "intros n Hn; apply H2, in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "}", "generalize (vec_pos v p); intros [ n | s w ] H5 H6; simpl.", "-", "apply H5; simpl; auto.", "-", "rewrite H3; f_equal; auto.", "2: apply H6; rew fot; simpl; auto.", "clear H5 H6.", "revert w; rewrite H\u03a3; intros w.", "vec nil w; auto.", "+", "apply fol_bin_sem_ext.", "*", "apply HA; auto.", "-", "intros s G1 G2; apply (H1 _ G1), in_app_iff; auto.", "-", "intros; apply H2, in_app_iff; auto.", "-", "intros ? ?; apply H4, in_app_iff; auto.", "*", "apply HB; auto.", "-", "intros s G1 G2; apply (H1 _ G1), in_app_iff; auto.", "-", "intros; apply H2, in_app_iff; auto.", "-", "intros ? ?; apply H4, in_app_iff; auto.", "+", "apply fol_quant_sem_ext; intros x.", "apply HA; auto.", "*", "intros s G1 G2; apply (H1 _ G1).", "simpl; apply in_flat_map.", "exists (S (\u03c3 s)); simpl; auto.", "*", "intros [|n] Hn; simpl; auto.", "apply H2; simpl; apply in_flat_map.", "exists (S n); simpl; auto.", "Qed.", "End soundness.", "Section completeness.", "Variable (X : Type) (M' : fo_model \u03a3' X).", "Definition \u03a3add_cst_model \u03c3 (\u03c8 : nat -> X) : fo_model \u03a3 X.", "Proof.", "split.", "+", "intros s _; exact (\u03c8 (\u03c3 s)).", "+", "apply (fom_rels M').", "Defined.", "Notation M := \u03a3add_cst_model.", "Local Fact completeness \u03c3 (A : \ud835\udd3d) \u03c6 \u03c8 : (forall s, In s ls -> In (\u03c3 s) (fol_vars A) -> False) -> (forall n, In n (fol_vars A) -> \u03c6 n = \u03c8 n) -> incl (fol_syms A) ls -> fol_sem (\u03a3add_cst_model \u03c3 \u03c8) \u03c6 A <-> fol_sem M' \u03c8 (encode \u03c3 A).", "Proof.", "induction A as [ | r v | b A HA B HB | q A HA ] in \u03c3, \u03c6, \u03c8 |- *; intros H1 H2 H3; simpl; try tauto.", "+", "rewrite vec_map_map.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intro p; rew vec.", "cut (incl (fo_term_syms (vec_pos v p)) ls).", "2:{", "intros s Hs; apply H3; simpl; apply in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "}", "cut (forall n, In n (fo_term_vars (vec_pos v p)) -> \u03c6 n = \u03c8 n).", "2:{", "intros n Hn; apply H2, in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "}", "generalize (vec_pos v p); intros [ n | s w ] H5 H6; simpl; auto.", "apply H5; simpl; auto.", "+", "apply fol_bin_sem_ext.", "*", "apply HA; auto.", "-", "intros s G1 G2; apply (H1 _ G1), in_app_iff; auto.", "-", "intros; apply H2, in_app_iff; auto.", "-", "intros ? ?; apply H3, in_app_iff; auto.", "*", "apply HB; auto.", "-", "intros s G1 G2; apply (H1 _ G1), in_app_iff; auto.", "-", "intros; apply H2, in_app_iff; auto.", "-", "intros ? ?; apply H3, in_app_iff; auto.", "+", "apply fol_quant_sem_ext; intros x.", "rewrite <- HA with (\u03c6 := x\u00b7\u03c6); unfold M; simpl; try tauto.", "*", "intros s G1 G2; apply (H1 _ G1).", "simpl; apply in_flat_map.", "exists (S (\u03c3 s)); simpl; auto.", "*", "intros [|n] Hn; simpl; auto.", "apply H2; simpl; apply in_flat_map.", "exists (S n); simpl; auto.", "Qed.", "End completeness.", "End remove_constants.", "Section reduction.", "Variable (\u03a3 : fo_signature) (\u03a30 : forall s, ar_syms \u03a3 s = 0) (\u03a3d : discrete (syms \u03a3)).", "Section syms_map.", "Variable A : fol_form \u03a3.", "Let ls := fol_syms A.", "Let K := list_discr_pos_n \u03a3d ls.", "Let n := projT1 K.", "Let v : vec _ n := projT1 (projT2 K).", "Let g : _ -> option (pos n) := proj1_sig (projT2 (projT2 K)).", "Let HK := proj2_sig (projT2 (projT2 K)).", "Let H1 x : in_vec x v <-> In x ls.", "Proof.", "apply (proj1 HK).", "Qed.", "Let H2 x : In x ls <-> g x <> None.", "Proof.", "apply (proj1 (proj2 HK)).", "Qed.", "Let H3 p : g (vec_pos v p) = Some p.", "Proof.", "apply (proj1 (proj2 (proj2 HK))).", "Qed.", "Let H4 x p : g x = Some p -> vec_pos v p = x.", "Proof.", "apply (proj2 (proj2 (proj2 HK))).", "Qed.", "Let \u03c3 s := match g s with | Some p => pos2nat p | None => 0 end.", "Let f x : option (syms \u03a3) := match le_lt_dec n x with | left _ => None | right H => Some (vec_pos v (nat2pos H)) end.", "Let Hf\u03c3 s : In s ls -> f (\u03c3 s) = Some s.", "Proof.", "rewrite H2.", "unfold f, \u03c3.", "generalize (H4 s).", "destruct (g s) as [ p | ].", "+", "intros E _.", "specialize (E _ eq_refl); subst.", "generalize (pos2nat_prop p).", "destruct (le_lt_dec n (pos2nat p)) as [ | H ].", "*", "intros; exfalso; lia.", "*", "rewrite nat2pos_pos2nat; auto.", "+", "intros _ []; auto.", "Qed.", "Local Fact syms_map : { \u03c3 : syms \u03a3 -> nat & { f : nat -> option (syms \u03a3) | forall s, In s ls -> f (\u03c3 s) = Some s } }.", "Proof.", "exists \u03c3, f; auto.", "Qed.", "End syms_map.", "Hint Resolve incl_refl : core.", "Theorem Sig_rem_cst_dep_red A : { B | @fo_form_fin_dec_SAT \u03a3 A <-> @fo_form_fin_dec_SAT (\u03a3rem_cst \u03a3) B }.", "Proof.", "generalize (fol_vars_max_spec A).", "set (m := fol_vars_max A); intros Hm.", "destruct (syms_map A) as (g & f & Hfg).", "set (\u03c3 s := g s + S m).", "exists (encode \u03c3 A).", "split.", "+", "intros (X & M & G1 & G2 & phi & G3).", "exists X, (\u03a3rem_cst_model M), G1.", "exists.", "{", "intros r; simpl; apply G2.", "}", "set (psi n := match le_lt_dec (S m) n with | left _ => match f (n - S m) with | Some s => fom_syms M s (cast \u00f8 (eq_sym (\u03a30 _))) | None => phi 0 end | right _ => phi n end).", "exists psi.", "revert G3; apply soundness with (H\u03a3 := \u03a30) (ls := fol_syms A); auto.", "*", "intros s Hs; unfold \u03c3; intros H.", "apply Hm in H; lia.", "*", "intros n Hn; apply Hm in Hn.", "unfold psi.", "destruct (le_lt_dec (S m) n); try lia; auto.", "*", "intros s Hs.", "unfold psi, \u03c3.", "apply Hfg in Hs.", "replace (g s + S m - S m) with (g s) by lia.", "rewrite Hs.", "destruct (le_lt_dec (S m) (g s + S m)); auto; lia.", "+", "intros (X & M' & G1 & G2 & psi & G3).", "exists X, (\u03a3add_cst_model M' \u03c3 psi), G1.", "exists.", "{", "intros r; simpl; apply G2.", "}", "exists psi.", "revert G3; apply completeness with (ls := fol_syms A); auto.", "intros s Hs; unfold \u03c3; intros H.", "apply Hm in H; lia.", "Qed.", "End reduction."], "theorems": [{"name": "\u03a3rem_cst", "kind": "Definition", "begin": 9, "end": 16}, {"name": "\u03a3rem_cst_model", "kind": "Definition", "begin": 27, "end": 34}, {"name": "\u03a3add_cst_model", "kind": "Definition", "begin": 99, "end": 106}, {"name": "H1", "kind": "Let", "begin": 171, "end": 174}, {"name": "H2", "kind": "Let", "begin": 175, "end": 178}, {"name": "H3", "kind": "Let", "begin": 179, "end": 182}, {"name": "H4", "kind": "Let", "begin": 183, "end": 186}, {"name": "Hf\u03c3", "kind": "Let", "begin": 189, "end": 206}, {"name": "Sig_rem_cst_dep_red", "kind": "Theorem", "begin": 213, "end": 256}]}