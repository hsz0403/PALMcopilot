{"code": ["Require Import List Arith Nat Lia Max Wellfounded Coq.Setoids.Setoid.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations fol_ops fo_sig fo_terms fo_logic.", "Set Implicit Arguments.", "Section membership.", "Variable (X : Type) (mem : X -> X -> Prop).", "Infix \"\u2208\" := mem.", "Notation \"x \u2209 y\" := (~ x \u2208 y).", "Definition mb_incl x y := forall a, a \u2208 x -> a \u2208 y.", "Definition mb_equiv x y := forall a, a \u2208 x <-> a \u2208 y.", "Infix \"\u2286\" := mb_incl.", "Infix \"\u2248\" := mb_equiv.", "Notation \"x \u2249 y\" := (~ x \u2248 y).", "Definition mb_transitive t := forall x y, x \u2208 y -> y \u2208 t -> x \u2208 t.", "Variable (Rdec : forall x y, { x \u2208 y } + { x \u2209 y }) (Xfin : finite_t X).", "Let lX : list X := proj1_sig Xfin.", "Let HX : forall x, In x lX := proj2_sig Xfin.", "Fact mb_incl_refl x : x \u2286 x.", "Proof.", "red; auto.", "Qed.", "Fact mb_incl_trans x y z : x \u2286 y -> y \u2286 z -> x \u2286 z.", "Proof.", "unfold mb_incl; auto.", "Qed.", "Fact mb_incl_choose x y : { z | z \u2208 x /\\ z \u2209 y } + { x \u2286 y }.", "Proof.", "set (P z := z \u2208 x /\\ z \u2209 y).", "set (Q z := z \u2208 x -> z \u2208 y).", "destruct list_dec with (P := P) (Q := Q) (l := lX) as [ (z & _ & H2 & H3) | H ]; unfold P, Q in *; clear P Q.", "+", "intros z; destruct (Rdec z x); destruct (Rdec z y); tauto.", "+", "left; exists z; auto.", "+", "right; intros z; apply H; auto.", "Qed.", "Fact mb_incl_dec x y : { x \u2286 y } + { ~ x \u2286 y }.", "Proof.", "destruct (mb_incl_choose x y) as [ (?&?&?) |]; auto.", "Qed.", "Fact mb_equiv_eq x y : x \u2248 y <-> x \u2286 y /\\ y \u2286 x.", "Proof.", "firstorder.", "Qed.", "Fact mb_equiv_dec x y : { x \u2248 y } + { x \u2249 y }.", "Proof.", "destruct (mb_incl_dec x y); [ destruct (mb_incl_dec y x) | ].", "1: left; apply mb_equiv_eq; auto.", "all: right; rewrite mb_equiv_eq; tauto.", "Qed.", "Hint Resolve mb_equiv_dec : core.", "Fact mb_equiv_refl_True x : x \u2248 x <-> True.", "Proof.", "unfold mb_equiv; tauto.", "Qed.", "Fact mb_equiv_refl x : x \u2248 x.", "Proof.", "unfold mb_equiv; tauto.", "Qed.", "Fact mb_equiv_sym x y : x \u2248 y -> y \u2248 x.", "Proof.", "do 2 rewrite mb_equiv_eq; tauto.", "Qed.", "Fact mb_equiv_trans x y z : x \u2248 y -> y \u2248 z -> x \u2248 z.", "Proof.", "repeat rewrite mb_equiv_eq; unfold mb_incl; intros [] []; split; auto.", "Qed.", "Add Parametric Relation: (X) (mb_equiv) reflexivity proved by mb_equiv_refl symmetry proved by mb_equiv_sym transitivity proved by mb_equiv_trans as mb_equiv_equivalence.", "Hint Resolve mb_equiv_refl mb_equiv_sym : core.", "Definition mb_member_ext := forall x y z, x \u2248 y -> x \u2208 z -> y \u2208 z.", "Variable (mb_axiom_ext : mb_member_ext).", "Fact mb_equiv_mem x y : x \u2248 y -> forall z, x \u2208 z <-> y \u2208 z.", "Proof.", "split; apply mb_axiom_ext; auto.", "Qed.", "Add Parametric Morphism: (mem) with signature (mb_equiv) ==> (mb_equiv) ==> (iff) as mb_mem_congruence.", "Proof.", "intros x y H1 a b H2; red in H1, H2; split; rewrite <- H2; apply mb_axiom_ext; auto.", "Qed.", "Add Parametric Morphism: (fun x y => x \u2286 y) with signature (mb_equiv) ==> (mb_equiv) ==> (iff) as mb_incl_congruence.", "Proof.", "intros x y H1 a b H2; split; intros H z.", "+", "rewrite <- H1, <- H2; auto.", "+", "rewrite H1, H2; auto.", "Qed.", "Definition mb_is_pair p x y := forall a, a \u2208 p <-> a \u2248 x \\/ a \u2248 y.", "Fact mb_is_pair_comm p x y : mb_is_pair p x y -> mb_is_pair p y x.", "Proof.", "unfold mb_is_pair; apply forall_equiv; intro; tauto.", "Qed.", "Add Parametric Morphism: (mb_is_pair) with signature (mb_equiv) ==> (mb_equiv) ==> (mb_equiv) ==> (iff) as mb_is_pair_congruence.", "Proof.", "intros p q H1 x x' H2 y y' H3.", "apply forall_equiv; intros a.", "rewrite H1, H2, H3; tauto.", "Qed.", "Fact mb_is_pair_fun p q x y : mb_is_pair p x y -> mb_is_pair q x y -> p \u2248 q.", "Proof.", "intros H1 H2; red in H1, H2; intro; rewrite H1, H2; tauto.", "Qed.", "Fact mb_is_pair_inj p x y x' y' : mb_is_pair p x y -> mb_is_pair p x' y' -> x \u2248 x' /\\ y \u2248 y' \\/ x \u2248 y' /\\ y \u2248 x'.", "Proof.", "unfold mb_is_pair; intros H1 H2.", "generalize (proj1 (H2 x)) (proj1 (H2 y)); rewrite H1, H1, mb_equiv_refl_True, mb_equiv_refl_True.", "generalize (proj1 (H1 x')) (proj1 (H1 y')); rewrite H2, H2, mb_equiv_refl_True, mb_equiv_refl_True.", "intros [] [] [] []; auto.", "Qed.", "Fact mb_is_pair_inj' p x y : mb_is_pair p x x -> mb_is_pair p y y -> x \u2248 y.", "Proof.", "intros H1 H2; generalize (mb_is_pair_inj H1 H2); tauto.", "Qed.", "Fact mb_is_pair_dec p x y : { mb_is_pair p x y } + { ~ mb_is_pair p x y }.", "Proof.", "unfold mb_is_pair.", "apply (fol_quant_sem_dec fol_fa); auto; intros u.", "apply fol_equiv_dec; auto.", "apply (fol_bin_sem_dec fol_disj); auto.", "Qed.", "Hint Resolve mb_is_pair_dec : core.", "Definition mb_is_opair p x y := exists a b, mb_is_pair a x x /\\ mb_is_pair b x y /\\ mb_is_pair p a b.", "Add Parametric Morphism: (mb_is_opair) with signature (mb_equiv) ==> (mb_equiv) ==> (mb_equiv) ==> (iff) as mb_is_opair_congruence.", "Proof.", "intros p q H1 x x' H2 y y' H3.", "apply exists_equiv; intros a.", "apply exists_equiv; intros b.", "rewrite H1, H2, H3; tauto.", "Qed.", "Fact mb_is_opair_fun p q x y : mb_is_opair p x y -> mb_is_opair q x y -> p \u2248 q.", "Proof.", "intros (a & b & H1 & H2 & H3) (u & v & G1 & G2 & G3).", "generalize (mb_is_pair_fun H1 G1) (mb_is_pair_fun H2 G2); intros E1 E2.", "rewrite E1, E2 in H3.", "revert H3 G3; apply mb_is_pair_fun.", "Qed.", "Fact mb_is_opair_inj p x y x' y' : mb_is_opair p x y -> mb_is_opair p x' y' -> x \u2248 x' /\\ y \u2248 y'.", "Proof.", "intros (a & b & H1 & H2 & H3) (u & v & G1 & G2 & G3).", "generalize (mb_is_pair_inj H3 G3); intros [ (E1 & E2) | (E1 & E2) ].", "+", "rewrite E1 in H1; rewrite E2 in H2.", "generalize (mb_is_pair_inj' H1 G1); intros E; split; auto.", "rewrite E in H2.", "generalize (mb_is_pair_inj H2 G2); intros [ | (E3 & E4) ]; try tauto.", "rewrite E4; auto.", "+", "rewrite E1 in H1; rewrite E2 in H2.", "generalize (mb_is_pair_inj H2 G1) (mb_is_pair_inj H1 G2).", "intros [ (E3 & E4) | (E3 & E4) ] [ (E5 & E6) | (E5 & E6) ]; rewrite E4, <- E5; auto.", "Qed.", "Fact mb_is_opair_dec p x y : { mb_is_opair p x y } + { ~ mb_is_opair p x y }.", "Proof.", "unfold mb_is_opair.", "do 2 (apply (fol_quant_sem_dec fol_ex); auto; intro).", "repeat (apply (fol_bin_sem_dec fol_conj); auto).", "Qed.", "Hint Resolve mb_is_opair_dec : core.", "Definition mb_is_otriple t x y z := exists p, mb_is_opair p x y /\\ mb_is_opair t p z.", "Add Parametric Morphism: (mb_is_otriple) with signature (mb_equiv) ==> (mb_equiv) ==> (mb_equiv) ==> (mb_equiv) ==> (iff) as mb_is_otriple_congruence.", "Proof.", "intros p q H1 x x' H2 y y' H3 z z' H4.", "unfold mb_is_otriple.", "apply exists_equiv; intros t.", "rewrite H1, H2, H3, H4; tauto.", "Qed.", "Fact mb_is_otriple_fun p q x y z : mb_is_otriple p x y z -> mb_is_otriple q x y z -> p \u2248 q.", "Proof.", "intros (t1 & H1 & H2) (t2 & H3 & H4).", "generalize (mb_is_opair_fun H1 H3); intros E.", "rewrite E in H2.", "apply (mb_is_opair_fun H2 H4).", "Qed.", "Fact mb_is_otriple_inj t x y z x' y' z' : mb_is_otriple t x y z -> mb_is_otriple t x' y' z' -> x \u2248 x' /\\ y \u2248 y' /\\ z \u2248 z'.", "Proof.", "intros (p & H1 & H2) (q & H3 & H4).", "destruct (mb_is_opair_inj H2 H4) as (H5 & H6).", "rewrite H5 in H1.", "generalize (mb_is_opair_inj H1 H3); tauto.", "Qed.", "Fact mb_is_otriple_dec p x y z : { mb_is_otriple p x y z } + { ~ mb_is_otriple p x y z }.", "Proof.", "apply (fol_quant_sem_dec fol_ex); auto; intro.", "repeat (apply (fol_bin_sem_dec fol_conj); auto).", "Qed.", "Hint Resolve mb_is_otriple_dec : core.", "Fixpoint mb_is_tuple t n (v : vec X n) := match v with | vec_nil => forall z, z \u2209 t | x##v => exists t', mb_is_opair t x t' /\\ mb_is_tuple t' v end.", "Fact mb_is_tuple_congr p q n v : p \u2248 q -> @mb_is_tuple p n v -> mb_is_tuple q v.", "Proof.", "revert p q; induction v as [ | n x v IHv ]; intros p q.", "+", "simpl; intros E H x; rewrite <- E; auto.", "+", "intros E (t & H1 & H2); exists t; split; auto.", "rewrite <- E; auto.", "Qed.", "Fact mb_is_tuple_fun p q n v : @mb_is_tuple p n v -> mb_is_tuple q v -> p \u2248 q.", "Proof.", "revert p q; induction v as [ | n x v IHv ]; intros p q.", "+", "simpl; intros H1 H2.", "apply mb_equiv_eq; split.", "*", "intros z Hz; apply H1 in Hz; tauto.", "*", "intros z Hz; apply H2 in Hz; tauto.", "+", "intros (p' & H1 & H2) (q' & H3 & H4).", "generalize (IHv _ _ H2 H4); intros E.", "rewrite E in H1.", "revert H1 H3; apply mb_is_opair_fun.", "Qed.", "Fact mb_is_tuple_inj t n v w : @mb_is_tuple t n v -> mb_is_tuple t w -> forall p, vec_pos v p \u2248 vec_pos w p.", "Proof.", "revert t w; induction v as [ | n x v IHv ]; intros t w.", "+", "intros _ _ p; invert pos p.", "+", "vec split w with y.", "intros (p & H1 & H2) (q & H3 & H4).", "destruct (mb_is_opair_inj H1 H3) as (E1 & E2).", "apply mb_is_tuple_congr with (1 := E2) in H2.", "specialize (IHv _ _ H2 H4).", "intros j; invert pos j; auto.", "Qed.", "Fact mb_is_tuple_dec t n v : { @mb_is_tuple t n v } + { ~ mb_is_tuple t v }.", "Proof.", "revert t; induction v as [ | x n v IHv ]; intros t.", "+", "apply (fol_quant_sem_dec fol_fa); auto; intro.", "apply (fol_bin_sem_dec fol_imp); auto.", "+", "simpl; apply (fol_quant_sem_dec fol_ex); auto; intro.", "apply (fol_bin_sem_dec fol_conj); auto.", "Qed.", "Hint Resolve mb_is_tuple_dec : core.", "Definition mb_has_pairs (l : X) := forall x y, x \u2208 l -> y \u2208 l -> exists p, mb_is_pair p x y.", "Definition mb_has_otriples (l : X) := forall x y z, x \u2208 l -> y \u2208 l -> z \u2208 l -> exists t, mb_is_otriple t x y z.", "Definition mb_has_tuples (l : X) n := forall v, (forall p, vec_pos v p \u2208 l) -> exists t, @mb_is_tuple t n v.", "Definition mb_is_otriple_in r x y z := exists t, mb_is_otriple t x y z /\\ t \u2208 r.", "Definition mb_is_tuple_in r n v := exists t, @mb_is_tuple t n v /\\ t \u2208 r.", "Fact mb_is_tuple_in_congr x y n v : y \u2248 x -> @mb_is_tuple_in x n v -> @mb_is_tuple_in y n v.", "Proof.", "intros E (t & H1 & H2); exists t; split; auto.", "rewrite E; auto.", "Qed.", "Fact mb_is_otriple_in_dec r x y z : { mb_is_otriple_in r x y z } + { ~ mb_is_otriple_in r x y z }.", "Proof.", "apply (fol_quant_sem_dec fol_ex); auto; intro.", "repeat (apply (fol_bin_sem_dec fol_conj); auto).", "Qed.", "Fact mb_is_tuple_in_dec r n v : { @mb_is_tuple_in r n v } + { ~ mb_is_tuple_in r v }.", "Proof.", "apply (fol_quant_sem_dec fol_ex); auto; intro.", "apply (fol_bin_sem_dec fol_conj); auto.", "Qed.", "Definition mb_is_tot n (l s : X) := forall v, (forall p, vec_pos v p \u2208 l) -> exists x p t, x \u2208 l /\\ p \u2208 s /\\ mb_is_opair p x t /\\ @mb_is_tuple t n v.", "Definition mb_is_fun (l s : X) := forall p q x x' y, x \u2208 l -> x' \u2208 l -> p \u2208 s -> q \u2208 s -> mb_is_opair p x y -> mb_is_opair q x' y -> x \u2248 x'.", "End membership.", "Section FOL_encoding.", "Notation \u03a32 := (\u03a3rel 2).", "Variable (Y : Type) (M2 : fo_model \u03a32 Y).", "Let mem a b := fom_rels M2 tt (a##b##\u00f8).", "Infix \"\u2208m\" := mem (at level 59, no associativity).", "Definition \u03a32_mem x y := @fol_atom \u03a32 tt (\u00a3x##\u00a3y##\u00f8).", "Infix \"\u2208\" := \u03a32_mem.", "Definition \u03a32_non_empty l := \u2203 0 \u2208 (1+l).", "Definition \u03a32_incl x y := \u2200 0 \u2208 (S x) \u2911 0 \u2208 (S y).", "Definition \u03a32_equiv x y := \u2200 0 \u2208 (S x) \u2194 0 \u2208 (S y).", "Infix \"\u2286\" := \u03a32_incl.", "Infix \"\u2248\" := \u03a32_equiv.", "Definition \u03a32_transitive t := \u2200\u2200 1 \u2208 0 \u2911 0 \u2208 (2+t) \u2911 1 \u2208 (2+t).", "Definition \u03a32_extensional := \u2200\u2200\u2200 2 \u2248 1 \u2911 2 \u2208 0 \u2911 1 \u2208 0.", "Definition \u03a32_is_pair p x y := \u2200 0 \u2208 (S p) \u2194 0 \u2248 S x \u27c7 0 \u2248 S y.", "Definition \u03a32_is_opair p x y := \u2203\u2203 \u03a32_is_pair 1 (2+x) (2+x) \u27d1 \u03a32_is_pair 0 (2+x) (2+y) \u27d1 \u03a32_is_pair (2+p) 1 0.", "Fact \u03a32_is_opair_vars p x y : incl (fol_vars (\u03a32_is_opair p x y)) (p::x::y::nil).", "Proof.", "cbv; tauto.", "Qed.", "Definition \u03a32_is_otriple p x y z := \u2203 \u03a32_is_opair 0 (S x) (S y) \u27d1 \u03a32_is_opair (S p) 0 (S z).", "Definition \u03a32_is_otriple_in r x y z := \u2203 \u03a32_is_otriple 0 (S x) (S y) (S z) \u27d1 0 \u2208 (S r).", "Definition \u03a32_has_otriples l := \u2200\u2200\u2200 2 \u2208 (3+l) \u2911 1 \u2208 (3+l) \u2911 0 \u2208 (3+l) \u2911 \u2203 \u03a32_is_otriple 0 3 2 1.", "Fixpoint \u03a32_is_tuple t n : vec nat n -> fol_form \u03a32 := match n with | 0 => fun _ => \u2200 0 \u2208 (S t) \u2911 \u22a5 | S n => fun v => \u2203 \u03a32_is_opair (S t) (S (vec_head v)) 0 \u27d1 \u03a32_is_tuple 0 (vec_map S (vec_tail v)) end.", "Fact \u03a32_is_tuple_vars t n v : incl (fol_vars (@\u03a32_is_tuple t n v)) (t::vec_list v).", "Proof.", "revert t v; induction n as [ | n IHn ]; intros t v.", "+", "vec nil v; cbv; tauto.", "+", "vec split v with x; simpl \u03a32_is_tuple.", "intros i; rewrite fol_vars_quant, in_flat_map.", "intros (j & H1 & H2).", "rewrite fol_vars_bin, in_app_iff in H1.", "destruct H1 as [ H1 | H1 ].", "*", "apply \u03a32_is_opair_vars in H1.", "destruct H1 as [ | [ | [ | [] ] ] ]; subst j; simpl in *; tauto.", "*", "apply IHn in H1.", "destruct H1 as [ <- | H1 ].", "-", "simpl in *; tauto.", "-", "rewrite vec_list_vec_map, in_map_iff in H1.", "destruct H1 as (y & <- & H1); simpl in *.", "destruct H2 as [ -> | [] ]; tauto.", "Qed.", "Definition \u03a32_is_tuple_in r n v := \u2203 @\u03a32_is_tuple 0 n (vec_map S v) \u27d1 0 \u2208 (S r).", "Fact \u03a32_is_tuple_in_vars r n v : incl (fol_vars (@\u03a32_is_tuple_in r n v)) (r::vec_list v).", "Proof.", "unfold \u03a32_is_tuple_in.", "intros x; rewrite fol_vars_quant, in_flat_map.", "intros (y & H1 & H2).", "rewrite fol_vars_bin, in_app_iff in H1.", "destruct H1 as [ H1 | H1 ].", "+", "apply \u03a32_is_tuple_vars in H1.", "rewrite vec_list_vec_map in H1; simpl in H1.", "rewrite in_map_iff in H1.", "destruct H1 as [ <- | (z & <- & H1) ]; simpl in *; try tauto.", "destruct H2 as [ <- | [] ]; auto.", "+", "simpl in H1.", "destruct H1 as [ <- | [ <- | [] ] ]; simpl in *; tauto.", "Qed.", "Definition \u03a32_has_tuples l n := fol_mquant fol_fa n ( (fol_vec_fa (vec_set_pos (fun p : pos n => pos2nat p \u2208 (l+n)))) \u2911 \u2203 \u03a32_is_tuple 0 (vec_set_pos (fun p : pos n => S (pos2nat p)))).", "Definition \u03a32_is_tot n l s := fol_mquant fol_fa n ( (fol_vec_fa (vec_set_pos (fun p : pos n => pos2nat p \u2208 (l+n)))) \u2911 \u2203\u2203\u2203 2 \u2208 ((3+l)+n) \u27d1 1 \u2208 ((3+s)+n) \u27d1 \u03a32_is_opair 1 2 0 \u27d1 @\u03a32_is_tuple 0 n (vec_set_pos (fun p : pos n => 3+pos2nat p)) ).", "Definition \u03a32_is_fun l s := \u2200\u2200\u2200\u2200\u2200 2 \u2208 (5+l) \u2911 1 \u2208 (5+l) \u2911 4 \u2208 (5+s) \u2911 3 \u2208 (5+s) \u2911 \u03a32_is_opair 4 2 0 \u2911 \u03a32_is_opair 3 1 0 \u2911 2 \u2248 1.", "Definition \u03a32_list_in l lv := fol_lconj (map (fun x => x \u2208 l) lv).", "Fact \u03a32_is_otriple_in_vars r x y z : incl (fol_vars (\u03a32_is_otriple_in r x y z)) (r::x::y::z::nil).", "Proof.", "intros a; simpl; tauto.", "Qed.", "Notation \"\u27ea A \u27eb\" := (fun \u03c8 => fol_sem M2 \u03c8 A).", "Section semantics.", "Fact \u03a32_transitive_spec t \u03c8 : \u27ea\u03a32_transitive t\u27eb \u03c8 = mb_transitive mem (\u03c8 t).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_non_empty_spec l \u03c8 : \u27ea\u03a32_non_empty l\u27eb \u03c8 = exists x, x \u2208m \u03c8 l.", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_incl_spec x y \u03c8 : \u27ea\u03a32_incl x y\u27eb \u03c8 = mb_incl mem (\u03c8 x) (\u03c8 y).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_equiv_spec x y \u03c8 : \u27ea\u03a32_equiv x y\u27eb \u03c8 = mb_equiv mem (\u03c8 x) (\u03c8 y).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_extensional_spec \u03c8 : \u27ea\u03a32_extensional\u27eb \u03c8 = mb_member_ext mem.", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_is_pair_spec p x y \u03c8 : \u27ea\u03a32_is_pair p x y\u27eb \u03c8 = mb_is_pair mem (\u03c8 p) (\u03c8 x) (\u03c8 y).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_is_opair_spec p x y \u03c8 : \u27ea\u03a32_is_opair p x y\u27eb \u03c8 = mb_is_opair mem (\u03c8 p) (\u03c8 x) (\u03c8 y).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_is_otriple_spec p x y z \u03c8 : \u27ea\u03a32_is_otriple p x y z\u27eb \u03c8 = mb_is_otriple mem (\u03c8 p) (\u03c8 x) (\u03c8 y) (\u03c8 z).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_is_otriple_in_spec r x y z \u03c8 : \u27ea\u03a32_is_otriple_in r x y z\u27eb \u03c8 = mb_is_otriple_in mem (\u03c8 r) (\u03c8 x) (\u03c8 y) (\u03c8 z).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_has_otriples_spec l \u03c8 : \u27ea\u03a32_has_otriples l\u27eb \u03c8 = mb_has_otriples mem (\u03c8 l).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_is_tuple_spec t n v \u03c8 : \u27ea@\u03a32_is_tuple t n v\u27eb \u03c8 <-> mb_is_tuple mem (\u03c8 t) (vec_map \u03c8 v).", "Proof.", "induction n as [ | n IHn ] in t, v, \u03c8 |- *.", "+", "vec nil v; reflexivity.", "+", "vec split v with x.", "simpl \u03a32_is_tuple.", "simpl mb_is_tuple.", "rewrite fol_sem_quant_fix.", "apply (fol_quant_sem_ext fol_ex); intros y.", "rewrite fol_sem_bin_fix.", "apply fol_bin_sem_ext.", "*", "reflexivity.", "*", "rewrite IHn, vec_map_map; reflexivity.", "Qed.", "Fact \u03a32_is_tuple_in_spec r n v \u03c8 : \u27ea@\u03a32_is_tuple_in r n v\u27eb \u03c8 <-> mb_is_tuple_in mem (\u03c8 r) (vec_map \u03c8 v).", "Proof.", "simpl; apply (fol_quant_sem_ext fol_ex); intros y.", "apply (fol_bin_sem_ext fol_conj).", "+", "rewrite \u03a32_is_tuple_spec, vec_map_map; simpl; reflexivity.", "+", "reflexivity.", "Qed.", "Fact \u03a32_has_tuples_spec l n \u03c8 : \u27ea\u03a32_has_tuples l n\u27eb \u03c8 <-> mb_has_tuples mem (\u03c8 l) n.", "Proof.", "unfold \u03a32_has_tuples.", "rewrite fol_sem_mforall.", "apply (fol_quant_sem_ext fol_fa); intros v.", "rewrite fol_sem_bin_fix.", "apply (fol_bin_sem_ext fol_imp).", "+", "rewrite fol_sem_vec_fa.", "apply (fol_quant_sem_ext fol_fa); intros p.", "rew vec.", "simpl.", "rewrite env_vlift_fix0, env_vlift_fix1.", "reflexivity.", "+", "rewrite fol_sem_quant_fix.", "apply (fol_quant_sem_ext fol_ex); intros x.", "rewrite \u03a32_is_tuple_spec; simpl.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p.", "rew vec; simpl.", "rewrite env_vlift_fix0; auto.", "Qed.", "Fact \u03a32_is_fun_spec l s \u03c8 : \u27ea\u03a32_is_fun l s\u27eb \u03c8 = mb_is_fun mem (\u03c8 l) (\u03c8 s).", "Proof.", "reflexivity.", "Qed.", "Fact \u03a32_is_tot_spec n l s \u03c8 : \u27ea\u03a32_is_tot n l s\u27eb \u03c8 <-> mb_is_tot mem n (\u03c8 l) (\u03c8 s).", "Proof.", "unfold \u03a32_is_tot, mb_is_tot.", "rewrite fol_sem_mforall.", "apply forall_equiv; intros v.", "rewrite fol_sem_bin_fix.", "apply (fol_bin_sem_ext fol_imp).", "+", "rewrite fol_sem_vec_fa.", "apply forall_equiv; intros p.", "rew vec.", "simpl; rewrite env_vlift_fix0, env_vlift_fix1; tauto.", "+", "rewrite fol_sem_quant_fix; apply exists_equiv; intros x.", "rewrite fol_sem_quant_fix; apply exists_equiv; intros p.", "rewrite fol_sem_quant_fix; apply exists_equiv; intros t.", "do 3 (rewrite fol_sem_bin_fix).", "repeat apply (fol_bin_sem_ext fol_conj).", "*", "simpl; rewrite env_vlift_fix1; tauto.", "*", "simpl; rewrite env_vlift_fix1; tauto.", "*", "rewrite \u03a32_is_opair_spec; simpl; tauto.", "*", "rewrite \u03a32_is_tuple_spec; simpl.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros q; rew vec.", "simpl; rewrite env_vlift_fix0; auto.", "Qed.", "Fact \u03a32_list_in_spec l lv \u03c8 : \u27ea\u03a32_list_in l lv\u27eb \u03c8 <-> forall x, In x lv -> \u03c8 x \u2208m \u03c8 l.", "Proof.", "unfold \u03a32_list_in; rewrite fol_sem_lconj.", "split.", "+", "intros H x Hx.", "apply (H (_ \u2208 _)), in_map_iff.", "exists x; auto.", "+", "intros H f; rewrite in_map_iff.", "intros (x & <- & ?); apply H; auto.", "Qed.", "End semantics.", "Fact \u03a32_is_otriple_in_equiv r x y z \u03c6 \u03c8 : \u27ea\u03a32_is_otriple_in 3 2 1 0\u27eb z\u00b7y\u00b7x\u00b7r\u00b7\u03c6 <-> \u27ea\u03a32_is_otriple_in 3 2 1 0\u27eb z\u00b7y\u00b7x\u00b7r\u00b7\u03c8.", "Proof.", "cbv beta; do 2 rewrite \u03a32_is_otriple_in_spec; simpl; tauto.", "Qed.", "End FOL_encoding."], "theorems": [{"name": "mb_incl_refl", "kind": "Fact", "begin": 18, "end": 21}, {"name": "mb_incl_trans", "kind": "Fact", "begin": 22, "end": 25}, {"name": "mb_incl_choose", "kind": "Fact", "begin": 26, "end": 37}, {"name": "mb_incl_dec", "kind": "Fact", "begin": 38, "end": 41}, {"name": "mb_equiv_eq", "kind": "Fact", "begin": 42, "end": 45}, {"name": "mb_equiv_dec", "kind": "Fact", "begin": 46, "end": 51}, {"name": "mb_equiv_refl_True", "kind": "Fact", "begin": 53, "end": 56}, {"name": "mb_equiv_refl", "kind": "Fact", "begin": 57, "end": 60}, {"name": "mb_equiv_sym", "kind": "Fact", "begin": 61, "end": 64}, {"name": "mb_equiv_trans", "kind": "Fact", "begin": 65, "end": 68}, {"name": "mb_equiv_mem", "kind": "Fact", "begin": 73, "end": 76}, {"name": "mb_is_pair_comm", "kind": "Fact", "begin": 90, "end": 93}, {"name": "mb_is_pair_fun", "kind": "Fact", "begin": 100, "end": 103}, {"name": "mb_is_pair_inj", "kind": "Fact", "begin": 104, "end": 110}, {"name": "mb_is_pair_inj'", "kind": "Fact", "begin": 111, "end": 114}, {"name": "mb_is_pair_dec", "kind": "Fact", "begin": 115, "end": 121}, {"name": "mb_is_opair_fun", "kind": "Fact", "begin": 131, "end": 137}, {"name": "mb_is_opair_inj", "kind": "Fact", "begin": 138, "end": 152}, {"name": "mb_is_opair_dec", "kind": "Fact", "begin": 153, "end": 158}, {"name": "mb_is_otriple_fun", "kind": "Fact", "begin": 168, "end": 174}, {"name": "mb_is_otriple_inj", "kind": "Fact", "begin": 175, "end": 181}, {"name": "mb_is_otriple_dec", "kind": "Fact", "begin": 182, "end": 186}, {"name": "mb_is_tuple_congr", "kind": "Fact", "begin": 189, "end": 197}, {"name": "mb_is_tuple_fun", "kind": "Fact", "begin": 198, "end": 213}, {"name": "mb_is_tuple_inj", "kind": "Fact", "begin": 214, "end": 226}, {"name": "mb_is_tuple_dec", "kind": "Fact", "begin": 227, "end": 236}, {"name": "mb_is_tuple_in_congr", "kind": "Fact", "begin": 243, "end": 247}, {"name": "mb_is_otriple_in_dec", "kind": "Fact", "begin": 248, "end": 252}, {"name": "mb_is_tuple_in_dec", "kind": "Fact", "begin": 253, "end": 257}, {"name": "\u03a32_is_opair_vars", "kind": "Fact", "begin": 277, "end": 280}, {"name": "\u03a32_is_tuple_vars", "kind": "Fact", "begin": 285, "end": 308}, {"name": "\u03a32_is_tuple_in_vars", "kind": "Fact", "begin": 310, "end": 326}, {"name": "\u03a32_is_otriple_in_vars", "kind": "Fact", "begin": 331, "end": 334}, {"name": "\u03a32_transitive_spec", "kind": "Fact", "begin": 337, "end": 340}, {"name": "\u03a32_non_empty_spec", "kind": "Fact", "begin": 341, "end": 344}, {"name": "\u03a32_incl_spec", "kind": "Fact", "begin": 345, "end": 348}, {"name": "\u03a32_equiv_spec", "kind": "Fact", "begin": 349, "end": 352}, {"name": "\u03a32_extensional_spec", "kind": "Fact", "begin": 353, "end": 356}, {"name": "\u03a32_is_pair_spec", "kind": "Fact", "begin": 357, "end": 360}, {"name": "\u03a32_is_opair_spec", "kind": "Fact", "begin": 361, "end": 364}, {"name": "\u03a32_is_otriple_spec", "kind": "Fact", "begin": 365, "end": 368}, {"name": "\u03a32_is_otriple_in_spec", "kind": "Fact", "begin": 369, "end": 372}, {"name": "\u03a32_has_otriples_spec", "kind": "Fact", "begin": 373, "end": 376}, {"name": "\u03a32_is_tuple_spec", "kind": "Fact", "begin": 377, "end": 394}, {"name": "\u03a32_is_tuple_in_spec", "kind": "Fact", "begin": 395, "end": 403}, {"name": "\u03a32_has_tuples_spec", "kind": "Fact", "begin": 404, "end": 426}, {"name": "\u03a32_is_fun_spec", "kind": "Fact", "begin": 427, "end": 430}, {"name": "\u03a32_is_tot_spec", "kind": "Fact", "begin": 431, "end": 460}, {"name": "\u03a32_list_in_spec", "kind": "Fact", "begin": 461, "end": 472}, {"name": "\u03a32_is_otriple_in_equiv", "kind": "Fact", "begin": 474, "end": 477}]}