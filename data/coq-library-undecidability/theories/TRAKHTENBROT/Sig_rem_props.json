{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Local Reserved Notation \"\u27ea A \u27eb'\" (at level 1, format \"\u27ea A \u27eb'\").", "Local Notation \u00f8 := vec_nil.", "Section remove_constants.", "Variable (\u03a3 : fo_signature) (H\u03a3 : forall r, ar_rels \u03a3 r <= 1).", "Definition \u03a3no_props : fo_signature.", "Proof.", "exists (syms \u03a3) (rels \u03a3).", "+", "apply ar_syms.", "+", "exact (fun _ => 1).", "Defined.", "Notation \u03a3' := \u03a3no_props.", "Implicit Type (A : fol_form \u03a3).", "Let choice : forall a, { a = 0 } + { a = 1 } + { 1 < a }.", "Proof.", "intros [ | [ | a ] ]; auto; right; lia.", "Qed.", "Fixpoint \u03a3rem_props (n : nat) A { struct A } : fol_form \u03a3'.", "Proof.", "refine (match A with | \u22a5 => \u22a5 | fol_atom r v => match choice (ar_rels _ r) with | inleft (left _) => @fol_atom \u03a3' r (\u00a3n##\u00f8) | inleft (right E) => @fol_atom \u03a3' r (cast v E) | inright H => _ end | fol_bin b A B => fol_bin b (\u03a3rem_props n A) (\u03a3rem_props n B) | fol_quant q A => fol_quant q (\u03a3rem_props (S n) A) end).", "exfalso.", "abstract (generalize (H\u03a3 r); lia).", "Defined.", "Variable (X : Type).", "Section soundness.", "Variable (M : fo_model \u03a3 X) (\u03c6 : nat -> X).", "Let M' : fo_model \u03a3' X.", "Proof.", "split.", "+", "apply (fom_syms M).", "+", "simpl; intros r.", "destruct (choice (ar_rels _ r)) as [ [ H | H ] | H ].", "*", "exact (fun _ => fom_rels M r (cast \u00f8 (eq_sym H))).", "*", "exact (fun v => fom_rels M r (cast v (eq_sym H))).", "*", "exact (fun _ => False).", "Defined.", "Local Fact \u03a3rem_props_sound n A : fol_sem M \u03c6 A <-> fol_sem M' \u03c6 (\u03a3rem_props n A).", "Proof.", "revert n \u03c6; induction A as [ | r v | b A HA B HB | q A HA ]; intros n \u03c6.", "+", "simpl; tauto.", "+", "simpl.", "case_eq (choice (ar_rels \u03a3 r)); [ intros [ E | E ] | intros E ]; intros HE; simpl; try rewrite HE.", "*", "apply fol_equiv_ext; f_equal.", "clear n HE; revert E v.", "intros -> v; vec nil v; auto.", "*", "apply fol_equiv_ext; f_equal.", "clear n HE; revert E v.", "intros -> v; auto.", "*", "exfalso; generalize (H\u03a3 r); intros.", "clear v n HE; lia.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; auto.", "Qed.", "Hypothesis (Xfin : finite_t X) (Mdec : fo_model_dec M) (A : fol_form \u03a3) (HA : fol_sem M \u03c6 A).", "Local Lemma \u03a3rem_props_soundness : fo_form_fin_dec_SAT_in (\u03a3rem_props 0 A) X.", "Proof.", "exists M', Xfin.", "exists.", "{", "intros r; simpl; intros v; simpl in *.", "destruct (choice (ar_rels _ r)) as [ [ | ] | ]; try apply Mdec; tauto.", "}", "exists \u03c6; apply \u03a3rem_props_sound; auto.", "Qed.", "End soundness.", "Section completeness.", "Variable (M' : fo_model \u03a3' X) (\u03c6 : nat -> X).", "Let M : fo_model \u03a3 X.", "Proof.", "split.", "+", "apply (fom_syms M').", "+", "simpl; intros r.", "destruct (choice (ar_rels _ r)) as [ [ H | H ] | H ].", "*", "exact (fun _ => fom_rels M' r (\u03c6 0##\u00f8)).", "*", "exact (fun v => fom_rels M' r (cast v H)).", "*", "exact (fun _ => False).", "Defined.", "Local Fact \u03a3rem_props_complete n A \u03c8 : \u03c8 n = \u03c6 0 -> fol_sem M \u03c8 A <-> fol_sem M' \u03c8 (\u03a3rem_props n A).", "Proof.", "revert n \u03c8; induction A as [ | r v | b A HA B HB | q A HA ]; intros n \u03c8 H.", "+", "simpl; tauto.", "+", "simpl.", "destruct (choice (ar_rels \u03a3 r)) as [ [ E | E ] | E ].", "*", "apply fol_equiv_ext; simpl; now do 2 f_equal.", "*", "apply fol_equiv_ext; f_equal.", "clear n H; revert E v.", "intros -> v; auto.", "*", "exfalso; generalize (H\u03a3 r); intros.", "clear v n H; lia.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; apply HA; simpl; auto.", "Qed.", "Hypothesis (Xfin : finite_t X) (M'dec : fo_model_dec M') (A : fol_form \u03a3) (HA : fol_sem M' \u03c6 (\u03a3rem_props 0 A)).", "Local Lemma \u03a3rem_props_completeness : fo_form_fin_dec_SAT_in A X.", "Proof.", "exists M, Xfin.", "exists.", "{", "intros r v; simpl in *.", "destruct (choice (ar_rels _ r)) as [ [ | ] | ]; try apply M'dec; tauto.", "}", "exists \u03c6; revert HA; apply \u03a3rem_props_complete; auto.", "Qed.", "End completeness.", "Theorem \u03a3rem_props_correct A : fo_form_fin_dec_SAT_in A X <-> fo_form_fin_dec_SAT_in (\u03a3rem_props 0 A) X.", "Proof.", "split.", "+", "intros (M & H1 & H2 & phi & H3).", "apply \u03a3rem_props_soundness with M phi; auto.", "+", "intros (M & H1 & H2 & phi & H3).", "apply \u03a3rem_props_completeness with M phi; auto.", "Qed.", "End remove_constants."], "theorems": [{"name": "\u03a3no_props", "kind": "Definition", "begin": 9, "end": 16}, {"name": "choice", "kind": "Let", "begin": 19, "end": 22}, {"name": "\u03a3rem_props", "kind": "Fixpoint", "begin": 23, "end": 28}, {"name": "M'", "kind": "Let", "begin": 32, "end": 46}, {"name": "M", "kind": "Let", "begin": 85, "end": 99}, {"name": "\u03a3rem_props_correct", "kind": "Theorem", "begin": 134, "end": 143}]}