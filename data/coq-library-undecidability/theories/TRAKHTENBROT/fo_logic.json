{"code": ["Require Import List Arith Lia.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms.", "Set Implicit Arguments.", "Notation \u00f8 := vec_nil.", "Opaque fo_term_subst fo_term_map fo_term_sem.", "Definition \u03a3rel_var k : fol_term (\u03a3rel k) -> nat.", "Proof.", "intros [ n | [] ]; exact n.", "Defined.", "Inductive fol_form (\u03a3 : fo_signature) : Type := | fol_false : fol_form \u03a3 | fol_atom : forall p, vec (fol_term \u03a3) (ar_rels \u03a3 p) -> fol_form \u03a3 | fol_bin : fol_bop -> fol_form \u03a3 -> fol_form \u03a3 -> fol_form \u03a3 | fol_quant : fol_qop -> fol_form \u03a3 -> fol_form \u03a3.", "Infix \"\u2911\" := (fol_bin fol_imp) (at level 62, right associativity).", "Infix \"\u27d1\" := (fol_bin fol_conj) (at level 60, right associativity).", "Infix \"\u27c7\" := (fol_bin fol_disj) (at level 61, right associativity).", "Notation \"\u2200 f\" := (fol_quant fol_fa f) (at level 64, right associativity).", "Notation \"\u2203 f\" := (fol_quant fol_ex f) (at level 64, right associativity).", "Notation \"x \u2194 y\" := ((x\u2911y)\u27d1(y\u2911x)) (at level 63, no associativity).", "Notation \"\u00a3\" := (in_var : nat -> fol_term _).", "Notation \"\u22a5\" := (fol_false _).", "Section fol_subst.", "Variable (\u03a3 : fo_signature).", "Notation \ud835\udd4b := (fol_term \u03a3).", "Notation \ud835\udd3d := (fol_form \u03a3).", "Implicit Type A : \ud835\udd3d.", "Fixpoint fol_height A := match A with | \u22a5 => 1 | fol_atom p v => 1 | fol_bin c A B => 1 + max (fol_height A) (fol_height B) | fol_quant q A => 1 + fol_height A end.", "Fixpoint fol_vars A := match A with | \u22a5 => nil | fol_atom p v => flat_map fo_term_vars (vec_list v) | fol_bin c A B => fol_vars A ++ fol_vars B | fol_quant q A => flat_map (fun n => match n with 0 => nil | S n => n::nil end) (fol_vars A) end.", "Fact fol_vars_bin b A B : fol_vars (fol_bin b A B) = fol_vars A ++ fol_vars B.", "Proof.", "trivial.", "Qed.", "Fact fol_vars_quant q A : fol_vars (fol_quant q A) = flat_map (fun n => match n with 0 => nil | S n => n::nil end) (fol_vars A).", "Proof.", "trivial.", "Qed.", "Definition fol_vars_max A := lmax (fol_vars A).", "Fact fol_vars_max_spec A n : In n (fol_vars A) -> n <= fol_vars_max A.", "Proof.", "apply lmax_prop.", "Qed.", "Fixpoint fol_syms (A : \ud835\udd3d) := match A with | \u22a5 => nil | fol_atom p v => flat_map fo_term_syms (vec_list v) | fol_bin c A B => fol_syms A ++ fol_syms B | fol_quant q A => fol_syms A end.", "Fact fol_syms_bin b A B : fol_syms (fol_bin b A B) = fol_syms A ++ fol_syms B.", "Proof.", "trivial.", "Qed.", "Fact fol_syms_quant q A : fol_syms (fol_quant q A) = fol_syms A.", "Proof.", "trivial.", "Qed.", "Fixpoint fol_rels (A : \ud835\udd3d) := match A with | \u22a5 => nil | fol_atom p v => p::nil | fol_bin c A B => fol_rels A ++ fol_rels B | fol_quant q A => fol_rels A end.", "Fact fol_rels_bin b A B : fol_rels (fol_bin b A B) = fol_rels A ++ fol_rels B.", "Proof.", "trivial.", "Qed.", "Fact fol_rels_quant q A : fol_rels (fol_quant q A) = fol_rels A.", "Proof.", "trivial.", "Qed.", "Fixpoint fol_subst \u03c3 (A : \ud835\udd3d) := match A with | \u22a5 => \u22a5 | fol_atom _ v => fol_atom _ (vec_map (fo_term_subst \u03c3) v) | fol_bin c A B => fol_bin c (A\u2983\u03c3\u2984) (B\u2983\u03c3\u2984) | fol_quant q A => fol_quant q (A\u2983\u21e1\u03c3\u2984) end where \"A \u2983 \u03c3 \u2984\" := (fol_subst \u03c3 A).", "Fact fol_subst_ext \u03c3 \u03c1 A : (forall n, In n (fol_vars A) -> \u03c3 n = \u03c1 n) -> A\u2983\u03c3\u2984 = A\u2983\u03c1\u2984.", "Proof.", "intros Hfg; revert A \u03c3 \u03c1 Hfg.", "induction A as [ | p v | c A IHA B IHB | q A IHA ]; intros f g Hfg; simpl; f_equal; auto.", "+", "apply vec_map_ext; intros t Ht.", "apply fo_term_subst_ext; intros n Hn.", "apply Hfg, in_flat_map; exists t; split; auto.", "apply in_vec_list; auto.", "+", "apply IHA; intros n Hn; apply Hfg, in_or_app; auto.", "+", "apply IHB; intros n Hn; apply Hfg, in_or_app; auto.", "+", "apply IHA; intros [ | n ] Hn; simpl; auto; rew fot.", "f_equal; apply Hfg; simpl.", "apply in_flat_map; exists (S n); simpl; auto.", "Qed.", "Fact fol_vars_subst \u03c3 (A : \ud835\udd3d) : fol_vars (A\u2983\u03c3\u2984) = flat_map (fun x => fo_term_vars (\u03c3 x)) (fol_vars A).", "Proof.", "revert \u03c3; induction A as [ | s r | b A HA B HB | q A HA ]; intros phi; auto.", "+", "simpl fol_vars.", "rewrite vec_list_vec_map.", "rewrite flat_map_flat_map.", "do 2 rewrite flat_map_concat_map.", "rewrite map_map; f_equal.", "apply map_ext; intros x.", "rewrite fo_term_vars_subst; auto.", "+", "simpl; rewrite flat_map_app; f_equal; auto.", "+", "simpl; rewrite HA.", "do 2 rewrite flat_map_flat_map.", "do 2 rewrite flat_map_concat_map; f_equal.", "apply map_ext_in; intros [ | x ] Hx; simpl; auto.", "rewrite fo_term_vars_map; rew fot.", "rewrite flat_map_concat_map, map_map.", "rewrite <- flat_map_concat_map.", "rewrite <- app_nil_end.", "rewrite flat_map_single, map_id; auto.", "Qed.", "Fact fol_vars_map \u03c3 (A : \ud835\udd3d) : fol_vars (A\u2983fun n => \u00a3(\u03c3 n)\u2984) = map \u03c3 (fol_vars A).", "Proof.", "rewrite fol_vars_subst, <- flat_map_single; auto.", "Qed.", "Fact fol_syms_subst P \u03c3 (A : \ud835\udd3d) : (forall n, In n (fol_vars A) -> Forall P (fo_term_syms (\u03c3 n))) -> Forall P (fol_syms A) -> Forall P (fol_syms (A\u2983\u03c3\u2984)).", "Proof.", "revert \u03c3.", "induction A as [ | s r | b A HA B HB | q A HA ]; intros f Hf H; simpl; auto.", "+", "rewrite Forall_forall in H |- *.", "intros s'; rewrite in_flat_map.", "intros (t & Ht); revert Ht.", "rewrite vec_list_vec_map, in_map_iff.", "intros ((t' & <- & H1) & H2).", "revert s' H2; apply Forall_forall.", "apply fo_term_syms_subst.", "simpl in H, Hf.", "*", "intros n Hn; apply Hf, in_flat_map.", "exists t'; auto.", "*", "apply Forall_forall; intros s' Hs'.", "apply H, in_flat_map; exists t'; auto.", "+", "simpl in H; rewrite Forall_app in H.", "rewrite Forall_app; split.", "*", "apply HA; try tauto.", "intros; apply Hf, in_or_app; auto.", "*", "apply HB; try tauto.", "intros; apply Hf, in_or_app; auto.", "+", "simpl in H; apply HA; auto.", "intros [ | n ]; simpl; rew fot; auto.", "rewrite fo_term_syms_map; intros Hn.", "apply Hf, in_flat_map.", "exists (S n); simpl; auto.", "Qed.", "Fact fol_rels_subst \u03c3 (A : \ud835\udd3d) : fol_rels (A\u2983\u03c3\u2984) = fol_rels A.", "Proof.", "revert \u03c3.", "induction A as [ | s r | b A HA B HB | q A HA ]; intros f; simpl; auto.", "rewrite HA, HB; auto.", "Qed.", "Definition fol_bigop c A := fold_right (@fol_bin \u03a3 c) A.", "Fact fol_vars_bigop c l A : fol_vars (fol_bigop c A l) = flat_map fol_vars l++fol_vars A.", "Proof.", "induction l; simpl; auto.", "rewrite app_ass; f_equal; auto.", "Qed.", "Fact fol_syms_bigop c l A : fol_syms (fol_bigop c A l) = flat_map fol_syms l++fol_syms A.", "Proof.", "induction l; simpl; auto.", "rewrite app_ass; f_equal; auto.", "Qed.", "Fact fol_rels_bigop c l A : fol_rels (fol_bigop c A l) = flat_map fol_rels l++fol_rels A.", "Proof.", "induction l; simpl; auto.", "rewrite app_ass; f_equal; auto.", "Qed.", "Fact fol_subst_bigop c l A \u03c3 : (fol_bigop c A l)\u2983\u03c3\u2984 = fol_bigop c (A\u2983\u03c3\u2984) (map (fol_subst \u03c3) l).", "Proof.", "induction l; simpl; f_equal; auto.", "Qed.", "Fixpoint fol_mquant q n (A : \ud835\udd3d) := match n with | 0 => A | S n => fol_quant q (fol_mquant q n A) end.", "Fact fol_mquant_plus q a b A : fol_mquant q (a+b) A = fol_mquant q a (fol_mquant q b A).", "Proof.", "induction a; simpl; f_equal; auto.", "Qed.", "Fact fol_mquant_S q n A : fol_mquant q (S n) A = fol_mquant q n (fol_quant q A).", "Proof.", "replace (S n) with (n+1) by lia.", "apply fol_mquant_plus.", "Qed.", "Fact fol_vars_mquant q n (A : \ud835\udd3d) : fol_vars (fol_mquant q n A) = flat_map (fun i => if le_lt_dec n i then (i-n::nil) else nil) (fol_vars A).", "Proof.", "revert A; induction n as [ | n IHn ]; intros A.", "+", "simpl; rewrite <- map_id at 1; rewrite <- flat_map_single.", "do 2 rewrite flat_map_concat_map; f_equal; apply map_ext.", "intro a; destruct (le_lt_dec 0 a); f_equal; lia.", "+", "rewrite fol_mquant_S.", "rewrite IHn; simpl fol_vars; rewrite flat_map_flat_map.", "do 2 rewrite flat_map_concat_map; f_equal; apply map_ext.", "intros [ | a ]; auto; simpl flat_map.", "rewrite <- app_nil_end.", "destruct (le_lt_dec n a); destruct (le_lt_dec (S n) (S a)); auto; lia.", "Qed.", "Fact fol_syms_mquant q n A : fol_syms (fol_mquant q n A) = fol_syms A.", "Proof.", "induction n; simpl; auto.", "Qed.", "Fact fol_rels_mquant q n A : fol_rels (fol_mquant q n A) = fol_rels A.", "Proof.", "induction n; simpl; auto.", "Qed.", "Fact fol_subst_subst \u03c3 \u03c1 A : A\u2983\u03c3\u2984\u2983\u03c1\u2984 = A\u2983fun n => (\u03c3 n)\u27ec\u03c1\u27ed\u2984.", "Proof.", "revert \u03c3 \u03c1; induction A as [ | p v | b A IHA B IHB | q A IHA ]; simpl; intros f g; auto.", "+", "f_equal.", "rewrite vec_map_map.", "apply vec_map_ext.", "intros A w; rew fot; auto.", "+", "f_equal; auto.", "+", "f_equal.", "rewrite IHA; auto.", "apply fol_subst_ext.", "intros [ | n ] _; rew fot; simpl; rew fot; simpl; auto.", "do 2 rewrite <- fo_term_subst_map, fo_term_subst_comp.", "apply fo_term_subst_ext.", "intros; rew fot; rewrite fo_term_subst_map; simpl; rew fot; auto.", "Qed.", "End fol_subst.", "Notation \"A \u2983 \u03c3 \u2984\" := (fol_subst \u03c3 A).", "Notation fol_lconj := (@fol_bigop _ fol_conj (\u22a5\u2911\u22a5)).", "Notation fol_ldisj := (@fol_bigop _ fol_disj \u22a5).", "Section fol_semantics.", "Variable (\u03a3 : fo_signature) (X : Type) (M : fo_model \u03a3 X).", "Implicit Type \u03c6 : nat -> X.", "Notation \ud835\udd4b := (fol_term \u03a3).", "Notation \ud835\udd3d := (fol_form \u03a3).", "Notation \"\u27e6 t \u27e7\" := (fun \u03c6 => fo_term_sem M \u03c6 t).", "Fixpoint fol_sem \u03c6 A : Prop := match A with | \u22a5 => False | fol_atom _ v => fom_rels M _ (vec_map (fun t => \u27e6t\u27e7 \u03c6) v) | fol_bin b A B => fol_bin_sem b (\u27eaA\u27eb \u03c6) (\u27eaB\u27eb \u03c6) | fol_quant q A => fol_quant_sem q (fun x => \u27eaA\u27eb x\u00b7\u03c6) end where \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem \u03c6 A).", "Fact fol_sem_bin_fix \u03c6 b A B : fol_sem \u03c6 (fol_bin b A B) = fol_bin_sem b (\u27eaA\u27eb \u03c6) (\u27eaB\u27eb \u03c6).", "Proof.", "reflexivity.", "Qed.", "Fact fol_sem_quant_fix \u03c6 q A : fol_sem \u03c6 (fol_quant q A) = fol_quant_sem q (fun x => \u27eaA\u27eb x\u00b7\u03c6).", "Proof.", "reflexivity.", "Qed.", "Fact fol_sem_ext \u03c6 \u03c8 A : (forall n, In n (fol_vars A) -> \u03c6 n = \u03c8 n) -> \u27eaA\u27eb \u03c6 <-> \u27eaA\u27eb \u03c8.", "Proof.", "intros H; revert A \u03c6 \u03c8 H.", "induction A as [ | p v | b A IHA B IHB | q A IHA ]; simpl; intros phi psy H; try tauto.", "+", "apply fol_equiv_ext; f_equal.", "apply vec_map_ext; intros w Hw.", "apply fo_term_sem_ext; auto.", "intros n Hn; apply H, in_flat_map; exists w; split; auto.", "apply in_vec_list; auto.", "+", "apply fol_bin_sem_ext.", "*", "apply IHA; intros; apply H, in_or_app; auto.", "*", "apply IHB; intros; apply H, in_or_app; auto.", "+", "apply fol_quant_sem_ext.", "intros x; apply IHA.", "intros [ | n] Hn; simpl; auto; apply H, in_flat_map.", "exists (S n); simpl; auto.", "Qed.", "Section decidable.", "Variable (M_fin : finite_t X).", "Variable (rels_dec : fo_model_dec M).", "Theorem fol_sem_dec A \u03c6 : { \u27eaA\u27eb \u03c6 } + { ~ \u27eaA\u27eb \u03c6 }.", "Proof.", "revert \u03c6.", "induction A as [ | p v | b A IHA B IHB | q A IHA ]; intros phi.", "+", "simpl; tauto.", "+", "simpl; apply rels_dec.", "+", "simpl fol_sem; apply fol_bin_sem_dec; auto.", "+", "simpl fol_sem; apply fol_quant_sem_dec; auto.", "Qed.", "End decidable.", "Theorem fol_sem_subst \u03c6 \u03c3 A : \u27ea A\u2983\u03c3\u2984 \u27eb \u03c6 <-> \u27eaA\u27eb (fun n => \u27e6\u03c3 n\u27e7 \u03c6).", "Proof.", "revert \u03c6 \u03c3; induction A as [ | p v | b A IHA B IHB | q A IHA ]; simpl; intros phi f; try tauto.", "+", "apply fol_equiv_ext; f_equal.", "rewrite vec_map_map; apply vec_map_ext.", "intros; rewrite fo_term_sem_subst; auto.", "+", "apply fol_bin_sem_ext; auto.", "+", "apply fol_quant_sem_ext.", "intros x; rewrite IHA.", "apply fol_sem_ext.", "intros [ | n ] _; simpl; rew fot; simpl; auto.", "rewrite <- fo_term_subst_map; rew fot.", "apply fo_term_sem_ext; intros; rew fot; auto.", "Qed.", "Definition fol_lift t n : \ud835\udd4b := match n with 0 => t | S n => \u00a3n end.", "Corollary fol_sem_lift \u03c6 t A : \u27ea A\u2983fol_lift t\u2984 \u27eb \u03c6 <-> \u27eaA\u27eb (\u27e6t\u27e7 \u03c6)\u00b7\u03c6.", "Proof.", "rewrite fol_sem_subst.", "apply fol_sem_ext; intros [ | n ] _; simpl; rew fot; auto.", "Qed.", "Fact fol_sem_lconj lf \u03c6 : \u27eafol_lconj lf\u27eb \u03c6 <-> forall f, In f lf -> \u27ea f \u27eb \u03c6.", "Proof.", "induction lf as [ | f lf IHlf ]; simpl.", "+", "split; tauto.", "+", "rewrite IHlf.", "split.", "*", "intros [] ? [ -> | ]; auto.", "*", "intros H; split; intros; apply H; auto.", "Qed.", "Fact fol_sem_lconj_app l m \u03c6 : \u27ea fol_lconj (l++m) \u27eb \u03c6 <-> \u27ea fol_lconj l \u27eb \u03c6 /\\ \u27ea fol_lconj m \u27eb \u03c6.", "Proof.", "do 3 rewrite fol_sem_lconj; split.", "+", "intros H; split; intros; apply H, in_app_iff; firstorder.", "+", "intros (H1 & H2) f; rewrite in_app_iff; firstorder.", "Qed.", "Fact fol_sem_ldisj lf \u03c6 : \u27eafol_ldisj lf\u27eb \u03c6 <-> exists f, In f lf /\\ \u27ea f \u27eb \u03c6.", "Proof.", "induction lf as [ | f lf IHlf ]; simpl.", "+", "split; try tauto; intros ( ? & [] & _).", "+", "rewrite IHlf.", "split.", "*", "intros [ H | (g & H1 & H2) ].", "-", "exists f; auto.", "-", "exists g; auto.", "*", "intros (g & [ <- | Hg ] & ?); auto.", "right; exists g; auto.", "Qed.", "Fact fol_sem_ldisj_app l m \u03c6 : \u27ea fol_ldisj (l++m) \u27eb \u03c6 <-> \u27ea fol_ldisj l \u27eb \u03c6 \\/ \u27ea fol_ldisj m \u27eb \u03c6.", "Proof.", "do 3 rewrite fol_sem_ldisj; split.", "+", "intros (f & H1 & H2); revert H1; rewrite in_app_iff; firstorder.", "+", "intros [ (? & ? & ?) | (? & ? & ?) ]; firstorder auto with *.", "Qed.", "Definition fol_vec_fa n (A : vec \ud835\udd3d n) := fol_lconj (vec_list A).", "Fact fol_vars_vec_fa n A : fol_vars (@fol_vec_fa n A) = flat_map (@fol_vars _) (vec_list A).", "Proof.", "unfold fol_vec_fa; rewrite fol_vars_bigop; simpl.", "rewrite app_nil_end; auto.", "Qed.", "Fact fol_syms_vec_fa n A : fol_syms (@fol_vec_fa n A) = flat_map (@fol_syms _) (vec_list A).", "Proof.", "unfold fol_vec_fa; rewrite fol_syms_bigop; simpl.", "rewrite app_nil_end; auto.", "Qed.", "Fact fol_rels_vec_fa n A : fol_rels (@fol_vec_fa n A) = flat_map (@fol_rels _) (vec_list A).", "Proof.", "unfold fol_vec_fa; rewrite fol_rels_bigop; simpl.", "rewrite app_nil_end; auto.", "Qed.", "Fact fol_sem_vec_fa n A \u03c6 : \u27ea @fol_vec_fa n A \u27eb \u03c6 <-> forall p, \u27ea vec_pos A p \u27eb \u03c6.", "Proof.", "unfold fol_vec_fa; rewrite fol_sem_lconj; split.", "+", "intros H p; apply H, in_vec_list, in_vec_pos.", "+", "intros H f Hf.", "apply vec_list_inv in Hf.", "destruct Hf as (p & ->); auto.", "Qed.", "Fixpoint env_vlift \u03c6 n (v : vec X n) := match v with | \u00f8 => \u03c6 | x##v => x\u00b7(env_vlift \u03c6 v) end.", "Fact env_vlift_fix0 \u03c6 n (v : vec X n) p : env_vlift \u03c6 v (pos2nat p) = vec_pos v p.", "Proof.", "revert \u03c6 p; induction v as [ | n x v IHv ]; intros phi p; auto.", "+", "invert pos p.", "+", "invert pos p.", "*", "rewrite pos2nat_fst; auto.", "*", "rewrite pos2nat_nxt; simpl; auto.", "Qed.", "Fact env_vlift_fix1 \u03c6 n (v : vec X n) k : env_vlift \u03c6 v (k+n) = \u03c6 k.", "Proof.", "revert \u03c6 k; induction v as [ | x n v IHv ]; intros phi k; simpl; auto.", "replace (k+S n) with (S (k+n)) by lia; simpl; auto.", "Qed.", "Fact fol_sem_mforall n A \u03c6 : \u27eafol_mquant fol_fa n A\u27eb \u03c6 <-> forall v : vec X n, \u27eaA\u27eb (env_vlift \u03c6 v).", "Proof.", "revert A \u03c6; induction n as [ | n IHn ]; intros A phi.", "+", "split.", "*", "intros H v; vec nil v; simpl; auto.", "*", "intros H; apply (H \u00f8).", "+", "rewrite fol_mquant_S, IHn; split.", "*", "intros H v; vec split v with x; apply (H v).", "*", "intros H v; intros x; apply (H (x##v)).", "Qed.", "Fact fol_sem_mexists n A \u03c6 : \u27eafol_mquant fol_ex n A\u27eb \u03c6 <-> exists v : vec X n, \u27eaA\u27eb (env_vlift \u03c6 v).", "Proof.", "revert A \u03c6; induction n as [ | n IHn ]; intros A phi.", "+", "split.", "*", "intros H; exists \u00f8; auto.", "*", "intros (v & Hv); revert Hv; vec nil v; auto.", "+", "rewrite fol_mquant_S, IHn; split.", "*", "intros (v & x & Hv).", "exists (x##v); auto.", "*", "intros (v & Hv); revert Hv; vec split v with x.", "exists v, x; auto.", "Qed.", "End fol_semantics.", "Definition fot_vec_env \u03a3 n p : { w : vec (fo_term (ar_syms \u03a3)) n | (forall X (M : fo_model \u03a3 X) v \u03c6 q x, fo_term_sem M x\u00b7(env_vlift \u03c6 v) (vec_pos w q) = vec_pos (vec_change v p x) q) /\\ forall q, fo_term_syms (vec_pos w q) = nil }.", "Proof.", "exists (vec_change (vec_set_pos (fun q => \u00a3(S (pos2nat q)))) p (\u00a30)); split.", "*", "intros X M v phi q x;rew fot; rew vec; rew fot.", "destruct (pos_eq_dec p q) as [ H | H ].", "+", "rewrite !vec_change_eq; auto.", "+", "rewrite !vec_change_neq; auto; rew vec; rew fot; simpl.", "rewrite env_vlift_fix0; auto.", "*", "intros q; destruct (pos_eq_dec p q) as [ H | H ].", "+", "rewrite !vec_change_eq; auto.", "+", "rewrite !vec_change_neq; auto; rew vec.", "Qed.", "Section fo_model_simulation.", "Variables (\u03a3 : fo_signature) (ls : list (syms \u03a3)) (lr : list (rels \u03a3)) (X : Type) (M : fo_model \u03a3 X) (Y : Type) (N : fo_model \u03a3 Y).", "Record fo_simulation := Mk_fo_simulation { fos_simul :> X -> Y -> Prop; fos_syms : forall s v w, In s ls -> (forall p, fos_simul (vec_pos v p) (vec_pos w p)) -> fos_simul (fom_syms M s v) (fom_syms N s w); fos_rels : forall s v w, In s lr -> (forall p, fos_simul (vec_pos v p) (vec_pos w p)) -> fom_rels M s v <-> fom_rels N s w; fos_total : forall x, exists y, fos_simul x y; fos_surj : forall y, exists x, fos_simul x y; }.", "Record fo_projection := Mk_fo_projection { fop_surj :> X -> Y; fop_inj : Y -> X; fop_eq : forall x, fop_surj (fop_inj x) = x; fop_syms : forall s v, In s ls -> fop_surj (fom_syms M s v) = fom_syms N s (vec_map fop_surj v); fop_rels : forall s v, In s lr -> fom_rels M s v <-> fom_rels N s (vec_map fop_surj v); }.", "Fact fo_proj_simul : fo_projection -> fo_simulation.", "Proof.", "intros [ i j E Hs Hr ].", "exists (fun x y => i x = y); auto.", "+", "intros s v w H1 H2; rewrite Hs; auto.", "f_equal; apply vec_pos_ext; intro; rew vec.", "+", "intros s v w H1 H2; rewrite Hr; auto.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intro; rew vec.", "+", "intros x; exists (i x); auto.", "+", "intros y; exists (j y); auto.", "Defined.", "Variable R : fo_simulation.", "Infix \"\u22c8\" := R (at level 70, no associativity).", "Notation \"\u27e6 t \u27e7\" := (fun \u03c6 => fo_term_sem M \u03c6 t).", "Notation \"\u27e6 t \u27e7'\" := (fun \u03c6 => fo_term_sem N \u03c6 t) (at level 1, format \"\u27e6 t \u27e7'\").", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem M \u03c6 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c6 => fol_sem N \u03c6 A) (at level 1, format \"\u27ea A \u27eb'\").", "Let fo_term_simulation t \u03c6 \u03c8 : (forall n : nat, In n (fo_term_vars t) -> \u03c6 n \u22c8 \u03c8 n) -> incl (fo_term_syms t) ls -> \u27e6t\u27e7 \u03c6 \u22c8 \u27e6t\u27e7' \u03c8.", "Proof.", "revert \u03c6 \u03c8.", "induction t as [ k | s v IH ]; intros phi psi Hv Hls; rew fot; auto.", "+", "apply Hv; simpl; auto.", "+", "apply fos_syms.", "*", "apply Hls; simpl; auto.", "*", "intros p; do 2 rewrite vec_pos_map.", "apply IH; auto.", "-", "intros n Hn; apply Hv; rew fot.", "apply in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "-", "apply incl_tran with (2 := Hls).", "intros s' Hs'; rew fot.", "right; apply in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "Qed.", "Theorem fo_model_simulation A \u03c6 \u03c8 : incl (fol_syms A) ls -> incl (fol_rels A) lr -> (forall n : nat, In n (fol_vars A) -> \u03c6 n \u22c8 \u03c8 n) -> \u27eaA\u27eb \u03c6 <-> \u27eaA\u27eb' \u03c8.", "Proof.", "revert \u03c6 \u03c8.", "induction A as [ | r v | b A HA B HB | q A HA ]; intros phi psi Hs1 Hr1 Hp; simpl; try tauto.", "+", "apply (fos_rels R).", "*", "apply Hr1; simpl; auto.", "*", "intros p; do 2 rewrite vec_pos_map.", "apply fo_term_simulation.", "-", "intros n Hn; apply Hp; simpl.", "apply in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "-", "apply incl_tran with (2 := Hs1).", "intros s' Hs'; simpl.", "apply in_flat_map.", "exists (vec_pos v p); split; auto.", "apply in_vec_list, in_vec_pos.", "+", "apply fol_bin_sem_ext; [ apply HA | apply HB ].", "3,6: intros; apply Hp; simpl; apply in_or_app; auto.", "1,3: apply incl_tran with (2 := Hs1); intros ? ?; apply in_or_app; auto.", "1,2: apply incl_tran with (2 := Hr1); intros ? ?; apply in_or_app; auto.", "+", "destruct q; simpl; split.", "1: intros (x & Hx); destruct (fos_total R x) as (y & Hy); exists y; revert Hx; apply HA; eauto.", "2: intros (y & Hy); destruct (fos_surj R y) as (x & Hx); exists x; revert Hy; apply HA; eauto.", "3: intros H y; destruct (fos_surj R y) as (x & Hx); generalize (H x); apply HA; eauto.", "4: intros H x; destruct (fos_total R x) as (y & Hy); generalize (H y); apply HA; eauto.", "all: intros []; simpl; auto; intros; apply Hp, in_flat_map; exists (S n); simpl; auto.", "Qed.", "End fo_model_simulation.", "Theorem fo_model_projection \u03a3 ls lr X M Y N (p : @fo_projection \u03a3 ls lr X M Y N) A \u03c6 \u03c8 : (forall n, In n (fol_vars A) -> p (\u03c6 n) = \u03c8 n) -> incl (fol_syms A) ls -> incl (fol_rels A) lr -> fol_sem M \u03c6 A <-> fol_sem N \u03c8 A.", "Proof.", "intros H1 H2 H3.", "apply fo_model_simulation with (R := fo_proj_simul p); auto.", "destruct p; simpl; auto.", "Qed.", "Section fo_model_projection.", "Variable (\u03a3 : fo_signature) (ls : list (syms \u03a3)) (lr : list (rels \u03a3)) (X : Type) (M : fo_model \u03a3 X) (\u03c6 : nat -> X) (Y : Type) (N : fo_model \u03a3 Y) (\u03c8 : nat -> Y) (i : X -> Y) (j : Y -> X) (E : forall x, i (j x) = x) (Hs : forall s v, In s ls -> i (fom_syms M s v) = fom_syms N s (vec_map i v)) (Hr : forall s v, In s lr -> fom_rels M s v <-> fom_rels N s (vec_map i v)).", "Let p : fo_projection ls lr M N.", "Proof.", "exists i j; auto.", "Defined.", "Theorem fo_model_projection' A : (forall n, In n (fol_vars A) -> i (\u03c6 n) = \u03c8 n) -> incl (fol_syms A) ls -> incl (fol_rels A) lr -> fol_sem M \u03c6 A <-> fol_sem N \u03c8 A.", "Proof.", "apply fo_model_projection with (p := p).", "Qed.", "End fo_model_projection.", "Section fo_model_nosyms.", "Variable (\u03a3 : fo_signature) (X : Type) (M M' : fo_model \u03a3 X) (\u03c6 : nat -> X) (A : fol_form \u03a3) (HA : fol_syms A = nil) (H : forall r v, In r (fol_rels A) -> fom_rels M r v <-> fom_rels M' r v).", "Theorem fo_model_nosyms : fol_sem M \u03c6 A <-> fol_sem M' \u03c6 A.", "Proof.", "apply fo_model_projection' with (ls := nil) (lr := fol_rels A) (i := fun x => x) (j := fun x => x); auto.", "+", "intros; rewrite H; auto.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intro; rew vec.", "+", "rewrite HA; apply incl_refl.", "Qed.", "End fo_model_nosyms."], "theorems": [{"name": "\u03a3rel_var", "kind": "Definition", "begin": 7, "end": 10}, {"name": "fol_vars_bin", "kind": "Fact", "begin": 27, "end": 30}, {"name": "fol_vars_quant", "kind": "Fact", "begin": 31, "end": 34}, {"name": "fol_vars_max_spec", "kind": "Fact", "begin": 36, "end": 39}, {"name": "fol_syms_bin", "kind": "Fact", "begin": 41, "end": 44}, {"name": "fol_syms_quant", "kind": "Fact", "begin": 45, "end": 48}, {"name": "fol_rels_bin", "kind": "Fact", "begin": 50, "end": 53}, {"name": "fol_rels_quant", "kind": "Fact", "begin": 54, "end": 57}, {"name": "fol_subst_ext", "kind": "Fact", "begin": 59, "end": 76}, {"name": "fol_vars_subst", "kind": "Fact", "begin": 77, "end": 100}, {"name": "fol_vars_map", "kind": "Fact", "begin": 101, "end": 104}, {"name": "fol_syms_subst", "kind": "Fact", "begin": 105, "end": 139}, {"name": "fol_rels_subst", "kind": "Fact", "begin": 140, "end": 145}, {"name": "fol_vars_bigop", "kind": "Fact", "begin": 147, "end": 151}, {"name": "fol_syms_bigop", "kind": "Fact", "begin": 152, "end": 156}, {"name": "fol_rels_bigop", "kind": "Fact", "begin": 157, "end": 161}, {"name": "fol_subst_bigop", "kind": "Fact", "begin": 162, "end": 165}, {"name": "fol_mquant_plus", "kind": "Fact", "begin": 167, "end": 170}, {"name": "fol_mquant_S", "kind": "Fact", "begin": 171, "end": 175}, {"name": "fol_vars_mquant", "kind": "Fact", "begin": 176, "end": 190}, {"name": "fol_syms_mquant", "kind": "Fact", "begin": 191, "end": 194}, {"name": "fol_rels_mquant", "kind": "Fact", "begin": 195, "end": 198}, {"name": "fol_subst_subst", "kind": "Fact", "begin": 199, "end": 217}, {"name": "fol_sem_bin_fix", "kind": "Fact", "begin": 229, "end": 232}, {"name": "fol_sem_quant_fix", "kind": "Fact", "begin": 233, "end": 236}, {"name": "fol_sem_ext", "kind": "Fact", "begin": 237, "end": 258}, {"name": "fol_sem_dec", "kind": "Theorem", "begin": 262, "end": 274}, {"name": "fol_sem_subst", "kind": "Theorem", "begin": 276, "end": 292}, {"name": "fol_sem_lift", "kind": "Corollary", "begin": 294, "end": 298}, {"name": "fol_sem_lconj", "kind": "Fact", "begin": 299, "end": 311}, {"name": "fol_sem_lconj_app", "kind": "Fact", "begin": 312, "end": 319}, {"name": "fol_sem_ldisj", "kind": "Fact", "begin": 320, "end": 337}, {"name": "fol_sem_ldisj_app", "kind": "Fact", "begin": 338, "end": 345}, {"name": "fol_vars_vec_fa", "kind": "Fact", "begin": 347, "end": 351}, {"name": "fol_syms_vec_fa", "kind": "Fact", "begin": 352, "end": 356}, {"name": "fol_rels_vec_fa", "kind": "Fact", "begin": 357, "end": 361}, {"name": "fol_sem_vec_fa", "kind": "Fact", "begin": 362, "end": 371}, {"name": "env_vlift_fix0", "kind": "Fact", "begin": 373, "end": 384}, {"name": "env_vlift_fix1", "kind": "Fact", "begin": 385, "end": 389}, {"name": "fol_sem_mforall", "kind": "Fact", "begin": 390, "end": 405}, {"name": "fol_sem_mexists", "kind": "Fact", "begin": 406, "end": 423}, {"name": "fot_vec_env", "kind": "Definition", "begin": 425, "end": 442}, {"name": "fo_proj_simul", "kind": "Fact", "begin": 447, "end": 462}, {"name": "fo_term_simulation", "kind": "Let", "begin": 469, "end": 493}, {"name": "fo_model_simulation", "kind": "Theorem", "begin": 494, "end": 528}, {"name": "fo_model_projection", "kind": "Theorem", "begin": 530, "end": 535}, {"name": "p", "kind": "Let", "begin": 538, "end": 541}, {"name": "fo_model_projection'", "kind": "Theorem", "begin": 542, "end": 545}, {"name": "fo_model_nosyms", "kind": "Theorem", "begin": 549, "end": 558}]}