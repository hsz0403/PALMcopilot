{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_sat Sig_no_syms.", "Set Implicit Arguments.", "Fixpoint find_non_empty_word X (l : list (list X)) : { s & { w | In (s::w) l } } + { concat l = nil }.", "Proof.", "destruct l as [ | [ | s w ] l ].", "+", "right; auto.", "+", "destruct (find_non_empty_word X l) as [ (s & w & H) | H ].", "*", "left; exists s, w; right; auto.", "*", "right; simpl; auto.", "+", "left; exists s, w; left; auto.", "Qed.", "Local Notation \u00f8 := vec_nil.", "Section fot_word_var.", "Variable (X : Type).", "Implicit Type t : fo_term (fun _ : X => 1).", "Fixpoint fot_var t := match t with | in_var i => i | in_fot s v => fot_var (vec_pos v pos0) end.", "Fixpoint fot_word t := match t with | in_var i => nil | in_fot s v => s::fot_word (vec_pos v pos0) end.", "Fixpoint fot_word_var w i : fo_term (fun _ : X => 1) := match w with | nil => in_var i | s::w => in_fot s (fot_word_var w i##\u00f8) end.", "Fact fot_word_var_eq t : t = fot_word_var (fot_word t) (fot_var t).", "Proof.", "induction t as [ | s v IH ]; simpl in *; auto; f_equal.", "generalize (IH pos0); clear IH; vec split v with t; vec nil v; clear v; simpl.", "intro; f_equal; auto.", "Qed.", "Fact fot_word_eq w i : fot_word (fot_word_var w i) = w.", "Proof.", "induction w; simpl; f_equal; auto.", "Qed.", "Fact fot_var_eq w i : fot_var (fot_word_var w i) = i.", "Proof.", "induction w; simpl; f_equal; auto.", "Qed.", "End fot_word_var.", "Section \u03a311_words.", "Variable (X Y : Type).", "Definition \u03a311 : fo_signature.", "Proof.", "exists X Y; intros _.", "+", "exact 1.", "+", "exact 1.", "Defined.", "Fixpoint \u03a311_words (A : fol_form \u03a311) : list (list X) := match A with | \u22a5 => nil | fol_atom r v => (fot_word (vec_pos v pos0))::nil | fol_bin _ A B => \u03a311_words A++\u03a311_words B | fol_quant _ A => \u03a311_words A end.", "End \u03a311_words.", "Section \u03a3full_mon_rem.", "Variable (Y : Type) (HY : finite_t Y) (n m : nat).", "Notation X := (pos n).", "Let Yw := { w : list X | length w < S m }.", "Let YwY_fin : finite_t (Yw*Y).", "Proof.", "apply finite_t_prod; auto.", "apply finite_t_list, finite_t_pos.", "Qed.", "Let lwY := proj1_sig YwY_fin.", "Let HlwY p : In p lwY.", "Proof.", "apply (proj2_sig YwY_fin).", "Qed.", "Notation \u03a3 := (\u03a311 X Y).", "Notation \u03a3' := (\u03a311 X (list X*Y + Y)).", "Fixpoint \u03a3full_mon_rec (A : fol_form \u03a3) : fol_form \u03a3' := match A with | \u22a5 => \u22a5 | fol_atom r v => let w := fot_word (vec_head v) in let i := fot_var (vec_head v) in @fol_atom \u03a3' (inl (rev w,r)) (\u00a3i##\u00f8) | fol_bin b A B => fol_bin b (\u03a3full_mon_rec A) (\u03a3full_mon_rec B) | fol_quant q A => fol_quant q (\u03a3full_mon_rec A) end.", "Fact \u03a3full_mon_rec_syms A : fol_syms (\u03a3full_mon_rec A) = nil.", "Proof.", "induction A as [ | r v | b A HA B HB | q A HA ].", "1,2,4: simpl; tauto.", "simpl; rewrite HA, HB; auto.", "Qed.", "Variable (A : fol_form \u03a3) (HwA : forall w, In w (\u03a311_words A) -> length w < S m).", "Let Eq (p : Yw * Y) := let (w,r) := p in let (w,_) := w in match w with | nil => @fol_atom \u03a3' (inl (nil,r)) (\u00a30##\u00f8) \u2194 @fol_atom \u03a3' (inr r) (\u00a30##\u00f8) | s::w' => @fol_atom \u03a3' (inl (w',r)) (@in_fot _ (ar_syms \u03a3') s (\u00a30##\u00f8)##\u00f8) \u2194 @fol_atom \u03a3' (inl (w,r)) (\u00a30##\u00f8) end.", "Let Eq' (p : Yw * Y) := let (w,r) := p in let (w,_) := w in match w with | nil => @fol_atom \u03a3' (inl (nil,r)) (\u00a3n##\u00f8) \u2194 @fol_atom \u03a3' (inr r) (\u00a3n##\u00f8) | s::w' => @fol_atom \u03a3' (inl (w',r)) (\u00a3(pos2nat s)##\u00f8) \u2194 @fol_atom \u03a3' (inl (w,r)) (\u00a3n##\u00f8) end.", "Definition \u03a3full_mon_red : fol_form \u03a3' := \u03a3full_mon_rec A \u27d1 \u2200 fol_lconj (map Eq lwY).", "Variable (K : Type).", "Let Fixpoint f (M : fo_model \u03a3 K) w x := match w with | nil => x | s::w => f M w (fom_syms M s (x##\u00f8)) end.", "Let f_app M w1 w2 x : f M (w1++w2) x = f M w2 (f M w1 x).", "Proof.", "revert x; induction w1; simpl; auto.", "Qed.", "Let f_snoc M w s x : f M (w++s::nil) x = fom_syms M s (f M w x##\u00f8).", "Proof.", "rewrite f_app; auto.", "Qed.", "Section soundness.", "Variable (M : fo_model \u03a3 K).", "Let M' : fo_model \u03a3' K.", "Proof.", "split.", "+", "exact (fom_syms M).", "+", "intros [ (w,r) | r ]; simpl in r |- *.", "*", "exact (fun v => fom_rels M r (f M w (vec_head v)##\u00f8)).", "*", "exact (fom_rels M r).", "Defined.", "Fact \u03a3full_mon_rec_sound \u03c6 : fol_sem M' \u03c6 (\u03a3full_mon_rec A) <-> fol_sem M \u03c6 A.", "Proof.", "revert \u03c6 HwA; induction A as [ | r v | b B HB C HC | q B HB ]; intros \u03c6 HA.", "+", "simpl; tauto.", "+", "simpl in v; unfold \u03a3full_mon_rec.", "revert HA; vec split v with t; vec nil v; clear v; simpl vec_head; simpl syms; intros HA.", "specialize (HA _ (or_introl eq_refl)); simpl in HA |- *.", "replace (fo_term_sem M \u03c6 t) with (fo_term_sem M \u03c6 (fot_word_var (fot_word t) (fot_var t))).", "*", "simpl; apply fol_equiv_ext; do 2 f_equal.", "generalize (fot_word t) (fot_var t); clear t HA; intros w.", "induction w as [ | s w IHw ]; simpl; auto; intros i.", "rewrite f_snoc; simpl; do 2 f_equal; auto.", "*", "f_equal; symmetry; apply fot_word_var_eq.", "+", "simpl; apply fol_bin_sem_ext.", "*", "apply HB; intros ? ?; apply HA, in_app_iff; auto.", "*", "apply HC; intros ? ?; apply HA, in_app_iff; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; apply HB; auto.", "Qed.", "Variable (Kfin : finite_t K) (Mdec : fo_model_dec M) (\u03c6 : nat -> K) (HA : fol_sem M \u03c6 A).", "Theorem \u03a3full_mon_rem_sound : fo_form_fin_dec_SAT_in \u03a3full_mon_red K.", "Proof.", "exists M', Kfin.", "exists.", "{", "intros [ (w,r) | r ]; simpl in r |- *; intro; apply Mdec.", "}", "exists \u03c6; simpl; split.", "+", "apply \u03a3full_mon_rec_sound; auto.", "+", "intro x; rewrite fol_sem_lconj.", "intros ?; rewrite in_map_iff.", "intros ((([|s w]&Hw),r) & <- & Hr); unfold Eq.", "*", "simpl; auto.", "*", "simpl; auto.", "Qed.", "End soundness.", "Section completeness.", "Variable (M' : fo_model \u03a3' K).", "Let M : fo_model \u03a3 K.", "Proof.", "split.", "+", "exact (fom_syms M').", "+", "exact (fun r => fom_rels M' (inr r)).", "Defined.", "Section \u03a3full_mon_rec_complete.", "Hypothesis HM1' : forall s w r x, length (s::w) < S m -> fom_rels M' (inl (s::w, r)) (x##\u00f8) <-> fom_rels M' (inl (w, r)) (fom_syms M s (x##\u00f8)##\u00f8).", "Hypothesis HM2' : forall r x, fom_rels M' (inr r) (x##\u00f8) <-> fom_rels M' (inl (nil,r)) (x##\u00f8).", "Let Hf \u03c6 w i : f M (rev w) (\u03c6 i) = fo_term_sem M \u03c6 (fot_word_var w i).", "Proof.", "induction w; simpl; auto.", "rewrite f_snoc; simpl in *; rewrite IHw; auto.", "Qed.", "Fact \u03a3full_mon_rec_complete \u03c6 : fol_sem M' \u03c6 (\u03a3full_mon_rec A) <-> fol_sem M \u03c6 A.", "Proof.", "revert \u03c6 HwA; induction A as [ | r v | b B HB C HC | q B HB ]; intros \u03c6 HwA.", "+", "simpl; tauto.", "+", "simpl in v; unfold \u03a3full_mon_rec.", "revert HwA; vec split v with t; vec nil v; clear v; simpl vec_head; simpl syms; intros HwA.", "specialize (HwA _ (or_introl eq_refl)); simpl in HwA |- *.", "replace (fo_term_sem M \u03c6 t) with (fo_term_sem M \u03c6 (fot_word_var (fot_word t) (fot_var t))).", "*", "revert HwA; generalize (fot_word t) (fot_var t); intros w i.", "rewrite <- (rev_length w), <- Hf.", "simpl; generalize (rev w) (\u03c6 i); clear w; intros w.", "induction w as [ | s w IHw ]; simpl; auto; intros Hw x.", "-", "rewrite HM2'; tauto.", "-", "rewrite HM1', IHw; simpl; try tauto; lia.", "*", "f_equal; symmetry; apply fot_word_var_eq.", "+", "apply fol_bin_sem_ext.", "*", "apply HB; intros ? ?; apply HwA, in_app_iff; auto.", "*", "apply HC; intros ? ?; apply HwA, in_app_iff; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; apply HB; auto.", "Qed.", "End \u03a3full_mon_rec_complete.", "Variable (Kfin : finite_t K) (M'dec : fo_model_dec M') (\u03c6 : nat -> K) (HA : fol_sem M' \u03c6 \u03a3full_mon_red).", "Theorem \u03a3full_mon_rem_complete : fo_form_fin_dec_SAT_in A K.", "Proof.", "exists M, Kfin.", "exists.", "{", "intros r'; simpl in r'; intros v; apply M'dec.", "}", "exists \u03c6; simpl.", "destruct HA as [ H1 H2 ].", "revert H1; apply \u03a3full_mon_rec_complete.", "+", "intros s w r x Hw.", "simpl in H2; specialize (H2 x).", "rewrite fol_sem_lconj in H2.", "symmetry; apply (H2 (Eq (exist _ (s::w) Hw,r))), in_map_iff.", "exists (exist _ (s::w) Hw,r); split; auto.", "+", "intros r x.", "simpl in H2; specialize (H2 x).", "rewrite fol_sem_lconj in H2.", "symmetry; apply (H2 (Eq (exist _ nil (lt_0_Sn _),r))), in_map_iff.", "exists (exist _ nil (lt_0_Sn _),r); split; auto.", "Qed.", "End completeness.", "Theorem \u03a3full_mon_red_correct : fo_form_fin_dec_SAT_in A K <-> fo_form_fin_dec_SAT_in \u03a3full_mon_red K.", "Proof.", "split.", "+", "intros (M & H1 & H2 & phi & H3).", "apply \u03a3full_mon_rem_sound with M phi; auto.", "+", "intros (M' & H1 & H2 & phi & H3).", "apply \u03a3full_mon_rem_complete with M' phi; auto.", "Qed.", "Definition \u03a3full_mon_red' : fol_form \u03a3' := \u03a3full_mon_rec A \u27d1 \u2200 fol_mquant fol_ex n (fol_lconj (map Eq' lwY)).", "Local Lemma \u03a3full_mon_red'_sound : fo_form_fin_dec_SAT_in \u03a3full_mon_red K -> fo_form_fin_dec_SAT_in \u03a3full_mon_red' K.", "Proof.", "intros (M & Kfin & Mdec & \u03c6 & H1 & H2); simpl in H1, H2.", "exists M, Kfin, Mdec, \u03c6; simpl; split; auto.", "intros x; specialize (H2 x).", "rewrite fol_sem_mexists.", "exists (vec_set_pos (fun p => fom_syms M p (x##\u00f8))).", "rewrite fol_sem_lconj; intros g; rewrite in_map_iff.", "intros (c & <- & Hg).", "rewrite fol_sem_lconj in H2.", "specialize (H2 (Eq c) (in_map _ _ _ Hg)).", "clear Hg; revert H2.", "destruct c as (([ | s w ],?),r); simpl.", "+", "rewrite env_vlift_fix1 with (k := 0); simpl; auto.", "+", "rewrite env_vlift_fix1 with (k := 0).", "rewrite env_vlift_fix0; simpl; rew vec.", "Qed.", "Section \u03a3full_mon_red'_complete.", "Variable (M : fo_model \u03a3' K) (Kfin : finite_t K) (Mdec : fo_model_dec M) (\u03c6 : nat -> K) (HA : fol_sem M \u03c6 \u03a3full_mon_red').", "Let R x (v : vec _ n) := fol_sem M (env_vlift x\u00b7\u03c6 v) (fol_lconj (map Eq' lwY)).", "Let Rreif : { f : K -> vec K n | forall x, R x (f x) }.", "Proof.", "apply finite_t_dec_choice.", "+", "apply finite_t_vec; auto.", "+", "intros x v; apply fol_sem_dec; auto.", "+", "simpl in HA; apply proj2 in HA.", "intros x; generalize (HA x).", "rewrite fol_sem_mexists; auto.", "Qed.", "Let g := proj1_sig Rreif.", "Let Hg x : fol_sem M (env_vlift x\u00b7\u03c6 (g x)) (fol_lconj (map Eq' lwY)).", "Proof.", "apply (proj2_sig Rreif).", "Qed.", "Let M' : fo_model \u03a3' K.", "Proof.", "split.", "+", "simpl; intros p v.", "exact (vec_pos (g (vec_head v)) p).", "+", "exact (fom_rels M).", "Defined.", "Local Lemma \u03a3full_mon_red'_complete : fo_form_fin_dec_SAT_in \u03a3full_mon_red K.", "Proof.", "exists M', Kfin, Mdec, \u03c6.", "simpl; split.", "+", "simpl in HA; generalize (proj1 HA).", "apply fo_model_nosyms.", "*", "apply \u03a3full_mon_rec_syms.", "*", "intros; simpl; tauto.", "+", "intros x.", "specialize (Hg x).", "rewrite fol_sem_lconj in Hg.", "rewrite fol_sem_lconj.", "intros u; rewrite in_map_iff.", "intros (c & <- & Hc).", "specialize (Hg (Eq' c) (in_map _ _ _ Hc)).", "revert Hg.", "destruct c as (([|s w]&?),r); simpl.", "*", "rewrite env_vlift_fix1 with (k := 0); simpl; auto.", "*", "rewrite env_vlift_fix1 with (k := 0).", "rewrite env_vlift_fix0; simpl; rew vec.", "Qed.", "End \u03a3full_mon_red'_complete.", "Theorem \u03a3full_mon_red'_correct : fo_form_fin_dec_SAT_in A K <-> fo_form_fin_dec_SAT_in \u03a3full_mon_red' K.", "Proof.", "rewrite \u03a3full_mon_red_correct.", "split.", "+", "apply \u03a3full_mon_red'_sound.", "+", "intros (M & H1 & H2 & phi & H3).", "apply \u03a3full_mon_red'_complete with M phi; auto.", "Qed.", "Theorem \u03a3full_mon_red'_no_syms : fol_syms \u03a3full_mon_red' = nil.", "Proof.", "cut (incl (fol_syms \u03a3full_mon_red') nil).", "+", "generalize (fol_syms \u03a3full_mon_red').", "intros [ | x l ] H; auto.", "destruct (H x); simpl; auto.", "+", "simpl.", "rewrite \u03a3full_mon_rec_syms, fol_syms_mquant.", "rewrite fol_syms_bigop, <- app_nil_end; simpl.", "intros x; rewrite in_flat_map.", "intros (u & H & Hu); revert H.", "rewrite in_map_iff.", "intros (c & <- & Hc).", "revert Hu.", "destruct c as (([|s w]&?),r); simpl; auto.", "Qed.", "End \u03a3full_mon_rem.", "Section \u03a311_reduction.", "Variable (n : nat) (Y : Type) (HY : finite_t Y) (A : fol_form (\u03a311 (pos n) Y)) (K : Type).", "Let m := lmax (map (@length _) (\u03a311_words A)).", "Let Hm w : In w (\u03a311_words A) -> length w < S m.", "Proof.", "intros Hw; apply le_n_S, lmax_prop, in_map_iff.", "exists w; auto.", "Qed.", "Definition \u03a311_red := \u03a3full_mon_red' HY m A.", "Theorem \u03a311_red_correct : fo_form_fin_dec_SAT_in A K <-> fo_form_fin_dec_SAT_in \u03a311_red K.", "Proof.", "apply \u03a3full_mon_red'_correct; auto.", "Qed.", "Theorem \u03a311_red_no_syms : fol_syms \u03a311_red = nil.", "Proof.", "apply \u03a3full_mon_red'_no_syms.", "Qed.", "End \u03a311_reduction.", "Section \u03a311_\u03a31.", "Variable (n : nat) (Y : Type) (HY : finite_t Y) (A : fol_form (\u03a311 (pos n) Y)).", "Theorem \u03a311_\u03a31_reduction : { B : fol_form (\u03a311 Empty_set (list (pos n)*Y + Y)) | fo_form_fin_dec_SAT A <-> fo_form_fin_dec_SAT B }.", "Proof.", "destruct \u03a3_no_sym_correct with (A := \u03a311_red HY A) as (B & HB).", "{", "rewrite \u03a311_red_no_syms; apply incl_refl.", "}", "exists B; rewrite <- HB; split; intros (X & H); exists X; revert H; apply \u03a311_red_correct.", "Qed.", "End \u03a311_\u03a31."], "theorems": [{"name": "find_non_empty_word", "kind": "Fixpoint", "begin": 5, "end": 18}, {"name": "fot_word_var_eq", "kind": "Fact", "begin": 26, "end": 31}, {"name": "fot_word_eq", "kind": "Fact", "begin": 32, "end": 35}, {"name": "fot_var_eq", "kind": "Fact", "begin": 36, "end": 39}, {"name": "\u03a311", "kind": "Definition", "begin": 43, "end": 50}, {"name": "YwY_fin", "kind": "Let", "begin": 57, "end": 61}, {"name": "HlwY", "kind": "Let", "begin": 63, "end": 66}, {"name": "\u03a3full_mon_rec_syms", "kind": "Fact", "begin": 70, "end": 75}, {"name": "f_app", "kind": "Let", "begin": 82, "end": 85}, {"name": "f_snoc", "kind": "Let", "begin": 86, "end": 89}, {"name": "M'", "kind": "Let", "begin": 92, "end": 103}, {"name": "\u03a3full_mon_rec_sound", "kind": "Fact", "begin": 104, "end": 129}, {"name": "\u03a3full_mon_rem_sound", "kind": "Theorem", "begin": 131, "end": 149}, {"name": "M", "kind": "Let", "begin": 153, "end": 160}, {"name": "Hf", "kind": "Let", "begin": 164, "end": 168}, {"name": "\u03a3full_mon_rec_complete", "kind": "Fact", "begin": 169, "end": 198}, {"name": "\u03a3full_mon_rem_complete", "kind": "Theorem", "begin": 201, "end": 223}, {"name": "\u03a3full_mon_red_correct", "kind": "Theorem", "begin": 225, "end": 234}, {"name": "Rreif", "kind": "Let", "begin": 258, "end": 269}, {"name": "Hg", "kind": "Let", "begin": 271, "end": 274}, {"name": "M'", "kind": "Let", "begin": 275, "end": 283}, {"name": "\u03a3full_mon_red'_correct", "kind": "Theorem", "begin": 312, "end": 321}, {"name": "\u03a3full_mon_red'_no_syms", "kind": "Theorem", "begin": 322, "end": 339}, {"name": "Hm", "kind": "Let", "begin": 344, "end": 348}, {"name": "\u03a311_red_correct", "kind": "Theorem", "begin": 350, "end": 353}, {"name": "\u03a311_red_no_syms", "kind": "Theorem", "begin": 354, "end": 357}, {"name": "\u03a311_\u03a31_reduction", "kind": "Theorem", "begin": 361, "end": 368}]}