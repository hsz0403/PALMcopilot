{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Local Notation \u00f8 := vec_nil.", "Section remove_constants.", "Variable (\u03a3 : fo_signature) (H\u03a3 : forall s, ar_syms \u03a3 s <= 1).", "Definition \u03a3no_constants : fo_signature.", "Proof.", "exists (syms \u03a3) (rels \u03a3).", "+", "exact (fun _ => 1).", "+", "apply ar_rels.", "Defined.", "Notation \u03a3' := \u03a3no_constants.", "Implicit Type (t : fo_term (ar_syms \u03a3)) (A : fol_form \u03a3).", "Let choice : forall a, { a = 0 } + { a = 1 } + { 1 < a }.", "Proof.", "intros [ | [ | a ] ]; auto; right; lia.", "Qed.", "Let Fixpoint fot_rem_cst (n : nat) t { struct t } : fo_term (ar_syms \u03a3').", "Proof.", "refine (match t with | in_var i => in_var i | in_fot s v => match choice (ar_syms _ s) with | inleft (left _) => @in_fot _ (ar_syms \u03a3') s (\u00a3n##\u00f8) | inleft (right E) => @in_fot _ (ar_syms \u03a3') s (fot_rem_cst n (vec_pos (cast v E) pos0)##\u00f8) | inright H => _ end end).", "exfalso; abstract (generalize (H\u03a3 s); lia).", "Defined.", "Fixpoint \u03a3rem_constants (n : nat) A { struct A } := match A with | \u22a5 => \u22a5 | fol_atom r v => @fol_atom \u03a3' r (vec_map (fot_rem_cst n) v) | fol_bin b A B => fol_bin b (\u03a3rem_constants n A) (\u03a3rem_constants n B) | fol_quant q A => fol_quant q (\u03a3rem_constants (S n) A) end.", "Variable (X : Type).", "Section soundness.", "Variable (M : fo_model \u03a3 X).", "Let M' : fo_model \u03a3' X.", "Proof.", "split.", "+", "intros s; simpl in *.", "destruct (choice (ar_syms _ s)) as [ [ H | H ] | H ].", "*", "exact (fun _ => fom_syms M s (cast \u00f8 (eq_sym H))).", "*", "exact (fun v => fom_syms M s (cast v (eq_sym H))).", "*", "abstract (intros; exfalso; generalize (H\u03a3 s); lia).", "+", "apply (fom_rels M).", "Defined.", "Let fot_rem_cst_sound n t \u03c6 : fo_term_sem M \u03c6 t = fo_term_sem M' \u03c6 (fot_rem_cst n t).", "Proof.", "induction t as [ i | s v IHv ].", "+", "simpl; auto.", "+", "simpl.", "case_eq (choice (ar_syms \u03a3 s)); [ intros [ E | E ] | intros E ]; intros HE; simpl; try rewrite HE; clear HE.", "*", "f_equal.", "clear n IHv; revert E v.", "intros -> v; vec nil v; auto.", "*", "f_equal; apply vec_pos_ext; intros p; rew vec.", "specialize (IHv p); rewrite IHv; clear IHv.", "revert E p v; intros -> p v.", "analyse pos p; rew vec.", "*", "exfalso; clear v IHv.", "generalize (H\u03a3 s); lia.", "Qed.", "Local Fact \u03a3rem_constants_sound n A \u03c6 : fol_sem M \u03c6 A <-> fol_sem M' \u03c6 (\u03a3rem_constants n A).", "Proof.", "revert n \u03c6; induction A as [ | r v | b A HA B HB | q A HA ]; intros n \u03c6.", "+", "simpl; tauto.", "+", "simpl.", "rewrite vec_map_map.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p; rew vec.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; auto.", "Qed.", "Hypothesis (Xfin : finite_t X) (Mdec : fo_model_dec M) (\u03c6 : nat -> X) (A : fol_form \u03a3) (HA : fol_sem M \u03c6 A).", "Local Lemma \u03a3rem_constants_soundness : fo_form_fin_dec_SAT_in (\u03a3rem_constants 0 A) X.", "Proof.", "exists M', Xfin, Mdec, \u03c6.", "apply \u03a3rem_constants_sound; auto.", "Qed.", "End soundness.", "Section completeness.", "Variable (M' : fo_model \u03a3' X) (\u03c6 : nat -> X).", "Let M : fo_model \u03a3 X.", "Proof.", "split.", "+", "simpl; intros s.", "destruct (choice (ar_syms _ s)) as [ [ H | H ] | H ].", "*", "exact (fun _ => fom_syms M' s (\u03c6 0##\u00f8)).", "*", "exact (fun v => fom_syms M' s (cast v H)).", "*", "abstract (intros; exfalso; generalize (H\u03a3 s); lia).", "+", "apply (fom_rels M').", "Defined.", "Let fot_rem_cst_complete n t \u03c8 : \u03c8 n = \u03c6 0 -> fo_term_sem M \u03c8 t = fo_term_sem M' \u03c8 (fot_rem_cst n t).", "Proof.", "intros H0; induction t as [ i | s v IHv ].", "+", "simpl; auto.", "+", "simpl.", "destruct (choice (ar_syms \u03a3 s)) as [ [ E | E ] | E ].", "*", "simpl; now do 2 f_equal.", "*", "simpl fo_term_sem; f_equal.", "revert E v IHv; intros -> v IHv.", "apply vec_pos_ext; intros p; rew vec.", "analyse pos p; simpl; rew vec.", "*", "exfalso; clear v IHv.", "generalize (H\u03a3 s); lia.", "Qed.", "Local Fact \u03a3rem_constants_complete n A \u03c8 : \u03c8 n = \u03c6 0 -> fol_sem M \u03c8 A <-> fol_sem M' \u03c8 (\u03a3rem_constants n A).", "Proof.", "revert n \u03c8; induction A as [ | r v | b A HA B HB | q A HA ]; intros n \u03c8 H.", "+", "simpl; tauto.", "+", "simpl; apply fol_equiv_ext; f_equal; rewrite vec_map_map.", "apply vec_pos_ext; intros p; rewrite !vec_pos_map; auto.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; apply HA; simpl; auto.", "Qed.", "Hypothesis (Xfin : finite_t X) (M'dec : fo_model_dec M') (A : fol_form \u03a3) (HA : fol_sem M' \u03c6 (\u03a3rem_constants 0 A)).", "Local Lemma \u03a3rem_constants_completeness : fo_form_fin_dec_SAT_in A X.", "Proof.", "exists M, Xfin, M'dec, \u03c6.", "revert HA; apply \u03a3rem_constants_complete; auto.", "Qed.", "End completeness.", "Theorem \u03a3rem_constants_correct A : fo_form_fin_dec_SAT_in A X <-> fo_form_fin_dec_SAT_in (\u03a3rem_constants 0 A) X.", "Proof.", "split.", "+", "intros (M & H1 & H2 & phi & H3).", "apply \u03a3rem_constants_soundness with M phi; auto.", "+", "intros (M & H1 & H2 & phi & H3).", "apply \u03a3rem_constants_completeness with M phi; auto.", "Qed.", "End remove_constants."], "theorems": [{"name": "\u03a3no_constants", "kind": "Definition", "begin": 8, "end": 15}, {"name": "choice", "kind": "Let", "begin": 18, "end": 21}, {"name": "Fixpoint", "kind": "Let", "begin": 22, "end": 26}, {"name": "M'", "kind": "Let", "begin": 31, "end": 45}, {"name": "fot_rem_cst_sound", "kind": "Let", "begin": 46, "end": 66}, {"name": "M", "kind": "Let", "begin": 91, "end": 105}, {"name": "fot_rem_cst_complete", "kind": "Let", "begin": 106, "end": 124}, {"name": "\u03a3rem_constants_correct", "kind": "Theorem", "begin": 145, "end": 154}]}