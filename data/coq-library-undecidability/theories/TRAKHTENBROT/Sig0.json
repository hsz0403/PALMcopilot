{"code": ["Require Import List Arith Lia Max.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils decidable fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Section \u03a3_\u03a30.", "Variable (\u03a3 : fo_signature) (H\u03a3 : forall r, ar_rels \u03a3 r = 0).", "Definition \u03a30 : fo_signature.", "Proof.", "exists Empty_set (rels \u03a3); exact (fun _ => 0).", "Defined.", "Fixpoint \u03a3_\u03a30 (A : fol_form \u03a3) := match A with | \u22a5 => \u22a5 | fol_atom r _ => @fol_atom \u03a30 r vec_nil | fol_bin b A B => fol_bin b (\u03a3_\u03a30 A) (\u03a3_\u03a30 B) | fol_quant q A => fol_quant q (\u03a3_\u03a30 A) end.", "Section soundness.", "Variable (X : Type) (M : fo_model \u03a3 X).", "Let M' : fo_model \u03a30 unit.", "Proof.", "split.", "+", "intros [].", "+", "intros r _; apply (fom_rels M r).", "rewrite H\u03a3; exact vec_nil.", "Defined.", "Local Fact \u03a3_\u03a30_sound A \u03c6 \u03c8 : fol_sem M \u03c6 A <-> fol_sem M' \u03c8 (\u03a3_\u03a30 A).", "Proof.", "revert \u03c6 \u03c8; induction A as [ | r v | b A HA B HB | [] A HA ]; intros \u03c6 \u03c8.", "+", "simpl; tauto.", "+", "simpl; apply fol_equiv_ext; f_equal.", "revert v; rewrite (H\u03a3 r); unfold eq_rect_r; simpl.", "intros v; vec nil v; auto.", "+", "apply fol_bin_sem_ext; auto.", "+", "simpl; split.", "*", "intros (x & Hx); exists tt; revert Hx; apply HA.", "*", "intros (x & Hx); exists (\u03c6 0); revert Hx; apply HA.", "+", "simpl; split.", "*", "intros H x; generalize (H (\u03c6 0)); apply HA.", "*", "intros H x; generalize (H tt); apply HA.", "Qed.", "Hypothesis (Mdec : fo_model_dec M) (phi : nat -> X) (A : fol_form \u03a3) (HA : fol_sem M phi A).", "Local Lemma \u03a3_\u03a30_soundness : fo_form_fin_dec_SAT_in (\u03a3_\u03a30 A) unit.", "Proof.", "exists M', finite_t_unit.", "exists.", "{", "intros r v; simpl; apply Mdec.", "}", "exists (fun _ => tt).", "revert HA; apply \u03a3_\u03a30_sound.", "Qed.", "End soundness.", "Section completeness.", "Variable (M' : fo_model \u03a30 unit).", "Let M : fo_model \u03a3 unit.", "Proof.", "split.", "+", "intros; exact tt.", "+", "intros r _; apply (fom_rels M' r vec_nil).", "Defined.", "Local Fact \u03a3_\u03a30_complete A \u03c6 \u03c8 : fol_sem M \u03c6 A <-> fol_sem M' \u03c8 (\u03a3_\u03a30 A).", "Proof.", "revert \u03c6 \u03c8; induction A as [ | r v | b A HA B HB | [] A HA ]; intros \u03c6 \u03c8.", "+", "simpl; tauto.", "+", "simpl; tauto.", "+", "apply fol_bin_sem_ext; auto.", "+", "simpl; split.", "*", "intros (x & Hx); exists tt; revert Hx; apply HA.", "*", "intros (x & Hx); exists (\u03c6 0); revert Hx; apply HA.", "+", "simpl; split.", "*", "intros H x; generalize (H (\u03c6 0)); apply HA.", "*", "intros H x; generalize (H tt); apply HA.", "Qed.", "Hypothesis (M'dec : fo_model_dec M') (psi : nat -> unit) (A : fol_form \u03a3) (HA : fol_sem M' psi (\u03a3_\u03a30 A)).", "Local Lemma \u03a3_\u03a30_completeness : fo_form_fin_dec_SAT_in A unit.", "Proof.", "exists M, finite_t_unit.", "exists.", "{", "intros r v; simpl; apply M'dec.", "}", "exists (fun _ => tt).", "revert HA; apply \u03a3_\u03a30_complete.", "Qed.", "End completeness.", "Theorem \u03a3_\u03a30_correct A : fo_form_fin_dec_SAT A <-> fo_form_fin_dec_SAT_in (\u03a3_\u03a30 A) unit.", "Proof.", "split.", "+", "intros (X & M & _ & G2 & phi & G3).", "apply \u03a3_\u03a30_soundness with X M phi; auto.", "+", "intros (M & _ & G2 & phi & G3).", "exists unit; apply \u03a3_\u03a30_completeness with M phi; auto.", "Qed.", "End \u03a3_\u03a30."], "theorems": [{"name": "\u03a30", "kind": "Definition", "begin": 7, "end": 10}, {"name": "M'", "kind": "Let", "begin": 14, "end": 22}, {"name": "M", "kind": "Let", "begin": 61, "end": 68}, {"name": "\u03a3_\u03a30_correct", "kind": "Theorem", "begin": 103, "end": 112}]}