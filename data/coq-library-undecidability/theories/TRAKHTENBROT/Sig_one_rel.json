{"code": ["Require Import List Arith Lia.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic.", "Set Implicit Arguments.", "Local Reserved Notation \"\u27ea A \u27eb'\" (at level 1, format \"\u27ea A \u27eb'\").", "Local Notation \u00f8 := vec_nil.", "Section Uniform_arities_to_one.", "Variable (\u03a3 : fo_signature) (H\u03a3 : syms \u03a3 -> False) (a : nat) (Ha : forall r, ar_rels \u03a3 r = a).", "Definition \u03a3one_rel : fo_signature.", "Proof.", "exists (rels \u03a3) unit.", "+", "exact (fun _ => 0).", "+", "exact (fun _ => S a).", "Defined.", "Notation \u03a3' := \u03a3one_rel.", "Notation \ud835\udd4b := (fol_term \u03a3).", "Notation \ud835\udd3d := (fol_form \u03a3).", "Notation \ud835\udd4b' := (fol_term \u03a3').", "Notation \ud835\udd3d' := (fol_form \u03a3').", "Let convert_t (t : \ud835\udd4b) : \ud835\udd4b' := match t with | in_var s => in_var s | in_fot s _ => False_rect _ (H\u03a3 s) end.", "Let convert_v n (v : vec _ n) := vec_map convert_t v.", "Fixpoint \u03a3unif_one_rel (A : \ud835\udd3d) : \ud835\udd3d' := match A with | \u22a5 => \u22a5 | fol_atom r v => @fol_atom \u03a3' tt (in_fot r \u00f8##cast (convert_v v) (Ha _)) | fol_bin b A B => fol_bin b (\u03a3unif_one_rel A) (\u03a3unif_one_rel B) | fol_quant q A => fol_quant q (\u03a3unif_one_rel A) end.", "Notation encode := \u03a3unif_one_rel.", "Variable X : Type.", "Section soundness.", "Variable (M : fo_model \u03a3 X) (x0 : X).", "Notation X' := (X + rels \u03a3)%type.", "Let fX (x : X') : X := match x with | inl x => x | inr _ => x0 end.", "Let vX n (v : vec _ n) := vec_map fX v.", "Definition \u03a3unif_one_rel_model : fo_model \u03a3' X'.", "Proof.", "split.", "+", "exact (fun r _ => inr r).", "+", "exact (fun r v => match vec_head v with | inl _ => False (* arbitrary value here *) | inr r => fom_rels M r (cast (vX (vec_tail v)) (eq_sym (Ha _))) end).", "Defined.", "Notation M' := \u03a3unif_one_rel_model.", "Let convert_env (\u03c6 : nat -> X) n : X' := inl (\u03c6 n).", "Let env_fill (\u03c8 : nat -> X') n : X' := inl (fX (\u03c8 n)).", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem M \u03c6 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c8 => fol_sem M' \u03c8 A).", "Let env_fill_sat_help A \u03c8 x : \u27eaencode A\u27eb' (env_fill x\u00b7(env_fill \u03c8)) <-> \u27eaencode A\u27eb' (env_fill x\u00b7\u03c8).", "Proof.", "apply fol_sem_ext; intros [] _; auto.", "Qed.", "Let env_fill_sat A \u03c8 : \u27eaencode A\u27eb' (env_fill \u03c8) <-> \u27eaencode A\u27eb' \u03c8.", "Proof.", "induction A as [ | r v | b A HA B HB | q A HA ] in \u03c8 |- *; try tauto.", "-", "simpl; rewrite <- (Ha r), !cast_refl.", "unfold vX, convert_v; rewrite !vec_map_map.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p; rew vec.", "generalize (vec_pos v p).", "intros []; simpl; auto; exfalso; auto.", "-", "apply fol_bin_sem_ext; auto.", "-", "simpl; apply fol_quant_sem_ext; intro; auto.", "rewrite <- HA, env_fill_sat_help, HA; tauto.", "Qed.", "Lemma \u03a3unif_one_rel_sound A \u03c6 : \u27eaA\u27eb \u03c6 <-> \u27eaencode A\u27eb' (convert_env \u03c6).", "Proof.", "induction A as [ | r v | b A HA B HB | [] A HA ] in \u03c6 |- *; try tauto.", "-", "cbn; rewrite <- (Ha r), !cast_refl.", "unfold convert_v; rewrite !vec_map_map.", "apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p; rew vec.", "generalize (vec_pos v p).", "intros [ n | s w ]; simpl; auto; exfalso; auto.", "-", "apply fol_bin_sem_ext; auto.", "-", "simpl; split.", "*", "intros (x & Hx); exists (inl x).", "revert Hx; rewrite HA; apply fol_sem_ext.", "intros []; simpl; auto.", "*", "intros ( [x | r] & H).", "+", "exists x.", "revert H; rewrite HA; apply fol_sem_ext.", "intros []; simpl; auto.", "+", "exists x0.", "apply HA; revert H.", "rewrite <- env_fill_sat.", "apply fol_sem_ext.", "intros []; simpl; auto.", "-", "simpl; split.", "*", "intros H [ x | r ].", "+", "generalize (H x); rewrite HA.", "apply fol_sem_ext.", "intros []; simpl; auto.", "+", "generalize (H x0).", "rewrite <- env_fill_sat, HA; apply fol_sem_ext.", "intros []; simpl; auto.", "*", "intros H x.", "generalize (H (inl x)).", "rewrite HA; apply fol_sem_ext.", "intros []; simpl; auto.", "Qed.", "End soundness.", "Section completeness.", "Variable (M' : fo_model \u03a3' X).", "Definition \u03a3one_unif_rel_model : fo_model \u03a3 X.", "Proof.", "split.", "+", "intros ? _; exfalso; auto.", "+", "exact (fun r v => fom_rels M' tt (fom_syms M' r \u00f8##cast v (Ha _))).", "Defined.", "Notation M := \u03a3one_unif_rel_model.", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem M \u03c6 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c8 => fol_sem M' \u03c8 A).", "Lemma \u03a3unif_one_rel_complete A \u03c6 : \u27eaA\u27eb \u03c6 <-> \u27eaencode A\u27eb' \u03c6.", "Proof.", "induction A as [ | r v | | ] in \u03c6 |- *; cbn; try tauto.", "+", "apply fol_equiv_ext; do 2 f_equal.", "revert v; generalize (Ha r); rewrite Ha; intros E v.", "rewrite eq_nat_uniq with (H := E).", "unfold convert_v; rewrite !cast_refl, vec_map_map.", "apply vec_pos_ext; intro; rew vec.", "generalize (vec_pos v p); intros []; simpl; auto; exfalso; auto.", "+", "apply fol_bin_sem_ext; auto.", "+", "apply fol_quant_sem_ext; intro; auto.", "Qed.", "End completeness.", "End Uniform_arities_to_one."], "theorems": [{"name": "\u03a3one_rel", "kind": "Definition", "begin": 9, "end": 16}, {"name": "\u03a3unif_one_rel_model", "kind": "Definition", "begin": 32, "end": 39}, {"name": "env_fill_sat_help", "kind": "Let", "begin": 45, "end": 48}, {"name": "env_fill_sat", "kind": "Let", "begin": 49, "end": 64}, {"name": "\u03a3unif_one_rel_sound", "kind": "Lemma", "begin": 65, "end": 112}, {"name": "\u03a3one_unif_rel_model", "kind": "Definition", "begin": 116, "end": 123}, {"name": "\u03a3unif_one_rel_complete", "kind": "Lemma", "begin": 127, "end": 141}]}