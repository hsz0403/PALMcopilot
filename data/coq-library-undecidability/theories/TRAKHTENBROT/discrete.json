{"code": ["Require Import List Arith Nat Lia Relations Bool.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations decidable gfp fol_ops fo_sig fo_terms fo_logic fo_definable fo_sat.", "Set Implicit Arguments.", "Local Notation \" e '#>' x \" := (vec_pos e x).", "Local Notation \" e [ v / x ] \" := (vec_change e x v).", "Section discrete_quotient.", "Variables (\u03a3 : fo_signature) (ls : list (syms \u03a3)) (lr : list (rels \u03a3)).", "Definition fo_bisimilar X M x y := forall A \u03c6, incl (fol_syms A) ls -> incl (fol_rels A) lr -> @fol_sem \u03a3 X M x\u00b7\u03c6 A <-> fol_sem M y\u00b7\u03c6 A.", "Variables (X : Type) (fin : finite_t X) (M : fo_model \u03a3 X) (dec : fo_model_dec M).", "Implicit Type (R T : X -> X -> Prop).", "Local Definition fom_op1 R x y := forall s, In s ls -> forall (v : vec _ (ar_syms \u03a3 s)) p, R (fom_syms M s (v[x/p])) (fom_syms M s (v[y/p])).", "Local Definition fom_op2 x y := forall s, In s lr -> forall (v : vec _ (ar_rels \u03a3 s)) p, fom_rels M s (v[x/p]) <-> fom_rels M s (v[y/p]).", "Local Definition fom_op R x y := fom_op1 R x y /\\ fom_op2 x y.", "Hint Resolve finite_t_pos finite_t_vec : core.", "Local Fact fom_op_mono R T : (forall x y, R x y -> T x y) -> (forall x y, fom_op R x y -> fom_op T x y).", "Proof.", "unfold fom_op, fom_op1, fom_op2; intros ? ? ? []; split; intros; auto.", "Qed.", "Local Fact fom_op_id x y : x = y -> fom_op (@eq _) x y.", "Proof.", "unfold fom_op, fom_op1, fom_op2; intros []; split; auto; tauto.", "Qed.", "Local Fact fom_op_sym R x y : fom_op R y x -> fom_op (fun x y => R y x) x y.", "Proof.", "unfold fom_op, fom_op1, fom_op2; intros []; split; intros; auto; symmetry; auto.", "Qed.", "Local Fact fom_op_trans R x z : (exists y, fom_op R x y /\\ fom_op R y z) -> fom_op (fun x z => exists y, R x y /\\ R y z) x z.", "Proof.", "unfold fom_op, fom_op1, fom_op2.", "intros (y & H1 & H2); split; intros s Hs v p.", "+", "exists (fom_syms M s (v[y/p])); split; [ apply H1 | apply H2 ]; auto.", "+", "transitivity (fom_rels M s (v[y/p])); [ apply H1 | apply H2 ]; auto.", "Qed.", "Local Fact fom_op_continuous : gfp_continuous fom_op.", "Proof.", "intros f Hf x y H; split; intros s Hs v p.", "+", "intros n.", "generalize (H n); intros (H1 & H2).", "apply H1; auto.", "+", "apply (H 0); auto.", "Qed.", "Let fom_op1_dec R : (forall x y, { R x y } + { ~ R x y }) -> (forall x y, { fom_op1 R x y } + { ~ fom_op1 R x y }).", "Proof.", "unfold fom_op1.", "intros HR x y.", "apply forall_list_sem_dec; intros.", "do 2 (apply (fol_quant_sem_dec fol_fa); auto; intros).", "Qed.", "Let fom_op2_dec : (forall x y, { fom_op2 x y } + { ~ fom_op2 x y }).", "Proof.", "unfold fom_op2.", "intros x y.", "apply forall_list_sem_dec; intros.", "do 2 (apply (fol_quant_sem_dec fol_fa); auto; intros).", "apply (fol_bin_sem_dec fol_conj); apply (fol_bin_sem_dec fol_imp); auto.", "Qed.", "Local Fact fom_op_dec R : (forall x y, { R x y } + { ~ R x y }) -> (forall x y, { fom_op R x y } + { ~ fom_op R x y }).", "Proof.", "intros; apply (fol_bin_sem_dec fol_conj); auto.", "Qed.", "Tactic Notation \"solve\" \"with\" \"proj\" constr(t) := apply fot_def_equiv with (f := fun \u03c6 => \u03c6 t); fol def; intros; rew vec.", "Let fol_def_fom_op1 R : fol_definable ls lr M (fun \u03c8 => R (\u03c8 0) (\u03c8 1)) -> fol_definable ls lr M (fun \u03c8 => fom_op1 R (\u03c8 0) (\u03c8 1)).", "Proof.", "intros H.", "apply fol_def_list_fa; intros s Hs.", "apply fol_def_vec_fa.", "apply fol_def_finite_fa; auto; intro p.", "apply fol_def_subst2; auto.", "*", "apply fot_def_comp; auto; intro q.", "destruct (pos_eq_dec p q); subst.", "-", "solve with proj (ar_syms \u03a3 s).", "-", "solve with proj (pos2nat q).", "*", "apply fot_def_comp; auto; intro q.", "destruct (pos_eq_dec p q); subst.", "-", "solve with proj (ar_syms \u03a3 s+1).", "-", "solve with proj (pos2nat q).", "Qed.", "Let fol_def_fom_op2 : fol_definable ls lr M (fun \u03c8 => fom_op2 (\u03c8 0) (\u03c8 1)).", "Proof.", "apply fol_def_list_fa; intros r Hr.", "apply fol_def_vec_fa.", "apply fol_def_finite_fa; auto; intro p.", "apply fol_def_iff.", "*", "apply fol_def_atom; auto; intro q.", "destruct (pos_eq_dec p q); subst.", "-", "solve with proj (ar_rels \u03a3 r).", "-", "solve with proj (pos2nat q).", "*", "apply fol_def_atom; auto; intro q.", "destruct (pos_eq_dec p q); subst.", "-", "solve with proj (ar_rels \u03a3 r+1).", "-", "solve with proj (pos2nat q).", "Qed.", "Let fol_def_fom_op R : fol_definable ls lr M (fun \u03c8 => R (\u03c8 0) (\u03c8 1)) -> fol_definable ls lr M (fun \u03c8 => fom_op R (\u03c8 0) (\u03c8 1)).", "Proof.", "intro; apply fol_def_conj; auto.", "Qed.", "Reserved Notation \"x \u2261 y\" (at level 70, no associativity).", "Definition fom_eq := gfp fom_op.", "Infix \"\u2261\" := fom_eq.", "Hint Resolve fom_op_mono fom_op_id fom_op_sym fom_op_trans fom_op_continuous fom_op_dec : core.", "Let fom_eq_equiv : equiv _ fom_eq.", "Proof.", "apply gfp_equiv; eauto.", "Qed.", "Fact fom_eq_fix x y : fom_op fom_eq x y <-> x \u2261 y.", "Proof.", "apply gfp_fix; eauto.", "Qed.", "Fact fom_eq_incl R : (forall x y, R x y -> fom_op R x y) -> (forall x y, R x y -> x \u2261 y).", "Proof.", "apply gfp_greatest; eauto.", "Qed.", "Fact fom_eq_refl x : x \u2261 x.", "Proof.", "apply (proj1 fom_eq_equiv).", "Qed.", "Fact fom_eq_sym x y : x \u2261 y -> y \u2261 x.", "Proof.", "apply fom_eq_equiv.", "Qed.", "Fact fom_eq_trans x y z : x \u2261 y -> y \u2261 z -> x \u2261 z.", "Proof.", "apply fom_eq_equiv.", "Qed.", "Fact fom_eq_syms x y s v p : In s ls -> x \u2261 y -> fom_syms M s (v[x/p]) \u2261 fom_syms M s (v[y/p]).", "Proof.", "intros; apply fom_eq_fix; auto.", "Qed.", "Fact fom_eq_rels x y s v p : In s lr -> x \u2261 y -> fom_rels M s (v[x/p]) <-> fom_rels M s (v[y/p]).", "Proof.", "intros; apply fom_eq_fix; auto.", "Qed.", "Hint Resolve fom_eq_refl fom_eq_sym fom_eq_trans fom_eq_syms fom_eq_rels : core.", "Theorem fom_eq_syms_full s v w : In s ls -> (forall p, v#>p \u2261 w#>p) -> fom_syms M s v \u2261 fom_syms M s w.", "Proof.", "intro; apply map_vec_pos_equiv; eauto.", "Qed.", "Theorem fom_eq_rels_full s v w : In s lr -> (forall p, v#>p \u2261 w#>p) -> fom_rels M s v <-> fom_rels M s w.", "Proof.", "intro; apply map_vec_pos_equiv; eauto; tauto.", "Qed.", "Section fol_characterization.", "Hint Resolve fom_eq_syms_full fom_eq_rels_full : core.", "Let f : fo_simulation ls lr M M.", "Proof.", "exists fom_eq; auto; intros a; exists a; auto.", "Defined.", "Let fom_eq_fol_charac1 A phi psi : (forall n, In n (fol_vars A) -> phi n \u2261 psi n) -> incl (fol_syms A) ls -> incl (fol_rels A) lr -> fol_sem M phi A <-> fol_sem M psi A.", "Proof.", "intros; apply fo_model_simulation with (R := f); auto.", "Qed.", "Local Fact fom_eq_fo_bisimilar x y : x \u2261 y -> fo_bisimilar M x y.", "Proof.", "intros H A phi.", "apply fom_eq_fol_charac1.", "intros [ | n ] _; simpl; auto.", "Qed.", "Local Fact fo_bisimilar_fom_eq x y : fo_bisimilar M x y -> x \u2261 y.", "Proof.", "revert x y; apply gfp_greatest; eauto.", "intros x y H; split.", "*", "intros s Hs v p A phi H1 H2.", "destruct (fot_vec_env \u03a3 p) as (w & Hw1 & Hw2).", "set (B := fol_subst (fun n => match n with | 0 => in_fot s w | S n => \u00a3 (S n + ar_syms \u03a3 s) end) A).", "assert (HB : forall z, fol_sem M (z\u00b7(env_vlift phi v)) B <-> fol_sem M (fom_syms M s (v[z/p]))\u00b7phi A).", "{", "intros z; unfold B; rewrite fol_sem_subst; apply fol_sem_ext.", "intros [ | n] _; rew fot; simpl; f_equal.", "*", "apply vec_pos_ext; intros q; rewrite vec_pos_map; apply Hw1.", "*", "rewrite env_vlift_fix1; auto.", "}", "rewrite <- !HB; apply H.", "-", "red; apply Forall_forall, fol_syms_subst.", "intros [ | n ]; rew fot.", "+", "intros _; apply Forall_forall.", "intros s' [ <- | Hs' ]; auto; apply H1; revert Hs'.", "rewrite in_flat_map; intros (z & H3 & H4).", "apply vec_list_inv in H3; destruct H3 as (q & ->).", "rewrite Hw2 in H4; destruct H4.", "+", "constructor.", "+", "apply Forall_forall, H1.", "-", "unfold B; rewrite fol_rels_subst; auto.", "*", "intros r Hr v p; red in H.", "destruct (fot_vec_env \u03a3 p) as (w & Hw1 & Hw2).", "set (B := fol_atom r w).", "assert (HB : forall z, fol_sem M (z\u00b7(env_vlift (fun _ => x) v)) B <-> fom_rels M r (v[z/p])).", "{", "intros z; unfold B; simpl; apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros q; rewrite vec_pos_map; apply Hw1.", "}", "rewrite <- !HB; apply H.", "-", "unfold B; simpl; intros z; rewrite in_flat_map.", "intros (t & H3 & H4).", "apply vec_list_inv in H3.", "destruct H3 as (q & ->).", "rewrite Hw2 in H4; destruct H4.", "-", "unfold B; simpl; intros ? [ <- | [] ]; auto.", "Qed.", "Theorem fom_eq_fol_characterization x y : x \u2261 y <-> fo_bisimilar M x y.", "Proof.", "split.", "+", "apply fom_eq_fo_bisimilar.", "+", "apply fo_bisimilar_fom_eq.", "Qed.", "End fol_characterization.", "Fact fom_eq_dec : forall x y, { x \u2261 y } + { ~ x \u2261 y }.", "Proof.", "apply gfp_decidable; eauto.", "Qed.", "Definition fo_congruence_upto R := ( (equivalence _ R) * (forall s v w, In s ls -> (forall p, R (v#>p) (w#>p)) -> R (fom_syms M s v) (fom_syms M s w)) * (forall r v w, In r lr -> (forall p, R (v#>p) (w#>p)) -> fom_rels M r v <-> fom_rels M r w) )%type.", "Theorem fo_bisimilar_dec_congr : fo_congruence_upto (@fo_bisimilar X M) * (forall x y, decidable (fo_bisimilar M x y)).", "Proof.", "split; [ split; [ split | ] | ].", "+", "split; red; [ intros ? | intros ? ? ? | intros ? ?]; rewrite <- !fom_eq_fol_characterization; auto.", "apply fom_eq_trans.", "+", "intros ? ? ? ? ?; apply fom_eq_fol_characterization, fom_eq_syms_full; auto.", "intro; apply fom_eq_fol_characterization; auto.", "+", "intros ? ? ? ? ?; apply fom_eq_rels_full; auto.", "intro; apply fom_eq_fol_characterization; auto.", "+", "intros x y.", "destruct (fom_eq_dec x y); [ left | right ]; rewrite <- fom_eq_fol_characterization; auto.", "Qed.", "Theorem fom_eq_finite : { n | forall x y, x \u2261 y <-> iter fom_op (fun _ _ => True) n x y }.", "Proof.", "apply gfp_finite_t; eauto.", "Qed.", "Theorem fom_eq_fol_def : fol_definable ls lr M (fun \u03c6 => \u03c6 0 \u2261 \u03c6 1).", "Proof.", "destruct fom_eq_finite as (n & Hn).", "apply fol_def_equiv with (R := fun \u03c6 => iter fom_op (fun _ _ : X => True) n (\u03c6 0) (\u03c6 1)).", "+", "intro; rewrite <- Hn; tauto.", "+", "clear Hn; induction n as [ | n IHn ].", "*", "simpl; fol def.", "*", "rewrite iter_S; auto.", "Qed.", "Section fom_eq_form.", "Let A := proj1_sig fom_eq_fol_def.", "Definition fom_eq_form := fol_subst (fun n => match n with 0 => \u00a31 | _ => \u00a30 end) A.", "Fact fom_eq_form_sem \u03c6 x y : fol_sem M y\u00b7x\u00b7\u03c6 fom_eq_form <-> x \u2261 y.", "Proof.", "unfold fom_eq_form; rewrite fol_sem_subst.", "apply (proj2_sig fom_eq_fol_def).", "Qed.", "Fact fom_eq_form_vars : incl (fol_vars fom_eq_form) (0::1::nil).", "Proof.", "unfold fom_eq_form; rewrite fol_vars_subst.", "intros n; rewrite in_flat_map; intros (? & _ & H).", "revert x H; intros [ | [] ]; simpl; tauto.", "Qed.", "Fact fom_eq_form_syms : incl (fol_syms fom_eq_form) ls.", "Proof.", "unfold fom_eq_form; red.", "apply Forall_forall, fol_syms_subst.", "+", "intros [ | []]; rew fot; auto.", "+", "apply Forall_forall, (proj2_sig fom_eq_fol_def).", "Qed.", "Fact fom_eq_form_rels : incl (fol_rels fom_eq_form) lr.", "Proof.", "unfold fom_eq_form; rewrite fol_rels_subst.", "apply (proj2_sig fom_eq_fol_def).", "Qed.", "End fom_eq_form.", "Hint Resolve fom_eq_form_vars fom_eq_form_syms fom_eq_form_rels fom_eq_dec : core.", "Section build_the_model.", "Let l := proj1_sig fin.", "Let Hl : forall x, In x l := proj2_sig fin.", "Let Q : fin_quotient fom_eq.", "Proof.", "apply decidable_EQUIV_fin_quotient with (l := l); eauto.", "Qed.", "Let n := fq_size Q.", "Let cls := fq_class Q.", "Let repr := fq_repr Q.", "Let E1 p : cls (repr p) = p.", "Proof.", "apply fq_surj.", "Qed.", "Let E2 x y : x \u2261 y <-> cls x = cls y.", "Proof.", "apply fq_equiv.", "Qed.", "Let Md : fo_model \u03a3 (pos n).", "Proof.", "exists.", "+", "intros s v; apply cls, (fom_syms M s), (vec_map repr v).", "+", "intros s v; apply (fom_rels M s), (vec_map repr v).", "Defined.", "Let H1 s v : In s ls -> cls (fom_syms M s v) = fom_syms Md s (vec_map cls v).", "Proof.", "intros Hs; simpl.", "apply E2.", "apply fom_eq_syms_full; auto.", "intros p; rewrite vec_map_map, vec_pos_map.", "apply E2; rewrite E1; auto.", "Qed.", "Let H2 s v : In s lr -> fom_rels M s v <-> fom_rels Md s (vec_map cls v).", "Proof.", "intros Hs; simpl.", "apply fom_eq_rels_full; auto.", "intros p; rewrite vec_map_map, vec_pos_map.", "apply E2; rewrite E1; auto.", "Qed.", "Let f : fo_projection ls lr M Md.", "Proof.", "exists cls repr; auto.", "Defined.", "Let H3 A phi : incl (fol_syms A) ls -> incl (fol_rels A) lr -> fol_sem M phi A <-> fol_sem Md (fun n => cls (phi n)) A.", "Proof.", "intros; apply fo_model_projection with (p := f); auto.", "Qed.", "Let H4 p q : fo_bisimilar Md p q <-> p = q.", "Proof.", "split.", "+", "intros H.", "rewrite <- (E1 q), <- (E1 p).", "apply E2, fom_eq_fol_characterization.", "intros A phi Hs Hr.", "specialize (H A (fun p => cls (phi p)) Hs Hr).", "revert H; apply fol_equiv_impl.", "all: rewrite H3; auto; apply fol_sem_ext; intros []; now simpl.", "+", "intros []; red; tauto.", "Qed.", "Theorem fo_fin_model_discretize : { n : nat & { Md : fo_model \u03a3 (pos n) & { _ : fo_model_dec Md & { _ : fo_projection ls lr M Md & (forall p q, fo_bisimilar Md p q <-> p = q) } } } }.", "Proof.", "exists n, Md.", "exists; eauto.", "intros x y; simpl; apply dec.", "Qed.", "End build_the_model.", "End discrete_quotient.", "Section counter_model_to_class_FO_definability.", "Let \u03a3 := \u03a3rel 2.", "Let M : fo_model \u03a3 bool.", "Proof.", "exists.", "+", "intros [].", "+", "intros []; simpl.", "exact (rel2_on_vec eq).", "Defined.", "Let M_dec : fo_model_dec M.", "Proof.", "intros [] ?; apply bool_dec.", "Qed.", "Let f : @fo_projection \u03a3 nil (tt::nil) _ M _ M.", "Proof.", "exists negb negb.", "+", "intros []; auto.", "+", "intros [].", "+", "intros [] v _; simpl.", "vec split v with x; vec split v with y; vec nil v; simpl.", "revert x y; now intros [] [].", "Defined.", "Notation \"\u27ea A \u27eb\" := (fun \u03c6 => fol_sem M \u03c6 A).", "Let homeomorphism (A : fol_form \u03a3) phi : \u27eaA\u27eb phi <-> \u27eaA\u27eb (fun x=> negb (phi x)).", "Proof.", "apply fo_model_projection with (p := f); auto.", "all: intros []; simpl; auto.", "Qed.", "Infix \"\u2261\" := (fom_eq (\u03a3 := \u03a3) nil (tt::nil) M) (at level 70, no associativity).", "Hint Resolve finite_t_bool : core.", "Let true_is_not_false : ~ true \u2261 false.", "Proof.", "intros H.", "apply fom_eq_fol_characterization in H; auto.", "specialize (H (@fol_atom \u03a3 tt (\u00a30##\u00a31##\u00f8)) (fun n => match n with 0 => true | _ => false end)).", "revert H; unfold M; simpl; rew fot; simpl.", "intros [H _]; cbv; auto.", "specialize (H eq_refl); discriminate.", "Qed.", "Let no_disctinct A phi : (forall n, In n (fol_vars A) -> n = 0) -> \u27eaA\u27eb true\u00b7phi <-> \u27eaA\u27eb false\u00b7phi.", "Proof.", "intros H.", "set (psi n := negb (phi n)).", "rewrite homeomorphism with (phi := false\u00b7phi) at 1.", "apply fol_sem_ext.", "intros n Hn; apply H in Hn; subst; auto.", "Qed.", "Theorem FO_does_not_characterize_classes : exists (M : fo_model \u03a3 bool) (_ : fo_model_dec M) (x y : bool), ~ fom_eq (\u03a3 := \u03a3) nil (tt::nil) M x y /\\ forall A \u03c6, (forall n, In n (fol_vars A) -> n = 0) -> fol_sem M x\u00b7\u03c6 A <-> fol_sem M y\u00b7\u03c6 A.", "Proof.", "exists M, M_dec, true, false; auto.", "Qed.", "End counter_model_to_class_FO_definability."], "theorems": [{"name": "fom_op1_dec", "kind": "Let", "begin": 47, "end": 53}, {"name": "fom_op2_dec", "kind": "Let", "begin": 54, "end": 61}, {"name": "fol_def_fom_op1", "kind": "Let", "begin": 67, "end": 88}, {"name": "fol_def_fom_op2", "kind": "Let", "begin": 89, "end": 109}, {"name": "fol_def_fom_op", "kind": "Let", "begin": 110, "end": 113}, {"name": "fom_eq_equiv", "kind": "Let", "begin": 118, "end": 121}, {"name": "fom_eq_fix", "kind": "Fact", "begin": 122, "end": 125}, {"name": "fom_eq_incl", "kind": "Fact", "begin": 126, "end": 129}, {"name": "fom_eq_refl", "kind": "Fact", "begin": 130, "end": 133}, {"name": "fom_eq_sym", "kind": "Fact", "begin": 134, "end": 137}, {"name": "fom_eq_trans", "kind": "Fact", "begin": 138, "end": 141}, {"name": "fom_eq_syms", "kind": "Fact", "begin": 142, "end": 145}, {"name": "fom_eq_rels", "kind": "Fact", "begin": 146, "end": 149}, {"name": "fom_eq_syms_full", "kind": "Theorem", "begin": 151, "end": 154}, {"name": "fom_eq_rels_full", "kind": "Theorem", "begin": 155, "end": 158}, {"name": "f", "kind": "Let", "begin": 161, "end": 164}, {"name": "fom_eq_fol_charac1", "kind": "Let", "begin": 165, "end": 168}, {"name": "fom_eq_fol_characterization", "kind": "Theorem", "begin": 227, "end": 234}, {"name": "fom_eq_dec", "kind": "Fact", "begin": 236, "end": 239}, {"name": "fo_bisimilar_dec_congr", "kind": "Theorem", "begin": 241, "end": 256}, {"name": "fom_eq_finite", "kind": "Theorem", "begin": 257, "end": 260}, {"name": "fom_eq_fol_def", "kind": "Theorem", "begin": 261, "end": 273}, {"name": "fom_eq_form_sem", "kind": "Fact", "begin": 277, "end": 281}, {"name": "fom_eq_form_vars", "kind": "Fact", "begin": 282, "end": 287}, {"name": "fom_eq_form_syms", "kind": "Fact", "begin": 288, "end": 296}, {"name": "fom_eq_form_rels", "kind": "Fact", "begin": 297, "end": 301}, {"name": "Q", "kind": "Let", "begin": 307, "end": 310}, {"name": "E1", "kind": "Let", "begin": 314, "end": 317}, {"name": "E2", "kind": "Let", "begin": 318, "end": 321}, {"name": "Md", "kind": "Let", "begin": 322, "end": 329}, {"name": "H1", "kind": "Let", "begin": 330, "end": 337}, {"name": "H2", "kind": "Let", "begin": 338, "end": 344}, {"name": "f", "kind": "Let", "begin": 345, "end": 348}, {"name": "H3", "kind": "Let", "begin": 349, "end": 352}, {"name": "H4", "kind": "Let", "begin": 353, "end": 366}, {"name": "fo_fin_model_discretize", "kind": "Theorem", "begin": 367, "end": 372}, {"name": "M", "kind": "Let", "begin": 377, "end": 385}, {"name": "M_dec", "kind": "Let", "begin": 386, "end": 389}, {"name": "f", "kind": "Let", "begin": 390, "end": 401}, {"name": "homeomorphism", "kind": "Let", "begin": 403, "end": 407}, {"name": "true_is_not_false", "kind": "Let", "begin": 410, "end": 418}, {"name": "no_disctinct", "kind": "Let", "begin": 419, "end": 426}, {"name": "FO_does_not_characterize_classes", "kind": "Theorem", "begin": 427, "end": 430}]}