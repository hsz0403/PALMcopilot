{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Local Notation \u00f8 := vec_nil.", "Section no_syms.", "Variable \u03a3 : fo_signature.", "Definition \u03a3_empty_syms : fo_signature.", "Proof.", "exists Empty_set (rels \u03a3).", "+", "exact (fun _ => 1).", "+", "exact (ar_rels \u03a3).", "Defined.", "Notation \u03a3' := \u03a3_empty_syms.", "Implicit Types (t : fo_term (ar_syms \u03a3)) (A : fol_form \u03a3).", "Local Definition fo_term_no_sym t : incl (fo_term_syms t) nil -> nat.", "Proof.", "refine (match t with | in_var i => fun _ => i | in_fot s _ => fun H => False_rect nat _ end).", "apply (H s (or_introl eq_refl)).", "Defined.", "Local Fact fo_term_no_sym_pirr t H1 H2 : fo_term_no_sym t H1 = fo_term_no_sym t H2.", "Proof.", "revert t H1 H2; intros [ i | s v ] H1 H2; simpl; auto.", "destruct (H1 s).", "Qed.", "Fixpoint \u03a3_no_sym (A : fol_form \u03a3) : incl (fol_syms A) nil -> fol_form \u03a3'.", "Proof.", "refine (match A with | \u22a5 => fun _ => \u22a5 | fol_atom r v => fun H => @fol_atom \u03a3' r (vec_set_pos (fun p => in_var (fo_term_no_sym (vec_pos v p) _))) | fol_bin b A B => fun H => fol_bin b (\u03a3_no_sym A _) (\u03a3_no_sym B _) | fol_quant q A => fun H => fol_quant q (\u03a3_no_sym A _) end).", "+", "intros s Hs; apply H, in_flat_map; exists (vec_pos v p); split; auto; apply in_vec_list, in_vec_pos.", "+", "intros ? ?; apply H, in_app_iff; simpl; auto.", "+", "intros ? ?; apply H, in_app_iff; simpl; auto.", "+", "apply H.", "Defined.", "Variable (A : fol_form \u03a3) (HA : incl (fol_syms A) nil).", "Section semantics.", "Variable (X : Type).", "Local Fact fo_term_no_sym_sem t Ht M \u03c6 : @fo_term_sem _ X M \u03c6 t = \u03c6 (@fo_term_no_sym t Ht).", "Proof.", "revert t Ht; intros [ i | s v ] H; simpl; auto; destruct H.", "Qed.", "Section soundness.", "Hypothesis (M : fo_model \u03a3 X).", "Let M' : fo_model \u03a3' X.", "Proof.", "split.", "+", "intros [].", "+", "apply (fom_rels M).", "Defined.", "Local Fact \u03a3_no_sym_sound \u03c6 : fol_sem M \u03c6 A <-> fol_sem M' \u03c6 (\u03a3_no_sym A HA).", "Proof.", "revert HA \u03c6.", "induction A as [ | r v | b B HB C HC | q B HB ]; intros H \u03c6.", "+", "simpl; tauto.", "+", "simpl fol_sem; apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p; rew vec; rew fot.", "apply fo_term_no_sym_sem.", "+", "apply fol_bin_sem_ext; auto.", "+", "apply fol_quant_sem_ext; auto.", "Qed.", "Hypothesis (Xf : finite_t X) (Md : fo_model_dec M) (phi : nat -> X) (H : fol_sem M phi A).", "Local Fact \u03a3_no_sym_soundness : fo_form_fin_dec_SAT_in (\u03a3_no_sym A HA) X.", "Proof.", "exists M', Xf, Md, phi.", "revert H; apply \u03a3_no_sym_sound.", "Qed.", "End soundness.", "Section completeness.", "Hypothesis (M' : fo_model \u03a3' X) (phi : nat -> X).", "Let M : fo_model \u03a3 X.", "Proof.", "split.", "+", "intros _ _; exact (phi 0).", "+", "apply (fom_rels M').", "Defined.", "Local Fact \u03a3_no_sym_complete \u03c6 : fol_sem M \u03c6 A <-> fol_sem M' \u03c6 (\u03a3_no_sym A HA).", "Proof.", "revert HA \u03c6.", "induction A as [ | r v | b B HB C HC | q B HB ]; intros H \u03c6.", "+", "simpl; tauto.", "+", "simpl fol_sem; apply fol_equiv_ext; f_equal.", "apply vec_pos_ext; intros p; rew vec; rew fot.", "apply fo_term_no_sym_sem.", "+", "apply fol_bin_sem_ext; auto.", "+", "apply fol_quant_sem_ext; auto.", "Qed.", "Hypothesis (Xf : finite_t X) (M'd : fo_model_dec M') (H : fol_sem M' phi (\u03a3_no_sym A HA)).", "Local Fact \u03a3_no_sym_completeness : fo_form_fin_dec_SAT_in A X.", "Proof.", "exists M, Xf, M'd, phi.", "revert H; apply \u03a3_no_sym_complete.", "Qed.", "End completeness.", "End semantics.", "Theorem \u03a3_no_sym_correct : { B : fol_form \u03a3' | fo_form_fin_dec_SAT A <-> fo_form_fin_dec_SAT B }.", "Proof.", "exists (\u03a3_no_sym A HA).", "split.", "+", "intros (X & M & H1 & H2 & phi & H3); exists X; apply \u03a3_no_sym_soundness with M phi; auto.", "+", "intros (X & M & H1 & H2 & phi & H3); exists X; apply \u03a3_no_sym_completeness with M phi; auto.", "Qed.", "End no_syms."], "theorems": [{"name": "\u03a3_empty_syms", "kind": "Definition", "begin": 8, "end": 15}, {"name": "\u03a3_no_sym", "kind": "Fixpoint", "begin": 28, "end": 39}, {"name": "M'", "kind": "Let", "begin": 49, "end": 56}, {"name": "M", "kind": "Let", "begin": 81, "end": 88}, {"name": "\u03a3_no_sym_correct", "kind": "Theorem", "begin": 112, "end": 120}]}