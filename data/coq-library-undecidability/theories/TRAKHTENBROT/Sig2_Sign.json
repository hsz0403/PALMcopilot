{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Local Notation \u00f8 := vec_nil.", "Section Sig2_Sig_n_encoding.", "Variable (n : nat).", "Notation \u03a32 := (\u03a3rel 2).", "Notation \u03a3n := (\u03a3rel (S (S n))).", "Fixpoint \u03a32_\u03a3n (A : fol_form \u03a32) : fol_form \u03a3n := match A with | \u22a5 => \u22a5 | fol_atom _ v => let x := \u03a3rel_var (vec_head v) in let y := \u03a3rel_var (vec_head (vec_tail v)) in @fol_atom \u03a3n tt (\u00a3x##vec_set_pos (fun _ => \u00a3y)) | fol_bin b A B => fol_bin b (\u03a32_\u03a3n A) (\u03a32_\u03a3n B) | fol_quant q A => fol_quant q (\u03a32_\u03a3n A) end.", "Section correctness.", "Variable (X : Type) (M2 : fo_model \u03a32 X) (Mn : fo_model \u03a3n X).", "Notation \"\u27ea A \u27eb\" := (fun \u03c8 => fol_sem M2 \u03c8 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c6 => fol_sem Mn \u03c6 A) (at level 1, format \"\u27ea A \u27eb'\").", "Let P2 a b := fom_rels M2 tt (a##b##\u00f8).", "Let Pn a b := fom_rels Mn tt (a##vec_set_pos (fun _ => b)).", "Hypothesis HP : forall x y, P2 x y <-> Pn x y.", "Lemma \u03a32_\u03a3n_correct (A : fol_form \u03a32) \u03c6 : \u27ea A \u27eb \u03c6 <-> \u27ea\u03a32_\u03a3n A\u27eb' \u03c6.", "Proof.", "revert \u03c6.", "induction A as [ | [] v | b A HA B HB | q A HA ]; intros phi.", "+", "simpl; tauto.", "+", "vec split v with a; vec split v with b; vec nil v; clear v; revert a b.", "intros [ a | [] ] [ b | [] ]; unfold \u03a32_\u03a3n; simpl; rew fot.", "rewrite vec_map_set_pos; apply HP.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; auto.", "Qed.", "End correctness.", "Variable (A : fol_form \u03a32).", "Section soundness.", "Variables (X : Type) (M2 : fo_model \u03a32 X) (H1 : finite_t X) (H2 : fo_model_dec M2) (phi : nat -> X) (H3 : fol_sem M2 phi A).", "Let Mn : fo_model \u03a3n X.", "Proof.", "exists.", "+", "intros [].", "+", "intros []; simpl.", "intros v.", "exact (fom_rels M2 tt (vec_head v##vec_head (vec_tail v)##\u00f8)).", "Defined.", "Local Lemma \u03a32_\u03a3n_sound_loc : fo_form_fin_dec_SAT (\u03a32_\u03a3n A).", "Proof.", "exists X, Mn, H1.", "exists.", "{", "intros [] ?; apply H2.", "}", "exists phi.", "revert H3.", "apply \u03a32_\u03a3n_correct; simpl; tauto.", "Qed.", "End soundness.", "Lemma \u03a32_\u03a3n_soundness : fo_form_fin_dec_SAT A -> fo_form_fin_dec_SAT (\u03a32_\u03a3n A).", "Proof.", "intros (X & M2 & H1 & H2 & phi & H3).", "apply \u03a32_\u03a3n_sound_loc with (M2 := M2) (phi := phi); auto.", "Qed.", "Section completeness.", "Variables (X : Type) (Mn : fo_model \u03a3n X) (H1 : finite_t X) (H2 : fo_model_dec Mn) (phi : nat -> X) (H3 : fol_sem Mn phi (\u03a32_\u03a3n A)).", "Let M2 : fo_model \u03a32 X.", "Proof.", "exists.", "+", "intros [].", "+", "intros []; simpl.", "intros v.", "exact (fom_rels Mn tt (vec_head v##vec_set_pos (fun _ => vec_head (vec_tail v)))).", "Defined.", "Local Lemma \u03a32_\u03a3n_complete_loc : fo_form_fin_dec_SAT A.", "Proof.", "exists X, M2, H1.", "exists.", "{", "intros [] ?; apply H2.", "}", "exists phi.", "revert H3.", "apply \u03a32_\u03a3n_correct; simpl; tauto.", "Qed.", "End completeness.", "Lemma \u03a32_\u03a3n_completeness : fo_form_fin_dec_SAT (\u03a32_\u03a3n A) -> fo_form_fin_dec_SAT A.", "Proof.", "intros (X & Mn & H1 & H2 & phi & H3).", "apply \u03a32_\u03a3n_complete_loc with (Mn := Mn) (phi := phi); auto.", "Qed.", "End Sig2_Sig_n_encoding."], "theorems": [{"name": "\u03a32_\u03a3n_correct", "kind": "Lemma", "begin": 18, "end": 32}, {"name": "Mn", "kind": "Let", "begin": 37, "end": 46}, {"name": "\u03a32_\u03a3n_soundness", "kind": "Lemma", "begin": 59, "end": 63}, {"name": "M2", "kind": "Let", "begin": 66, "end": 75}, {"name": "\u03a32_\u03a3n_completeness", "kind": "Lemma", "begin": 88, "end": 92}]}