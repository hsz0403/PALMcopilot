{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "Require Import Undecidability.Synthetic.Definitions Undecidability.Synthetic.ReducibilityFacts.", "Require Import Undecidability.Synthetic.InformativeDefinitions Undecidability.Synthetic.InformativeReducibilityFacts.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.Shared.Libs.DLW.Wf Require Import wf_finite.", "From Undecidability.TRAKHTENBROT Require Import notations utils decidable bpcp fo_sig fo_terms fo_logic fo_sat red_utils Sig_discrete BPCP_SigBPCP (* from BPCP to a finitary signature *) Sig_rem_syms (* convert symbols into rels *) Sig_uniform (* convert to same arity for every rels *) Sig_one_rel (* many rels of arity n into one (n+1) and constants *) Sig_rem_cst (* replace constants with free variables *) Sign_Sig2 (* From R_n to R_2 *) Sig2_Sign (* Embed R_2 into R_n with n >= 2 *) Sign_Sig (* Embed R_n into \u03a3 where R_n occurs in \u03a3 *) Sig_Sig_fin (* Alternate path: \u03a3 -> \u03a3fin -> \u03a32 *) Sig2_SigSSn1 (* Embed \u03a32 = (\u00f8,{R_2}) into \u03a3SSn1 = ({f_(2+n)},{P_1}) *) Sign1_Sig (* Embed \u03a3n1 = ({f_n},{R_1}) into \u03a3 where f_n and R_1 occur into \u03a3 *) .", "Set Implicit Arguments.", "Section BPCP_fo_fin_dec_SAT.", "Definition FIN_SAT_input := fol_form \u03a3bpcp.", "Theorem BPCP_FIN_DEC_EQ_SAT : BPCP_problem \u2aaf\u1d62 @fo_form_fin_dec_eq_SAT \u03a3bpcp \u03a3bpcp_eq eq_refl.", "Proof.", "apply ireduces_dependent; intros lc.", "exists (\u03a3bpcp_encode lc); split.", "+", "intros (l & Hl); revert Hl; apply Sig_bpcp_encode_sound.", "+", "apply Sig_bpcp_encode_complete.", "Qed.", "End BPCP_fo_fin_dec_SAT.", "Corollary BPCP_FSAT_\u03a3bpcp : BPCP_problem \u2aaf\u1d62 FSAT \u03a3bpcp.", "Proof.", "apply ireduces_transitive with (1 := BPCP_FIN_DEC_EQ_SAT).", "apply FIN_DEC_EQ_SAT_FIN_DEC_SAT.", "Qed.", "Section FIN_DISCR_DEC_SAT_FIN_DEC_EQ_NOSYMS_SAT.", "Variable (\u03a3 : fo_signature) (H\u03a3 : finite_t (syms \u03a3) + discrete (syms \u03a3)).", "Theorem FIN_DISCR_DEC_SAT_FIN_DEC_EQ_NOSYMS_SAT : @fo_form_fin_discr_dec_SAT \u03a3 \u2aaf\u1d62 @fo_form_fin_dec_eq_SAT (\u03a3nosyms \u03a3) (inl tt) eq_refl.", "Proof.", "destruct H\u03a3 as [ (l & Hl) | H ].", "-", "exists (fun A => \u03a3syms_\u03a3nosyms l A).", "intros A; split; intros (X & HX); exists X; revert HX.", "+", "apply \u03a3syms_\u03a3nosyms_sound.", "+", "apply \u03a3syms_\u03a3nosyms_complete.", "*", "left; auto.", "*", "intros ? ?; auto.", "-", "exists (fun A => \u03a3syms_\u03a3nosyms (fol_syms A) A).", "intros A; split; intros (X & HX); exists X; revert HX.", "+", "apply \u03a3syms_\u03a3nosyms_sound.", "+", "apply \u03a3syms_\u03a3nosyms_complete.", "*", "intros s; apply In_dec, H.", "*", "intro; auto.", "Qed.", "End FIN_DISCR_DEC_SAT_FIN_DEC_EQ_NOSYMS_SAT.", "Corollary FSAT_\u03a3nosyms \u03a3 : finite_t (syms \u03a3) -> FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3nosyms \u03a3).", "Proof.", "intros H.", "apply ireduces_transitive with (1 := FIN_DEC_SAT_FIN_DISCR_DEC_SAT _).", "apply ireduces_transitive with (2 := @FIN_DEC_EQ_SAT_FIN_DEC_SAT (\u03a3nosyms \u03a3) (inl tt) eq_refl).", "apply FIN_DISCR_DEC_SAT_FIN_DEC_EQ_NOSYMS_SAT; auto.", "Qed.", "Theorem FSAT_UNIFORM \u03a3 n : (forall r : rels \u03a3, ar_rels _ r <= n) -> FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3unif \u03a3 n).", "Proof.", "intros Hn.", "exists (fun A => @\u03a3uniformize \u03a3 n (fol_rels A) A); intros A.", "split; intros (X & HX); exists X; revert HX.", "+", "apply \u03a3uniformize_sound; auto.", "+", "intros H; generalize H.", "intros (_ & _ & _ & phi & _).", "revert H; apply \u03a3uniformize_complete; cbv; auto.", "Qed.", "Theorem FSAT_ONE_REL \u03a3 n : (syms \u03a3 -> False) -> (forall r : rels \u03a3, ar_rels _ r = n) -> finite_t (rels \u03a3) -> FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3one_rel \u03a3 n).", "Proof.", "intros Hs Hn (lr & Hr).", "exists (\u03a3unif_one_rel Hs Hn); intros A; split.", "+", "intros (X & M & H1 & H2 & phi & H3).", "exists (X + rels \u03a3)%type, (\u03a3unif_one_rel_model Hn M (phi 0)).", "exists.", "{", "apply finite_t_sum; auto; exists lr; auto.", "}", "exists.", "{", "intros [] v; vec split v with x; destruct x; simpl; try tauto; apply H2.", "}", "exists (fun n => inl (phi n)).", "revert H3; apply \u03a3unif_one_rel_sound.", "+", "intros (X & M' & H1 & H2 & phi & H3).", "exists X, (\u03a3one_unif_rel_model Hs Hn M'), H1.", "exists.", "{", "intros ? ?; apply H2.", "}", "exists phi.", "revert H3; apply \u03a3unif_one_rel_complete.", "Qed.", "Theorem FSAT_NOCST \u03a3 : (forall s, ar_syms \u03a3 s = 0) -> discrete (syms \u03a3) -> FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3rem_cst \u03a3).", "Proof.", "intros; apply ireduces_dependent.", "apply Sig_rem_cst_dep_red; auto.", "Qed.", "Lemma FSAT_REL_BOUNDED_ONE_REL \u03a3 n : (syms \u03a3 -> False) -> (forall r : rels \u03a3, ar_rels _ r <= n) -> finite_t (rels \u03a3) -> discrete (rels \u03a3) -> FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3rel (S n)).", "Proof.", "intros H1 H2 H3 H4.", "eapply ireduces_transitive; [ apply FSAT_UNIFORM, H2 | ].", "eapply ireduces_transitive; [ apply FSAT_ONE_REL; simpl; trivial | ].", "apply FSAT_NOCST; simpl; auto.", "Qed.", "Theorem FIN_DISCR_DEC_nSAT_FIN_DEC_2SAT n : @fo_form_fin_discr_dec_SAT (\u03a3rel n) \u2aaf\u1d62 @fo_form_fin_dec_SAT (\u03a3rel 2).", "Proof.", "exists (@\u03a3n_\u03a32_enc n); intros A; split.", "+", "apply SATn_SAT2.", "+", "intros H; apply fo_form_fin_dec_SAT_fin_discr_dec, SAT2_SATn, H.", "Qed.", "Corollary FSAT_REL_nto2 n : FSAT (\u03a3rel n) \u2aaf\u1d62 FSAT (\u03a3rel 2).", "Proof.", "apply ireduces_transitive with (1 := FIN_DEC_SAT_FIN_DISCR_DEC_SAT _).", "apply FIN_DISCR_DEC_nSAT_FIN_DEC_2SAT.", "Qed.", "Theorem FSAT_REL2_to_FUNnREL1 n : 2 <= n -> FSAT (\u03a3rel 2) \u2aaf\u1d62 FSAT (\u03a3n1 n).", "Proof.", "intros Hn; destruct n as [ | [ | n ] ]; try (exfalso; lia); clear Hn.", "exists (\u03a32_\u03a3SSn1_enc n); intros A; split.", "+", "intros (X & M2 & H1 & H2 & phi & H3).", "apply \u03a32_\u03a3SSn1_enc_sound with (1 := H3); auto.", "+", "intros (Y & M21 & H1 & H2 & psi & H3).", "apply \u03a32_\u03a3SSn1_enc_complete with (2 := H3); auto.", "Qed.", "Theorem FSAT_FUNnREL1_ANY \u03a3 n f r : ar_syms \u03a3 f = n -> ar_rels \u03a3 r = 1 -> FSAT (\u03a3n1 n) \u2aaf\u1d62 FSAT \u03a3.", "Proof.", "intros H1 H2.", "apply ireduces_dependent.", "intros A.", "exists (\u03a3n1_\u03a3 _ _ _ H1 H2 A).", "apply \u03a3n1_\u03a3_correct.", "Qed.", "Theorem FSAT_REL_2ton n : 2 <= n -> FSAT (\u03a3rel 2) \u2aaf\u1d62 FSAT (\u03a3rel n).", "Proof.", "revert n; intros [ | [ | n ] ] H; try (exfalso; lia).", "exists (\u03a32_\u03a3n n); intros A; split.", "+", "apply \u03a32_\u03a3n_soundness.", "+", "apply \u03a32_\u03a3n_completeness.", "Qed.", "Theorem FSAT_RELn_ANY \u03a3 n r : ar_rels \u03a3 r = n -> FSAT (\u03a3rel n) \u2aaf\u1d62 FSAT \u03a3.", "Proof.", "intros Hr.", "destruct (SATn_SAT_reduction _ _ Hr) as (f & Hf).", "exists f; red; apply Hf.", "Qed.", "Section FINITARY_TO_BINARY.", "Variable (\u03a3 : fo_signature) (H\u03a31 : finite_t (syms \u03a3)) (H\u03a32 : discrete (syms \u03a3)) (H\u03a33 : finite_t (rels \u03a3)) (H\u03a34 : discrete (rels \u03a3)).", "Let max_syms : { n | forall s, ar_syms \u03a3 s <= n }.", "Proof.", "destruct H\u03a31 as (l & Hl).", "exists (lmax (map (ar_syms _) l)).", "intros s; apply lmax_prop, in_map_iff.", "exists s; auto.", "Qed.", "Let max_rels : { n | forall s, ar_rels \u03a3 s <= n }.", "Proof.", "destruct H\u03a33 as (l & Hl).", "exists (lmax (map (ar_rels _) l)).", "intros r; apply lmax_prop, in_map_iff.", "exists r; auto.", "Qed.", "Hint Resolve finite_t_sum finite_sum finite_t_finite finite_t_unit : core.", "Theorem FINITARY_TO_BINARY : FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3rel 2).", "Proof.", "destruct max_syms as (ns & Hns).", "destruct max_rels as (nr & Hnr).", "set (m := lmax (2::(S ns)::nr::nil)).", "eapply ireduces_transitive.", "{", "apply FSAT_\u03a3nosyms; auto.", "}", "eapply ireduces_transitive.", "{", "apply FSAT_UNIFORM with (n := m).", "intros [ [] | [] ].", "+", "apply lmax_prop; simpl; auto.", "+", "apply le_trans with (S ns).", "*", "simpl; apply le_n_S, Hns.", "*", "apply lmax_prop; simpl; auto.", "+", "apply le_trans with nr.", "*", "simpl; auto.", "*", "apply lmax_prop; simpl; auto.", "}", "eapply ireduces_transitive.", "{", "apply FSAT_ONE_REL; simpl; auto; intros [].", "}", "eapply ireduces_transitive.", "{", "apply FSAT_NOCST; simpl; auto.", "}", "apply (FSAT_REL_nto2 (S m)).", "Qed.", "End FINITARY_TO_BINARY.", "Section DISCRETE_TO_BINARY.", "Variable (\u03a3 : fo_signature) (H\u03a31 : discrete (syms \u03a3)) (H\u03a32 : discrete (rels \u03a3)).", "Hint Resolve finite_t_pos : core.", "Theorem DISCRETE_TO_BINARY : FSAT \u03a3 \u2aaf\u1d62 FSAT (\u03a3rel 2).", "Proof.", "apply ireduces_dependent.", "intros A.", "destruct (Sig_discrete_to_pos H\u03a31 H\u03a32 A) as (n & m & i & j & B & HB).", "destruct (@FINITARY_TO_BINARY (\u03a3pos _ i j)) as (f & Hf); simpl; auto.", "exists (f B).", "red in Hf.", "rewrite <- Hf; apply HB.", "Qed.", "End DISCRETE_TO_BINARY.", "Section FULL_TRAKHTENBROT.", "Let finite_t_bpcp_syms : finite_t \u03a3bpcp_syms.", "Proof.", "exists (\u03a3bpcp_bool true::\u03a3bpcp_bool false::\u03a3bpcp_unit::\u03a3bpcp_undef::nil).", "intros [ [] | | ]; simpl; auto.", "Qed.", "Let discrete_bpcp_syms : discrete \u03a3bpcp_syms.", "Proof.", "unfold discrete, decidable; repeat decide equality.", "Qed.", "Let finite_t_bpcp_rels : finite_t \u03a3bpcp_rels.", "Proof.", "exists (\u03a3bpcp_hand::\u03a3bpcp_ssfx::\u03a3bpcp_eq::nil).", "intros []; simpl; auto.", "Qed.", "Let discrete_bpcp_rels : discrete \u03a3bpcp_rels.", "Proof.", "unfold discrete, decidable; repeat decide equality.", "Qed.", "Let BPCP_Sig2 : BPCP_problem \u2aaf\u1d62 FSAT (\u03a3rel 2).", "Proof.", "apply ireduces_transitive with (1 := BPCP_FSAT_\u03a3bpcp).", "apply FINITARY_TO_BINARY; auto.", "Qed.", "Theorem FULL_TRAKHTENBROT \u03a3 : { r | 2 <= ar_rels \u03a3 r } + { f : _ & { r | 2 <= ar_syms \u03a3 f /\\ ar_rels \u03a3 r = 1 } } -> BPCP_problem \u2aaf\u1d62 FSAT \u03a3.", "Proof.", "intros H.", "apply ireduces_transitive with (1 := BPCP_Sig2).", "revert H; intros [ (r & Hr) | (f & r & Hf & Hr) ].", "+", "apply ireduces_transitive with (1 := FSAT_REL_2ton Hr).", "apply FSAT_RELn_ANY with (1 := eq_refl).", "+", "apply ireduces_transitive with (1 := FSAT_REL2_to_FUNnREL1 Hf).", "apply FSAT_FUNnREL1_ANY with f r; auto.", "Qed.", "Corollary FULL_TRAKHTENBROT_non_informative \u03a3 : (exists r, 2 <= ar_rels \u03a3 r) \\/ (exists f r, 2 <= ar_syms \u03a3 f /\\ ar_rels \u03a3 r = 1) -> BPCP_problem \u2aaf FSAT \u03a3.", "Proof.", "intros [ (?&?) | (?&?&?&?) ]; apply ireduces_reduces, FULL_TRAKHTENBROT; firstorder.", "Qed.", "End FULL_TRAKHTENBROT."], "theorems": [{"name": "BPCP_FIN_DEC_EQ_SAT", "kind": "Theorem", "begin": 10, "end": 18}, {"name": "BPCP_FSAT_\u03a3bpcp", "kind": "Corollary", "begin": 20, "end": 24}, {"name": "FIN_DISCR_DEC_SAT_FIN_DEC_EQ_NOSYMS_SAT", "kind": "Theorem", "begin": 27, "end": 52}, {"name": "FSAT_\u03a3nosyms", "kind": "Corollary", "begin": 54, "end": 60}, {"name": "FSAT_UNIFORM", "kind": "Theorem", "begin": 61, "end": 72}, {"name": "FSAT_ONE_REL", "kind": "Theorem", "begin": 73, "end": 99}, {"name": "FSAT_NOCST", "kind": "Theorem", "begin": 100, "end": 104}, {"name": "FSAT_REL_BOUNDED_ONE_REL", "kind": "Lemma", "begin": 105, "end": 111}, {"name": "FIN_DISCR_DEC_nSAT_FIN_DEC_2SAT", "kind": "Theorem", "begin": 112, "end": 119}, {"name": "FSAT_REL_nto2", "kind": "Corollary", "begin": 120, "end": 124}, {"name": "FSAT_REL2_to_FUNnREL1", "kind": "Theorem", "begin": 125, "end": 135}, {"name": "FSAT_FUNnREL1_ANY", "kind": "Theorem", "begin": 136, "end": 143}, {"name": "FSAT_REL_2ton", "kind": "Theorem", "begin": 144, "end": 152}, {"name": "FSAT_RELn_ANY", "kind": "Theorem", "begin": 153, "end": 158}, {"name": "max_syms", "kind": "Let", "begin": 161, "end": 167}, {"name": "max_rels", "kind": "Let", "begin": 168, "end": 174}, {"name": "FINITARY_TO_BINARY", "kind": "Theorem", "begin": 176, "end": 213}, {"name": "DISCRETE_TO_BINARY", "kind": "Theorem", "begin": 218, "end": 227}, {"name": "finite_t_bpcp_syms", "kind": "Let", "begin": 230, "end": 234}, {"name": "discrete_bpcp_syms", "kind": "Let", "begin": 235, "end": 238}, {"name": "finite_t_bpcp_rels", "kind": "Let", "begin": 239, "end": 243}, {"name": "discrete_bpcp_rels", "kind": "Let", "begin": 244, "end": 247}, {"name": "BPCP_Sig2", "kind": "Let", "begin": 248, "end": 252}, {"name": "FULL_TRAKHTENBROT", "kind": "Theorem", "begin": 253, "end": 264}, {"name": "FULL_TRAKHTENBROT_non_informative", "kind": "Corollary", "begin": 265, "end": 268}]}