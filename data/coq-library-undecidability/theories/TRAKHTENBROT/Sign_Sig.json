{"code": ["Require Import List Arith Bool Lia Eqdep_dec.", "From Undecidability.Shared.Libs.DLW.Utils Require Import utils_tac utils_list utils_nat finite.", "From Undecidability.Shared.Libs.DLW.Vec Require Import pos vec.", "From Undecidability.TRAKHTENBROT Require Import notations utils fol_ops fo_sig fo_terms fo_logic fo_sat.", "Set Implicit Arguments.", "Tactic Notation \"iff\" \"equal\" := apply fol_equiv_ext.", "Local Notation \u00f8 := vec_nil.", "Section Sig_n_Sig.", "Variable (\u03a3 : fo_signature) (r : rels \u03a3).", "Notation \u03a3n := (\u03a3rel (ar_rels _ r)).", "Local Fixpoint enc (A : fol_form \u03a3n) : fol_form \u03a3 := match A with | \u22a5 => \u22a5 | fol_atom _ v => fol_atom r (vec_map (fun x => \u00a3(\u03a3rel_var x)) v) | fol_bin b A B => fol_bin b (enc A) (enc B) | fol_quant q A => fol_quant q (enc A) end.", "Section M_enc_n.", "Variables (X : Type) (M : fo_model \u03a3 X).", "Local Definition M_enc_n : fo_model \u03a3n X.", "Proof.", "exists; intros [] v.", "exact (fom_rels M r v).", "Defined.", "Notation \"\u27ea A \u27eb\" := (fun \u03c8 => fol_sem M \u03c8 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c6 => fol_sem M_enc_n \u03c6 A) (at level 1, format \"\u27ea A \u27eb'\").", "Local Fact enc_correct_1 A \u03c6 : \u27ea A \u27eb' \u03c6 <-> \u27ea enc A \u27eb \u03c6.", "Proof.", "revert \u03c6.", "induction A as [ | [] v | b A HA B HB | q A HA ]; intros phi.", "+", "simpl; tauto.", "+", "unfold M_enc_n; simpl; rewrite vec_map_map.", "iff equal; f_equal; apply vec_pos_ext.", "intros p; do 2 rewrite vec_pos_map; rew fot.", "simpl in v; generalize (vec_pos v p); intros [ i | [] ].", "rew fot; simpl; auto.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; auto.", "Qed.", "End M_enc_n.", "Local Lemma SAT_SATn A : fo_form_fin_dec_SAT (enc A) -> fo_form_fin_dec_SAT A.", "Proof.", "intros (X & M & H1 & H2 & phi & H3).", "exists X, (M_enc_n M), H1.", "exists.", "{", "intros [] v; apply H2.", "}", "exists phi.", "revert H3; apply enc_correct_1.", "Qed.", "Section Mn_enc.", "Variables (X : Type) (Mn : fo_model \u03a3n X) (x0 : X).", "Local Definition Mn_enc : fo_model \u03a3 X.", "Proof.", "exists.", "+", "intros s v; apply x0.", "+", "intros r' v.", "destruct (eq_nat_dec (ar_rels _ r) (ar_rels _ r')) as [ H | H ].", "*", "exact (fom_rels Mn tt (eq_rect_r _ v H)).", "*", "exact False.", "Defined.", "Notation \"\u27ea A \u27eb\" := (fun \u03c8 => fol_sem Mn_enc \u03c8 A).", "Notation \"\u27ea A \u27eb'\" := (fun \u03c6 => fol_sem Mn \u03c6 A) (at level 1, format \"\u27ea A \u27eb'\").", "Local Fact enc_correct_2 A \u03c6 : \u27ea A \u27eb' \u03c6 <-> \u27ea enc A \u27eb \u03c6.", "Proof.", "revert \u03c6.", "induction A as [ | [] v | b A HA B HB | q A HA ]; intros phi.", "+", "simpl; tauto.", "+", "unfold Mn_enc; simpl; rewrite vec_map_map.", "destruct (eq_nat_dec (ar_rels \u03a3 r) (ar_rels \u03a3 r)) as [ H | [] ]; auto.", "rewrite eq_nat_uniq with (H := H); unfold eq_rect_r; simpl.", "iff equal; f_equal; apply vec_pos_ext.", "intros p; do 2 rewrite vec_pos_map; rew fot.", "simpl in v; generalize (vec_pos v p); intros [ i | [] ].", "rew fot; simpl; auto.", "+", "simpl; apply fol_bin_sem_ext; auto.", "+", "simpl; apply fol_quant_sem_ext; intro; auto.", "Qed.", "End Mn_enc.", "Local Lemma SATn_SAT A : fo_form_fin_dec_SAT A -> fo_form_fin_dec_SAT (enc A).", "Proof.", "intros (X & Mn & H1 & H2 & phi & H3).", "exists X, (Mn_enc Mn (phi 0)), H1.", "exists.", "{", "intros r' v; simpl.", "destruct (eq_nat_dec (ar_rels \u03a3 r) (ar_rels \u03a3 r')) as [ H | H ].", "+", "revert v; rewrite <- H; unfold eq_rect_r; simpl; intro; apply H2.", "+", "right; tauto.", "}", "exists phi.", "revert H3; apply enc_correct_2.", "Qed.", "Hint Resolve SATn_SAT SAT_SATn : core.", "Local Theorem SATn_SAT_red : { f : fol_form \u03a3n -> fol_form \u03a3 | forall A, fo_form_fin_dec_SAT A <-> fo_form_fin_dec_SAT (f A) }.", "Proof.", "exists enc; split; auto.", "Qed.", "End Sig_n_Sig.", "Theorem SATn_SAT_reduction (\u03a3 : fo_signature) (n : nat) (r : rels \u03a3) (Hr : ar_rels _ r = n) : { f : fol_form (\u03a3rel n) -> fol_form \u03a3 | forall A, fo_form_fin_dec_SAT A <-> fo_form_fin_dec_SAT (f A) }.", "Proof.", "subst n; apply SATn_SAT_red.", "Qed."], "theorems": [{"name": "SATn_SAT_reduction", "kind": "Theorem", "begin": 108, "end": 111}]}