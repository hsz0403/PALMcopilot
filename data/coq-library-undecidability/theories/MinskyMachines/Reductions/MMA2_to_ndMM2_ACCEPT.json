{"code": ["Require Import List Arith Lia Relations.", "From Undecidability.MinskyMachines Require Import MMA mma_defs ndMM2.", "From Undecidability.Shared.Libs.DLW Require Import utils Vec.pos Vec.vec Code.subcode Code.sss.", "From Undecidability.Synthetic Require Import Definitions ReducibilityFacts.", "Set Implicit Arguments.", "Set Default Proof Using \"Type\".", "Local Tactic Notation \"vec2\" hyp(v) \"into\" ident(x) ident(y) := vec split v with x; vec split v with y; vec nil v; clear v.", "Section MMA2_ndMM2.", "Notation STOP\u2099 := (@ndmm2_stop _).", "Notation INC\u2099 := (@ndmm2_inc _).", "Notation DEC\u2099 := (@ndmm2_dec _).", "Notation ZERO\u2099 := (@ndmm2_zero _).", "Notation \u03b1 := true.", "Notation \u03b2 := false.", "Infix \"\u220a\" := In (at level 70).", "Infix \"\u2286\" := incl (at level 70).", "Notation \u00f8 := vec_nil.", "Definition pos2_to_bool (p : pos 2) := match p with pos0 => \u03b1 | _ => \u03b2 end.", "Notation \"\u2308 p \u2309\" := (pos2_to_bool p) (at level 1, format \"\u2308 p \u2309\").", "Definition mma2_instr_enc i (\u03c1 : mm_instr (pos 2)) := match \u03c1 with | INC\u2090 x => INC\u2099 \u2308x\u2309 i (1+i) :: nil | DEC\u2090 x j => DEC\u2099 \u2308x\u2309 i j :: ZERO\u2099 \u2308x\u2309 i (1+i) :: nil end.", "Notation \"'\u27e8' i , \u03c1 '\u27e9\u2081'\" := (mma2_instr_enc i \u03c1) (format \"\u27e8 i , \u03c1 \u27e9\u2081\").", "Reserved Notation \"'\u27ea' i , l '\u27eb\u2097'\" (at level 1, format \"\u27ea i , l \u27eb\u2097\").", "Fixpoint mma2_linstr_enc i l := match l with | nil => nil | \u03c1::l => \u27e8i,\u03c1\u27e9\u2081 ++ \u27ea1+i,l\u27eb\u2097 end where \"\u27ea i , l \u27eb\u2097\" := (mma2_linstr_enc i l).", "Fact mma2_linstr_enc_app i l m : \u27eai,l++m\u27eb\u2097 = \u27eai,l\u27eb\u2097 ++ \u27ealength l+i,m\u27eb\u2097.", "Proof.", "revert i; induction l as [ | ? l IHl ]; intros ?; simpl; auto.", "rewrite app_ass, IHl; do 3 f_equal; auto.", "Qed.", "Fact mma2_linstr_enc_In i P c : c \u220a \u27eai,P\u27eb\u2097 -> exists L \u03c1 R, P = L++\u03c1::R /\\ c \u220a \u27e8length L+i,\u03c1\u27e9\u2081.", "Proof.", "revert i; induction P as [ | \u03c1 P IH ]; intros i.", "+", "intros [].", "+", "simpl; rewrite in_app_iff; intros [ H | H ].", "*", "exists nil, \u03c1, P; split; auto.", "*", "destruct (IH (1+i)) as (l & \u03c1' & r & H1 & H2); auto.", "exists (\u03c1::l), \u03c1', r; split; auto.", "-", "simpl; f_equal; auto.", "-", "eq goal H2; do 2 f_equal; simpl; lia.", "Qed.", "Notation \"\u03a3 //\u2099 a \u2295 b \u22a6 u\" := (ndmm2_accept \u03a3 a b u) (at level 70, no associativity).", "Notation \"\u03c1 //\u2090 s -1> t\" := (mma_sss \u03c1 s t) (at level 70, no associativity).", "Notation \"P //\u2090 r :1> s\" := (sss_step (@mma_sss _) P r s) (at level 70, no associativity).", "Notation \"P //\u2090 s ->> t\" := (sss_compute (@mma_sss _) P s t) (at level 70, no associativity).", "Notation \"P //\u2090 s ~~> t\" := (sss_output (@mma_sss _) P s t) (at level 70, no associativity).", "Tactic Notation \"state\" \"rebuild\" ident(s) hyp(i) hyp(a) hyp(b) := set (s := (i,a##b##\u00f8)); change a with (vec_pos (snd s) pos0); change b with (vec_pos (snd s) pos1); change i with (fst s).", "Local Fact mma2_instr_enc_sound \u03a3 \u03c1 i a b j a' b' : \u03c1 //\u2090 (i,a##b##\u00f8) -1> (j,a'##b'##\u00f8) -> \u27e8i,\u03c1\u27e9\u2081 \u2286 \u03a3 -> \u03a3 //\u2099 a' \u2295 b' \u22a6 j -> \u03a3 //\u2099 a \u2295 b \u22a6 i.", "Proof.", "state rebuild s1 i a b.", "state rebuild s2 j a' b'.", "generalize s1 s2; clear s1 s2 i a b j a' b'.", "destruct 1 as [ i x v | i x k v Hv | i x k v u Hv ]; try revert Hv; vec2 v into a b; repeat invert pos x; simpl.", "+", "constructor 2 with (1+i); auto.", "+", "constructor 3 with (1+i); auto.", "+", "intros -> ?; constructor 6 with (1+i); auto.", "+", "intros -> ?; constructor 7 with (1+i); auto.", "+", "intros -> ?; constructor 4 with k; auto.", "+", "intros -> ?; constructor 5 with k; auto.", "Qed.", "Local Fact mma2_step_linstr_sound \u03a3 P i a b j a' b' : (1,P) //\u2090 (i,a##b##\u00f8) :1> (j,a'##b'##\u00f8) -> \u27ea1,P\u27eb\u2097 \u2286 \u03a3 -> \u03a3 //\u2099 a' \u2295 b' \u22a6 j -> \u03a3 //\u2099 a \u2295 b \u22a6 i.", "Proof.", "intros (n & L & \u03c1 & R & v & H1 & H2 & H3).", "inversion H1; subst n P; clear H1.", "inversion H2; subst v i; clear H2.", "intros H.", "apply mma2_instr_enc_sound with (1 := H3).", "apply incl_tran with (2 := H).", "rewrite mma2_linstr_enc_app; simpl.", "rewrite plus_comm.", "apply incl_appr, incl_appl, incl_refl.", "Qed.", "Variable P : list (mm_instr (pos 2)).", "Definition mma2_prog_enc := STOP\u2099 0 :: \u27ea1,P\u27eb\u2097.", "Notation \u03a3P := mma2_prog_enc.", "Local Lemma mma2_compute_linstr_sound i a b j a' b' : (1,P) //\u2090 (i,a##b##\u00f8) ->> (j,a'##b'##\u00f8) -> \u03a3P //\u2099 a' \u2295 b' \u22a6 j -> \u03a3P //\u2099 a \u2295 b \u22a6 i.", "Proof.", "intros (n & Hn); revert Hn.", "state rebuild s1 i a b.", "state rebuild s2 j a' b'.", "generalize s1 s2; clear s1 s2 i a b j a' b'.", "induction 1 as [ (i,v) | n (i,u) (j,v) (k,w) H1 H2 IH2 ]; simpl; auto.", "revert H1 H2 IH2; vec2 u into au bu; vec2 v into av bv; vec2 w into aw bw.", "simpl; intros H1 H2 IH3 H; generalize (IH3 H).", "apply mma2_step_linstr_sound with (1 := H1), incl_tl, incl_refl.", "Qed.", "Local Lemma mma2_prog_enc_stop : \u03a3P //\u2099 0 \u2295 0 \u22a6 0.", "Proof.", "constructor 1; simpl; auto.", "Qed.", "Hint Resolve mma2_prog_enc_stop : core.", "Local Lemma mma2_prog_enc_sound i a b : (1,P) //\u2090 (i,a##b##\u00f8) ->> (0,0##0##\u00f8) -> \u03a3P //\u2099 a \u2295 b \u22a6 i.", "Proof.", "intros H; apply mma2_compute_linstr_sound in H; auto.", "Qed.", "Local Lemma mma2_prog_enc_complete a b i : \u03a3P //\u2099 a \u2295 b \u22a6 i -> (1,P) //\u2090 (i,a##b##\u00f8) ->> (0,0##0##\u00f8).", "Proof.", "induction 1 as [ u H | a b u v H H1 IH1 | a b u v H H1 IH1 | a b u v H H1 IH1 | a b u v H H1 IH1 | b p u H H1 IH1 | a p u H H1 IH1 ].", "+", "destruct H as [ H | H ].", "*", "inversion H; subst u.", "exists 0; constructor 1.", "*", "apply mma2_linstr_enc_In in H as (l & [ x | x ] & r & H1 & H2); repeat invert pos x; simpl in H2.", "1-2: now destruct H2.", "1-2: now destruct H2 as [ | [] ].", "+", "destruct H as [ H | H ]; try discriminate.", "apply mma2_linstr_enc_In in H as (l & [ x | x ] & r & H3 & H2); repeat invert pos x; simpl in H2.", "2: now destruct H2.", "2-3: now destruct H2 as [ | [] ].", "destruct H2 as [ H2 | [] ]; inversion H2; subst.", "apply sss_compute_trans with (2 := IH1).", "rewrite H3.", "mma sss INC with pos0.", "mma sss stop.", "+", "destruct H as [ H | H ]; try discriminate.", "apply mma2_linstr_enc_In in H as (l & [ x | x ] & r & H3 & H2); repeat invert pos x; simpl in H2.", "1: now destruct H2.", "2-3: now destruct H2 as [ | [] ].", "destruct H2 as [ H2 | [] ]; inversion H2; subst.", "apply sss_compute_trans with (2 := IH1).", "rewrite H3.", "mma sss INC with pos1.", "mma sss stop.", "+", "destruct H as [ H | H ]; try discriminate.", "apply mma2_linstr_enc_In in H as (l & [ x | x ] & r & H3 & H2); repeat invert pos x; simpl in H2.", "1-2: now destruct H2.", "2: now destruct H2 as [ | [] ].", "destruct H2 as [ H2 | H2 ].", "2: now destruct H2.", "inversion H2; subst.", "apply sss_compute_trans with (2 := IH1).", "rewrite H3.", "mma sss DEC S with pos0 v a.", "mma sss stop.", "+", "destruct H as [ H | H ]; try discriminate.", "apply mma2_linstr_enc_In in H as (l & [ x | x ] & r & H3 & H2); repeat invert pos x; simpl in H2.", "1-2: now destruct H2.", "1: now destruct H2 as [ | [] ].", "destruct H2 as [ H2 | H2 ].", "2: now destruct H2.", "inversion H2; subst.", "apply sss_compute_trans with (2 := IH1).", "rewrite H3.", "mma sss DEC S with pos1 v b.", "mma sss stop.", "+", "destruct H as [ H | H ]; try discriminate.", "apply mma2_linstr_enc_In in H as (l & [ x | x j ] & r & H3 & H2); repeat invert pos x; simpl in H2.", "1-2: now destruct H2.", "2: now destruct H2 as [ | [] ].", "destruct H2 as [ H2 | [ H2 | [] ] ].", "1: easy.", "inversion H2; subst.", "apply sss_compute_trans with (2 := IH1).", "rewrite H3.", "mma sss DEC 0 with pos0 j.", "mma sss stop.", "+", "destruct H as [ H | H ]; try discriminate.", "apply mma2_linstr_enc_In in H as (l & [ x | x j ] & r & H3 & H2); repeat invert pos x; simpl in H2.", "1-2: now destruct H2.", "1: now destruct H2 as [ | [] ].", "destruct H2 as [ H2 | [ H2 | [] ] ].", "1: easy.", "inversion H2; subst.", "apply sss_compute_trans with (2 := IH1).", "rewrite H3.", "mma sss DEC 0 with pos1 j.", "mma sss stop.", "Qed.", "Theorem MMA2_ndMM2_equiv a b : (1,P) //\u2090 (1,a##b##\u00f8) ~~> (0,0##0##\u00f8) <-> \u03a3P //\u2099 a \u2295 b \u22a6 1.", "Proof.", "split.", "+", "intros []; apply mma2_prog_enc_sound; auto.", "+", "split.", "*", "now apply mma2_prog_enc_complete.", "*", "simpl; lia.", "Qed.", "End MMA2_ndMM2.", "Theorem reduction : MMA2_HALTS_ON_ZERO \u2aaf @ndMM2_ACCEPT nat.", "Proof.", "apply reduces_dependent; exists.", "intros (P & v); vec2 v into a b.", "exists (existT _ (mma2_prog_enc P) (1,(a,b))).", "apply MMA2_ndMM2_equiv.", "Qed."], "theorems": [{"name": "mma2_linstr_enc_app", "kind": "Fact", "begin": 23, "end": 27}, {"name": "mma2_linstr_enc_In", "kind": "Fact", "begin": 28, "end": 44}, {"name": "MMA2_ndMM2_equiv", "kind": "Theorem", "begin": 186, "end": 197}, {"name": "reduction", "kind": "Theorem", "begin": 199, "end": 205}]}